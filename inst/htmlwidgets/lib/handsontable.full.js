/*!
 * Copyright (c) HANDSONCODE sp. z o. o.
 *
 * HANDSONTABLE is a software distributed by HANDSONCODE sp. z o. o., a Polish corporation based in
 * Gdynia, Poland, at Aleja Zwyciestwa 96-98, registered by the District Court in Gdansk under number
 * 538651, EU tax ID number: PL5862294002, share capital: PLN 62,800.00.
 *
 * This software is protected by applicable copyright laws, including international treaties, and dual-
 * licensed - depending on whether your use for commercial purposes, meaning intended for or
 * resulting in commercial advantage or monetary compensation, or not.
 *
 * If your use is strictly personal or solely for evaluation purposes, meaning for the purposes of testing
 * the suitability, performance, and usefulness of this software outside the production environment,
 * you agree to be bound by the terms included in the "handsontable-non-commercial-license.pdf" file.
 *
 * Your use of this software for commercial purposes is subject to the terms included in an applicable
 * license agreement.
 *
 * In any case, you must not make any such use of this software as to develop software which may be
 * considered competitive with this software.
 *
 * UNLESS EXPRESSLY AGREED OTHERWISE, HANDSONCODE PROVIDES THIS SOFTWARE ON AN "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, AND IN NO EVENT AND UNDER NO
 * LEGAL THEORY, SHALL HANDSONCODE BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER ARISING FROM
 * USE OR INABILITY TO USE THIS SOFTWARE.
 *
 * Version: 15.0.0
 * Release date: 16/12/2024 (built at 16/12/2024 13:19:40)
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Handsontable", [], factory);
	else if(typeof exports === 'object')
		exports["Handsontable"] = factory();
	else
		root["Handsontable"] = factory();
})(typeof self !== 'undefined' ? self : this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlwaysDense: () => (/* reexport safe */ _DependencyGraph_AddressMapping_ChooseAddressMappingPolicy__WEBPACK_IMPORTED_MODULE_4__.AlwaysDense),
/* harmony export */   AlwaysSparse: () => (/* reexport safe */ _DependencyGraph_AddressMapping_ChooseAddressMappingPolicy__WEBPACK_IMPORTED_MODULE_4__.AlwaysSparse),
/* harmony export */   ArraySize: () => (/* reexport safe */ _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize),
/* harmony export */   CellError: () => (/* reexport safe */ _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError),
/* harmony export */   CellType: () => (/* reexport safe */ _Cell__WEBPACK_IMPORTED_MODULE_1__.CellType),
/* harmony export */   CellValueDetailedType: () => (/* reexport safe */ _Cell__WEBPACK_IMPORTED_MODULE_1__.CellValueDetailedType),
/* harmony export */   CellValueType: () => (/* reexport safe */ _Cell__WEBPACK_IMPORTED_MODULE_1__.CellValueType),
/* harmony export */   ConfigValueTooBigError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.ConfigValueTooBigError),
/* harmony export */   ConfigValueTooSmallError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.ConfigValueTooSmallError),
/* harmony export */   DenseSparseChooseBasedOnThreshold: () => (/* reexport safe */ _DependencyGraph_AddressMapping_ChooseAddressMappingPolicy__WEBPACK_IMPORTED_MODULE_4__.DenseSparseChooseBasedOnThreshold),
/* harmony export */   DetailedCellError: () => (/* reexport safe */ _CellValue__WEBPACK_IMPORTED_MODULE_2__.DetailedCellError),
/* harmony export */   EmptyValue: () => (/* reexport safe */ _interpreter__WEBPACK_IMPORTED_MODULE_9__.EmptyValue),
/* harmony export */   ErrorType: () => (/* reexport safe */ _Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType),
/* harmony export */   EvaluationSuspendedError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.EvaluationSuspendedError),
/* harmony export */   ExpectedOneOfValuesError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.ExpectedOneOfValuesError),
/* harmony export */   ExpectedValueOfTypeError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.ExpectedValueOfTypeError),
/* harmony export */   ExportedCellChange: () => (/* reexport safe */ _Exporter__WEBPACK_IMPORTED_MODULE_6__.ExportedCellChange),
/* harmony export */   ExportedNamedExpressionChange: () => (/* reexport safe */ _Exporter__WEBPACK_IMPORTED_MODULE_6__.ExportedNamedExpressionChange),
/* harmony export */   FunctionArgumentType: () => (/* reexport safe */ _interpreter__WEBPACK_IMPORTED_MODULE_9__.FunctionArgumentType),
/* harmony export */   FunctionPlugin: () => (/* reexport safe */ _interpreter__WEBPACK_IMPORTED_MODULE_9__.FunctionPlugin),
/* harmony export */   FunctionPluginValidationError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.FunctionPluginValidationError),
/* harmony export */   HyperFormula: () => (/* reexport safe */ _HyperFormula__WEBPACK_IMPORTED_MODULE_7__.HyperFormula),
/* harmony export */   InvalidAddressError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.InvalidAddressError),
/* harmony export */   InvalidArgumentsError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.InvalidArgumentsError),
/* harmony export */   LanguageAlreadyRegisteredError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.LanguageAlreadyRegisteredError),
/* harmony export */   LanguageNotRegisteredError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.LanguageNotRegisteredError),
/* harmony export */   MissingTranslationError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.MissingTranslationError),
/* harmony export */   NamedExpressionDoesNotExistError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NamedExpressionDoesNotExistError),
/* harmony export */   NamedExpressionNameIsAlreadyTakenError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NamedExpressionNameIsAlreadyTakenError),
/* harmony export */   NamedExpressionNameIsInvalidError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NamedExpressionNameIsInvalidError),
/* harmony export */   NoOperationToRedoError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NoOperationToRedoError),
/* harmony export */   NoOperationToUndoError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NoOperationToUndoError),
/* harmony export */   NoRelativeAddressesAllowedError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NoRelativeAddressesAllowedError),
/* harmony export */   NoSheetWithIdError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NoSheetWithIdError),
/* harmony export */   NoSheetWithNameError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NoSheetWithNameError),
/* harmony export */   NotAFormulaError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NotAFormulaError),
/* harmony export */   NothingToPasteError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.NothingToPasteError),
/* harmony export */   ProtectedFunctionTranslationError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.ProtectedFunctionTranslationError),
/* harmony export */   SheetNameAlreadyTakenError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.SheetNameAlreadyTakenError),
/* harmony export */   SheetSizeLimitExceededError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.SheetSizeLimitExceededError),
/* harmony export */   SimpleRangeValue: () => (/* reexport safe */ _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_11__.SimpleRangeValue),
/* harmony export */   SourceLocationHasArrayError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.SourceLocationHasArrayError),
/* harmony export */   TargetLocationHasArrayError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.TargetLocationHasArrayError),
/* harmony export */   UnableToParseError: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_5__.UnableToParseError),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _CellValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(100);
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(101);
/* harmony import */ var _DependencyGraph_AddressMapping_ChooseAddressMappingPolicy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(105);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77);
/* harmony import */ var _Exporter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(128);
/* harmony import */ var _HyperFormula__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(110);
/* harmony import */ var _i18n_languages_enGB__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(146);
/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(96);
/* harmony import */ var _interpreter_plugin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(147);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(69);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */












/**
 * Aggregate class for default export
 */
class HyperFormulaNS extends _HyperFormula__WEBPACK_IMPORTED_MODULE_7__.HyperFormula {}
HyperFormulaNS.HyperFormula = _HyperFormula__WEBPACK_IMPORTED_MODULE_7__.HyperFormula;
HyperFormulaNS.ErrorType = _Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType;
HyperFormulaNS.CellError = _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError;
HyperFormulaNS.CellType = _Cell__WEBPACK_IMPORTED_MODULE_1__.CellType;
HyperFormulaNS.CellValueType = _Cell__WEBPACK_IMPORTED_MODULE_1__.CellValueType;
HyperFormulaNS.CellValueDetailedType = _Cell__WEBPACK_IMPORTED_MODULE_1__.CellValueDetailedType;
HyperFormulaNS.DetailedCellError = _CellValue__WEBPACK_IMPORTED_MODULE_2__.DetailedCellError;
HyperFormulaNS.ExportedCellChange = _Exporter__WEBPACK_IMPORTED_MODULE_6__.ExportedCellChange;
HyperFormulaNS.ExportedNamedExpressionChange = _Exporter__WEBPACK_IMPORTED_MODULE_6__.ExportedNamedExpressionChange;
HyperFormulaNS.ConfigValueTooBigError = _errors__WEBPACK_IMPORTED_MODULE_5__.ConfigValueTooBigError;
HyperFormulaNS.ConfigValueTooSmallError = _errors__WEBPACK_IMPORTED_MODULE_5__.ConfigValueTooSmallError;
HyperFormulaNS.EvaluationSuspendedError = _errors__WEBPACK_IMPORTED_MODULE_5__.EvaluationSuspendedError;
HyperFormulaNS.ExpectedOneOfValuesError = _errors__WEBPACK_IMPORTED_MODULE_5__.ExpectedOneOfValuesError;
HyperFormulaNS.ExpectedValueOfTypeError = _errors__WEBPACK_IMPORTED_MODULE_5__.ExpectedValueOfTypeError;
HyperFormulaNS.ArraySize = _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize;
HyperFormulaNS.SimpleRangeValue = _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_11__.SimpleRangeValue;
HyperFormulaNS.EmptyValue = _interpreter__WEBPACK_IMPORTED_MODULE_9__.EmptyValue;
HyperFormulaNS.FunctionPlugin = _interpreter__WEBPACK_IMPORTED_MODULE_9__.FunctionPlugin;
HyperFormulaNS.FunctionArgumentType = _interpreter__WEBPACK_IMPORTED_MODULE_9__.FunctionArgumentType;
HyperFormulaNS.FunctionPluginValidationError = _errors__WEBPACK_IMPORTED_MODULE_5__.FunctionPluginValidationError;
HyperFormulaNS.InvalidAddressError = _errors__WEBPACK_IMPORTED_MODULE_5__.InvalidAddressError;
HyperFormulaNS.InvalidArgumentsError = _errors__WEBPACK_IMPORTED_MODULE_5__.InvalidArgumentsError;
HyperFormulaNS.LanguageNotRegisteredError = _errors__WEBPACK_IMPORTED_MODULE_5__.LanguageNotRegisteredError;
HyperFormulaNS.LanguageAlreadyRegisteredError = _errors__WEBPACK_IMPORTED_MODULE_5__.LanguageAlreadyRegisteredError;
HyperFormulaNS.MissingTranslationError = _errors__WEBPACK_IMPORTED_MODULE_5__.MissingTranslationError;
HyperFormulaNS.NamedExpressionDoesNotExistError = _errors__WEBPACK_IMPORTED_MODULE_5__.NamedExpressionDoesNotExistError;
HyperFormulaNS.NamedExpressionNameIsAlreadyTakenError = _errors__WEBPACK_IMPORTED_MODULE_5__.NamedExpressionNameIsAlreadyTakenError;
HyperFormulaNS.NamedExpressionNameIsInvalidError = _errors__WEBPACK_IMPORTED_MODULE_5__.NamedExpressionNameIsInvalidError;
HyperFormulaNS.NoOperationToRedoError = _errors__WEBPACK_IMPORTED_MODULE_5__.NoOperationToRedoError;
HyperFormulaNS.NoOperationToUndoError = _errors__WEBPACK_IMPORTED_MODULE_5__.NoOperationToUndoError;
HyperFormulaNS.NoRelativeAddressesAllowedError = _errors__WEBPACK_IMPORTED_MODULE_5__.NoRelativeAddressesAllowedError;
HyperFormulaNS.NoSheetWithIdError = _errors__WEBPACK_IMPORTED_MODULE_5__.NoSheetWithIdError;
HyperFormulaNS.NoSheetWithNameError = _errors__WEBPACK_IMPORTED_MODULE_5__.NoSheetWithNameError;
HyperFormulaNS.NotAFormulaError = _errors__WEBPACK_IMPORTED_MODULE_5__.NotAFormulaError;
HyperFormulaNS.NothingToPasteError = _errors__WEBPACK_IMPORTED_MODULE_5__.NothingToPasteError;
HyperFormulaNS.ProtectedFunctionTranslationError = _errors__WEBPACK_IMPORTED_MODULE_5__.ProtectedFunctionTranslationError;
HyperFormulaNS.SheetNameAlreadyTakenError = _errors__WEBPACK_IMPORTED_MODULE_5__.SheetNameAlreadyTakenError;
HyperFormulaNS.SheetSizeLimitExceededError = _errors__WEBPACK_IMPORTED_MODULE_5__.SheetSizeLimitExceededError;
HyperFormulaNS.SourceLocationHasArrayError = _errors__WEBPACK_IMPORTED_MODULE_5__.SourceLocationHasArrayError;
HyperFormulaNS.TargetLocationHasArrayError = _errors__WEBPACK_IMPORTED_MODULE_5__.TargetLocationHasArrayError;
HyperFormulaNS.UnableToParseError = _errors__WEBPACK_IMPORTED_MODULE_5__.UnableToParseError;
const defaultLanguage = _Config__WEBPACK_IMPORTED_MODULE_3__.Config.defaultConfig.language;
_HyperFormula__WEBPACK_IMPORTED_MODULE_7__.HyperFormula.registerLanguage(defaultLanguage, _i18n_languages_enGB__WEBPACK_IMPORTED_MODULE_8__["default"]);
_HyperFormula__WEBPACK_IMPORTED_MODULE_7__.HyperFormula.languages[_i18n_languages_enGB__WEBPACK_IMPORTED_MODULE_8__["default"].langCode] = _i18n_languages_enGB__WEBPACK_IMPORTED_MODULE_8__["default"];
for (const pluginName of Object.getOwnPropertyNames(_interpreter_plugin__WEBPACK_IMPORTED_MODULE_10__)) {
  if (!pluginName.startsWith('_')) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    _HyperFormula__WEBPACK_IMPORTED_MODULE_7__.HyperFormula.registerFunctionPlugin(_interpreter_plugin__WEBPACK_IMPORTED_MODULE_10__[pluginName]);
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HyperFormulaNS);


/*** EXPORTS FROM exports-to-window-loader ***/
window['HyperFormula'] = (__webpack_require__(0)["default"]);

/***/ }),
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArraySize: () => (/* binding */ ArraySize),
/* harmony export */   ArraySizePredictor: () => (/* binding */ ArraySizePredictor)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _interpreter_InterpreterState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(95);
/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class ArraySize {
  constructor(width, height, isRef = false) {
    this.width = width;
    this.height = height;
    this.isRef = isRef;
  }
  static error() {
    return new ArraySize(1, 1, true);
  }
  static scalar() {
    return new ArraySize(1, 1, false);
  }
  isScalar() {
    return this.width === 1 && this.height === 1 || this.isRef;
  }
}
function arraySizeForBinaryOp(leftArraySize, rightArraySize) {
  return new ArraySize(Math.max(leftArraySize.width, rightArraySize.width), Math.max(leftArraySize.height, rightArraySize.height));
}
function arraySizeForUnaryOp(arraySize) {
  return new ArraySize(arraySize.width, arraySize.height);
}
class ArraySizePredictor {
  constructor(config, functionRegistry) {
    this.config = config;
    this.functionRegistry = functionRegistry;
  }
  checkArraySize(ast, formulaAddress) {
    return this.checkArraySizeForAst(ast, {
      formulaAddress,
      arraysFlag: this.config.useArrayArithmetic
    });
  }
  checkArraySizeForAst(ast, state) {
    switch (ast.type) {
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.FUNCTION_CALL:
        {
          return this.checkArraySizeForFunction(ast, state);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.COLUMN_RANGE:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ROW_RANGE:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_RANGE:
        {
          const range = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.fromAstOrUndef(ast, state.formulaAddress);
          if (range === undefined) {
            return ArraySize.error();
          } else {
            return new ArraySize(range.width(), range.height(), true);
          }
        }
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ARRAY:
        {
          const heights = [];
          const widths = [];
          for (const row of ast.args) {
            const sizes = row.map(ast => this.checkArraySizeForAst(ast, state));
            const h = Math.min(...sizes.map(size => size.height));
            const w = sizes.reduce((total, size) => total + size.width, 0);
            heights.push(h);
            widths.push(w);
          }
          const height = heights.reduce((total, h) => total + h, 0);
          const width = Math.min(...widths);
          return new ArraySize(width, height);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.STRING:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.NUMBER:
        return ArraySize.scalar();
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_REFERENCE:
        return new ArraySize(1, 1, true);
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.DIV_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CONCATENATE_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.EQUALS_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.GREATER_THAN_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.GREATER_THAN_OR_EQUAL_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.LESS_THAN_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.LESS_THAN_OR_EQUAL_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.MINUS_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.NOT_EQUAL_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PLUS_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.POWER_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.TIMES_OP:
        {
          const left = this.checkArraySizeForAst(ast.left, state);
          const right = this.checkArraySizeForAst(ast.right, state);
          if (!state.arraysFlag && (left.height > 1 || left.width > 1 || right.height > 1 || right.width > 1)) {
            return ArraySize.error();
          }
          return arraySizeForBinaryOp(left, right);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.MINUS_UNARY_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PLUS_UNARY_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PERCENT_OP:
        {
          const val = this.checkArraySizeForAst(ast.value, state);
          if (!state.arraysFlag && (val.height > 1 || val.width > 1)) {
            return ArraySize.error();
          }
          return arraySizeForUnaryOp(val);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PARENTHESIS:
        {
          return this.checkArraySizeForAst(ast.expression, state);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.EMPTY:
        return ArraySize.error();
      default:
        return ArraySize.error();
    }
  }
  checkArraySizeForFunction(ast, state) {
    const pluginArraySizeFunction = this.functionRegistry.getArraySizeFunction(ast.procedureName);
    if (pluginArraySizeFunction !== undefined) {
      return pluginArraySizeFunction(ast, state);
    }
    const metadata = this.functionRegistry.getMetadata(ast.procedureName);
    if (metadata === undefined || metadata.expandRanges || !state.arraysFlag || metadata.vectorizationForbidden || metadata.parameters === undefined) {
      return new ArraySize(1, 1);
    }
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.checkArraySizeForAst(arg, new _interpreter_InterpreterState__WEBPACK_IMPORTED_MODULE_1__.InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const argumentDefinitions = [...metadata.parameters];
    if (metadata.repeatLastArgs !== undefined && argumentDefinitions.length < subChecks.length && (subChecks.length - argumentDefinitions.length) % metadata.repeatLastArgs !== 0) {
      return ArraySize.error();
    }
    while (argumentDefinitions.length < subChecks.length) {
      if (metadata.repeatLastArgs === undefined) {
        return ArraySize.error();
      }
      argumentDefinitions.push(...argumentDefinitions.slice(argumentDefinitions.length - metadata.repeatLastArgs));
    }
    let maxWidth = 1;
    let maxHeight = 1;
    for (let i = 0; i < subChecks.length; i++) {
      if (argumentDefinitions[i].argumentType !== _interpreter__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE && argumentDefinitions[i].argumentType !== _interpreter__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.ANY) {
        maxHeight = Math.max(maxHeight, subChecks[i].height);
        maxWidth = Math.max(maxWidth, subChecks[i].width);
      }
    }
    return new ArraySize(maxWidth, maxHeight);
  }
}

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbsoluteCellRange: () => (/* binding */ AbsoluteCellRange),
/* harmony export */   AbsoluteColumnRange: () => (/* binding */ AbsoluteColumnRange),
/* harmony export */   AbsoluteRowRange: () => (/* binding */ AbsoluteRowRange),
/* harmony export */   WRONG_RANGE_SIZE: () => (/* binding */ WRONG_RANGE_SIZE),
/* harmony export */   isSimpleCellRange: () => (/* binding */ isSimpleCellRange),
/* harmony export */   simpleCellRange: () => (/* binding */ simpleCellRange)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _Span__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




const WRONG_RANGE_SIZE = 'AbsoluteCellRange: Wrong range size';
function isSimpleCellRange(obj) {
  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {
    return 'start' in obj && (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellAddress)(obj.start) && 'end' in obj && (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellAddress)(obj.end);
  } else {
    return false;
  }
}
const simpleCellRange = (start, end) => ({
  start,
  end
});
class AbsoluteCellRange {
  constructor(start, end) {
    if (start.sheet !== end.sheet) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.SheetsNotEqual(start.sheet, end.sheet);
    }
    this.start = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(start.sheet, start.col, start.row);
    this.end = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(end.sheet, end.col, end.row);
  }
  get sheet() {
    return this.start.sheet;
  }
  static fromSimpleCellAddresses(start, end) {
    if (start.sheet !== end.sheet) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.SheetsNotEqual(start.sheet, end.sheet);
    }
    const width = end.col - start.col;
    const height = end.row - start.row;
    if (Number.isFinite(height) && Number.isFinite(width)) {
      return new AbsoluteCellRange(start, end);
    }
    if (Number.isFinite(height)) {
      return new AbsoluteRowRange(start.sheet, start.row, end.row);
    }
    return new AbsoluteColumnRange(start.sheet, start.col, end.col);
  }
  static fromAst(ast, baseAddress) {
    if (ast.type === _parser__WEBPACK_IMPORTED_MODULE_2__.AstNodeType.CELL_RANGE) {
      return AbsoluteCellRange.fromCellRange(ast, baseAddress);
    } else if (ast.type === _parser__WEBPACK_IMPORTED_MODULE_2__.AstNodeType.COLUMN_RANGE) {
      return AbsoluteColumnRange.fromColumnRange(ast, baseAddress);
    } else {
      return AbsoluteRowRange.fromRowRangeAst(ast, baseAddress);
    }
  }
  static fromAstOrUndef(ast, baseAddress) {
    try {
      return AbsoluteCellRange.fromAst(ast, baseAddress);
    } catch (_e) {
      return undefined;
    }
  }
  static fromCellRange(x, baseAddress) {
    return new AbsoluteCellRange(x.start.toSimpleCellAddress(baseAddress), x.end.toSimpleCellAddress(baseAddress));
  }
  static spanFrom(topLeftCorner, width, height) {
    const ret = AbsoluteCellRange.spanFromOrUndef(topLeftCorner, width, height);
    if (ret === undefined) {
      throw new Error(WRONG_RANGE_SIZE);
    }
    return ret;
  }
  static spanFromOrUndef(topLeftCorner, width, height) {
    if (!Number.isFinite(width) && Number.isFinite(height)) {
      if (topLeftCorner.col !== 0) {
        return undefined;
      }
      return new AbsoluteRowRange(topLeftCorner.sheet, topLeftCorner.row, topLeftCorner.row + height - 1);
    } else if (!Number.isFinite(height) && Number.isFinite(width)) {
      if (topLeftCorner.row !== 0) {
        return undefined;
      }
      return new AbsoluteColumnRange(topLeftCorner.sheet, topLeftCorner.col, topLeftCorner.col + width - 1);
    } else if (Number.isFinite(height) && Number.isFinite(width)) {
      return new AbsoluteCellRange(topLeftCorner, (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(topLeftCorner.sheet, topLeftCorner.col + width - 1, topLeftCorner.row + height - 1));
    }
    return undefined;
  }
  static fromCoordinates(sheet, x1, y1, x2, y2) {
    return new AbsoluteCellRange((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, x1, y1), (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, x2, y2));
  }
  isFinite() {
    return Number.isFinite(this.size());
  }
  doesOverlap(other) {
    if (this.start.sheet != other.start.sheet) {
      return false;
    }
    if (this.end.row < other.start.row || this.start.row > other.end.row) {
      return false;
    }
    if (this.end.col < other.start.col || this.start.col > other.end.col) {
      return false;
    }
    return true;
  }
  addressInRange(address) {
    if (this.sheet !== address.sheet) {
      return false;
    }
    return this.start.row <= address.row && this.end.row >= address.row && this.start.col <= address.col && this.end.col >= address.col;
  }
  columnInRange(address) {
    if (this.sheet !== address.sheet) {
      return false;
    }
    return this.start.col <= address.col && this.end.col >= address.col;
  }
  rowInRange(address) {
    if (this.sheet !== address.sheet) {
      return false;
    }
    return this.start.row <= address.row && this.end.row >= address.row;
  }
  containsRange(range) {
    return this.addressInRange(range.start) && this.addressInRange(range.end);
  }
  intersectionWith(other) {
    if (this.sheet !== other.start.sheet) {
      return undefined;
    }
    const startRow = Math.max(this.start.row, other.start.row);
    const endRow = Math.min(this.end.row, other.end.row);
    const startCol = Math.max(this.start.col, other.start.col);
    const endCol = Math.min(this.end.col, other.end.col);
    if (startRow > endRow || startCol > endCol) {
      return undefined;
    }
    return new AbsoluteCellRange((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.sheet, startCol, startRow), (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.sheet, endCol, endRow));
  }
  includesRow(row) {
    return this.start.row < row && this.end.row >= row;
  }
  includesColumn(column) {
    return this.start.col < column && this.end.col >= column;
  }
  shiftByRows(numberOfRows) {
    this.start.row += numberOfRows;
    this.end.row += numberOfRows;
  }
  expandByRows(numberOfRows) {
    this.end.row += numberOfRows;
  }
  shiftByColumns(numberOfColumns) {
    this.start.col += numberOfColumns;
    this.end.col += numberOfColumns;
  }
  shifted(byCols, byRows) {
    return AbsoluteCellRange.spanFrom((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.sheet, this.start.col + byCols, this.start.row + byRows), this.width(), this.height());
  }
  expandByColumns(numberOfColumns) {
    this.end.col += numberOfColumns;
  }
  moveToSheet(toSheet) {
    this.start.sheet = toSheet;
    this.end.sheet = toSheet;
  }
  removeSpan(span) {
    if (span instanceof _Span__WEBPACK_IMPORTED_MODULE_3__.RowsSpan) {
      this.removeRows(span.start, span.end);
    } else {
      this.removeColumns(span.start, span.end);
    }
  }
  shouldBeRemoved() {
    return this.width() <= 0 || this.height() <= 0;
  }
  rangeWithSameWidth(startRow, numberOfRows) {
    return AbsoluteCellRange.spanFrom((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.sheet, this.start.col, startRow), this.width(), numberOfRows);
  }
  rangeWithSameHeight(startColumn, numberOfColumns) {
    return AbsoluteCellRange.spanFrom((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.sheet, startColumn, this.start.row), numberOfColumns, this.height());
  }
  toString() {
    return `${this.start.sheet},${this.start.col},${this.start.row},${this.end.col},${this.end.row}`;
  }
  width() {
    return this.end.col - this.start.col + 1;
  }
  height() {
    return this.end.row - this.start.row + 1;
  }
  size() {
    return this.height() * this.width();
  }
  arrayOfAddressesInRange() {
    const result = [];
    for (let y = 0; y < this.height(); ++y) {
      result[y] = [];
      for (let x = 0; x < this.width(); ++x) {
        const value = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.sheet, this.start.col + x, this.start.row + y);
        result[y].push(value);
      }
    }
    return result;
  }
  withStart(newStart) {
    return new AbsoluteCellRange(newStart, this.end);
  }
  sameDimensionsAs(other) {
    return this.width() === other.width() && this.height() === other.height();
  }
  sameAs(other) {
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.equalSimpleCellAddress)(this.start, other.start) && (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.equalSimpleCellAddress)(this.end, other.end);
  }
  addressesArrayMap(dependencyGraph, op) {
    const ret = [];
    let currentRow = this.start.row;
    while (currentRow <= this.effectiveEndRow(dependencyGraph)) {
      let currentColumn = this.start.col;
      const tmp = [];
      while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {
        tmp.push(op((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.start.sheet, currentColumn, currentRow)));
        currentColumn++;
      }
      ret.push(tmp);
      currentRow++;
    }
    return ret;
  }
  addresses(dependencyGraph) {
    const ret = [];
    let currentRow = this.start.row;
    const limitRow = this.effectiveEndRow(dependencyGraph);
    const limitColumn = this.effectiveEndColumn(dependencyGraph);
    while (currentRow <= limitRow) {
      let currentColumn = this.start.col;
      while (currentColumn <= limitColumn) {
        ret.push((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.start.sheet, currentColumn, currentRow));
        currentColumn++;
      }
      currentRow++;
    }
    return ret;
  }
  *addressesWithDirection(right, bottom, dependencyGraph) {
    if (right > 0) {
      if (bottom > 0) {
        let currentRow = this.effectiveEndRow(dependencyGraph);
        while (currentRow >= this.start.row) {
          let currentColumn = this.effectiveEndColumn(dependencyGraph);
          while (currentColumn >= this.start.col) {
            yield (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.start.sheet, currentColumn, currentRow);
            currentColumn -= 1;
          }
          currentRow -= 1;
        }
      } else {
        let currentRow = this.start.row;
        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {
          let currentColumn = this.effectiveEndColumn(dependencyGraph);
          while (currentColumn >= this.start.col) {
            yield (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.start.sheet, currentColumn, currentRow);
            currentColumn -= 1;
          }
          currentRow += 1;
        }
      }
    } else {
      if (bottom > 0) {
        let currentRow = this.effectiveEndRow(dependencyGraph);
        while (currentRow >= this.start.row) {
          let currentColumn = this.start.col;
          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {
            yield (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.start.sheet, currentColumn, currentRow);
            currentColumn += 1;
          }
          currentRow -= 1;
        }
      } else {
        let currentRow = this.start.row;
        while (currentRow <= this.effectiveEndRow(dependencyGraph)) {
          let currentColumn = this.start.col;
          while (currentColumn <= this.effectiveEndColumn(dependencyGraph)) {
            yield (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.start.sheet, currentColumn, currentRow);
            currentColumn += 1;
          }
          currentRow += 1;
        }
      }
    }
  }
  getAddress(col, row) {
    if (col < 0 || row < 0 || row > this.height() - 1 || col > this.width() - 1) {
      throw Error('Index out of bound');
    }
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.start.sheet, this.start.col + col, this.start.row + row);
  }
  exceedsSheetSizeLimits(maxColumns, maxRows) {
    return this.end.col >= maxColumns || this.end.row >= maxRows;
  }
  effectiveEndColumn(_dependencyGraph) {
    return this.end.col;
  }
  effectiveEndRow(_dependencyGraph) {
    return this.end.row;
  }
  effectiveWidth(_dependencyGraph) {
    return this.width();
  }
  effectiveHeight(_dependencyGraph) {
    return this.height();
  }
  removeRows(rowStart, rowEnd) {
    if (rowStart > this.end.row) {
      return;
    }
    if (rowEnd < this.start.row) {
      const numberOfRows = rowEnd - rowStart + 1;
      return this.shiftByRows(-numberOfRows);
    }
    if (rowStart <= this.start.row) {
      this.start.row = rowStart;
    }
    this.end.row -= Math.min(rowEnd, this.end.row) - rowStart + 1;
  }
  removeColumns(columnStart, columnEnd) {
    if (columnStart > this.end.col) {
      return;
    }
    if (columnEnd < this.start.col) {
      const numberOfColumns = columnEnd - columnStart + 1;
      return this.shiftByColumns(-numberOfColumns);
    }
    if (columnStart <= this.start.col) {
      this.start.col = columnStart;
    }
    this.end.col -= Math.min(columnEnd, this.end.col) - columnStart + 1;
  }
}
class AbsoluteColumnRange extends AbsoluteCellRange {
  constructor(sheet, columnStart, columnEnd) {
    super((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, columnStart, 0), (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, columnEnd, Number.POSITIVE_INFINITY));
  }
  static fromColumnRange(x, baseAddress) {
    const start = x.start.toSimpleColumnAddress(baseAddress);
    const end = x.end.toSimpleColumnAddress(baseAddress);
    if (start.sheet !== end.sheet) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.SheetsNotEqual(start.sheet, end.sheet);
    }
    return new AbsoluteColumnRange(start.sheet, start.col, end.col);
  }
  shouldBeRemoved() {
    return this.width() <= 0;
  }
  shiftByRows(_numberOfRows) {
    return;
  }
  expandByRows(_numberOfRows) {
    return;
  }
  shifted(byCols, _byRows) {
    return new AbsoluteColumnRange(this.sheet, this.start.col + byCols, this.end.col + byCols);
  }
  rangeWithSameHeight(startColumn, numberOfColumns) {
    return new AbsoluteColumnRange(this.sheet, startColumn, startColumn + numberOfColumns - 1);
  }
  exceedsSheetSizeLimits(maxColumns, _maxRows) {
    return this.end.col >= maxColumns;
  }
  effectiveEndRow(dependencyGraph) {
    return this.effectiveHeight(dependencyGraph) - 1;
  }
  effectiveHeight(dependencyGraph) {
    return dependencyGraph.getSheetHeight(this.sheet);
  }
  removeRows(_rowStart, _rowEnd) {
    return;
  }
}
class AbsoluteRowRange extends AbsoluteCellRange {
  constructor(sheet, rowStart, rowEnd) {
    super((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, 0, rowStart), (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, Number.POSITIVE_INFINITY, rowEnd));
  }
  static fromRowRangeAst(x, baseAddress) {
    const start = x.start.toSimpleRowAddress(baseAddress);
    const end = x.end.toSimpleRowAddress(baseAddress);
    if (start.sheet !== end.sheet) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.SheetsNotEqual(start.sheet, end.sheet);
    }
    return new AbsoluteRowRange(start.sheet, start.row, end.row);
  }
  shouldBeRemoved() {
    return this.height() <= 0;
  }
  shiftByColumns(_numberOfColumns) {
    return;
  }
  expandByColumns(_numberOfColumns) {
    return;
  }
  shifted(byCols, byRows) {
    return new AbsoluteRowRange(this.sheet, this.start.row + byRows, this.end.row + byRows);
  }
  rangeWithSameWidth(startRow, numberOfRows) {
    return new AbsoluteRowRange(this.sheet, startRow, startRow + numberOfRows - 1);
  }
  exceedsSheetSizeLimits(_maxColumns, maxRows) {
    return this.end.row >= maxRows;
  }
  effectiveEndColumn(dependencyGraph) {
    return this.effectiveWidth(dependencyGraph) - 1;
  }
  effectiveWidth(dependencyGraph) {
    return dependencyGraph.getSheetWidth(this.sheet);
  }
  removeColumns(_columnStart, _columnEnd) {
    return;
  }
}

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellError: () => (/* binding */ CellError),
/* harmony export */   CellType: () => (/* binding */ CellType),
/* harmony export */   CellValueDetailedType: () => (/* binding */ CellValueDetailedType),
/* harmony export */   CellValueJustNumber: () => (/* binding */ CellValueJustNumber),
/* harmony export */   CellValueNoNumber: () => (/* binding */ CellValueNoNumber),
/* harmony export */   CellValueType: () => (/* binding */ CellValueType),
/* harmony export */   CellValueTypeOrd: () => (/* binding */ CellValueTypeOrd),
/* harmony export */   ErrorType: () => (/* binding */ ErrorType),
/* harmony export */   absoluteSheetReference: () => (/* binding */ absoluteSheetReference),
/* harmony export */   addressKey: () => (/* binding */ addressKey),
/* harmony export */   equalSimpleCellAddress: () => (/* binding */ equalSimpleCellAddress),
/* harmony export */   getCellType: () => (/* binding */ getCellType),
/* harmony export */   getCellValueDetailedType: () => (/* binding */ getCellValueDetailedType),
/* harmony export */   getCellValueFormat: () => (/* binding */ getCellValueFormat),
/* harmony export */   getCellValueType: () => (/* binding */ getCellValueType),
/* harmony export */   invalidSimpleCellAddress: () => (/* binding */ invalidSimpleCellAddress),
/* harmony export */   invalidSimpleColumnAddress: () => (/* binding */ invalidSimpleColumnAddress),
/* harmony export */   invalidSimpleRowAddress: () => (/* binding */ invalidSimpleRowAddress),
/* harmony export */   isSimpleCellAddress: () => (/* binding */ isSimpleCellAddress),
/* harmony export */   movedSimpleCellAddress: () => (/* binding */ movedSimpleCellAddress),
/* harmony export */   simpleCellAddress: () => (/* binding */ simpleCellAddress),
/* harmony export */   simpleColumnAddress: () => (/* binding */ simpleColumnAddress),
/* harmony export */   simpleRowAddress: () => (/* binding */ simpleRowAddress)
/* harmony export */ });
/* harmony import */ var _DependencyGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(69);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/**
 * Possible errors returned by our interpreter.
 */
var ErrorType;
(function (ErrorType) {
  /** Division by zero. */
  ErrorType["DIV_BY_ZERO"] = "DIV_BY_ZERO";
  /** Unknown function name. */
  ErrorType["NAME"] = "NAME";
  ErrorType["VALUE"] = "VALUE";
  ErrorType["NUM"] = "NUM";
  ErrorType["NA"] = "NA";
  /** Cyclic dependency. */
  ErrorType["CYCLE"] = "CYCLE";
  /** Wrong address reference. */
  ErrorType["REF"] = "REF";
  /** Array spill error. */
  ErrorType["SPILL"] = "SPILL";
  /** Invalid/missing licence error. */
  ErrorType["LIC"] = "LIC";
  /** Generic error */
  ErrorType["ERROR"] = "ERROR";
})(ErrorType || (ErrorType = {}));
var CellType;
(function (CellType) {
  CellType["FORMULA"] = "FORMULA";
  CellType["VALUE"] = "VALUE";
  CellType["ARRAY"] = "ARRAY";
  CellType["EMPTY"] = "EMPTY";
  CellType["ARRAYFORMULA"] = "ARRAYFORMULA";
})(CellType || (CellType = {}));
const getCellType = (vertex, address) => {
  if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_0__.ArrayVertex) {
    if (vertex.isLeftCorner(address)) {
      return CellType.ARRAYFORMULA;
    } else {
      return CellType.ARRAY;
    }
  }
  if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_0__.FormulaCellVertex || vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_0__.ParsingErrorVertex) {
    return CellType.FORMULA;
  }
  if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_0__.ValueCellVertex) {
    return CellType.VALUE;
  }
  return CellType.EMPTY;
};
var CellValueNoNumber;
(function (CellValueNoNumber) {
  CellValueNoNumber["EMPTY"] = "EMPTY";
  CellValueNoNumber["NUMBER"] = "NUMBER";
  CellValueNoNumber["STRING"] = "STRING";
  CellValueNoNumber["BOOLEAN"] = "BOOLEAN";
  CellValueNoNumber["ERROR"] = "ERROR";
})(CellValueNoNumber || (CellValueNoNumber = {}));
var CellValueJustNumber;
(function (CellValueJustNumber) {
  CellValueJustNumber["NUMBER"] = "NUMBER";
})(CellValueJustNumber || (CellValueJustNumber = {}));
const CellValueType = Object.assign(Object.assign({}, CellValueNoNumber), CellValueJustNumber);
const CellValueDetailedType = Object.assign(Object.assign({}, CellValueNoNumber), _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType);
const CellValueTypeOrd = arg => {
  switch (arg) {
    case CellValueType.EMPTY:
      return 0;
    case CellValueType.NUMBER:
      return 1;
    case CellValueType.STRING:
      return 2;
    case CellValueType.BOOLEAN:
      return 3;
    case CellValueType.ERROR:
      return 4;
  }
  throw new Error('Cell value not computed');
};
const getCellValueType = cellValue => {
  if (cellValue === _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.EmptyValue) {
    return CellValueType.EMPTY;
  }
  if (cellValue instanceof CellError || cellValue instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_3__.SimpleRangeValue) {
    return CellValueType.ERROR;
  }
  if (typeof cellValue === 'string') {
    return CellValueType.STRING;
  } else if ((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.isExtendedNumber)(cellValue)) {
    return CellValueType.NUMBER;
  } else if (typeof cellValue === 'boolean') {
    return CellValueType.BOOLEAN;
  }
  throw new Error('Cell value not computed');
};
const getCellValueDetailedType = cellValue => {
  if ((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.isExtendedNumber)(cellValue)) {
    return (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.getTypeOfExtendedNumber)(cellValue);
  } else {
    return getCellValueType(cellValue);
  }
};
const getCellValueFormat = cellValue => {
  if ((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.isExtendedNumber)(cellValue)) {
    return (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.getFormatOfExtendedNumber)(cellValue);
  } else {
    return undefined;
  }
};
class CellError {
  constructor(type, message, root) {
    this.type = type;
    this.message = message;
    this.root = root;
  }
  /**
   * Returns a CellError with a given message.
   * @param {string} detailedMessage - message to be displayed
   */
  static parsingError(detailedMessage) {
    return new CellError(ErrorType.ERROR, `${_error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ParseError}${detailedMessage ? ' ' + detailedMessage : ''}`);
  }
  attachRootVertex(vertex) {
    if (this.root === undefined) {
      return new CellError(this.type, this.message, vertex);
    } else {
      return this;
    }
  }
}
const simpleRowAddress = (sheet, row) => ({
  sheet,
  row
});
const invalidSimpleRowAddress = address => address.row < 0;
const simpleColumnAddress = (sheet, col) => ({
  sheet,
  col
});
const invalidSimpleColumnAddress = address => address.col < 0;
const simpleCellAddress = (sheet, col, row) => ({
  sheet,
  col,
  row
});
const invalidSimpleCellAddress = address => address.col < 0 || address.row < 0;
const movedSimpleCellAddress = (address, toSheet, toRight, toBottom) => {
  return simpleCellAddress(toSheet, address.col + toRight, address.row + toBottom);
};
const addressKey = address => `${address.sheet},${address.row},${address.col}`;
/**
 * Checks if the object is a simple cell address.
 */
function isSimpleCellAddress(obj) {
  var _a, _b, _c;
  return obj && (typeof obj === 'object' || typeof obj === 'function') && typeof ((_a = obj) === null || _a === void 0 ? void 0 : _a.sheet) === 'number' && typeof ((_b = obj) === null || _b === void 0 ? void 0 : _b.col) === 'number' && typeof ((_c = obj) === null || _c === void 0 ? void 0 : _c.row) === 'number';
}
const absoluteSheetReference = (address, baseAddress) => {
  var _a;
  return (_a = address.sheet) !== null && _a !== void 0 ? _a : baseAddress.sheet;
};
const equalSimpleCellAddress = (left, right) => {
  return left.sheet === right.sheet && left.col === right.col && left.row === right.row;
};

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddressMapping: () => (/* reexport safe */ _AddressMapping_AddressMapping__WEBPACK_IMPORTED_MODULE_1__.AddressMapping),
/* harmony export */   ArrayMapping: () => (/* reexport safe */ _ArrayMapping__WEBPACK_IMPORTED_MODULE_6__.ArrayMapping),
/* harmony export */   ArrayVertex: () => (/* reexport safe */ _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_7__.ArrayVertex),
/* harmony export */   DenseStrategy: () => (/* reexport safe */ _AddressMapping_DenseStrategy__WEBPACK_IMPORTED_MODULE_13__.DenseStrategy),
/* harmony export */   DependencyGraph: () => (/* reexport safe */ _DependencyGraph__WEBPACK_IMPORTED_MODULE_0__.DependencyGraph),
/* harmony export */   EmptyCellVertex: () => (/* reexport safe */ _EmptyCellVertex__WEBPACK_IMPORTED_MODULE_8__.EmptyCellVertex),
/* harmony export */   FormulaCellVertex: () => (/* reexport safe */ _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_7__.FormulaCellVertex),
/* harmony export */   Graph: () => (/* reexport safe */ _Graph__WEBPACK_IMPORTED_MODULE_2__.Graph),
/* harmony export */   ParsingErrorVertex: () => (/* reexport safe */ _ParsingErrorVertex__WEBPACK_IMPORTED_MODULE_10__.ParsingErrorVertex),
/* harmony export */   RangeMapping: () => (/* reexport safe */ _RangeMapping__WEBPACK_IMPORTED_MODULE_4__.RangeMapping),
/* harmony export */   RangeVertex: () => (/* reexport safe */ _RangeVertex__WEBPACK_IMPORTED_MODULE_11__.RangeVertex),
/* harmony export */   SheetMapping: () => (/* reexport safe */ _SheetMapping__WEBPACK_IMPORTED_MODULE_5__.SheetMapping),
/* harmony export */   SparseStrategy: () => (/* reexport safe */ _AddressMapping_SparseStrategy__WEBPACK_IMPORTED_MODULE_12__.SparseStrategy),
/* harmony export */   TopSort: () => (/* reexport safe */ _TopSort__WEBPACK_IMPORTED_MODULE_3__.TopSort),
/* harmony export */   ValueCellVertex: () => (/* reexport safe */ _ValueCellVertex__WEBPACK_IMPORTED_MODULE_9__.ValueCellVertex)
/* harmony export */ });
/* harmony import */ var _DependencyGraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var _AddressMapping_AddressMapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(83);
/* harmony import */ var _TopSort__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84);
/* harmony import */ var _RangeMapping__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(86);
/* harmony import */ var _SheetMapping__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(87);
/* harmony import */ var _ArrayMapping__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(78);
/* harmony import */ var _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(80);
/* harmony import */ var _EmptyCellVertex__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(90);
/* harmony import */ var _ValueCellVertex__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(91);
/* harmony import */ var _ParsingErrorVertex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(92);
/* harmony import */ var _RangeVertex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(82);
/* harmony import */ var _AddressMapping_SparseStrategy__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(93);
/* harmony import */ var _AddressMapping_DenseStrategy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(94);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
















/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DependencyGraph: () => (/* binding */ DependencyGraph)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _ContentChanges__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(61);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(69);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);
/* harmony import */ var _Span__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(71);
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(72);
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(4);
/* harmony import */ var _AddressMapping_AddressMapping__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(76);
/* harmony import */ var _ArrayMapping__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(78);
/* harmony import */ var _collectAddressesDependentToRange__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(79);
/* harmony import */ var _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(80);
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(83);
/* harmony import */ var _RangeMapping__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(86);
/* harmony import */ var _SheetMapping__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(87);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


















class DependencyGraph {
  constructor(addressMapping, rangeMapping, sheetMapping, arrayMapping, stats, lazilyTransformingAstService, functionRegistry, namedExpressions) {
    this.addressMapping = addressMapping;
    this.rangeMapping = rangeMapping;
    this.sheetMapping = sheetMapping;
    this.arrayMapping = arrayMapping;
    this.stats = stats;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.functionRegistry = functionRegistry;
    this.namedExpressions = namedExpressions;
    this.changes = _ContentChanges__WEBPACK_IMPORTED_MODULE_3__.ContentChanges.empty();
    this.dependencyQueryAddresses = vertex => {
      if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex) {
        return this.rangeDependencyQuery(vertex).map(([address, _]) => address);
      } else {
        const dependenciesResult = this.formulaDependencyQuery(vertex);
        if (dependenciesResult !== undefined) {
          const [address, dependencies] = dependenciesResult;
          return dependencies.map(dependency => {
            if (dependency instanceof _parser__WEBPACK_IMPORTED_MODULE_7__.NamedExpressionDependency) {
              return this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet).address;
            } else if ((0,_Cell__WEBPACK_IMPORTED_MODULE_2__.isSimpleCellAddress)(dependency)) {
              return dependency;
            } else {
              return (0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.simpleCellRange)(dependency.start, dependency.end);
            }
          });
        } else {
          return [];
        }
      }
    };
    this.dependencyQueryVertices = vertex => {
      if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex) {
        return this.rangeDependencyQuery(vertex);
      } else {
        const dependenciesResult = this.formulaDependencyQuery(vertex);
        if (dependenciesResult !== undefined) {
          const [address, dependencies] = dependenciesResult;
          return dependencies.map(dependency => {
            if (dependency instanceof _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange) {
              return [dependency.start, this.rangeMapping.fetchRange(dependency.start, dependency.end)];
            } else if (dependency instanceof _parser__WEBPACK_IMPORTED_MODULE_7__.NamedExpressionDependency) {
              const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(dependency.name, address.sheet);
              return [namedExpression.address, this.addressMapping.fetchCell(namedExpression.address)];
            } else {
              return [dependency, this.addressMapping.fetchCell(dependency)];
            }
          });
        } else {
          return [];
        }
      }
    };
    this.rangeDependencyQuery = vertex => {
      const allDeps = [];
      const {
        smallerRangeVertex,
        restRange
      } = this.rangeMapping.findSmallerRange(vertex.range); //checking whether this range was splitted by bruteForce or not
      let range;
      if (smallerRangeVertex !== undefined && this.graph.adjacentNodes(smallerRangeVertex).has(vertex)) {
        range = restRange;
        allDeps.push([new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(smallerRangeVertex.start, smallerRangeVertex.end), smallerRangeVertex]);
      } else {
        //did we ever need to use full range
        range = vertex.range;
      }
      for (const address of range.addresses(this)) {
        const cell = this.addressMapping.getCell(address);
        if (cell !== undefined) {
          allDeps.push([address, cell]);
        }
      }
      return allDeps;
    };
    this.formulaDependencyQuery = vertex => {
      let formula;
      let address;
      if (vertex instanceof _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_14__.FormulaVertex) {
        address = vertex.getAddress(this.lazilyTransformingAstService);
        formula = vertex.getFormula(this.lazilyTransformingAstService);
      } else {
        return undefined;
      }
      const deps = (0,_parser__WEBPACK_IMPORTED_MODULE_7__.collectDependencies)(formula, this.functionRegistry);
      return [address, (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.absolutizeDependencies)(deps, address)];
    };
    this.graph = new _Graph__WEBPACK_IMPORTED_MODULE_15__.Graph(this.dependencyQueryVertices);
  }
  /**
   * Invariants:
   * - empty cell has associated EmptyCellVertex if and only if it is a dependency (possibly indirect, through range) to some formula
   */
  static buildEmpty(lazilyTransformingAstService, config, functionRegistry, namedExpressions, stats) {
    return new DependencyGraph(new _AddressMapping_AddressMapping__WEBPACK_IMPORTED_MODULE_11__.AddressMapping(config.chooseAddressMappingPolicy), new _RangeMapping__WEBPACK_IMPORTED_MODULE_16__.RangeMapping(), new _SheetMapping__WEBPACK_IMPORTED_MODULE_17__.SheetMapping(config.translationPackage), new _ArrayMapping__WEBPACK_IMPORTED_MODULE_12__.ArrayMapping(), stats, lazilyTransformingAstService, functionRegistry, namedExpressions);
  }
  setFormulaToCell(address, ast, dependencies, size, hasVolatileFunction, hasStructuralChangeFunction) {
    const newVertex = _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_14__.FormulaVertex.fromAst(ast, address, size, this.lazilyTransformingAstService.version());
    this.exchangeOrAddFormulaVertex(newVertex);
    this.processCellDependencies(dependencies, newVertex);
    this.graph.markNodeAsDirty(newVertex);
    if (hasVolatileFunction) {
      this.markAsVolatile(newVertex);
    }
    if (hasStructuralChangeFunction) {
      this.markAsDependentOnStructureChange(newVertex);
    }
    this.correctInfiniteRangesDependency(address);
    return this.getAndClearContentChanges();
  }
  setParsingErrorToCell(address, errorVertex) {
    const vertex = this.shrinkPossibleArrayAndGetCell(address);
    this.exchangeOrAddGraphNode(vertex, errorVertex);
    this.addressMapping.setCell(address, errorVertex);
    this.graph.markNodeAsDirty(errorVertex);
    this.correctInfiniteRangesDependency(address);
    return this.getAndClearContentChanges();
  }
  setValueToCell(address, value) {
    const vertex = this.shrinkPossibleArrayAndGetCell(address);
    if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
      this.arrayMapping.removeArray(vertex.getRange());
    }
    if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ValueCellVertex) {
      const oldValues = vertex.getValues();
      if (oldValues.rawValue !== value.rawValue) {
        vertex.setValues(value);
        this.graph.markNodeAsDirty(vertex);
      }
    } else {
      const newVertex = new ___WEBPACK_IMPORTED_MODULE_10__.ValueCellVertex(value.parsedValue, value.rawValue);
      this.exchangeOrAddGraphNode(vertex, newVertex);
      this.addressMapping.setCell(address, newVertex);
      this.graph.markNodeAsDirty(newVertex);
    }
    this.correctInfiniteRangesDependency(address);
    return this.getAndClearContentChanges();
  }
  setCellEmpty(address) {
    const vertex = this.shrinkPossibleArrayAndGetCell(address);
    if (vertex === undefined) {
      return _ContentChanges__WEBPACK_IMPORTED_MODULE_3__.ContentChanges.empty();
    }
    if (this.graph.adjacentNodes(vertex).size > 0) {
      const emptyVertex = new ___WEBPACK_IMPORTED_MODULE_10__.EmptyCellVertex();
      this.exchangeGraphNode(vertex, emptyVertex);
      if (this.graph.adjacentNodesCount(emptyVertex) === 0) {
        this.removeVertex(emptyVertex);
        this.addressMapping.removeCell(address);
      } else {
        this.graph.markNodeAsDirty(emptyVertex);
        this.addressMapping.setCell(address, emptyVertex);
      }
    } else {
      this.removeVertex(vertex);
      this.addressMapping.removeCell(address);
    }
    return this.getAndClearContentChanges();
  }
  clearDirtyVertices() {
    this.graph.clearDirtyNodes();
  }
  verticesToRecompute() {
    return this.graph.getDirtyAndVolatileNodes();
  }
  processCellDependencies(cellDependencies, endVertex) {
    const endVertexId = this.graph.getNodeId(endVertex);
    cellDependencies.forEach(dep => {
      if (dep instanceof _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange) {
        const range = dep;
        let rangeVertex = this.getRange(range.start, range.end);
        if (rangeVertex === undefined) {
          rangeVertex = new ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex(range);
          this.rangeMapping.setRange(rangeVertex);
        }
        this.graph.addNodeAndReturnId(rangeVertex);
        const rangeVertexId = this.graph.getNodeId(rangeVertex);
        if (!range.isFinite()) {
          this.graph.markNodeAsInfiniteRange(rangeVertexId);
        }
        const {
          smallerRangeVertex,
          restRange
        } = this.rangeMapping.findSmallerRange(range);
        if (smallerRangeVertex !== undefined) {
          this.graph.addEdge(smallerRangeVertex, rangeVertexId);
          if (rangeVertex.bruteForce) {
            rangeVertex.bruteForce = false;
            for (const cellFromRange of range.addresses(this)) {
              //if we ever switch heuristic to processing by sorted sizes, this would be unnecessary
              this.graph.removeEdge(this.fetchCell(cellFromRange), rangeVertexId);
            }
          }
        } else {
          rangeVertex.bruteForce = true;
        }
        const array = this.arrayMapping.getArray(restRange);
        if (array !== undefined) {
          this.graph.addEdge(array, rangeVertexId);
        } else {
          for (const cellFromRange of restRange.addresses(this)) {
            const {
              vertex,
              id
            } = this.fetchCellOrCreateEmpty(cellFromRange);
            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertexId);
          }
        }
        this.graph.addEdge(rangeVertexId, endVertexId);
        if (range.isFinite()) {
          this.correctInfiniteRangesDependenciesByRangeVertex(rangeVertex);
        }
      } else if (dep instanceof _parser__WEBPACK_IMPORTED_MODULE_7__.NamedExpressionDependency) {
        const sheetOfVertex = endVertex.getAddress(this.lazilyTransformingAstService).sheet;
        const {
          vertex,
          id
        } = this.fetchNamedExpressionVertex(dep.name, sheetOfVertex);
        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, endVertexId);
      } else {
        const {
          vertex,
          id
        } = this.fetchCellOrCreateEmpty(dep);
        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, endVertexId);
      }
    });
  }
  fetchNamedExpressionVertex(expressionName, sheetId) {
    const namedExpression = this.namedExpressions.namedExpressionOrPlaceholder(expressionName, sheetId);
    return this.fetchCellOrCreateEmpty(namedExpression.address);
  }
  exchangeNode(addressFrom, addressTo) {
    const vertexFrom = this.fetchCellOrCreateEmpty(addressFrom).vertex;
    const vertexTo = this.fetchCellOrCreateEmpty(addressTo).vertex;
    this.addressMapping.removeCell(addressFrom);
    this.exchangeGraphNode(vertexFrom, vertexTo);
  }
  fetchCellOrCreateEmpty(address) {
    const existingVertex = this.addressMapping.getCell(address);
    if (existingVertex !== undefined) {
      return {
        vertex: existingVertex,
        id: undefined
      };
    }
    const newVertex = new ___WEBPACK_IMPORTED_MODULE_10__.EmptyCellVertex();
    const newVertexId = this.graph.addNodeAndReturnId(newVertex);
    this.addressMapping.setCell(address, newVertex);
    return {
      vertex: newVertex,
      id: newVertexId
    };
  }
  removeRows(removedRows) {
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_GRAPH, () => {
      for (const [address, vertex] of this.addressMapping.entriesFromRowsSpan(removedRows)) {
        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {
          this.graph.markNodeAsDirty(adjacentNode);
        }
        if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
          if (vertex.isLeftCorner(address)) {
            this.shrinkArrayToCorner(vertex);
            this.arrayMapping.removeArray(vertex.getRange());
          } else {
            continue;
          }
        }
        this.removeVertex(vertex);
      }
    });
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ADDRESS_MAPPING, () => {
      this.addressMapping.removeRows(removedRows);
    });
    const affectedArrays = this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_RANGES, () => {
      const affectedRanges = this.truncateRanges(removedRows, address => address.row);
      return this.getArrayVerticesRelatedToRanges(affectedRanges);
    });
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ARRAY_MAPPING, () => {
      this.fixArraysAfterRemovingRows(removedRows.sheet, removedRows.rowStart, removedRows.numberOfRows);
    });
    this.addStructuralNodesToChangeSet();
    return {
      affectedArrays,
      contentChanges: this.getAndClearContentChanges()
    };
  }
  removeSheet(removedSheetId) {
    this.clearSheet(removedSheetId);
    for (const [adr, vertex] of this.addressMapping.sheetEntries(removedSheetId)) {
      for (const adjacentNode of this.graph.adjacentNodes(vertex)) {
        this.graph.markNodeAsDirty(adjacentNode);
      }
      this.removeVertex(vertex);
      this.addressMapping.removeCell(adr);
    }
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_RANGES, () => {
      const rangesToRemove = this.rangeMapping.removeRangesInSheet(removedSheetId);
      for (const range of rangesToRemove) {
        this.removeVertex(range);
      }
      this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ADDRESS_MAPPING, () => {
        this.addressMapping.removeSheet(removedSheetId);
      });
    });
  }
  clearSheet(sheetId) {
    const arrays = new Set();
    for (const [address, vertex] of this.addressMapping.sheetEntries(sheetId)) {
      if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
        arrays.add(vertex);
      } else {
        this.setCellEmpty(address);
      }
    }
    for (const array of arrays.values()) {
      this.setArrayEmpty(array);
    }
    this.addStructuralNodesToChangeSet();
  }
  removeColumns(removedColumns) {
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_GRAPH, () => {
      for (const [address, vertex] of this.addressMapping.entriesFromColumnsSpan(removedColumns)) {
        for (const adjacentNode of this.graph.adjacentNodes(vertex)) {
          this.graph.markNodeAsDirty(adjacentNode);
        }
        if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
          if (vertex.isLeftCorner(address)) {
            this.shrinkArrayToCorner(vertex);
            this.arrayMapping.removeArray(vertex.getRange());
          } else {
            continue;
          }
        }
        this.removeVertex(vertex);
      }
    });
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ADDRESS_MAPPING, () => {
      this.addressMapping.removeColumns(removedColumns);
    });
    const affectedArrays = this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_RANGES, () => {
      const affectedRanges = this.truncateRanges(removedColumns, address => address.col);
      return this.getArrayVerticesRelatedToRanges(affectedRanges);
    });
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ARRAY_MAPPING, () => {
      return this.fixArraysAfterRemovingColumns(removedColumns.sheet, removedColumns.columnStart, removedColumns.numberOfColumns);
    });
    this.addStructuralNodesToChangeSet();
    return {
      affectedArrays,
      contentChanges: this.getAndClearContentChanges()
    };
  }
  addRows(addedRows) {
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ADDRESS_MAPPING, () => {
      this.addressMapping.addRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
    });
    const affectedArrays = this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_RANGES, () => {
      const result = this.rangeMapping.moveAllRangesInSheetAfterRowByRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
      this.fixRangesWhenAddingRows(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);
    });
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ARRAY_MAPPING, () => {
      this.fixArraysAfterAddingRow(addedRows.sheet, addedRows.rowStart, addedRows.numberOfRows);
    });
    for (const vertex of this.addressMapping.verticesFromRowsSpan(addedRows)) {
      this.graph.markNodeAsDirty(vertex);
    }
    this.addStructuralNodesToChangeSet();
    return {
      affectedArrays
    };
  }
  addColumns(addedColumns) {
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ADDRESS_MAPPING, () => {
      this.addressMapping.addColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
    });
    const affectedArrays = this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_RANGES, () => {
      const result = this.rangeMapping.moveAllRangesInSheetAfterColumnByColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
      this.fixRangesWhenAddingColumns(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
      return this.getArrayVerticesRelatedToRanges(result.verticesWithChangedSize);
    });
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.ADJUSTING_ARRAY_MAPPING, () => {
      return this.fixArraysAfterAddingColumn(addedColumns.sheet, addedColumns.columnStart, addedColumns.numberOfColumns);
    });
    for (const vertex of this.addressMapping.verticesFromColumnsSpan(addedColumns)) {
      this.graph.markNodeAsDirty(vertex);
    }
    this.addStructuralNodesToChangeSet();
    return {
      affectedArrays,
      contentChanges: this.getAndClearContentChanges()
    };
  }
  isThereSpaceForArray(arrayVertex) {
    const range = arrayVertex.getRangeOrUndef();
    if (range === undefined) {
      return false;
    }
    for (const address of range.addresses(this)) {
      const vertexUnderAddress = this.addressMapping.getCell(address);
      if (vertexUnderAddress !== undefined && !(vertexUnderAddress instanceof ___WEBPACK_IMPORTED_MODULE_10__.EmptyCellVertex) && vertexUnderAddress !== arrayVertex) {
        return false;
      }
    }
    return true;
  }
  moveCells(sourceRange, toRight, toBottom, toSheet) {
    for (const sourceAddress of sourceRange.addressesWithDirection(toRight, toBottom, this)) {
      const targetAddress = (0,_Cell__WEBPACK_IMPORTED_MODULE_2__.simpleCellAddress)(toSheet, sourceAddress.col + toRight, sourceAddress.row + toBottom);
      let sourceVertex = this.addressMapping.getCell(sourceAddress);
      const targetVertex = this.addressMapping.getCell(targetAddress);
      this.addressMapping.removeCell(sourceAddress);
      if (sourceVertex !== undefined) {
        this.graph.markNodeAsDirty(sourceVertex);
        this.addressMapping.setCell(targetAddress, sourceVertex);
        let emptyVertex = undefined;
        for (const adjacentNode of this.graph.adjacentNodes(sourceVertex)) {
          if (adjacentNode instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {
            emptyVertex = emptyVertex !== null && emptyVertex !== void 0 ? emptyVertex : this.fetchCellOrCreateEmpty(sourceAddress).vertex;
            this.graph.addEdge(emptyVertex, adjacentNode);
            this.graph.removeEdge(sourceVertex, adjacentNode);
          }
        }
        if (emptyVertex) {
          this.graph.markNodeAsDirty(emptyVertex);
          this.addressMapping.setCell(sourceAddress, emptyVertex);
        }
      }
      if (targetVertex !== undefined) {
        if (sourceVertex === undefined) {
          this.addressMapping.removeCell(targetAddress);
        }
        for (const adjacentNode of this.graph.adjacentNodes(targetVertex)) {
          sourceVertex = sourceVertex !== null && sourceVertex !== void 0 ? sourceVertex : this.fetchCellOrCreateEmpty(targetAddress).vertex;
          this.graph.addEdge(sourceVertex, adjacentNode);
          this.graph.markNodeAsDirty(sourceVertex);
        }
        this.removeVertex(targetVertex);
      }
    }
    for (const rangeVertex of this.rangeMapping.rangeVerticesContainedInRange(sourceRange)) {
      for (const adjacentNode of this.graph.adjacentNodes(rangeVertex)) {
        if (adjacentNode instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex && !sourceRange.containsRange(adjacentNode.range)) {
          this.graph.removeEdge(rangeVertex, adjacentNode);
          for (const address of rangeVertex.range.addresses(this)) {
            const {
              vertex,
              id
            } = this.fetchCellOrCreateEmpty(address);
            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, adjacentNode);
            this.addressMapping.setCell(address, vertex);
            this.graph.markNodeAsDirty(vertex);
          }
        }
      }
    }
    this.rangeMapping.moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet);
  }
  setArrayEmpty(arrayVertex) {
    const arrayRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(arrayVertex.getAddress(this.lazilyTransformingAstService), arrayVertex.width, arrayVertex.height);
    const adjacentNodes = this.graph.adjacentNodes(arrayVertex);
    for (const address of arrayRange.addresses(this)) {
      this.addressMapping.removeCell(address);
    }
    for (const adjacentNode of adjacentNodes.values()) {
      const nodeDependencies = (0,_collectAddressesDependentToRange__WEBPACK_IMPORTED_MODULE_13__.collectAddressesDependentToRange)(this.functionRegistry, adjacentNode, arrayVertex.getRange(), this.lazilyTransformingAstService, this);
      for (const address of nodeDependencies) {
        const {
          vertex,
          id
        } = this.fetchCellOrCreateEmpty(address);
        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, adjacentNode);
      }
      if (nodeDependencies.length > 0) {
        this.graph.markNodeAsDirty(adjacentNode);
      }
    }
    this.removeVertex(arrayVertex);
    this.arrayMapping.removeArray(arrayVertex.getRange());
  }
  addVertex(address, vertex) {
    this.graph.addNodeAndReturnId(vertex);
    this.addressMapping.setCell(address, vertex);
  }
  addArrayVertex(address, vertex) {
    this.graph.addNodeAndReturnId(vertex);
    this.setAddressMappingForArrayVertex(vertex, address);
  }
  *arrayFormulaNodes() {
    for (const vertex of this.graph.getNodes()) {
      if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
        yield vertex;
      }
    }
  }
  *entriesFromRowsSpan(rowsSpan) {
    yield* this.addressMapping.entriesFromRowsSpan(rowsSpan);
  }
  *entriesFromColumnsSpan(columnsSpan) {
    yield* this.addressMapping.entriesFromColumnsSpan(columnsSpan);
  }
  fetchCell(address) {
    return this.addressMapping.fetchCell(address);
  }
  getCell(address) {
    return this.addressMapping.getCell(address);
  }
  getCellValue(address) {
    return this.addressMapping.getCellValue(address);
  }
  getRawValue(address) {
    return this.addressMapping.getRawValue(address);
  }
  getScalarValue(address) {
    const value = this.addressMapping.getCellValue(address);
    if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage.ScalarExpected);
    }
    return value;
  }
  existsEdge(fromNode, toNode) {
    return this.graph.existsEdge(fromNode, toNode);
  }
  getSheetId(sheetName) {
    return this.sheetMapping.fetch(sheetName);
  }
  getSheetHeight(sheet) {
    return this.addressMapping.getHeight(sheet);
  }
  getSheetWidth(sheet) {
    return this.addressMapping.getWidth(sheet);
  }
  getArray(range) {
    return this.arrayMapping.getArray(range);
  }
  getRange(start, end) {
    return this.rangeMapping.getRange(start, end);
  }
  topSortWithScc() {
    return this.graph.topSortWithScc();
  }
  markAsVolatile(vertex) {
    this.graph.markNodeAsVolatile(vertex);
  }
  markAsDependentOnStructureChange(vertex) {
    this.graph.markNodeAsChangingWithStructure(vertex);
  }
  forceApplyPostponedTransformations() {
    for (const vertex of this.graph.getNodes()) {
      if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.FormulaCellVertex) {
        vertex.ensureRecentData(this.lazilyTransformingAstService);
      }
    }
  }
  *rawValuesFromRange(range) {
    for (const address of range.addresses(this)) {
      const value = this.getScalarValue(address);
      if (value !== _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.EmptyValue) {
        yield [(0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.getRawValue)(value), address];
      }
    }
  }
  computeListOfValuesInRange(range) {
    const values = [];
    for (const cellFromRange of range.addresses(this)) {
      const value = this.getScalarValue(cellFromRange);
      values.push(value);
    }
    return values;
  }
  shrinkArrayToCorner(array) {
    this.cleanAddressMappingUnderArray(array);
    for (const adjacentVertex of this.adjacentArrayVertices(array)) {
      let relevantDependencies;
      if (adjacentVertex instanceof _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_14__.FormulaVertex) {
        relevantDependencies = this.formulaDirectDependenciesToArray(adjacentVertex, array);
      } else {
        relevantDependencies = this.rangeDirectDependenciesToArray(adjacentVertex, array);
      }
      let dependentToCorner = false;
      for (const [address, vertex] of relevantDependencies) {
        if (array.isLeftCorner(address)) {
          dependentToCorner = true;
        }
        this.graph.addEdge(vertex, adjacentVertex);
        this.graph.markNodeAsDirty(vertex);
      }
      if (!dependentToCorner) {
        this.graph.removeEdge(array, adjacentVertex);
      }
    }
    this.graph.markNodeAsDirty(array);
  }
  isArrayInternalCell(address) {
    const vertex = this.getCell(address);
    return vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex && !vertex.isLeftCorner(address);
  }
  getAndClearContentChanges() {
    const changes = this.changes;
    this.changes = _ContentChanges__WEBPACK_IMPORTED_MODULE_3__.ContentChanges.empty();
    return changes;
  }
  getAdjacentNodesAddresses(inputVertex) {
    const deps = this.graph.adjacentNodes(inputVertex);
    const ret = [];
    deps.forEach(vertex => {
      const castVertex = vertex;
      if (castVertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex) {
        ret.push((0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.simpleCellRange)(castVertex.start, castVertex.end));
      } else {
        ret.push(castVertex.getAddress(this.lazilyTransformingAstService));
      }
    });
    return ret;
  }
  exchangeGraphNode(oldNode, newNode) {
    this.graph.addNodeAndReturnId(newNode);
    const adjNodesStored = this.graph.adjacentNodes(oldNode);
    this.removeVertex(oldNode);
    adjNodesStored.forEach(adjacentNode => {
      if (this.graph.hasNode(adjacentNode)) {
        this.graph.addEdge(newNode, adjacentNode);
      }
    });
  }
  setArray(range, vertex) {
    this.arrayMapping.setArray(range, vertex);
  }
  correctInfiniteRangesDependency(address) {
    const relevantInfiniteRanges = this.graph.getInfiniteRanges().filter(({
      node
    }) => node.range.addressInRange(address));
    if (relevantInfiniteRanges.length <= 0) {
      return;
    }
    const {
      vertex,
      id: maybeVertexId
    } = this.fetchCellOrCreateEmpty(address);
    const vertexId = maybeVertexId !== null && maybeVertexId !== void 0 ? maybeVertexId : this.graph.getNodeId(vertex);
    relevantInfiniteRanges.forEach(({
      id
    }) => {
      this.graph.addEdge(vertexId, id);
    });
  }
  exchangeOrAddGraphNode(oldNode, newNode) {
    if (oldNode) {
      this.exchangeGraphNode(oldNode, newNode);
    } else {
      this.graph.addNodeAndReturnId(newNode);
    }
  }
  getArrayVerticesRelatedToRanges(ranges) {
    const arrayVertices = new Set();
    ranges.forEach(range => {
      if (!this.graph.hasNode(range)) {
        return;
      }
      this.graph.adjacentNodes(range).forEach(adjacentVertex => {
        if (adjacentVertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
          arrayVertices.add(adjacentVertex);
        }
      });
    });
    return arrayVertices;
  }
  correctInfiniteRangesDependenciesByRangeVertex(vertex) {
    this.graph.getInfiniteRanges().forEach(({
      id: infiniteRangeVertexId,
      node: infiniteRangeVertex
    }) => {
      const intersection = vertex.range.intersectionWith(infiniteRangeVertex.range);
      if (intersection === undefined) {
        return;
      }
      intersection.addresses(this).forEach(address => {
        const {
          vertex,
          id
        } = this.fetchCellOrCreateEmpty(address);
        this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, infiniteRangeVertexId);
      });
    });
  }
  cleanAddressMappingUnderArray(vertex) {
    const arrayRange = vertex.getRange();
    for (const address of arrayRange.addresses(this)) {
      const oldValue = vertex.getArrayCellValue(address);
      if (this.getCell(address) === vertex) {
        if (vertex.isLeftCorner(address)) {
          this.changes.addChange(new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.REF), address, oldValue);
        } else {
          this.addressMapping.removeCell(address);
          this.changes.addChange(_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.EmptyValue, address, oldValue);
        }
      } else {
        this.changes.addChange(_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.EmptyValue, address, oldValue);
      }
    }
  }
  *formulaDirectDependenciesToArray(vertex, array) {
    var _a;
    const [, formulaDependencies] = (_a = this.formulaDependencyQuery(vertex)) !== null && _a !== void 0 ? _a : [];
    if (formulaDependencies === undefined) {
      return;
    }
    for (const dependency of formulaDependencies) {
      if (dependency instanceof _parser__WEBPACK_IMPORTED_MODULE_7__.NamedExpressionDependency || dependency instanceof _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange) {
        continue;
      }
      if (array.getRange().addressInRange(dependency)) {
        const vertex = this.fetchCellOrCreateEmpty(dependency).vertex;
        yield [dependency, vertex];
      }
    }
  }
  *rangeDirectDependenciesToArray(vertex, array) {
    const {
      restRange: range
    } = this.rangeMapping.findSmallerRange(vertex.range);
    for (const address of range.addresses(this)) {
      if (array.getRange().addressInRange(address)) {
        const cell = this.fetchCellOrCreateEmpty(address).vertex;
        yield [address, cell];
      }
    }
  }
  *adjacentArrayVertices(vertex) {
    const adjacentNodes = this.graph.adjacentNodes(vertex);
    for (const item of adjacentNodes) {
      if (item instanceof _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_14__.FormulaVertex || item instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex) {
        yield item;
      }
    }
  }
  addStructuralNodesToChangeSet() {
    this.graph.markChangingWithStructureNodesAsDirty();
  }
  fixRangesWhenAddingRows(sheet, row, numberOfRows) {
    const originalValues = Array.from(this.rangeMapping.rangesInSheet(sheet));
    for (const rangeVertex of originalValues) {
      if (rangeVertex.range.includesRow(row + numberOfRows)) {
        if (rangeVertex.bruteForce) {
          const addedSubrangeInThatRange = rangeVertex.range.rangeWithSameWidth(row, numberOfRows);
          for (const address of addedSubrangeInThatRange.addresses(this)) {
            const {
              vertex,
              id
            } = this.fetchCellOrCreateEmpty(address);
            this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);
          }
        } else {
          let currentRangeVertex = rangeVertex;
          let find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);
          if (find.smallerRangeVertex !== undefined) {
            continue;
          }
          while (find.smallerRangeVertex === undefined) {
            const newRangeVertex = new ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex(_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(currentRangeVertex.range.start, currentRangeVertex.range.width(), currentRangeVertex.range.height() - 1));
            this.rangeMapping.setRange(newRangeVertex);
            this.graph.addNodeAndReturnId(newRangeVertex);
            const restRange = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange((0,_Cell__WEBPACK_IMPORTED_MODULE_2__.simpleCellAddress)(currentRangeVertex.range.start.sheet, currentRangeVertex.range.start.col, currentRangeVertex.range.end.row), currentRangeVertex.range.end);
            this.addAllFromRange(restRange, currentRangeVertex);
            this.graph.addEdge(newRangeVertex, currentRangeVertex);
            currentRangeVertex = newRangeVertex;
            find = this.rangeMapping.findSmallerRange(currentRangeVertex.range);
          }
          this.graph.addEdge(find.smallerRangeVertex, currentRangeVertex);
          this.addAllFromRange(find.restRange, currentRangeVertex);
          this.graph.removeEdge(find.smallerRangeVertex, rangeVertex);
        }
      }
    }
  }
  addAllFromRange(range, rangeVertex) {
    for (const address of range.addresses(this)) {
      const {
        vertex,
        id
      } = this.fetchCellOrCreateEmpty(address);
      this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);
    }
  }
  fixRangesWhenAddingColumns(sheet, column, numberOfColumns) {
    for (const rangeVertex of this.rangeMapping.rangesInSheet(sheet)) {
      if (rangeVertex.range.includesColumn(column + numberOfColumns)) {
        let subrange;
        if (rangeVertex.bruteForce) {
          subrange = rangeVertex.range.rangeWithSameHeight(column, numberOfColumns);
        } else {
          subrange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom((0,_Cell__WEBPACK_IMPORTED_MODULE_2__.simpleCellAddress)(sheet, column, rangeVertex.range.end.row), numberOfColumns, 1);
        }
        for (const address of subrange.addresses(this)) {
          const {
            vertex,
            id
          } = this.fetchCellOrCreateEmpty(address);
          this.graph.addEdge(id !== null && id !== void 0 ? id : vertex, rangeVertex);
        }
      }
    }
  }
  exchangeOrAddFormulaVertex(vertex) {
    const address = vertex.getAddress(this.lazilyTransformingAstService);
    const range = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(address, vertex.width, vertex.height);
    const oldNode = this.shrinkPossibleArrayAndGetCell(address);
    if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
      this.setArray(range, vertex);
    }
    this.exchangeOrAddGraphNode(oldNode, vertex);
    this.addressMapping.setCell(address, vertex);
    if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
      if (!this.isThereSpaceForArray(vertex)) {
        return;
      }
      for (const cellAddress of range.addresses(this)) {
        if (vertex.isLeftCorner(cellAddress)) {
          continue;
        }
        const old = this.getCell(cellAddress);
        this.exchangeOrAddGraphNode(old, vertex);
      }
    }
    for (const cellAddress of range.addresses(this)) {
      this.addressMapping.setCell(cellAddress, vertex);
    }
  }
  setAddressMappingForArrayVertex(vertex, formulaAddress) {
    this.addressMapping.setCell(formulaAddress, vertex);
    if (!(vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex)) {
      return;
    }
    const range = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFromOrUndef(formulaAddress, vertex.width, vertex.height);
    if (range === undefined) {
      return;
    }
    this.setArray(range, vertex);
    if (!this.isThereSpaceForArray(vertex)) {
      return;
    }
    for (const address of range.addresses(this)) {
      this.addressMapping.setCell(address, vertex);
    }
  }
  truncateRanges(span, coordinate) {
    const {
      verticesToRemove,
      verticesToMerge,
      verticesWithChangedSize
    } = this.rangeMapping.truncateRanges(span, coordinate);
    for (const [existingVertex, mergedVertex] of verticesToMerge) {
      this.mergeRangeVertices(existingVertex, mergedVertex);
    }
    for (const rangeVertex of verticesToRemove) {
      this.removeVertexAndCleanupDependencies(rangeVertex);
    }
    return verticesWithChangedSize;
  }
  fixArraysAfterAddingRow(sheet, rowStart, numberOfRows) {
    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, numberOfRows);
    if (rowStart <= 0) {
      return;
    }
    for (const [, array] of this.arrayMapping.arraysInRows(_Span__WEBPACK_IMPORTED_MODULE_8__.RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {
      const arrayRange = array.getRange();
      for (let col = arrayRange.start.col; col <= arrayRange.end.col; ++col) {
        for (let row = rowStart; row <= arrayRange.end.row; ++row) {
          const destination = (0,_Cell__WEBPACK_IMPORTED_MODULE_2__.simpleCellAddress)(sheet, col, row);
          const source = (0,_Cell__WEBPACK_IMPORTED_MODULE_2__.simpleCellAddress)(sheet, col, row + numberOfRows);
          const value = array.getArrayCellValue(destination);
          this.addressMapping.moveCell(source, destination);
          this.changes.addChange(_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.EmptyValue, source, value);
        }
      }
    }
  }
  fixArraysAfterRemovingRows(sheet, rowStart, numberOfRows) {
    this.arrayMapping.moveArrayVerticesAfterRowByRows(sheet, rowStart, -numberOfRows);
    if (rowStart <= 0) {
      return;
    }
    for (const [, array] of this.arrayMapping.arraysInRows(_Span__WEBPACK_IMPORTED_MODULE_8__.RowsSpan.fromRowStartAndEnd(sheet, rowStart - 1, rowStart - 1))) {
      if (this.isThereSpaceForArray(array)) {
        for (const address of array.getRange().addresses(this)) {
          this.addressMapping.setCell(address, array);
        }
      } else {
        this.setNoSpaceIfArray(array);
      }
    }
  }
  fixArraysAfterAddingColumn(sheet, columnStart, numberOfColumns) {
    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, numberOfColumns);
    if (columnStart <= 0) {
      return;
    }
    for (const [, array] of this.arrayMapping.arraysInCols(_Span__WEBPACK_IMPORTED_MODULE_8__.ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {
      const arrayRange = array.getRange();
      for (let row = arrayRange.start.row; row <= arrayRange.end.row; ++row) {
        for (let col = columnStart; col <= arrayRange.end.col; ++col) {
          const destination = (0,_Cell__WEBPACK_IMPORTED_MODULE_2__.simpleCellAddress)(sheet, col, row);
          const source = (0,_Cell__WEBPACK_IMPORTED_MODULE_2__.simpleCellAddress)(sheet, col + numberOfColumns, row);
          const value = array.getArrayCellValue(destination);
          this.addressMapping.moveCell(source, destination);
          this.changes.addChange(_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.EmptyValue, source, value);
        }
      }
    }
  }
  fixArraysAfterRemovingColumns(sheet, columnStart, numberOfColumns) {
    this.arrayMapping.moveArrayVerticesAfterColumnByColumns(sheet, columnStart, -numberOfColumns);
    if (columnStart <= 0) {
      return;
    }
    for (const [, array] of this.arrayMapping.arraysInCols(_Span__WEBPACK_IMPORTED_MODULE_8__.ColumnsSpan.fromColumnStartAndEnd(sheet, columnStart - 1, columnStart - 1))) {
      if (this.isThereSpaceForArray(array)) {
        for (const address of array.getRange().addresses(this)) {
          this.addressMapping.setCell(address, array);
        }
      } else {
        this.setNoSpaceIfArray(array);
      }
    }
  }
  shrinkPossibleArrayAndGetCell(address) {
    const vertex = this.getCell(address);
    if (!(vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex)) {
      return vertex;
    }
    this.setNoSpaceIfArray(vertex);
    return this.getCell(address);
  }
  setNoSpaceIfArray(vertex) {
    if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.ArrayVertex) {
      this.shrinkArrayToCorner(vertex);
      vertex.setNoSpace();
    }
  }
  removeVertex(vertex) {
    this.removeVertexAndCleanupDependencies(vertex);
    if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex) {
      this.rangeMapping.removeRange(vertex);
    }
  }
  mergeRangeVertices(existingVertex, newVertex) {
    const adjNodesStored = this.graph.adjacentNodes(newVertex);
    this.removeVertexAndCleanupDependencies(newVertex);
    this.graph.removeEdgeIfExists(existingVertex, newVertex);
    adjNodesStored.forEach(adjacentNode => {
      if (this.graph.hasNode(adjacentNode)) {
        this.graph.addEdge(existingVertex, adjacentNode);
      }
    });
  }
  removeVertexAndCleanupDependencies(inputVertex) {
    const dependencies = new Set(this.graph.removeNode(inputVertex));
    while (dependencies.size > 0) {
      const dependency = dependencies.values().next().value;
      dependencies.delete(dependency);
      const [address, vertex] = dependency;
      if (this.graph.hasNode(vertex) && this.graph.adjacentNodesCount(vertex) === 0) {
        if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex || vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.EmptyCellVertex) {
          this.graph.removeNode(vertex).forEach(candidate => dependencies.add(candidate));
        }
        if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.RangeVertex) {
          this.rangeMapping.removeRange(vertex);
        } else if (vertex instanceof ___WEBPACK_IMPORTED_MODULE_10__.EmptyCellVertex) {
          this.addressMapping.removeCell(address);
        }
      }
    }
  }
}

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   absolutizeDependencies: () => (/* binding */ absolutizeDependencies),
/* harmony export */   filterDependenciesOutOfScope: () => (/* binding */ filterDependenciesOutOfScope)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



/**
 * Converts dependencies from maybe relative addressing to absolute addressing.
 *
 * @param deps - list of addresses in R0C0 format
 * @param baseAddress - base address with regard to which make a convertion
 */
const absolutizeDependencies = (deps, baseAddress) => {
  return deps.map(dep => dep.absolutize(baseAddress));
};
const filterDependenciesOutOfScope = deps => {
  return deps.filter(dep => {
    if (dep instanceof _parser__WEBPACK_IMPORTED_MODULE_2__.NamedExpressionDependency) {
      return true;
    }
    if (dep instanceof _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange) {
      return !((0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(dep.start) || (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(dep.end));
    } else {
      return !(0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(dep);
    }
  });
};

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddressDependency: () => (/* reexport safe */ _RelativeDependency__WEBPACK_IMPORTED_MODULE_8__.AddressDependency),
/* harmony export */   AstNodeType: () => (/* reexport safe */ _Ast__WEBPACK_IMPORTED_MODULE_6__.AstNodeType),
/* harmony export */   CellAddress: () => (/* reexport safe */ _CellAddress__WEBPACK_IMPORTED_MODULE_1__.CellAddress),
/* harmony export */   CellRangeDependency: () => (/* reexport safe */ _RelativeDependency__WEBPACK_IMPORTED_MODULE_8__.CellRangeDependency),
/* harmony export */   ColumnRangeDependency: () => (/* reexport safe */ _RelativeDependency__WEBPACK_IMPORTED_MODULE_8__.ColumnRangeDependency),
/* harmony export */   FormulaLexer: () => (/* reexport safe */ _FormulaParser__WEBPACK_IMPORTED_MODULE_5__.FormulaLexer),
/* harmony export */   NamedExpressionDependency: () => (/* reexport safe */ _RelativeDependency__WEBPACK_IMPORTED_MODULE_8__.NamedExpressionDependency),
/* harmony export */   ParserWithCaching: () => (/* reexport safe */ _ParserWithCaching__WEBPACK_IMPORTED_MODULE_2__.ParserWithCaching),
/* harmony export */   ParsingErrorType: () => (/* reexport safe */ _Ast__WEBPACK_IMPORTED_MODULE_6__.ParsingErrorType),
/* harmony export */   RowRangeDependency: () => (/* reexport safe */ _RelativeDependency__WEBPACK_IMPORTED_MODULE_8__.RowRangeDependency),
/* harmony export */   Unparser: () => (/* reexport safe */ _Unparser__WEBPACK_IMPORTED_MODULE_7__.Unparser),
/* harmony export */   buildCellErrorAst: () => (/* reexport safe */ _Ast__WEBPACK_IMPORTED_MODULE_6__.buildCellErrorAst),
/* harmony export */   buildCellRangeAst: () => (/* reexport safe */ _Ast__WEBPACK_IMPORTED_MODULE_6__.buildCellRangeAst),
/* harmony export */   buildLexerConfig: () => (/* reexport safe */ _LexerConfig__WEBPACK_IMPORTED_MODULE_4__.buildLexerConfig),
/* harmony export */   buildParsingErrorAst: () => (/* reexport safe */ _Ast__WEBPACK_IMPORTED_MODULE_6__.buildParsingErrorAst),
/* harmony export */   buildProcedureAst: () => (/* reexport safe */ _Ast__WEBPACK_IMPORTED_MODULE_6__.buildProcedureAst),
/* harmony export */   cellAddressFromString: () => (/* reexport safe */ _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_0__.cellAddressFromString),
/* harmony export */   collectDependencies: () => (/* reexport safe */ _collectDependencies__WEBPACK_IMPORTED_MODULE_3__.collectDependencies),
/* harmony export */   simpleCellAddressFromString: () => (/* reexport safe */ _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddressFromString),
/* harmony export */   simpleCellAddressToString: () => (/* reexport safe */ _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddressToString),
/* harmony export */   simpleCellRangeFromString: () => (/* reexport safe */ _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_0__.simpleCellRangeFromString),
/* harmony export */   simpleCellRangeToString: () => (/* reexport safe */ _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_0__.simpleCellRangeToString)
/* harmony export */ });
/* harmony import */ var _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _CellAddress__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var _ParserWithCaching__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _collectDependencies__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66);
/* harmony import */ var _LexerConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62);
/* harmony import */ var _FormulaParser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60);
/* harmony import */ var _Ast__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(57);
/* harmony import */ var _Unparser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(65);
/* harmony import */ var _RelativeDependency__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(67);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */










/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cellAddressFromString: () => (/* binding */ cellAddressFromString),
/* harmony export */   columnAddressFromString: () => (/* binding */ columnAddressFromString),
/* harmony export */   columnIndexToLabel: () => (/* binding */ columnIndexToLabel),
/* harmony export */   rowAddressFromString: () => (/* binding */ rowAddressFromString),
/* harmony export */   sheetIndexToString: () => (/* binding */ sheetIndexToString),
/* harmony export */   simpleCellAddressFromString: () => (/* binding */ simpleCellAddressFromString),
/* harmony export */   simpleCellAddressToString: () => (/* binding */ simpleCellAddressToString),
/* harmony export */   simpleCellRangeFromString: () => (/* binding */ simpleCellRangeFromString),
/* harmony export */   simpleCellRangeToString: () => (/* binding */ simpleCellRangeToString)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _CellAddress__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _ColumnAddress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _parser_consts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _RowAddress__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(11);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */






const addressRegex = new RegExp(`^(${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.SHEET_NAME_PATTERN})?(\\${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR}?)([A-Za-z]+)(\\${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR}?)([0-9]+)$`);
const columnRegex = new RegExp(`^(${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.SHEET_NAME_PATTERN})?(\\${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR}?)([A-Za-z]+)$`);
const rowRegex = new RegExp(`^(${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.SHEET_NAME_PATTERN})?(\\${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR}?)([0-9]+)$`);
const simpleSheetNameRegex = new RegExp(`^${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.UNQUOTED_SHEET_NAME_PATTERN}$`);
/**
 * Computes R0C0 representation of cell address based on it's string representation and base address.
 *
 * @param sheetMapping - mapping function needed to change name of a sheet to index
 * @param stringAddress - string representation of cell address, e.g., 'C64'
 * @param baseAddress - base address for R0C0 conversion
 * @returns object representation of address
 */
const cellAddressFromString = (sheetMapping, stringAddress, baseAddress) => {
  const result = addressRegex.exec(stringAddress);
  const col = columnLabelToIndex(result[6]);
  let sheet = extractSheetNumber(result, sheetMapping);
  if (sheet === undefined) {
    return undefined;
  }
  if (sheet === null) {
    sheet = undefined;
  }
  const row = Number(result[8]) - 1;
  if (result[5] === _parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR && result[7] === _parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR) {
    return _CellAddress__WEBPACK_IMPORTED_MODULE_2__.CellAddress.absolute(col, row, sheet);
  } else if (result[5] === _parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR) {
    return _CellAddress__WEBPACK_IMPORTED_MODULE_2__.CellAddress.absoluteCol(col, row - baseAddress.row, sheet);
  } else if (result[7] === _parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR) {
    return _CellAddress__WEBPACK_IMPORTED_MODULE_2__.CellAddress.absoluteRow(col - baseAddress.col, row, sheet);
  } else {
    return _CellAddress__WEBPACK_IMPORTED_MODULE_2__.CellAddress.relative(col - baseAddress.col, row - baseAddress.row, sheet);
  }
};
const columnAddressFromString = (sheetMapping, stringAddress, baseAddress) => {
  const result = columnRegex.exec(stringAddress);
  let sheet = extractSheetNumber(result, sheetMapping);
  if (sheet === undefined) {
    return undefined;
  }
  if (sheet === null) {
    sheet = undefined;
  }
  const col = columnLabelToIndex(result[6]);
  if (result[5] === _parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR) {
    return _ColumnAddress__WEBPACK_IMPORTED_MODULE_3__.ColumnAddress.absolute(col, sheet);
  } else {
    return _ColumnAddress__WEBPACK_IMPORTED_MODULE_3__.ColumnAddress.relative(col - baseAddress.col, sheet);
  }
};
const rowAddressFromString = (sheetMapping, stringAddress, baseAddress) => {
  const result = rowRegex.exec(stringAddress);
  let sheet = extractSheetNumber(result, sheetMapping);
  if (sheet === undefined) {
    return undefined;
  }
  if (sheet === null) {
    sheet = undefined;
  }
  const row = Number(result[6]) - 1;
  if (result[5] === _parser_consts__WEBPACK_IMPORTED_MODULE_4__.ABSOLUTE_OPERATOR) {
    return _RowAddress__WEBPACK_IMPORTED_MODULE_5__.RowAddress.absolute(row, sheet);
  } else {
    return _RowAddress__WEBPACK_IMPORTED_MODULE_5__.RowAddress.relative(row - baseAddress.row, sheet);
  }
};
/**
 * Computes simple (absolute) address of a cell address based on its string representation.
 * - If sheet name is present in the string representation but is not present in sheet mapping, returns `undefined`.
 * - If sheet name is not present in the string representation, returns {@param contextSheetId} as sheet number.
 *
 * @param sheetMapping - mapping function needed to change name of a sheet to index
 * @param stringAddress - string representation of cell address, e.g., 'C64'
 * @param contextSheetId - sheet in context of which we should parse the address
 * @returns absolute representation of address, e.g., { sheet: 0, col: 1, row: 1 }
 */
const simpleCellAddressFromString = (sheetMapping, stringAddress, contextSheetId) => {
  const regExpExecArray = addressRegex.exec(stringAddress);
  if (!regExpExecArray) {
    return undefined;
  }
  const col = columnLabelToIndex(regExpExecArray[6]);
  let sheet = extractSheetNumber(regExpExecArray, sheetMapping);
  if (sheet === undefined) {
    return undefined;
  }
  if (sheet === null) {
    sheet = contextSheetId;
  }
  const row = Number(regExpExecArray[8]) - 1;
  return (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(sheet, col, row);
};
const simpleCellRangeFromString = (sheetMapping, stringAddress, contextSheetId) => {
  const split = stringAddress.split(_parser_consts__WEBPACK_IMPORTED_MODULE_4__.RANGE_OPERATOR);
  if (split.length !== 2) {
    return undefined;
  }
  const [startString, endString] = split;
  const start = simpleCellAddressFromString(sheetMapping, startString, contextSheetId);
  if (start === undefined) {
    return undefined;
  }
  const end = simpleCellAddressFromString(sheetMapping, endString, start.sheet);
  if (end === undefined) {
    return undefined;
  }
  if (start.sheet !== end.sheet) {
    return undefined;
  }
  return (0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.simpleCellRange)(start, end);
};
/**
 * Returns string representation of absolute address
 * If sheet index is not present in sheet mapping, returns undefined
 *
 * @param sheetIndexMapping - mapping function needed to change sheet index to sheet name
 * @param address - object representation of absolute address
 * @param sheetIndex - if is not equal with address sheet index, string representation will contain sheet name
 */
const simpleCellAddressToString = (sheetIndexMapping, address, sheetIndex) => {
  const column = columnIndexToLabel(address.col);
  const sheetName = sheetIndexToString(address.sheet, sheetIndexMapping);
  if (sheetName === undefined) {
    return undefined;
  }
  if (sheetIndex !== address.sheet) {
    return `${sheetName}!${column}${address.row + 1}`;
  } else {
    return `${column}${address.row + 1}`;
  }
};
const simpleCellRangeToString = (sheetIndexMapping, address, sheetIndex) => {
  const startString = simpleCellAddressToString(sheetIndexMapping, address.start, sheetIndex);
  const endString = simpleCellAddressToString(sheetIndexMapping, address.end, address.start.sheet);
  if (startString === undefined || endString === undefined) {
    return undefined;
  } else {
    return `${startString}${_parser_consts__WEBPACK_IMPORTED_MODULE_4__.RANGE_OPERATOR}${endString}`;
  }
};
/**
 * Convert column label to index
 *
 * @param columnStringRepresentation - column label (e.g., 'AAB')
 * @returns column index
 */
function columnLabelToIndex(columnStringRepresentation) {
  if (columnStringRepresentation.length === 1) {
    return columnStringRepresentation.toUpperCase().charCodeAt(0) - 65;
  } else {
    return columnStringRepresentation.split('').reduce((currentColumn, nextLetter) => {
      return currentColumn * 26 + (nextLetter.toUpperCase().charCodeAt(0) - 64);
    }, 0) - 1;
  }
}
/**
 * Converts column index to label
 *
 * @param column - address to convert
 * @returns string representation, e.g., 'AAB'
 */
function columnIndexToLabel(column) {
  let result = '';
  while (column >= 0) {
    result = String.fromCharCode(column % 26 + 97) + result;
    column = Math.floor(column / 26) - 1;
  }
  return result.toUpperCase();
}
function sheetIndexToString(sheetId, sheetMappingFn) {
  let sheetName = sheetMappingFn(sheetId);
  if (sheetName === undefined) {
    return undefined;
  }
  if (simpleSheetNameRegex.test(sheetName)) {
    return sheetName;
  } else {
    sheetName = sheetName.replace(/'/g, "''");
    return `'${sheetName}'`;
  }
}
function extractSheetNumber(regexResult, sheetMapping) {
  var _a;
  let maybeSheetName = (_a = regexResult[3]) !== null && _a !== void 0 ? _a : regexResult[2];
  if (maybeSheetName) {
    maybeSheetName = maybeSheetName.replace(/''/g, "'");
    return sheetMapping(maybeSheetName);
  } else {
    return null;
  }
}

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellAddress: () => (/* binding */ CellAddress),
/* harmony export */   CellReferenceType: () => (/* binding */ CellReferenceType)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _ColumnAddress__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _RowAddress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/** Possible kinds of cell references */
var CellReferenceType;
(function (CellReferenceType) {
  /** Cell reference with both row and column relative. */
  CellReferenceType["CELL_REFERENCE_RELATIVE"] = "CELL_REFERENCE";
  /** Cell reference with both row and column absolute. */
  CellReferenceType["CELL_REFERENCE_ABSOLUTE"] = "CELL_REFERENCE_ABSOLUTE";
  /** Cell reference with absolute column and relative row. */
  CellReferenceType["CELL_REFERENCE_ABSOLUTE_COL"] = "CELL_REFERENCE_ABSOLUTE_COL";
  /** Cell reference with relative column and absolute row. */
  CellReferenceType["CELL_REFERENCE_ABSOLUTE_ROW"] = "CELL_REFERENCE_ABSOLUTE_ROW";
})(CellReferenceType || (CellReferenceType = {}));
class CellAddress {
  constructor(col, row, type, sheet) {
    this.col = col;
    this.row = row;
    this.type = type;
    this.sheet = sheet;
  }
  static fromColAndRow(col, row, sheet) {
    const factoryMethod = col.isColumnAbsolute() && row.isRowAbsolute() ? CellAddress.absolute.bind(this) : col.isColumnAbsolute() ? CellAddress.absoluteCol.bind(this) : row.isRowAbsolute() ? CellAddress.absoluteRow.bind(this) : CellAddress.relative.bind(this);
    return factoryMethod(col.col, row.row, sheet);
  }
  static relative(col, row, sheet) {
    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_RELATIVE, sheet);
  }
  static absolute(col, row, sheet) {
    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE, sheet);
  }
  static absoluteCol(col, row, sheet) {
    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL, sheet);
  }
  static absoluteRow(col, row, sheet) {
    return new CellAddress(col, row, CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW, sheet);
  }
  /**
   * Converts R0C0 representation of cell address to simple object representation.
   *
   * @param baseAddress - base address for R0C0 shifts
   */
  toSimpleCellAddress(baseAddress) {
    const sheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(this, baseAddress);
    if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE) {
      return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, this.col, this.row);
    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {
      return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, baseAddress.col + this.col, this.row);
    } else if (this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {
      return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, this.col, baseAddress.row + this.row);
    } else {
      return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, baseAddress.col + this.col, baseAddress.row + this.row);
    }
  }
  toColumnAddress() {
    const refType = this.isColumnRelative() ? _ColumnAddress__WEBPACK_IMPORTED_MODULE_2__.ReferenceType.RELATIVE : _ColumnAddress__WEBPACK_IMPORTED_MODULE_2__.ReferenceType.ABSOLUTE;
    return new _ColumnAddress__WEBPACK_IMPORTED_MODULE_2__.ColumnAddress(refType, this.col, this.sheet);
  }
  toRowAddress() {
    const refType = this.isRowRelative() ? _ColumnAddress__WEBPACK_IMPORTED_MODULE_2__.ReferenceType.RELATIVE : _ColumnAddress__WEBPACK_IMPORTED_MODULE_2__.ReferenceType.ABSOLUTE;
    return new _RowAddress__WEBPACK_IMPORTED_MODULE_3__.RowAddress(refType, this.row, this.sheet);
  }
  toSimpleColumnAddress(baseAddress) {
    const sheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(this, baseAddress);
    let column = this.col;
    if (this.isColumnRelative()) {
      column += baseAddress.col;
    }
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleColumnAddress)(sheet, column);
  }
  toSimpleRowAddress(baseAddress) {
    const sheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(this, baseAddress);
    let row = this.row;
    if (this.isRowRelative()) {
      row += baseAddress.row;
    }
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleRowAddress)(sheet, row);
  }
  isRowAbsolute() {
    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;
  }
  isColumnAbsolute() {
    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;
  }
  isColumnRelative() {
    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW;
  }
  isRowRelative() {
    return this.type === CellReferenceType.CELL_REFERENCE_RELATIVE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL;
  }
  isAbsolute() {
    return this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE && this.sheet !== undefined;
  }
  shiftedByRows(numberOfRows) {
    return new CellAddress(this.col, this.row + numberOfRows, this.type, this.sheet);
  }
  shiftedByColumns(numberOfColumns) {
    return new CellAddress(this.col + numberOfColumns, this.row, this.type, this.sheet);
  }
  moved(toSheet, toRight, toBottom) {
    const newSheet = this.sheet === undefined ? undefined : toSheet;
    return new CellAddress(this.col + toRight, this.row + toBottom, this.type, newSheet);
  }
  withSheet(sheet) {
    return new CellAddress(this.col, this.row, this.type, sheet);
  }
  isInvalid(baseAddress) {
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.invalidSimpleCellAddress)(this.toSimpleCellAddress(baseAddress));
  }
  shiftRelativeDimensions(toRight, toBottom) {
    const col = this.isColumnAbsolute() ? this.col : this.col + toRight;
    const row = this.isRowAbsolute() ? this.row : this.row + toBottom;
    return new CellAddress(col, row, this.type, this.sheet);
  }
  shiftAbsoluteDimensions(toRight, toBottom) {
    const col = this.isColumnRelative() ? this.col : this.col + toRight;
    const row = this.isRowRelative() ? this.row : this.row + toBottom;
    return new CellAddress(col, row, this.type, this.sheet);
  }
  hash(withSheet) {
    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';
    switch (this.type) {
      case CellReferenceType.CELL_REFERENCE_RELATIVE:
        {
          return `${sheetPart}#${this.row}R${this.col}`;
        }
      case CellReferenceType.CELL_REFERENCE_ABSOLUTE:
        {
          return `${sheetPart}#${this.row}A${this.col}`;
        }
      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL:
        {
          return `${sheetPart}#${this.row}AC${this.col}`;
        }
      case CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW:
        {
          return `${sheetPart}#${this.row}AR${this.col}`;
        }
    }
  }
  unparse(baseAddress) {
    const simpleAddress = this.toSimpleCellAddress(baseAddress);
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.invalidSimpleCellAddress)(simpleAddress)) {
      return undefined;
    }
    const column = (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_1__.columnIndexToLabel)(simpleAddress.col);
    const rowDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW ? '$' : '';
    const colDollar = this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE || this.type === CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL ? '$' : '';
    return `${colDollar}${column}${rowDollar}${simpleAddress.row + 1}`;
  }
  exceedsSheetSizeLimits(maxColumns, maxRows) {
    return this.row >= maxRows || this.col >= maxColumns;
  }
}

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColumnAddress: () => (/* binding */ ColumnAddress),
/* harmony export */   ReferenceType: () => (/* binding */ ReferenceType)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


var ReferenceType;
(function (ReferenceType) {
  ReferenceType["RELATIVE"] = "RELATIVE";
  ReferenceType["ABSOLUTE"] = "ABSOLUTE";
})(ReferenceType || (ReferenceType = {}));
class ColumnAddress {
  constructor(type, col, sheet) {
    this.type = type;
    this.col = col;
    this.sheet = sheet;
  }
  static absolute(column, sheet) {
    return new ColumnAddress(ReferenceType.ABSOLUTE, column, sheet);
  }
  static relative(column, sheet) {
    return new ColumnAddress(ReferenceType.RELATIVE, column, sheet);
  }
  static compareByAbsoluteAddress(baseAddress) {
    return (colA, colB) => colA.toSimpleColumnAddress(baseAddress).col - colB.toSimpleColumnAddress(baseAddress).col;
  }
  isColumnAbsolute() {
    return this.type === ReferenceType.ABSOLUTE;
  }
  isColumnRelative() {
    return this.type === ReferenceType.RELATIVE;
  }
  isAbsolute() {
    return this.type === ReferenceType.ABSOLUTE && this.sheet !== undefined;
  }
  moved(toSheet, toRight, _toBottom) {
    const newSheet = this.sheet === undefined ? undefined : toSheet;
    return new ColumnAddress(this.type, this.col + toRight, newSheet);
  }
  shiftedByColumns(numberOfColumns) {
    return new ColumnAddress(this.type, this.col + numberOfColumns, this.sheet);
  }
  toSimpleColumnAddress(baseAddress) {
    const sheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(this, baseAddress);
    let column = this.col;
    if (this.isColumnRelative()) {
      column = baseAddress.col + this.col;
    }
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleColumnAddress)(sheet, column);
  }
  shiftRelativeDimensions(toRight, _toBottom) {
    const col = this.isColumnRelative() ? this.col + toRight : this.col;
    return new ColumnAddress(this.type, col, this.sheet);
  }
  shiftAbsoluteDimensions(toRight, _toBottom) {
    const col = this.isColumnAbsolute() ? this.col + toRight : this.col;
    return new ColumnAddress(this.type, col, this.sheet);
  }
  withSheet(sheet) {
    return new ColumnAddress(this.type, this.col, sheet);
  }
  isInvalid(baseAddress) {
    return this.toSimpleColumnAddress(baseAddress).col < 0;
  }
  hash(withSheet) {
    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';
    switch (this.type) {
      case ReferenceType.RELATIVE:
        {
          return `${sheetPart}#COLR${this.col}`;
        }
      case ReferenceType.ABSOLUTE:
        {
          return `${sheetPart}#COLA${this.col}`;
        }
    }
  }
  unparse(baseAddress) {
    const simpleAddress = this.toSimpleColumnAddress(baseAddress);
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.invalidSimpleColumnAddress)(simpleAddress)) {
      return undefined;
    }
    const column = (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_1__.columnIndexToLabel)(simpleAddress.col);
    const dollar = this.type === ReferenceType.ABSOLUTE ? '$' : '';
    return `${dollar}${column}`;
  }
  exceedsSheetSizeLimits(maxColumns) {
    return this.col >= maxColumns;
  }
}

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RowAddress: () => (/* binding */ RowAddress)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _ColumnAddress__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class RowAddress {
  constructor(type, row, sheet) {
    this.type = type;
    this.row = row;
    this.sheet = sheet;
  }
  static absolute(row, sheet) {
    return new RowAddress(_ColumnAddress__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.ABSOLUTE, row, sheet);
  }
  static relative(row, sheet) {
    return new RowAddress(_ColumnAddress__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.RELATIVE, row, sheet);
  }
  static compareByAbsoluteAddress(baseAddress) {
    return (rowA, rowB) => rowA.toSimpleRowAddress(baseAddress).row - rowB.toSimpleRowAddress(baseAddress).row;
  }
  isRowAbsolute() {
    return this.type === _ColumnAddress__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.ABSOLUTE;
  }
  isRowRelative() {
    return this.type === _ColumnAddress__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.RELATIVE;
  }
  isAbsolute() {
    return this.type === _ColumnAddress__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.ABSOLUTE && this.sheet !== undefined;
  }
  moved(toSheet, toRight, toBottom) {
    const newSheet = this.sheet === undefined ? undefined : toSheet;
    return new RowAddress(this.type, this.row + toBottom, newSheet);
  }
  shiftedByRows(numberOfColumns) {
    return new RowAddress(this.type, this.row + numberOfColumns, this.sheet);
  }
  toSimpleRowAddress(baseAddress) {
    const sheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(this, baseAddress);
    let row = this.row;
    if (this.isRowRelative()) {
      row = baseAddress.row + this.row;
    }
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleRowAddress)(sheet, row);
  }
  shiftRelativeDimensions(toRight, toBottom) {
    const row = this.isRowRelative() ? this.row + toBottom : this.row;
    return new RowAddress(this.type, row, this.sheet);
  }
  shiftAbsoluteDimensions(toRight, toBottom) {
    const row = this.isRowAbsolute() ? this.row + toBottom : this.row;
    return new RowAddress(this.type, row, this.sheet);
  }
  withSheet(sheet) {
    return new RowAddress(this.type, this.row, sheet);
  }
  isInvalid(baseAddress) {
    return this.toSimpleRowAddress(baseAddress).row < 0;
  }
  hash(withSheet) {
    const sheetPart = withSheet && this.sheet !== undefined ? `#${this.sheet}` : '';
    switch (this.type) {
      case _ColumnAddress__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.RELATIVE:
        {
          return `${sheetPart}#ROWR${this.row}`;
        }
      case _ColumnAddress__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.ABSOLUTE:
        {
          return `${sheetPart}#ROWA${this.row}`;
        }
    }
  }
  unparse(baseAddress) {
    const simpleAddress = this.toSimpleRowAddress(baseAddress);
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.invalidSimpleRowAddress)(simpleAddress)) {
      return undefined;
    }
    const dollar = this.type === _ColumnAddress__WEBPACK_IMPORTED_MODULE_1__.ReferenceType.ABSOLUTE ? '$' : '';
    return `${dollar}${simpleAddress.row + 1}`;
  }
  exceedsSheetSizeLimits(maxRows) {
    return this.row >= maxRows;
  }
}

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ABSOLUTE_OPERATOR: () => (/* binding */ ABSOLUTE_OPERATOR),
/* harmony export */   ALL_DIGITS_ARRAY: () => (/* binding */ ALL_DIGITS_ARRAY),
/* harmony export */   ALL_UNICODE_LETTERS_ARRAY: () => (/* binding */ ALL_UNICODE_LETTERS_ARRAY),
/* harmony export */   ALL_WHITESPACE_PATTERN: () => (/* binding */ ALL_WHITESPACE_PATTERN),
/* harmony export */   CELL_REFERENCE_PATTERN: () => (/* binding */ CELL_REFERENCE_PATTERN),
/* harmony export */   CELL_REFERENCE_WITH_NEXT_CHARACTER_PATTERN: () => (/* binding */ CELL_REFERENCE_WITH_NEXT_CHARACTER_PATTERN),
/* harmony export */   COLUMN_REFERENCE_PATTERN: () => (/* binding */ COLUMN_REFERENCE_PATTERN),
/* harmony export */   NAMED_EXPRESSION_PATTERN: () => (/* binding */ NAMED_EXPRESSION_PATTERN),
/* harmony export */   NON_RESERVED_CHARACTER_PATTERN: () => (/* binding */ NON_RESERVED_CHARACTER_PATTERN),
/* harmony export */   ODFF_WHITESPACE_PATTERN: () => (/* binding */ ODFF_WHITESPACE_PATTERN),
/* harmony export */   QUOTED_SHEET_NAME_PATTERN: () => (/* binding */ QUOTED_SHEET_NAME_PATTERN),
/* harmony export */   R1C1_CELL_REFERENCE_PATTERN: () => (/* binding */ R1C1_CELL_REFERENCE_PATTERN),
/* harmony export */   RANGE_OPERATOR: () => (/* binding */ RANGE_OPERATOR),
/* harmony export */   ROW_REFERENCE_PATTERN: () => (/* binding */ ROW_REFERENCE_PATTERN),
/* harmony export */   SHEET_NAME_PATTERN: () => (/* binding */ SHEET_NAME_PATTERN),
/* harmony export */   UNICODE_LETTER_PATTERN: () => (/* binding */ UNICODE_LETTER_PATTERN),
/* harmony export */   UNQUOTED_SHEET_NAME_PATTERN: () => (/* binding */ UNQUOTED_SHEET_NAME_PATTERN)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
const RANGE_OPERATOR = ':';
const ABSOLUTE_OPERATOR = '$';
const ALL_WHITESPACE_PATTERN = '\\s+';
const ODFF_WHITESPACE_PATTERN = '[ \\t\\n\\r]+';
const UNICODE_LETTER_PATTERN = 'A-Za-z\u00C0-\u02AF';
const NON_RESERVED_CHARACTER_PATTERN = `${UNICODE_LETTER_PATTERN}0-9_.`;
const UNQUOTED_SHEET_NAME_PATTERN = `[${UNICODE_LETTER_PATTERN}0-9_]+`;
const QUOTED_SHEET_NAME_PATTERN = "'(((?!').|'')*)'";
const SHEET_NAME_PATTERN = `(${UNQUOTED_SHEET_NAME_PATTERN}|${QUOTED_SHEET_NAME_PATTERN})!`;
const CELL_REFERENCE_PATTERN = `(${SHEET_NAME_PATTERN})?\\${ABSOLUTE_OPERATOR}?[A-Za-z]+\\${ABSOLUTE_OPERATOR}?[0-9]+`;
const COLUMN_REFERENCE_PATTERN = `(${SHEET_NAME_PATTERN})?\\${ABSOLUTE_OPERATOR}?[A-Za-z]+`;
const ROW_REFERENCE_PATTERN = `(${SHEET_NAME_PATTERN})?\\${ABSOLUTE_OPERATOR}?[0-9]+`;
const R1C1_CELL_REFERENCE_PATTERN = '[rR][0-9]*[cC][0-9]*';
const CELL_REFERENCE_WITH_NEXT_CHARACTER_PATTERN = `(${CELL_REFERENCE_PATTERN})[^${NON_RESERVED_CHARACTER_PATTERN}]`;
const NAMED_EXPRESSION_PATTERN = `[${UNICODE_LETTER_PATTERN}_][${NON_RESERVED_CHARACTER_PATTERN}]*`;
const ALL_DIGITS_ARRAY = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
const ALL_UNICODE_LETTERS_ARRAY = [...Array.from(Array(26)).map((_, i) => i + 'A'.charCodeAt(0)), ...Array.from(Array(26)).map((_, i) => i + 'a'.charCodeAt(0)), ...Array.from(Array(0x02AF - 0x00C0 + 1)).map((_, i) => i + 0x00C0)].map(code => String.fromCharCode(code));

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParserWithCaching: () => (/* binding */ ParserWithCaching)
/* harmony export */ });
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _Ast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/* harmony import */ var _binaryOpTokenMap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(58);
/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(59);
/* harmony import */ var _FormulaParser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(60);
/* harmony import */ var _LexerConfig__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(62);
/* harmony import */ var _Unparser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(65);
/* harmony import */ var _ColumnAddress__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(10);
/* harmony import */ var _RowAddress__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(11);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */












/**
 * Parses formula using caching if feasible.
 */
class ParserWithCaching {
  constructor(config, functionRegistry, sheetMapping) {
    this.config = config;
    this.functionRegistry = functionRegistry;
    this.sheetMapping = sheetMapping;
    this.statsCacheUsed = 0;
    this.lexerConfig = (0,_LexerConfig__WEBPACK_IMPORTED_MODULE_8__.buildLexerConfig)(config);
    this.lexer = new _FormulaParser__WEBPACK_IMPORTED_MODULE_7__.FormulaLexer(this.lexerConfig);
    this.formulaParser = new _FormulaParser__WEBPACK_IMPORTED_MODULE_7__.FormulaParser(this.lexerConfig, this.sheetMapping);
    this.cache = new _Cache__WEBPACK_IMPORTED_MODULE_6__.Cache(this.functionRegistry);
  }
  /**
   * Parses a formula.
   *
   * @param text - formula to parse
   * @param formulaAddress - address with regard to which formula should be parsed. Impacts computed addresses in R0C0 format.
   */
  parse(text, formulaAddress) {
    this.formulaAddress = formulaAddress;
    const lexerResult = this.tokenizeFormula(text);
    if (lexerResult.errors.length > 0) {
      const errors = lexerResult.errors.map(e => ({
        type: _Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.LexingError,
        message: e.message
      }));
      return {
        ast: (0,___WEBPACK_IMPORTED_MODULE_2__.buildParsingErrorAst)(),
        errors,
        hasVolatileFunction: false,
        hasStructuralChangeFunction: false,
        dependencies: []
      };
    }
    const hash = this.computeHashFromTokens(lexerResult.tokens, formulaAddress);
    let cacheResult = this.cache.get(hash);
    if (cacheResult !== undefined) {
      ++this.statsCacheUsed;
    } else {
      const processedTokens = this.bindWhitespacesToTokens(lexerResult.tokens);
      const parsingResult = this.formulaParser.parseFromTokens(processedTokens, formulaAddress);
      if (parsingResult.errors.length > 0) {
        return Object.assign(Object.assign({}, parsingResult), {
          hasVolatileFunction: false,
          hasStructuralChangeFunction: false,
          dependencies: []
        });
      } else {
        cacheResult = this.cache.set(hash, parsingResult.ast);
      }
    }
    const {
      ast,
      hasVolatileFunction,
      hasStructuralChangeFunction
    } = cacheResult;
    const astWithNoReversedRanges = this.convertReversedRangesToRegularRanges(ast);
    const dependencies = (0,___WEBPACK_IMPORTED_MODULE_2__.collectDependencies)(astWithNoReversedRanges, this.functionRegistry);
    return {
      ast: astWithNoReversedRanges,
      errors: [],
      hasVolatileFunction,
      hasStructuralChangeFunction,
      dependencies
    };
  }
  convertReversedRangesToRegularRanges(ast) {
    switch (ast.type) {
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.EMPTY:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.NUMBER:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.STRING:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.ERROR:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.ERROR_WITH_RAW_INPUT:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.CELL_REFERENCE:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.NAMED_EXPRESSION:
        return ast;
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.CELL_RANGE:
        {
          const {
            start,
            end
          } = ast;
          const orderedEnds = this.orderCellRangeEnds(start, end);
          return Object.assign(Object.assign({}, ast), {
            start: orderedEnds.start,
            end: orderedEnds.end
          });
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.COLUMN_RANGE:
        {
          const {
            start,
            end
          } = ast;
          const orderedEnds = this.orderColumnRangeEnds(start, end);
          return Object.assign(Object.assign({}, ast), {
            start: orderedEnds.start,
            end: orderedEnds.end
          });
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.ROW_RANGE:
        {
          const {
            start,
            end
          } = ast;
          const orderedEnds = this.orderRowRangeEnds(start, end);
          return Object.assign(Object.assign({}, ast), {
            start: orderedEnds.start,
            end: orderedEnds.end
          });
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.PERCENT_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.PLUS_UNARY_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.MINUS_UNARY_OP:
        {
          const valueFixed = this.convertReversedRangesToRegularRanges(ast.value);
          return Object.assign(Object.assign({}, ast), {
            value: valueFixed
          });
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.CONCATENATE_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.EQUALS_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.NOT_EQUAL_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.LESS_THAN_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.GREATER_THAN_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.LESS_THAN_OR_EQUAL_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.GREATER_THAN_OR_EQUAL_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.MINUS_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.PLUS_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.TIMES_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.DIV_OP:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.POWER_OP:
        {
          const leftFixed = this.convertReversedRangesToRegularRanges(ast.left);
          const rightFixed = this.convertReversedRangesToRegularRanges(ast.right);
          return Object.assign(Object.assign({}, ast), {
            left: leftFixed,
            right: rightFixed
          });
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.PARENTHESIS:
        {
          const exprFixed = this.convertReversedRangesToRegularRanges(ast.expression);
          return Object.assign(Object.assign({}, ast), {
            expression: exprFixed
          });
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.FUNCTION_CALL:
        {
          const argsFixed = ast.args.map(arg => this.convertReversedRangesToRegularRanges(arg));
          return Object.assign(Object.assign({}, ast), {
            args: argsFixed
          });
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.ARRAY:
        {
          const argsFixed = ast.args.map(argsRow => argsRow.map(arg => this.convertReversedRangesToRegularRanges(arg)));
          return Object.assign(Object.assign({}, ast), {
            args: argsFixed
          });
        }
    }
  }
  orderCellRangeEnds(endA, endB) {
    const ends = [endA, endB];
    const [startCol, endCol] = ends.map(e => e.toColumnAddress()).sort(_ColumnAddress__WEBPACK_IMPORTED_MODULE_10__.ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));
    const [startRow, endRow] = ends.map(e => e.toRowAddress()).sort(_RowAddress__WEBPACK_IMPORTED_MODULE_11__.RowAddress.compareByAbsoluteAddress(this.formulaAddress));
    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));
    return {
      start: ___WEBPACK_IMPORTED_MODULE_2__.CellAddress.fromColAndRow(startCol, startRow, startSheet),
      end: ___WEBPACK_IMPORTED_MODULE_2__.CellAddress.fromColAndRow(endCol, endRow, endSheet)
    };
  }
  orderColumnRangeEnds(endA, endB) {
    const ends = [endA, endB];
    const [startCol, endCol] = ends.sort(_ColumnAddress__WEBPACK_IMPORTED_MODULE_10__.ColumnAddress.compareByAbsoluteAddress(this.formulaAddress));
    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));
    return {
      start: new _ColumnAddress__WEBPACK_IMPORTED_MODULE_10__.ColumnAddress(startCol.type, startCol.col, startSheet),
      end: new _ColumnAddress__WEBPACK_IMPORTED_MODULE_10__.ColumnAddress(endCol.type, endCol.col, endSheet)
    };
  }
  orderRowRangeEnds(endA, endB) {
    const ends = [endA, endB];
    const [startRow, endRow] = ends.sort(_RowAddress__WEBPACK_IMPORTED_MODULE_11__.RowAddress.compareByAbsoluteAddress(this.formulaAddress));
    const [startSheet, endSheet] = ends.map(e => e.sheet).sort(ParserWithCaching.compareSheetIds.bind(this));
    return {
      start: new _RowAddress__WEBPACK_IMPORTED_MODULE_11__.RowAddress(startRow.type, startRow.row, startSheet),
      end: new _RowAddress__WEBPACK_IMPORTED_MODULE_11__.RowAddress(endRow.type, endRow.row, endSheet)
    };
  }
  static compareSheetIds(sheetA, sheetB) {
    sheetA = sheetA != null ? sheetA : Infinity;
    sheetB = sheetB != null ? sheetB : Infinity;
    return sheetA - sheetB;
  }
  fetchCachedResultForAst(ast) {
    const hash = this.computeHashFromAst(ast);
    return this.fetchCachedResult(hash);
  }
  fetchCachedResult(hash) {
    const cacheResult = this.cache.get(hash);
    if (cacheResult === undefined) {
      throw new Error('There is no AST with such key in the cache');
    } else {
      const {
        ast,
        hasVolatileFunction,
        hasStructuralChangeFunction,
        relativeDependencies
      } = cacheResult;
      return {
        ast,
        errors: [],
        hasVolatileFunction,
        hasStructuralChangeFunction,
        dependencies: relativeDependencies
      };
    }
  }
  computeHashFromTokens(tokens, baseAddress) {
    var _a;
    let hash = '';
    let idx = 0;
    while (idx < tokens.length) {
      const token = tokens[idx];
      if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(token, _LexerConfig__WEBPACK_IMPORTED_MODULE_8__.CellReference)) {
        const cellAddress = (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.cellAddressFromString)(this.sheetMapping, token.image, baseAddress);
        if (cellAddress === undefined) {
          hash = hash.concat(token.image);
        } else {
          hash = hash.concat(cellAddress.hash(true));
        }
      } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(token, _LexerConfig__WEBPACK_IMPORTED_MODULE_8__.ProcedureName)) {
        const procedureName = token.image.toUpperCase().slice(0, -1);
        const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;
        hash = hash.concat(canonicalProcedureName, '(');
      } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(token, _LexerConfig__WEBPACK_IMPORTED_MODULE_8__.ColumnRange)) {
        const [start, end] = token.image.split(':');
        const startAddress = (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.columnAddressFromString)(this.sheetMapping, start, baseAddress);
        const endAddress = (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.columnAddressFromString)(this.sheetMapping, end, baseAddress);
        if (startAddress === undefined || endAddress === undefined) {
          hash = hash.concat('!REF');
        } else {
          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));
        }
      } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(token, _LexerConfig__WEBPACK_IMPORTED_MODULE_8__.RowRange)) {
        const [start, end] = token.image.split(':');
        const startAddress = (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.rowAddressFromString)(this.sheetMapping, start, baseAddress);
        const endAddress = (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.rowAddressFromString)(this.sheetMapping, end, baseAddress);
        if (startAddress === undefined || endAddress === undefined) {
          hash = hash.concat('!REF');
        } else {
          hash = hash.concat(startAddress.hash(true), ':', endAddress.hash(true));
        }
      } else {
        hash = hash.concat(token.image);
      }
      idx++;
    }
    return hash;
  }
  rememberNewAst(ast) {
    const hash = this.computeHashFromAst(ast);
    return this.cache.maybeSetAndThenGet(hash, ast);
  }
  computeHashFromAst(ast) {
    return '=' + this.computeHashOfAstNode(ast);
  }
  computeHashOfAstNode(ast) {
    switch (ast.type) {
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.EMPTY:
        {
          return ast.leadingWhitespace || '';
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.NUMBER:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)((0,_Unparser__WEBPACK_IMPORTED_MODULE_9__.formatNumber)(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.STRING:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)('"' + ast.value + '"', ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.NAMED_EXPRESSION:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(ast.expressionName, ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.FUNCTION_CALL:
        {
          const args = ast.args.map(arg => this.computeHashOfAstNode(arg)).join(this.config.functionArgSeparator);
          const rightPart = ast.procedureName + '(' + args + (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(')', ast.internalWhitespace);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(rightPart, ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.CELL_REFERENCE:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(ast.reference.hash(true), ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.COLUMN_RANGE:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.ROW_RANGE:
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.CELL_RANGE:
        {
          const start = ast.start.hash(ast.sheetReferenceType !== _Ast__WEBPACK_IMPORTED_MODULE_4__.RangeSheetReferenceType.RELATIVE);
          const end = ast.end.hash(ast.sheetReferenceType === _Ast__WEBPACK_IMPORTED_MODULE_4__.RangeSheetReferenceType.BOTH_ABSOLUTE);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(start + ':' + end, ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.MINUS_UNARY_OP:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)('-' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.PLUS_UNARY_OP:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)('+' + this.computeHashOfAstNode(ast.value), ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.PERCENT_OP:
        {
          return this.computeHashOfAstNode(ast.value) + (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)('%', ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.ERROR:
        {
          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : _Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.ERROR);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(image, ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.ERROR_WITH_RAW_INPUT:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(ast.rawInput, ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.ARRAY:
        {
          const args = ast.args.map(row => row.map(val => this.computeHashOfAstNode(val)).join(',')).join(';');
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)('{' + args + (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)('}', ast.internalWhitespace), ast.leadingWhitespace);
        }
      case ___WEBPACK_IMPORTED_MODULE_2__.AstNodeType.PARENTHESIS:
        {
          const expression = this.computeHashOfAstNode(ast.expression);
          const rightPart = '(' + expression + (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(')', ast.internalWhitespace);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(rightPart, ast.leadingWhitespace);
        }
      default:
        {
          return this.computeHashOfAstNode(ast.left) + (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.imageWithWhitespace)(_binaryOpTokenMap__WEBPACK_IMPORTED_MODULE_5__.binaryOpTokenMap[ast.type], ast.leadingWhitespace) + this.computeHashOfAstNode(ast.right);
        }
    }
  }
  bindWhitespacesToTokens(tokens) {
    const processedTokens = [];
    const first = tokens[0];
    if (!(0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(first, this.lexerConfig.WhiteSpace)) {
      processedTokens.push(first);
    }
    for (let i = 1; i < tokens.length; ++i) {
      const current = tokens[i];
      if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(current, this.lexerConfig.WhiteSpace)) {
        continue;
      }
      const previous = tokens[i - 1];
      if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(previous, this.lexerConfig.WhiteSpace)) {
        current.leadingWhitespace = previous;
      }
      processedTokens.push(current);
    }
    return processedTokens;
  }
  tokenizeFormula(text) {
    return this.lexer.tokenizeFormula(text);
  }
}

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alternation: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Alternation),
/* harmony export */   CstParser: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.CstParser),
/* harmony export */   EMPTY_ALT: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ALT),
/* harmony export */   EOF: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.EOF),
/* harmony export */   EarlyExitException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.EarlyExitException),
/* harmony export */   EmbeddedActionsParser: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.EmbeddedActionsParser),
/* harmony export */   Flat: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Flat),
/* harmony export */   GAstVisitor: () => (/* reexport safe */ _parse_grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_8__.GAstVisitor),
/* harmony export */   Lexer: () => (/* reexport safe */ _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__.Lexer),
/* harmony export */   LexerDefinitionErrorType: () => (/* reexport safe */ _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__.LexerDefinitionErrorType),
/* harmony export */   MismatchedTokenException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.MismatchedTokenException),
/* harmony export */   NoViableAltException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.NoViableAltException),
/* harmony export */   NonTerminal: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.NonTerminal),
/* harmony export */   NotAllInputParsedException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.NotAllInputParsedException),
/* harmony export */   Option: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Option),
/* harmony export */   Parser: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.Parser),
/* harmony export */   ParserDefinitionErrorType: () => (/* reexport safe */ _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType),
/* harmony export */   Repetition: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Repetition),
/* harmony export */   RepetitionMandatory: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.RepetitionMandatory),
/* harmony export */   RepetitionMandatoryWithSeparator: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.RepetitionMandatoryWithSeparator),
/* harmony export */   RepetitionWithSeparator: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.RepetitionWithSeparator),
/* harmony export */   Rule: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Rule),
/* harmony export */   Terminal: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.Terminal),
/* harmony export */   VERSION: () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_0__.VERSION),
/* harmony export */   assignOccurrenceIndices: () => (/* reexport safe */ _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__.assignOccurrenceIndices),
/* harmony export */   clearCache: () => (/* binding */ clearCache),
/* harmony export */   createSyntaxDiagramsCode: () => (/* reexport safe */ _diagrams_render_public__WEBPACK_IMPORTED_MODULE_10__.createSyntaxDiagramsCode),
/* harmony export */   createToken: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.createToken),
/* harmony export */   createTokenInstance: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.createTokenInstance),
/* harmony export */   defaultGrammarResolverErrorProvider: () => (/* reexport safe */ _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__.defaultGrammarResolverErrorProvider),
/* harmony export */   defaultGrammarValidatorErrorProvider: () => (/* reexport safe */ _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__.defaultGrammarValidatorErrorProvider),
/* harmony export */   defaultLexerErrorProvider: () => (/* reexport safe */ _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_6__.defaultLexerErrorProvider),
/* harmony export */   defaultParserErrorProvider: () => (/* reexport safe */ _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__.defaultParserErrorProvider),
/* harmony export */   generateParserFactory: () => (/* reexport safe */ _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__.generateParserFactory),
/* harmony export */   generateParserModule: () => (/* reexport safe */ _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__.generateParserModule),
/* harmony export */   isRecognitionException: () => (/* reexport safe */ _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__.isRecognitionException),
/* harmony export */   resolveGrammar: () => (/* reexport safe */ _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__.resolveGrammar),
/* harmony export */   serializeGrammar: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.serializeGrammar),
/* harmony export */   serializeProduction: () => (/* reexport safe */ _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__.serializeProduction),
/* harmony export */   tokenLabel: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.tokenLabel),
/* harmony export */   tokenMatcher: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.tokenMatcher),
/* harmony export */   tokenName: () => (/* reexport safe */ _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__.tokenName),
/* harmony export */   validateGrammar: () => (/* reexport safe */ _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__.validateGrammar)
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _parse_parser_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);
/* harmony import */ var _parse_errors_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);
/* harmony import */ var _parse_exceptions_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(42);
/* harmony import */ var _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(28);
/* harmony import */ var _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(20);
/* harmony import */ var _parse_grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(31);
/* harmony import */ var _parse_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(39);
/* harmony import */ var _diagrams_render_public__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(54);
/* harmony import */ var _generate_generate_public__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(55);
// semantic version



// Tokens utilities

// Other Utilities



// grammar reflection API

// GAST Utilities



/* istanbul ignore next */
function clearCache() {
    console.warn("The clearCache function was 'soft' removed from the Chevrotain API." +
        "\n\t It performs no action other than printing this message." +
        "\n\t Please avoid using it as it will be completely removed in the future");
}


//# sourceMappingURL=api.js.map

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
// needs a separate module as this is required inside chevrotain productive code
// and also in the entry point for webpack(api.ts).
// A separate file avoids cyclic dependencies and webpack errors.
var VERSION = "6.5.0";
//# sourceMappingURL=version.js.map

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CstParser: () => (/* binding */ CstParser),
/* harmony export */   DEFAULT_PARSER_CONFIG: () => (/* binding */ DEFAULT_PARSER_CONFIG),
/* harmony export */   DEFAULT_RULE_CONFIG: () => (/* binding */ DEFAULT_RULE_CONFIG),
/* harmony export */   EMPTY_ALT: () => (/* binding */ EMPTY_ALT),
/* harmony export */   END_OF_FILE: () => (/* binding */ END_OF_FILE),
/* harmony export */   EmbeddedActionsParser: () => (/* binding */ EmbeddedActionsParser),
/* harmony export */   Parser: () => (/* binding */ Parser),
/* harmony export */   ParserDefinitionErrorType: () => (/* binding */ ParserDefinitionErrorType)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _grammar_follow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _cst_cst__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35);
/* harmony import */ var _grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(39);
/* harmony import */ var _traits_recoverable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(41);
/* harmony import */ var _traits_looksahead__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(43);
/* harmony import */ var _traits_tree_builder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(44);
/* harmony import */ var _traits_lexer_adapter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(47);
/* harmony import */ var _traits_recognizer_api__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(48);
/* harmony import */ var _traits_recognizer_engine__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(49);
/* harmony import */ var _traits_error_handler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(50);
/* harmony import */ var _traits_context_assist__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(51);
/* harmony import */ var _traits_gast_recorder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(52);
/* harmony import */ var _traits_perf_tracer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(53);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
















var END_OF_FILE = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__.createTokenInstance)(_scan_tokens_public__WEBPACK_IMPORTED_MODULE_2__.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(END_OF_FILE);
var DEFAULT_PARSER_CONFIG = Object.freeze({
    recoveryEnabled: false,
    maxLookahead: 4,
    ignoredIssues: {},
    dynamicTokensEnabled: false,
    outputCst: true,
    errorMessageProvider: _errors_public__WEBPACK_IMPORTED_MODULE_4__.defaultParserErrorProvider,
    nodeLocationTracking: "none",
    traceInitPerf: false,
    skipValidations: false
});
var DEFAULT_RULE_CONFIG = Object.freeze({
    recoveryValueFunc: function () { return undefined; },
    resyncEnabled: true
});
var ParserDefinitionErrorType;
(function (ParserDefinitionErrorType) {
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
    ParserDefinitionErrorType[ParserDefinitionErrorType["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_NESTED_RULE_NAME"] = 10] = "INVALID_NESTED_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_NESTED_NAME"] = 11] = "DUPLICATE_NESTED_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NO_NON_EMPTY_LOOKAHEAD"] = 12] = "NO_NON_EMPTY_LOOKAHEAD";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_PREFIX_ALTS"] = 13] = "AMBIGUOUS_PREFIX_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["TOO_MANY_ALTS"] = 14] = "TOO_MANY_ALTS";
})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));
function EMPTY_ALT(value) {
    if (value === void 0) { value = undefined; }
    return function () {
        return value;
    };
}
var Parser = /** @class */ (function () {
    function Parser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        this.ignoredIssues = DEFAULT_PARSER_CONFIG.ignoredIssues;
        this.definitionErrors = [];
        this.selfAnalysisDone = false;
        var that = this;
        that.initErrorHandler(config);
        that.initLexerAdapter();
        that.initLooksAhead(config);
        that.initRecognizerEngine(tokenVocabulary, config);
        that.initRecoverable(config);
        that.initTreeBuilder(config);
        that.initContentAssist();
        that.initGastRecorder(config);
        that.initPerformanceTracer(config);
        /* istanbul ignore if - complete over-kill to test this, we should only add a test when we actually hard deprecate it and throw an error... */
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, "ignoredIssues") &&
            config.ignoredIssues !== DEFAULT_PARSER_CONFIG.ignoredIssues) {
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.PRINT_WARNING)("The <ignoredIssues> IParserConfig property is soft-deprecated and will be removed in future versions.\n\t" +
                "Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.");
        }
        this.ignoredIssues = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, "ignoredIssues")
            ? config.ignoredIssues
            : DEFAULT_PARSER_CONFIG.ignoredIssues;
        this.skipValidations = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, "skipValidations")
            ? config.skipValidations
            : DEFAULT_PARSER_CONFIG.skipValidations;
    }
    /**
     *  @deprecated use the **instance** method with the same name instead
     */
    Parser.performSelfAnalysis = function (parserInstance) {
        ;
        parserInstance.performSelfAnalysis();
    };
    Parser.prototype.performSelfAnalysis = function () {
        var _this = this;
        this.TRACE_INIT("performSelfAnalysis", function () {
            var defErrorsMsgs;
            _this.selfAnalysisDone = true;
            var className = _this.className;
            _this.TRACE_INIT("toFastProps", function () {
                // Without this voodoo magic the parser would be x3-x4 slower
                // It seems it is better to invoke `toFastProperties` **before**
                // Any manipulations of the `this` object done during the recording phase.
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.toFastProperties)(_this);
            });
            _this.TRACE_INIT("Grammar Recording", function () {
                try {
                    _this.enableRecording();
                    // Building the GAST
                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(_this.definedRulesNames, function (currRuleName) {
                        var wrappedRule = _this[currRuleName];
                        var originalGrammarAction = wrappedRule["originalGrammarAction"];
                        var recordedRuleGast = undefined;
                        _this.TRACE_INIT(currRuleName + " Rule", function () {
                            recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                        });
                        _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                    });
                }
                finally {
                    _this.disableRecording();
                }
            });
            var resolverErrors = [];
            _this.TRACE_INIT("Grammar Resolving", function () {
                resolverErrors = (0,_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_5__.resolveGrammar)({
                    rules: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache)
                });
                _this.definitionErrors.push.apply(_this.definitionErrors, resolverErrors); // mutability for the win?
            });
            _this.TRACE_INIT("Grammar Validations", function () {
                // only perform additional grammar validations IFF no resolving errors have occurred.
                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.
                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(resolverErrors) && _this.skipValidations === false) {
                    var validationErrors = (0,_grammar_gast_gast_resolver_public__WEBPACK_IMPORTED_MODULE_5__.validateGrammar)({
                        rules: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache),
                        maxLookahead: _this.maxLookahead,
                        tokenTypes: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.tokensMap),
                        ignoredIssues: _this.ignoredIssues,
                        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_4__.defaultGrammarValidatorErrorProvider,
                        grammarName: className
                    });
                    _this.definitionErrors.push.apply(_this.definitionErrors, validationErrors); // mutability for the win?
                }
            });
            // this analysis may fail if the grammar is not perfectly valid
            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(_this.definitionErrors)) {
                // The results of these computations are not needed unless error recovery is enabled.
                if (_this.recoveryEnabled) {
                    _this.TRACE_INIT("computeAllProdsFollows", function () {
                        var allFollows = (0,_grammar_follow__WEBPACK_IMPORTED_MODULE_1__.computeAllProdsFollows)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache));
                        _this.resyncFollows = allFollows;
                    });
                }
                _this.TRACE_INIT("ComputeLookaheadFunctions", function () {
                    _this.preComputeLookaheadFunctions((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache));
                });
            }
            _this.TRACE_INIT("expandAllNestedRuleNames", function () {
                // TODO: is this needed for EmbeddedActionsParser?
                var cstAnalysisResult = (0,_cst_cst__WEBPACK_IMPORTED_MODULE_3__.expandAllNestedRuleNames)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(_this.gastProductionsCache), _this.fullRuleNameToShort);
                _this.allRuleNames = cstAnalysisResult.allRuleNames;
            });
            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&
                !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(_this.definitionErrors)) {
                defErrorsMsgs = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(_this.definitionErrors, function (defError) { return defError.message; });
                throw new Error("Parser Definition Errors detected:\n " + defErrorsMsgs.join("\n-------------------------------\n"));
            }
        });
    };
    // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.
    // (normally during the parser's constructor).
    // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,
    // for example: duplicate rule names, referencing an unresolved subrule, ect...
    // This flag should not be enabled during normal usage, it is used in special situations, for example when
    // needing to display the parser definition errors in some GUI(online playground).
    Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;
    return Parser;
}());

(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.applyMixins)(Parser, [
    _traits_recoverable__WEBPACK_IMPORTED_MODULE_6__.Recoverable,
    _traits_looksahead__WEBPACK_IMPORTED_MODULE_7__.LooksAhead,
    _traits_tree_builder__WEBPACK_IMPORTED_MODULE_8__.TreeBuilder,
    _traits_lexer_adapter__WEBPACK_IMPORTED_MODULE_9__.LexerAdapter,
    _traits_recognizer_engine__WEBPACK_IMPORTED_MODULE_11__.RecognizerEngine,
    _traits_recognizer_api__WEBPACK_IMPORTED_MODULE_10__.RecognizerApi,
    _traits_error_handler__WEBPACK_IMPORTED_MODULE_12__.ErrorHandler,
    _traits_context_assist__WEBPACK_IMPORTED_MODULE_13__.ContentAssist,
    _traits_gast_recorder__WEBPACK_IMPORTED_MODULE_14__.GastRecorder,
    _traits_perf_tracer__WEBPACK_IMPORTED_MODULE_15__.PerformanceTracer
]);
var CstParser = /** @class */ (function (_super) {
    __extends(CstParser, _super);
    function CstParser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        var _this = this;
        var configClone = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneObj)(config);
        configClone.outputCst = true;
        _this = _super.call(this, tokenVocabulary, configClone) || this;
        return _this;
    }
    return CstParser;
}(Parser));

var EmbeddedActionsParser = /** @class */ (function (_super) {
    __extends(EmbeddedActionsParser, _super);
    function EmbeddedActionsParser(tokenVocabulary, config) {
        if (config === void 0) { config = DEFAULT_PARSER_CONFIG; }
        var _this = this;
        var configClone = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneObj)(config);
        configClone.outputCst = false;
        _this = _super.call(this, tokenVocabulary, configClone) || this;
        return _this;
    }
    return EmbeddedActionsParser;
}(Parser));

//# sourceMappingURL=parser.js.map

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IDENTITY: () => (/* binding */ IDENTITY),
/* harmony export */   NOOP: () => (/* binding */ NOOP),
/* harmony export */   PRINT_ERROR: () => (/* binding */ PRINT_ERROR),
/* harmony export */   PRINT_WARNING: () => (/* binding */ PRINT_WARNING),
/* harmony export */   applyMixins: () => (/* binding */ applyMixins),
/* harmony export */   assign: () => (/* binding */ assign),
/* harmony export */   assignNoOverwrite: () => (/* binding */ assignNoOverwrite),
/* harmony export */   cloneArr: () => (/* binding */ cloneArr),
/* harmony export */   cloneObj: () => (/* binding */ cloneObj),
/* harmony export */   compact: () => (/* binding */ compact),
/* harmony export */   contains: () => (/* binding */ contains),
/* harmony export */   defaults: () => (/* binding */ defaults),
/* harmony export */   difference: () => (/* binding */ difference),
/* harmony export */   drop: () => (/* binding */ drop),
/* harmony export */   dropRight: () => (/* binding */ dropRight),
/* harmony export */   every: () => (/* binding */ every),
/* harmony export */   filter: () => (/* binding */ filter),
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   findAll: () => (/* binding */ findAll),
/* harmony export */   first: () => (/* binding */ first),
/* harmony export */   flatten: () => (/* binding */ flatten),
/* harmony export */   forEach: () => (/* binding */ forEach),
/* harmony export */   groupBy: () => (/* binding */ groupBy),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   indexOf: () => (/* binding */ indexOf),
/* harmony export */   isArray: () => (/* binding */ isArray),
/* harmony export */   isES2015MapSupported: () => (/* binding */ isES2015MapSupported),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   isFunction: () => (/* binding */ isFunction),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isRegExp: () => (/* binding */ isRegExp),
/* harmony export */   isString: () => (/* binding */ isString),
/* harmony export */   isUndefined: () => (/* binding */ isUndefined),
/* harmony export */   keys: () => (/* binding */ keys),
/* harmony export */   last: () => (/* binding */ last),
/* harmony export */   map: () => (/* binding */ map),
/* harmony export */   mapValues: () => (/* binding */ mapValues),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   packArray: () => (/* binding */ packArray),
/* harmony export */   partial: () => (/* binding */ partial),
/* harmony export */   peek: () => (/* binding */ peek),
/* harmony export */   pick: () => (/* binding */ pick),
/* harmony export */   reduce: () => (/* binding */ reduce),
/* harmony export */   reject: () => (/* binding */ reject),
/* harmony export */   some: () => (/* binding */ some),
/* harmony export */   sortBy: () => (/* binding */ sortBy),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   toFastProperties: () => (/* binding */ toFastProperties),
/* harmony export */   uniq: () => (/* binding */ uniq),
/* harmony export */   values: () => (/* binding */ values),
/* harmony export */   zipObject: () => (/* binding */ zipObject)
/* harmony export */ });
/*
 Utils using lodash style API. (not necessarily 100% compliant) for functional and other utils.
 These utils should replace usage of lodash in the production code base. not because they are any better...
 but for the purpose of being a dependency free library.

 The hotspots in the code are already written in imperative style for performance reasons.
 so writing several dozen utils which may be slower than the original lodash, does not matter as much
 considering they will not be invoked in hotspots...
 */
function isEmpty(arr) {
    return arr && arr.length === 0;
}
function keys(obj) {
    if (obj === undefined || obj === null) {
        return [];
    }
    return Object.keys(obj);
}
function values(obj) {
    var vals = [];
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        vals.push(obj[keys[i]]);
    }
    return vals;
}
function mapValues(obj, callback) {
    var result = [];
    var objKeys = keys(obj);
    for (var idx = 0; idx < objKeys.length; idx++) {
        var currKey = objKeys[idx];
        result.push(callback.call(null, obj[currKey], currKey));
    }
    return result;
}
function map(arr, callback) {
    var result = [];
    for (var idx = 0; idx < arr.length; idx++) {
        result.push(callback.call(null, arr[idx], idx));
    }
    return result;
}
function flatten(arr) {
    var result = [];
    for (var idx = 0; idx < arr.length; idx++) {
        var currItem = arr[idx];
        if (Array.isArray(currItem)) {
            result = result.concat(flatten(currItem));
        }
        else {
            result.push(currItem);
        }
    }
    return result;
}
function first(arr) {
    return isEmpty(arr) ? undefined : arr[0];
}
function last(arr) {
    var len = arr && arr.length;
    return len ? arr[len - 1] : undefined;
}
function forEach(collection, iteratorCallback) {
    /* istanbul ignore else */
    if (Array.isArray(collection)) {
        for (var i = 0; i < collection.length; i++) {
            iteratorCallback.call(null, collection[i], i);
        }
    }
    else if (isObject(collection)) {
        var colKeys = keys(collection);
        for (var i = 0; i < colKeys.length; i++) {
            var key = colKeys[i];
            var value = collection[key];
            iteratorCallback.call(null, value, key);
        }
    }
    else {
        throw Error("non exhaustive match");
    }
}
function isString(item) {
    return typeof item === "string";
}
function isUndefined(item) {
    return item === undefined;
}
function isFunction(item) {
    return item instanceof Function;
}
function drop(arr, howMuch) {
    if (howMuch === void 0) { howMuch = 1; }
    return arr.slice(howMuch, arr.length);
}
function dropRight(arr, howMuch) {
    if (howMuch === void 0) { howMuch = 1; }
    return arr.slice(0, arr.length - howMuch);
}
function filter(arr, predicate) {
    var result = [];
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; i++) {
            var item = arr[i];
            if (predicate.call(null, item)) {
                result.push(item);
            }
        }
    }
    return result;
}
function reject(arr, predicate) {
    return filter(arr, function (item) { return !predicate(item); });
}
function pick(obj, predicate) {
    var keys = Object.keys(obj);
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        var currKey = keys[i];
        var currItem = obj[currKey];
        if (predicate(currItem)) {
            result[currKey] = currItem;
        }
    }
    return result;
}
function has(obj, prop) {
    if (isObject(obj)) {
        return obj.hasOwnProperty(prop);
    }
    return false;
}
function contains(arr, item) {
    return find(arr, function (currItem) { return currItem === item; }) !== undefined ? true : false;
}
/**
 * shallow clone
 */
function cloneArr(arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
        newArr.push(arr[i]);
    }
    return newArr;
}
/**
 * shallow clone
 */
function cloneObj(obj) {
    var clonedObj = {};
    for (var key in obj) {
        /* istanbul ignore else */
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            clonedObj[key] = obj[key];
        }
    }
    return clonedObj;
}
function find(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        if (predicate.call(null, item)) {
            return item;
        }
    }
    return undefined;
}
function findAll(arr, predicate) {
    var found = [];
    for (var i = 0; i < arr.length; i++) {
        var item = arr[i];
        if (predicate.call(null, item)) {
            found.push(item);
        }
    }
    return found;
}
function reduce(arrOrObj, iterator, initial) {
    var isArr = Array.isArray(arrOrObj);
    var vals = isArr ? arrOrObj : values(arrOrObj);
    var objKeys = isArr ? [] : keys(arrOrObj);
    var accumulator = initial;
    for (var i = 0; i < vals.length; i++) {
        accumulator = iterator.call(null, accumulator, vals[i], isArr ? i : objKeys[i]);
    }
    return accumulator;
}
function compact(arr) {
    return reject(arr, function (item) { return item === null || item === undefined; });
}
function uniq(arr, identity) {
    if (identity === void 0) { identity = function (item) { return item; }; }
    var identities = [];
    return reduce(arr, function (result, currItem) {
        var currIdentity = identity(currItem);
        if (contains(identities, currIdentity)) {
            return result;
        }
        else {
            identities.push(currIdentity);
            return result.concat(currItem);
        }
    }, []);
}
function partial(func) {
    var restArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        restArgs[_i - 1] = arguments[_i];
    }
    var firstArg = [null];
    var allArgs = firstArg.concat(restArgs);
    return Function.bind.apply(func, allArgs);
}
function isArray(obj) {
    return Array.isArray(obj);
}
function isRegExp(obj) {
    return obj instanceof RegExp;
}
function isObject(obj) {
    return obj instanceof Object;
}
function every(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        if (!predicate(arr[i], i)) {
            return false;
        }
    }
    return true;
}
function difference(arr, values) {
    return reject(arr, function (item) { return contains(values, item); });
}
function some(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        if (predicate(arr[i])) {
            return true;
        }
    }
    return false;
}
function indexOf(arr, value) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] === value) {
            return i;
        }
    }
    return -1;
}
function sortBy(arr, orderFunc) {
    var result = cloneArr(arr);
    result.sort(function (a, b) { return orderFunc(a) - orderFunc(b); });
    return result;
}
function zipObject(keys, values) {
    if (keys.length !== values.length) {
        throw Error("can't zipObject with different number of keys and values!");
    }
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = values[i];
    }
    return result;
}
/**
 * mutates! (and returns) target
 */
function assign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < sources.length; i++) {
        var curSource = sources[i];
        var currSourceKeys = keys(curSource);
        for (var j = 0; j < currSourceKeys.length; j++) {
            var currKey = currSourceKeys[j];
            target[currKey] = curSource[currKey];
        }
    }
    return target;
}
/**
 * mutates! (and returns) target
 */
function assignNoOverwrite(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < sources.length; i++) {
        var curSource = sources[i];
        if (isUndefined(curSource)) {
            continue;
        }
        var currSourceKeys = keys(curSource);
        for (var j = 0; j < currSourceKeys.length; j++) {
            var currKey = currSourceKeys[j];
            if (!has(target, currKey)) {
                target[currKey] = curSource[currKey];
            }
        }
    }
    return target;
}
function defaults() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return assignNoOverwrite.apply(null, [{}].concat(sources));
}
function groupBy(arr, groupKeyFunc) {
    var result = {};
    forEach(arr, function (item) {
        var currGroupKey = groupKeyFunc(item);
        var currGroupArr = result[currGroupKey];
        if (currGroupArr) {
            currGroupArr.push(item);
        }
        else {
            result[currGroupKey] = [item];
        }
    });
    return result;
}
/**
 * Merge obj2 into obj1.
 * Will overwrite existing properties with the same name
 */
function merge(obj1, obj2) {
    var result = cloneObj(obj1);
    var keys2 = keys(obj2);
    for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        var value = obj2[key];
        result[key] = value;
    }
    return result;
}
function NOOP() { }
function IDENTITY(item) {
    return item;
}
/**
 * Will return a new packed array with same values.
 */
function packArray(holeyArr) {
    var result = [];
    for (var i = 0; i < holeyArr.length; i++) {
        var orgValue = holeyArr[i];
        result.push(orgValue !== undefined ? orgValue : undefined);
    }
    return result;
}
function PRINT_ERROR(msg) {
    /* istanbul ignore else - can't override global.console in node.js */
    if (console && console.error) {
        console.error("Error: " + msg);
    }
}
function PRINT_WARNING(msg) {
    /* istanbul ignore else - can't override global.console in node.js*/
    if (console && console.warn) {
        // TODO: modify docs accordingly
        console.warn("Warning: " + msg);
    }
}
function isES2015MapSupported() {
    return typeof Map === "function";
}
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach(function (baseCtor) {
        var baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach(function (propName) {
            if (propName === "constructor") {
                return;
            }
            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
            // Handle Accessors
            if (basePropDescriptor &&
                (basePropDescriptor.get || basePropDescriptor.set)) {
                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
            }
            else {
                derivedCtor.prototype[propName] = baseCtor.prototype[propName];
            }
        });
    });
}
// base on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216
function toFastProperties(toBecomeFast) {
    function FakeConstructor() { }
    // If our object is used as a constructor it would receive
    FakeConstructor.prototype = toBecomeFast;
    var fakeInstance = new FakeConstructor();
    function fakeAccess() {
        return typeof fakeInstance.bar;
    }
    // help V8 understand this is a "real" prototype by actually using
    // the fake instance.
    fakeAccess();
    fakeAccess();
    return toBecomeFast;
    // Eval prevents optimization of this method (even though this is dead code)
    /* istanbul ignore next */
    // tslint:disable-next-line
    eval(toBecomeFast);
}
function peek(arr) {
    return arr[arr.length - 1];
}
/* istanbul ignore next - for performance tracing*/
function timer(func) {
    var start = new Date().getTime();
    var val = func();
    var end = new Date().getTime();
    var total = end - start;
    return { time: total, value: val };
}
//# sourceMappingURL=utils.js.map

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResyncFollowsWalker: () => (/* binding */ ResyncFollowsWalker),
/* harmony export */   buildBetweenProdsFollowPrefix: () => (/* binding */ buildBetweenProdsFollowPrefix),
/* harmony export */   buildInProdFollowPrefix: () => (/* binding */ buildInProdFollowPrefix),
/* harmony export */   computeAllProdsFollows: () => (/* binding */ computeAllProdsFollows)
/* harmony export */ });
/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _first__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





// This ResyncFollowsWalker computes all of the follows required for RESYNC
// (skipping reference production).
var ResyncFollowsWalker = /** @class */ (function (_super) {
    __extends(ResyncFollowsWalker, _super);
    function ResyncFollowsWalker(topProd) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.follows = {};
        return _this;
    }
    ResyncFollowsWalker.prototype.startWalking = function () {
        this.walk(this.topProd);
        return this.follows;
    };
    ResyncFollowsWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {
        // do nothing! just like in the public sector after 13:00
    };
    ResyncFollowsWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {
        var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +
            this.topProd.name;
        var fullRest = currRest.concat(prevRest);
        var restProd = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Flat({ definition: fullRest });
        var t_in_topProd_follows = (0,_first__WEBPACK_IMPORTED_MODULE_1__.first)(restProd);
        this.follows[followName] = t_in_topProd_follows;
    };
    return ResyncFollowsWalker;
}(_rest__WEBPACK_IMPORTED_MODULE_0__.RestWalker));

function computeAllProdsFollows(topProductions) {
    var reSyncFollows = {};
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(topProductions, function (topProd) {
        var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.assign)(reSyncFollows, currRefsFollow);
    });
    return reSyncFollows;
}
function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
    return inner.name + occurenceInParent + _constants__WEBPACK_IMPORTED_MODULE_3__.IN;
}
function buildInProdFollowPrefix(terminal) {
    var terminalName = terminal.terminalType.name;
    return terminalName + terminal.idx + _constants__WEBPACK_IMPORTED_MODULE_3__.IN;
}
//# sourceMappingURL=follow.js.map

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RestWalker: () => (/* binding */ RestWalker)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);


/**
 *  A Grammar Walker that computes the "remaining" grammar "after" a productions in the grammar.
 */
var RestWalker = /** @class */ (function () {
    function RestWalker() {
    }
    RestWalker.prototype.walk = function (prod, prevRest) {
        var _this = this;
        if (prevRest === void 0) { prevRest = []; }
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(prod.definition, function (subProd, index) {
            var currRest = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.drop)(prod.definition, index + 1);
            /* istanbul ignore else */
            if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {
                _this.walkProdRef(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal) {
                _this.walkTerminal(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Flat) {
                _this.walkFlat(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option) {
                _this.walkOption(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory) {
                _this.walkAtLeastOne(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator) {
                _this.walkAtLeastOneSep(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator) {
                _this.walkManySep(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition) {
                _this.walkMany(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation) {
                _this.walkOr(subProd, currRest, prevRest);
            }
            else {
                throw Error("non exhaustive match");
            }
        });
    };
    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };
    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };
    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {
        // ABCDEF => after the D the rest is EF
        var fullOrRest = currRest.concat(prevRest);
        this.walk(flatProd, fullOrRest);
    };
    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {
        // ABC(DE)?F => after the (DE)? the rest is F
        var fullOrRest = currRest.concat(prevRest);
        this.walk(optionProd, fullOrRest);
    };
    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F
        var fullAtLeastOneRest = [
            new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option({ definition: atLeastOneProd.definition })
        ].concat(currRest, prevRest);
        this.walk(atLeastOneProd, fullAtLeastOneRest);
    };
    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {
        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F
        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
    };
    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        // ABC(DE)*F => after the (DE)* the rest is (DE)?F
        var fullManyRest = [
            new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option({ definition: manyProd.definition })
        ].concat(currRest, prevRest);
        this.walk(manyProd, fullManyRest);
    };
    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F
        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
        this.walk(manySepProd, fullManySepRest);
    };
    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {
        var _this = this;
        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G
        var fullOrRest = currRest.concat(prevRest);
        // walk all different alternatives
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(orProd.definition, function (alt) {
            // wrapping each alternative in a single definition wrapper
            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows
            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1
            var prodWrapper = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Flat({ definition: [alt] });
            _this.walk(prodWrapper, fullOrRest);
        });
    };
    return RestWalker;
}());

function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
    var repSepRest = [
        new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option({
            definition: [
                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal({ terminalType: repSepProd.separator })
            ].concat(repSepProd.definition)
        })
    ];
    var fullRepSepRest = repSepRest.concat(currRest, prevRest);
    return fullRepSepRest;
}
//# sourceMappingURL=rest.js.map

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractProduction: () => (/* binding */ AbstractProduction),
/* harmony export */   Alternation: () => (/* binding */ Alternation),
/* harmony export */   Flat: () => (/* binding */ Flat),
/* harmony export */   NonTerminal: () => (/* binding */ NonTerminal),
/* harmony export */   Option: () => (/* binding */ Option),
/* harmony export */   Repetition: () => (/* binding */ Repetition),
/* harmony export */   RepetitionMandatory: () => (/* binding */ RepetitionMandatory),
/* harmony export */   RepetitionMandatoryWithSeparator: () => (/* binding */ RepetitionMandatoryWithSeparator),
/* harmony export */   RepetitionWithSeparator: () => (/* binding */ RepetitionWithSeparator),
/* harmony export */   Rule: () => (/* binding */ Rule),
/* harmony export */   Terminal: () => (/* binding */ Terminal),
/* harmony export */   serializeGrammar: () => (/* binding */ serializeGrammar),
/* harmony export */   serializeProduction: () => (/* binding */ serializeProduction)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var AbstractProduction = /** @class */ (function () {
    function AbstractProduction(definition) {
        this.definition = definition;
    }
    AbstractProduction.prototype.accept = function (visitor) {
        visitor.visit(this);
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(this.definition, function (prod) {
            prod.accept(visitor);
        });
    };
    return AbstractProduction;
}());

var NonTerminal = /** @class */ (function (_super) {
    __extends(NonTerminal, _super);
    function NonTerminal(options) {
        var _this = _super.call(this, []) || this;
        _this.idx = 1;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    Object.defineProperty(NonTerminal.prototype, "definition", {
        get: function () {
            if (this.referencedRule !== undefined) {
                return this.referencedRule.definition;
            }
            return [];
        },
        set: function (definition) {
            // immutable
        },
        enumerable: true,
        configurable: true
    });
    NonTerminal.prototype.accept = function (visitor) {
        visitor.visit(this);
        // don't visit children of a reference, we will get cyclic infinite loops if we do so
    };
    return NonTerminal;
}(AbstractProduction));

var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.orgText = "";
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Rule;
}(AbstractProduction));

// TODO: is this only used in an Alternation?
//       Perhaps `Flat` should be renamed to `Alternative`?
var Flat = /** @class */ (function (_super) {
    __extends(Flat, _super);
    // A named Flat production is used to indicate a Nested Rule in an alternation
    function Flat(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.ignoreAmbiguities = false;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Flat;
}(AbstractProduction));

var Option = /** @class */ (function (_super) {
    __extends(Option, _super);
    function Option(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Option;
}(AbstractProduction));

var RepetitionMandatory = /** @class */ (function (_super) {
    __extends(RepetitionMandatory, _super);
    function RepetitionMandatory(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionMandatory;
}(AbstractProduction));

var RepetitionMandatoryWithSeparator = /** @class */ (function (_super) {
    __extends(RepetitionMandatoryWithSeparator, _super);
    function RepetitionMandatoryWithSeparator(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionMandatoryWithSeparator;
}(AbstractProduction));

var Repetition = /** @class */ (function (_super) {
    __extends(Repetition, _super);
    function Repetition(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Repetition;
}(AbstractProduction));

var RepetitionWithSeparator = /** @class */ (function (_super) {
    __extends(RepetitionWithSeparator, _super);
    function RepetitionWithSeparator(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return RepetitionWithSeparator;
}(AbstractProduction));

var Alternation = /** @class */ (function (_super) {
    __extends(Alternation, _super);
    function Alternation(options) {
        var _this = _super.call(this, options.definition) || this;
        _this.idx = 1;
        _this.ignoreAmbiguities = false;
        _this.hasPredicates = false;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(_this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
        return _this;
    }
    return Alternation;
}(AbstractProduction));

var Terminal = /** @class */ (function () {
    function Terminal(options) {
        this.idx = 1;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.assign)(this, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(options, function (v) { return v !== undefined; }));
    }
    Terminal.prototype.accept = function (visitor) {
        visitor.visit(this);
    };
    return Terminal;
}());

function serializeGrammar(topRules) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topRules, serializeProduction);
}
function serializeProduction(node) {
    function convertDefinition(definition) {
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(definition, serializeProduction);
    }
    /* istanbul ignore else */
    if (node instanceof NonTerminal) {
        return {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx
        };
    }
    else if (node instanceof Flat) {
        return {
            type: "Flat",
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Option) {
        return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionMandatory) {
        return {
            type: "RepetitionMandatory",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionMandatoryWithSeparator) {
        return {
            type: "RepetitionMandatoryWithSeparator",
            name: node.name,
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof RepetitionWithSeparator) {
        return {
            type: "RepetitionWithSeparator",
            name: node.name,
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Repetition) {
        return {
            type: "Repetition",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Alternation) {
        return {
            type: "Alternation",
            name: node.name,
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    }
    else if (node instanceof Terminal) {
        var serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_1__.tokenLabel)(node.terminalType),
            idx: node.idx
        };
        var pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(pattern)
                ? pattern.source
                : pattern;
        }
        return serializedTerminal;
    }
    else if (node instanceof Rule) {
        return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition)
        };
    }
    else {
        throw Error("non exhaustive match");
    }
}
//# sourceMappingURL=gast_public.js.map

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EOF: () => (/* binding */ EOF),
/* harmony export */   createToken: () => (/* binding */ createToken),
/* harmony export */   createTokenInstance: () => (/* binding */ createTokenInstance),
/* harmony export */   hasTokenLabel: () => (/* binding */ hasTokenLabel),
/* harmony export */   tokenLabel: () => (/* binding */ tokenLabel),
/* harmony export */   tokenMatcher: () => (/* binding */ tokenMatcher),
/* harmony export */   tokenName: () => (/* binding */ tokenName)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _lexer_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);



function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
    }
    else {
        return tokType.name;
    }
}
function tokenName(tokType) {
    return tokType.name;
}
function hasTokenLabel(obj) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isString)(obj.LABEL) && obj.LABEL !== "";
}
var PARENT = "parent";
var CATEGORIES = "categories";
var LABEL = "label";
var GROUP = "group";
var PUSH_MODE = "push_mode";
var POP_MODE = "pop_mode";
var LONGER_ALT = "longer_alt";
var LINE_BREAKS = "line_breaks";
var START_CHARS_HINT = "start_chars_hint";
function createToken(config) {
    return createTokenInternal(config);
}
function createTokenInternal(config) {
    var pattern = config.pattern;
    var tokenType = {};
    tokenType.name = config.name;
    if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(pattern)) {
        tokenType.PATTERN = pattern;
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, PARENT)) {
        throw "The parent property is no longer supported.\n" +
            "See: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.";
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, CATEGORIES)) {
        // casting to ANY as this will be fixed inside `augmentTokenTypes``
        tokenType.CATEGORIES = config[CATEGORIES];
    }
    (0,_tokens__WEBPACK_IMPORTED_MODULE_2__.augmentTokenTypes)([tokenType]);
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, LABEL)) {
        tokenType.LABEL = config[LABEL];
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, GROUP)) {
        tokenType.GROUP = config[GROUP];
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, POP_MODE)) {
        tokenType.POP_MODE = config[POP_MODE];
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, PUSH_MODE)) {
        tokenType.PUSH_MODE = config[PUSH_MODE];
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, LONGER_ALT)) {
        tokenType.LONGER_ALT = config[LONGER_ALT];
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config[LINE_BREAKS];
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
    }
    return tokenType;
}
var EOF = createToken({ name: "EOF", pattern: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA });
(0,_tokens__WEBPACK_IMPORTED_MODULE_2__.augmentTokenTypes)([EOF]);
function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
    return {
        image: image,
        startOffset: startOffset,
        endOffset: endOffset,
        startLine: startLine,
        endLine: endLine,
        startColumn: startColumn,
        endColumn: endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType
    };
}
function tokenMatcher(token, tokType) {
    return (0,_tokens__WEBPACK_IMPORTED_MODULE_2__.tokenStructuredMatcher)(token, tokType);
}
//# sourceMappingURL=tokens_public.js.map

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lexer: () => (/* binding */ Lexer),
/* harmony export */   LexerDefinitionErrorType: () => (/* binding */ LexerDefinitionErrorType)
/* harmony export */ });
/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);





var LexerDefinitionErrorType;
(function (LexerDefinitionErrorType) {
    LexerDefinitionErrorType[LexerDefinitionErrorType["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
    LexerDefinitionErrorType[LexerDefinitionErrorType["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
    LexerDefinitionErrorType[LexerDefinitionErrorType["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));
var DEFAULT_LEXER_CONFIG = {
    deferDefinitionErrorsHandling: false,
    positionTracking: "full",
    lineTerminatorsPattern: /\n|\r\n?/g,
    lineTerminatorCharacters: ["\n", "\r"],
    ensureOptimizations: false,
    safeMode: false,
    errorMessageProvider: _scan_lexer_errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultLexerErrorProvider,
    traceInitPerf: false,
    skipValidations: false
};
Object.freeze(DEFAULT_LEXER_CONFIG);
var Lexer = /** @class */ (function () {
    function Lexer(lexerDefinition, config) {
        var _this = this;
        if (config === void 0) { config = DEFAULT_LEXER_CONFIG; }
        this.lexerDefinition = lexerDefinition;
        this.lexerDefinitionErrors = [];
        this.lexerDefinitionWarning = [];
        this.patternIdxToConfig = {};
        this.charCodeToPatternIdxToConfig = {};
        this.modes = [];
        this.emptyGroups = {};
        this.config = undefined;
        this.trackStartLines = true;
        this.trackEndLines = true;
        this.hasCustom = false;
        this.canModeBeOptimized = {};
        if (typeof config === "boolean") {
            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\n" +
                "a boolean 2nd argument is no longer supported");
        }
        // todo: defaults func?
        this.config = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.merge)(DEFAULT_LEXER_CONFIG, config);
        var traceInitVal = this.config.traceInitPerf;
        if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
        }
        else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
        }
        this.traceInitIndent = -1;
        this.TRACE_INIT("Lexer Constructor", function () {
            var actualDefinition;
            var hasOnlySingleMode = true;
            _this.TRACE_INIT("Lexer Config handling", function () {
                if (_this.config.lineTerminatorsPattern ===
                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                    // optimized built-in implementation for the defaults definition of lineTerminators
                    _this.config.lineTerminatorsPattern = _lexer__WEBPACK_IMPORTED_MODULE_0__.LineTerminatorOptimizedTester;
                }
                else {
                    if (_this.config.lineTerminatorCharacters ===
                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                        throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n" +
                            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                    }
                }
                if (config.safeMode && config.ensureOptimizations) {
                    throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                }
                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
                _this.trackEndLines = /full/i.test(_this.config.positionTracking);
                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.
                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(lexerDefinition)) {
                    actualDefinition = { modes: {} };
                    actualDefinition.modes[_lexer__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODE] = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(lexerDefinition);
                    actualDefinition[_lexer__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODE] = _lexer__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODE;
                }
                else {
                    // no conversion needed, input should already be a IMultiModeLexerDefinition
                    hasOnlySingleMode = false;
                    actualDefinition = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneObj)((lexerDefinition));
                }
            });
            if (_this.config.skipValidations === false) {
                _this.TRACE_INIT("performRuntimeChecks", function () {
                    _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0,_lexer__WEBPACK_IMPORTED_MODULE_0__.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
                _this.TRACE_INIT("performWarningRuntimeChecks", function () {
                    _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0,_lexer__WEBPACK_IMPORTED_MODULE_0__.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
            }
            // for extra robustness to avoid throwing an none informative error message
            actualDefinition.modes = actualDefinition.modes
                ? actualDefinition.modes
                : {};
            // an error of undefined TokenTypes will be detected in "performRuntimeChecks" above.
            // this transformation is to increase robustness in the case of partially invalid lexer definition.
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(actualDefinition.modes, function (currModeValue, currModeName) {
                actualDefinition.modes[currModeName] = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.reject)(currModeValue, function (currTokType) { return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(currTokType); });
            });
            var allModeNames = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.keys)(actualDefinition.modes);
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(actualDefinition.modes, function (currModDef, currModName) {
                _this.TRACE_INIT("Mode: <" + currModName + "> processing", function () {
                    _this.modes.push(currModName);
                    if (_this.config.skipValidations === false) {
                        _this.TRACE_INIT("validatePatterns", function () {
                            _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0,_lexer__WEBPACK_IMPORTED_MODULE_0__.validatePatterns)(currModDef, allModeNames));
                        });
                    }
                    // If definition errors were encountered, the analysis phase may fail unexpectedly/
                    // Considering a lexer with definition errors may never be used, there is no point
                    // to performing the analysis anyhow...
                    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(_this.lexerDefinitionErrors)) {
                        (0,_tokens__WEBPACK_IMPORTED_MODULE_2__.augmentTokenTypes)(currModDef);
                        var currAnalyzeResult_1;
                        _this.TRACE_INIT("analyzeTokenTypes", function () {
                            currAnalyzeResult_1 = (0,_lexer__WEBPACK_IMPORTED_MODULE_0__.analyzeTokenTypes)(currModDef, {
                                lineTerminatorCharacters: _this.config
                                    .lineTerminatorCharacters,
                                positionTracking: config.positionTracking,
                                ensureOptimizations: config.ensureOptimizations,
                                safeMode: config.safeMode,
                                tracer: _this.TRACE_INIT.bind(_this)
                            });
                        });
                        _this.patternIdxToConfig[currModName] =
                            currAnalyzeResult_1.patternIdxToConfig;
                        _this.charCodeToPatternIdxToConfig[currModName] =
                            currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                        _this.emptyGroups = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.merge)(_this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                        _this.hasCustom =
                            currAnalyzeResult_1.hasCustom || _this.hasCustom;
                        _this.canModeBeOptimized[currModName] =
                            currAnalyzeResult_1.canBeOptimized;
                    }
                });
            });
            _this.defaultMode = actualDefinition.defaultMode;
            if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(_this.lexerDefinitionErrors) &&
                !_this.config.deferDefinitionErrorsHandling) {
                var allErrMessages = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(_this.lexerDefinitionErrors, function (error) {
                    return error.message;
                });
                var allErrMessagesString = allErrMessages.join("-----------------------\n");
                throw new Error("Errors detected in definition of Lexer:\n" +
                    allErrMessagesString);
            }
            // Only print warning if there are no errors, This will avoid pl
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(_this.lexerDefinitionWarning, function (warningDescriptor) {
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_WARNING)(warningDescriptor.message);
            });
            _this.TRACE_INIT("Choosing sub-methods implementations", function () {
                // Choose the relevant internal implementations for this specific parser.
                // These implementations should be in-lined by the JavaScript engine
                // to provide optimal performance in each scenario.
                if (_lexer__WEBPACK_IMPORTED_MODULE_0__.SUPPORT_STICKY) {
                    _this.chopInput = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.IDENTITY;
                    _this.match = _this.matchWithTest;
                }
                else {
                    _this.updateLastIndex = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                    _this.match = _this.matchWithExec;
                }
                if (hasOnlySingleMode) {
                    _this.handleModes = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                }
                if (_this.trackStartLines === false) {
                    _this.computeNewColumn = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.IDENTITY;
                }
                if (_this.trackEndLines === false) {
                    _this.updateTokenEndLineColumnLocation = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                }
                if (/full/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createFullToken;
                }
                else if (/onlyStart/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createStartOnlyToken;
                }
                else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                    _this.createTokenInstance = _this.createOffsetOnlyToken;
                }
                else {
                    throw Error("Invalid <positionTracking> config option: \"" + _this.config.positionTracking + "\"");
                }
                if (_this.hasCustom) {
                    _this.addToken = _this.addTokenUsingPush;
                    _this.handlePayload = _this.handlePayloadWithCustom;
                }
                else {
                    _this.addToken = _this.addTokenUsingMemberAccess;
                    _this.handlePayload = _this.handlePayloadNoCustom;
                }
            });
            _this.TRACE_INIT("Failed Optimization Warnings", function () {
                var unOptimizedModes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.reduce)(_this.canModeBeOptimized, function (cannotBeOptimized, canBeOptimized, modeName) {
                    if (canBeOptimized === false) {
                        cannotBeOptimized.push(modeName);
                    }
                    return cannotBeOptimized;
                }, []);
                if (config.ensureOptimizations && !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(unOptimizedModes)) {
                    throw Error("Lexer Modes: < " + unOptimizedModes.join(", ") + " > cannot be optimized.\n" +
                        '\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n' +
                        "\t Or inspect the console log for details on how to resolve these issues.");
                }
            });
            _this.TRACE_INIT("clearRegExpParserCache", function () {
                (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__.clearRegExpParserCache)();
            });
            _this.TRACE_INIT("toFastProperties", function () {
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.toFastProperties)(_this);
            });
        });
    }
    Lexer.prototype.tokenize = function (text, initialMode) {
        if (initialMode === void 0) { initialMode = this.defaultMode; }
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.lexerDefinitionErrors)) {
            var allErrMessages = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.lexerDefinitionErrors, function (error) {
                return error.message;
            });
            var allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" +
                allErrMessagesString);
        }
        var lexResult = this.tokenizeInternal(text, initialMode);
        return lexResult;
    };
    // There is quite a bit of duplication between this and "tokenizeInternalLazy"
    // This is intentional due to performance considerations.
    Lexer.prototype.tokenizeInternal = function (text, initialMode) {
        var _this = this;
        var i, j, matchAltImage, longerAltIdx, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
        var orgText = text;
        var orgLength = orgText.length;
        var offset = 0;
        var matchedTokensIndex = 0;
        // initializing the tokensArray to the "guessed" size.
        // guessing too little will still reduce the number of array re-sizes on pushes.
        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory
        // but would still have a faster runtime by avoiding (All but one) array resizing.
        var guessedNumberOfTokens = this.hasCustom
            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.
            : Math.floor(text.length / 10);
        var matchedTokens = new Array(guessedNumberOfTokens);
        var errors = [];
        var line = this.trackStartLines ? 1 : undefined;
        var column = this.trackStartLines ? 1 : undefined;
        var groups = (0,_lexer__WEBPACK_IMPORTED_MODULE_0__.cloneEmptyGroups)(this.emptyGroups);
        var trackLines = this.trackStartLines;
        var lineTerminatorPattern = this.config.lineTerminatorsPattern;
        var currModePatternsLength = 0;
        var patternIdxToConfig = [];
        var currCharCodeToPatternIdxToConfig = [];
        var modeStack = [];
        var emptyArray = [];
        Object.freeze(emptyArray);
        var getPossiblePatterns = undefined;
        function getPossiblePatternsSlow() {
            return patternIdxToConfig;
        }
        function getPossiblePatternsOptimized(charCode) {
            var optimizedCharIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_0__.charCodeToOptimizedIndex)(charCode);
            var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === undefined) {
                return emptyArray;
            }
            else {
                return possiblePatterns;
            }
        }
        var pop_mode = function (popToken) {
            // TODO: perhaps avoid this error in the edge case there is no more input?
            if (modeStack.length === 1 &&
                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
                // So no error should occur.
                popToken.tokenType.PUSH_MODE === undefined) {
                // if we try to pop the last mode there lexer will no longer have ANY mode.
                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.
                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
                errors.push({
                    offset: popToken.startOffset,
                    line: popToken.startLine !== undefined
                        ? popToken.startLine
                        : undefined,
                    column: popToken.startColumn !== undefined
                        ? popToken.startColumn
                        : undefined,
                    length: popToken.image.length,
                    message: msg_1
                });
            }
            else {
                modeStack.pop();
                var newMode = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.last)(modeStack);
                patternIdxToConfig = _this.patternIdxToConfig[newMode];
                currCharCodeToPatternIdxToConfig = _this
                    .charCodeToPatternIdxToConfig[newMode];
                currModePatternsLength = patternIdxToConfig.length;
                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] &&
                    _this.config.safeMode === false;
                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                    getPossiblePatterns = getPossiblePatternsOptimized;
                }
                else {
                    getPossiblePatterns = getPossiblePatternsSlow;
                }
            }
        };
        function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig = this
                .charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            var modeCanBeOptimized = this.canModeBeOptimized[newMode] &&
                this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
            }
            else {
                getPossiblePatterns = getPossiblePatternsSlow;
            }
        }
        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not
        // seem to matter performance wise.
        push_mode.call(this, initialMode);
        var currConfig;
        while (offset < orgLength) {
            matchedImage = null;
            var nextCharCode = orgText.charCodeAt(offset);
            var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            var chosenPatternsLength = chosenPatternIdxToConfig.length;
            for (i = 0; i < chosenPatternsLength; i++) {
                currConfig = chosenPatternIdxToConfig[i];
                var currPattern = currConfig.pattern;
                payload = null;
                // manually in-lined because > 600 chars won't be in-lined in V8
                var singleCharCode = currConfig.short;
                if (singleCharCode !== false) {
                    if (nextCharCode === singleCharCode) {
                        // single character string
                        matchedImage = currPattern;
                    }
                }
                else if (currConfig.isCustom === true) {
                    match = currPattern.exec(orgText, offset, matchedTokens, groups);
                    if (match !== null) {
                        matchedImage = match[0];
                        if (match.payload !== undefined) {
                            payload = match.payload;
                        }
                    }
                    else {
                        matchedImage = null;
                    }
                }
                else {
                    this.updateLastIndex(currPattern, offset);
                    matchedImage = this.match(currPattern, text, offset);
                }
                if (matchedImage !== null) {
                    // even though this pattern matched we must try a another longer alternative.
                    // this can be used to prioritize keywords over identifiers
                    longerAltIdx = currConfig.longerAlt;
                    if (longerAltIdx !== undefined) {
                        // TODO: micro optimize, avoid extra prop access
                        // by saving/linking longerAlt on the original config?
                        var longerAltConfig = patternIdxToConfig[longerAltIdx];
                        var longerAltPattern = longerAltConfig.pattern;
                        altPayload = null;
                        // single Char can never be a longer alt so no need to test it.
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        if (longerAltConfig.isCustom === true) {
                            match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                            if (match !== null) {
                                matchAltImage = match[0];
                                if (match.payload !== undefined) {
                                    altPayload = match.payload;
                                }
                            }
                            else {
                                matchAltImage = null;
                            }
                        }
                        else {
                            this.updateLastIndex(longerAltPattern, offset);
                            matchAltImage = this.match(longerAltPattern, text, offset);
                        }
                        if (matchAltImage &&
                            matchAltImage.length > matchedImage.length) {
                            matchedImage = matchAltImage;
                            payload = altPayload;
                            currConfig = longerAltConfig;
                        }
                    }
                    break;
                }
            }
            // successful match
            if (matchedImage !== null) {
                imageLength = matchedImage.length;
                group = currConfig.group;
                if (group !== undefined) {
                    tokType = currConfig.tokenTypeIdx;
                    // TODO: "offset + imageLength" and the new column may be computed twice in case of "full" location information inside
                    // createFullToken method
                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                    this.handlePayload(newToken, payload);
                    // TODO: optimize NOOP in case there are no special groups?
                    if (group === false) {
                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                    }
                    else {
                        groups[group].push(newToken);
                    }
                }
                text = this.chopInput(text, imageLength);
                offset = offset + imageLength;
                // TODO: with newlines the column may be assigned twice
                column = this.computeNewColumn(column, imageLength);
                if (trackLines === true &&
                    currConfig.canLineTerminator === true) {
                    var numOfLTsInMatch = 0;
                    var foundTerminator = void 0;
                    var lastLTEndOffset = void 0;
                    lineTerminatorPattern.lastIndex = 0;
                    do {
                        foundTerminator = lineTerminatorPattern.test(matchedImage);
                        if (foundTerminator === true) {
                            lastLTEndOffset =
                                lineTerminatorPattern.lastIndex - 1;
                            numOfLTsInMatch++;
                        }
                    } while (foundTerminator === true);
                    if (numOfLTsInMatch !== 0) {
                        line = line + numOfLTsInMatch;
                        column = imageLength - lastLTEndOffset;
                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                    }
                }
                // will be NOOP if no modes present
                this.handleModes(currConfig, pop_mode, push_mode, newToken);
            }
            else {
                // error recovery, drop characters until we identify a valid token's start point
                var errorStartOffset = offset;
                var errorLine = line;
                var errorColumn = column;
                var foundResyncPoint = false;
                while (!foundResyncPoint && offset < orgLength) {
                    // drop chars until we succeed in matching something
                    droppedChar = orgText.charCodeAt(offset);
                    // Identity Func (when sticky flag is enabled)
                    text = this.chopInput(text, 1);
                    offset++;
                    for (j = 0; j < currModePatternsLength; j++) {
                        var currConfig_1 = patternIdxToConfig[j];
                        var currPattern = currConfig_1.pattern;
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        var singleCharCode = currConfig_1.short;
                        if (singleCharCode !== false) {
                            if (orgText.charCodeAt(offset) === singleCharCode) {
                                // single character string
                                foundResyncPoint = true;
                            }
                        }
                        else if (currConfig_1.isCustom === true) {
                            foundResyncPoint =
                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                        }
                        else {
                            this.updateLastIndex(currPattern, offset);
                            foundResyncPoint = currPattern.exec(text) !== null;
                        }
                        if (foundResyncPoint === true) {
                            break;
                        }
                    }
                }
                errLength = offset - errorStartOffset;
                // at this point we either re-synced or reached the end of the input text
                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
                errors.push({
                    offset: errorStartOffset,
                    line: errorLine,
                    column: errorColumn,
                    length: errLength,
                    message: msg
                });
            }
        }
        // if we do have custom patterns which push directly into the
        // TODO: custom tokens should not push directly??
        if (!this.hasCustom) {
            // if we guessed a too large size for the tokens array this will shrink it to the right size.
            matchedTokens.length = matchedTokensIndex;
        }
        return {
            tokens: matchedTokens,
            groups: groups,
            errors: errors
        };
    };
    Lexer.prototype.handleModes = function (config, pop_mode, push_mode, newToken) {
        if (config.pop === true) {
            // need to save the PUSH_MODE property as if the mode is popped
            // patternIdxToPopMode is updated to reflect the new mode after popping the stack
            var pushMode = config.push;
            pop_mode(newToken);
            if (pushMode !== undefined) {
                push_mode.call(this, pushMode);
            }
        }
        else if (config.push !== undefined) {
            push_mode.call(this, config.push);
        }
    };
    Lexer.prototype.chopInput = function (text, length) {
        return text.substring(length);
    };
    Lexer.prototype.updateLastIndex = function (regExp, newLastIndex) {
        regExp.lastIndex = newLastIndex;
    };
    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
    Lexer.prototype.updateTokenEndLineColumnLocation = function (newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
        var lastCharIsLT, fixForEndingInLT;
        if (group !== undefined) {
            // a none skipped multi line Token, need to update endLine/endColumn
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
                // if a token ends in a LT that last LT only affects the line numbering of following Tokens
                newToken.endLine = line + fixForEndingInLT;
                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)
                // inclusive to exclusive range.
                newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
            // else single LT in the last character of a token, no need to modify the endLine/EndColumn
        }
    };
    Lexer.prototype.computeNewColumn = function (oldColumn, imageLength) {
        return oldColumn + imageLength;
    };
    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.createTokenInstance = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return null;
    };
    Lexer.prototype.createOffsetOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType) {
        return {
            image: image,
            startOffset: startOffset,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    Lexer.prototype.createStartOnlyToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
        return {
            image: image,
            startOffset: startOffset,
            startLine: startLine,
            startColumn: startColumn,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    Lexer.prototype.createFullToken = function (image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
        return {
            image: image,
            startOffset: startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine: startLine,
            endLine: startLine,
            startColumn: startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx: tokenTypeIdx,
            tokenType: tokenType
        };
    };
    // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.addToken = function (tokenVector, index, tokenToAdd) {
        return 666;
    };
    Lexer.prototype.addTokenUsingPush = function (tokenVector, index, tokenToAdd) {
        tokenVector.push(tokenToAdd);
        return index;
    };
    Lexer.prototype.addTokenUsingMemberAccess = function (tokenVector, index, tokenToAdd) {
        tokenVector[index] = tokenToAdd;
        index++;
        return index;
    };
    // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.
    /* istanbul ignore next - place holder */
    Lexer.prototype.handlePayload = function (token, payload) { };
    Lexer.prototype.handlePayloadNoCustom = function (token, payload) { };
    Lexer.prototype.handlePayloadWithCustom = function (token, payload) {
        if (payload !== null) {
            token.payload = payload;
        }
    };
    /* istanbul ignore next - place holder to be replaced with chosen alternative at runtime */
    Lexer.prototype.match = function (pattern, text, offset) {
        return null;
    };
    Lexer.prototype.matchWithTest = function (pattern, text, offset) {
        var found = pattern.test(text);
        if (found === true) {
            return text.substring(offset, pattern.lastIndex);
        }
        return null;
    };
    Lexer.prototype.matchWithExec = function (pattern, text) {
        var regExpArray = pattern.exec(text);
        return regExpArray !== null ? regExpArray[0] : regExpArray;
    };
    // Duplicated from the parser's perf trace trait to allow future extraction
    // of the lexer to a separate package.
    Lexer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(indent + "--> <" + phaseDesc + ">");
            }
            var _a = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.timer)(phaseImpl), time = _a.time, value = _a.value;
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
            }
            this.traceInitIndent--;
            return value;
        }
        else {
            return phaseImpl();
        }
    };
    Lexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it will" +
        "be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
    Lexer.NA = /NOT_APPLICABLE/;
    return Lexer;
}());

//# sourceMappingURL=lexer_public.js.map

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_MODE: () => (/* binding */ DEFAULT_MODE),
/* harmony export */   LineTerminatorOptimizedTester: () => (/* binding */ LineTerminatorOptimizedTester),
/* harmony export */   MODES: () => (/* binding */ MODES),
/* harmony export */   SUPPORT_STICKY: () => (/* binding */ SUPPORT_STICKY),
/* harmony export */   addStartOfInput: () => (/* binding */ addStartOfInput),
/* harmony export */   addStickyFlag: () => (/* binding */ addStickyFlag),
/* harmony export */   analyzeTokenTypes: () => (/* binding */ analyzeTokenTypes),
/* harmony export */   buildLineBreakIssueMessage: () => (/* binding */ buildLineBreakIssueMessage),
/* harmony export */   charCodeToOptimizedIndex: () => (/* binding */ charCodeToOptimizedIndex),
/* harmony export */   cloneEmptyGroups: () => (/* binding */ cloneEmptyGroups),
/* harmony export */   disableSticky: () => (/* binding */ disableSticky),
/* harmony export */   enableSticky: () => (/* binding */ enableSticky),
/* harmony export */   findDuplicatePatterns: () => (/* binding */ findDuplicatePatterns),
/* harmony export */   findEmptyMatchRegExps: () => (/* binding */ findEmptyMatchRegExps),
/* harmony export */   findEndOfInputAnchor: () => (/* binding */ findEndOfInputAnchor),
/* harmony export */   findInvalidGroupType: () => (/* binding */ findInvalidGroupType),
/* harmony export */   findInvalidPatterns: () => (/* binding */ findInvalidPatterns),
/* harmony export */   findMissingPatterns: () => (/* binding */ findMissingPatterns),
/* harmony export */   findModesThatDoNotExist: () => (/* binding */ findModesThatDoNotExist),
/* harmony export */   findStartOfInputAnchor: () => (/* binding */ findStartOfInputAnchor),
/* harmony export */   findUnreachablePatterns: () => (/* binding */ findUnreachablePatterns),
/* harmony export */   findUnsupportedFlags: () => (/* binding */ findUnsupportedFlags),
/* harmony export */   isCustomPattern: () => (/* binding */ isCustomPattern),
/* harmony export */   isShortPattern: () => (/* binding */ isShortPattern),
/* harmony export */   minOptimizationVal: () => (/* binding */ minOptimizationVal),
/* harmony export */   performRuntimeChecks: () => (/* binding */ performRuntimeChecks),
/* harmony export */   performWarningRuntimeChecks: () => (/* binding */ performWarningRuntimeChecks),
/* harmony export */   validatePatterns: () => (/* binding */ validatePatterns)
/* harmony export */ });
/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lexer_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _reg_exp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25);
/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var PATTERN = "PATTERN";
var DEFAULT_MODE = "defaultMode";
var MODES = "modes";
var SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
function disableSticky() {
    SUPPORT_STICKY = false;
}
function enableSticky() {
    SUPPORT_STICKY = true;
}
function analyzeTokenTypes(tokenTypes, options) {
    options = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.defaults)(options, {
        useSticky: SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: function (msg, action) { return action(); }
    });
    var tracer = options.tracer;
    tracer("initCharCodeToOptimizedIndexMap", function () {
        initCharCodeToOptimizedIndexMap();
    });
    var onlyRelevantTypes;
    tracer("Reject Lexer.NA", function () {
        onlyRelevantTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reject)(tokenTypes, function (currType) {
            return currType[PATTERN] === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA;
        });
    });
    var hasCustom = false;
    var allTransformedPatterns;
    tracer("Transform Patterns", function () {
        hasCustom = false;
        allTransformedPatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (currType) {
            var currPattern = currType[PATTERN];
            /* istanbul ignore else */
            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(currPattern)) {
                var regExpSource = currPattern.source;
                if (regExpSource.length === 1 &&
                    // only these regExp meta characters which can appear in a length one regExp
                    regExpSource !== "^" &&
                    regExpSource !== "$" &&
                    regExpSource !== ".") {
                    return regExpSource;
                }
                else if (regExpSource.length === 2 &&
                    regExpSource[0] === "\\" &&
                    // not a meta character
                    !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.contains)([
                        "d",
                        "D",
                        "s",
                        "S",
                        "t",
                        "r",
                        "n",
                        "t",
                        "0",
                        "c",
                        "b",
                        "B",
                        "f",
                        "v",
                        "w",
                        "W"
                    ], regExpSource[1])) {
                    // escaped meta Characters: /\+/ /\[/
                    // or redundant escaping: /\a/
                    // without the escaping "\"
                    return regExpSource[1];
                }
                else {
                    return options.useSticky
                        ? addStickyFlag(currPattern)
                        : addStartOfInput(currPattern);
                }
            }
            else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(currPattern)) {
                hasCustom = true;
                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
                return { exec: currPattern };
            }
            else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(currPattern, "exec")) {
                hasCustom = true;
                // ICustomPattern
                return currPattern;
            }
            else if (typeof currPattern === "string") {
                if (currPattern.length === 1) {
                    return currPattern;
                }
                else {
                    var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
                    var wrappedRegExp = new RegExp(escapedRegExpString);
                    return options.useSticky
                        ? addStickyFlag(wrappedRegExp)
                        : addStartOfInput(wrappedRegExp);
                }
            }
            else {
                throw Error("non exhaustive match");
            }
        });
    });
    var patternIdxToType;
    var patternIdxToGroup;
    var patternIdxToLongerAltIdx;
    var patternIdxToPushMode;
    var patternIdxToPopMode;
    tracer("misc mapping", function () {
        patternIdxToType = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (currType) { return currType.tokenTypeIdx; });
        patternIdxToGroup = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (clazz) {
            var groupName = clazz.GROUP;
            /* istanbul ignore next */
            if (groupName === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED) {
                return undefined;
            }
            else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(groupName)) {
                return groupName;
            }
            else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(groupName)) {
                return false;
            }
            else {
                throw Error("non exhaustive match");
            }
        });
        patternIdxToLongerAltIdx = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (clazz) {
            var longerAltType = clazz.LONGER_ALT;
            if (longerAltType) {
                var longerAltIdx = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.indexOf)(onlyRelevantTypes, longerAltType);
                return longerAltIdx;
            }
        });
        patternIdxToPushMode = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (clazz) { return clazz.PUSH_MODE; });
        patternIdxToPopMode = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (clazz) {
            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(clazz, "POP_MODE");
        });
    });
    var patternIdxToCanLineTerminator;
    tracer("Line Terminator Handling", function () {
        var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (tokType) { return false; });
        if (options.positionTracking !== "onlyOffset") {
            patternIdxToCanLineTerminator = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, function (tokType) {
                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(tokType, "LINE_BREAKS")) {
                    return tokType.LINE_BREAKS;
                }
                else {
                    if (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false) {
                        return (0,_reg_exp__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
                    }
                }
            });
        }
    });
    var patternIdxToIsCustom;
    var patternIdxToShort;
    var emptyGroups;
    var patternIdxToConfig;
    tracer("Misc Mapping #2", function () {
        patternIdxToIsCustom = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(allTransformedPatterns, isShortPattern);
        emptyGroups = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reduce)(onlyRelevantTypes, function (acc, clazz) {
            var groupName = clazz.GROUP;
            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(groupName) && !(groupName === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED)) {
                acc[groupName] = [];
            }
            return acc;
        }, {});
        patternIdxToConfig = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(allTransformedPatterns, function (x, idx) {
            return {
                pattern: allTransformedPatterns[idx],
                longerAlt: patternIdxToLongerAltIdx[idx],
                canLineTerminator: patternIdxToCanLineTerminator[idx],
                isCustom: patternIdxToIsCustom[idx],
                short: patternIdxToShort[idx],
                group: patternIdxToGroup[idx],
                push: patternIdxToPushMode[idx],
                pop: patternIdxToPopMode[idx],
                tokenTypeIdx: patternIdxToType[idx],
                tokenType: onlyRelevantTypes[idx]
            };
        });
    });
    var canBeOptimized = true;
    var charCodeToPatternIdxToConfig = [];
    if (!options.safeMode) {
        tracer("First Char Optimization", function () {
            charCodeToPatternIdxToConfig = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reduce)(onlyRelevantTypes, function (result, currTokType, idx) {
                if (typeof currTokType.PATTERN === "string") {
                    var charCode = currTokType.PATTERN.charCodeAt(0);
                    var optimizedIdx = charCodeToOptimizedIndex(charCode);
                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
                }
                else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(currTokType.START_CHARS_HINT)) {
                    var lastOptimizedIdx_1;
                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(currTokType.START_CHARS_HINT, function (charOrInt) {
                        var charCode = typeof charOrInt === "string"
                            ? charOrInt.charCodeAt(0)
                            : charOrInt;
                        var currOptimizedIdx = charCodeToOptimizedIndex(charCode);
                        // Avoid adding the config multiple times
                        if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                            lastOptimizedIdx_1 = currOptimizedIdx;
                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                        }
                    });
                }
                else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(currTokType.PATTERN)) {
                    if (currTokType.PATTERN.unicode) {
                        canBeOptimized = false;
                        if (options.ensureOptimizations) {
                            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.PRINT_ERROR)("" + _reg_exp__WEBPACK_IMPORTED_MODULE_3__.failedOptimizationPrefixMsg +
                                ("\tUnable to analyze < " + currTokType.PATTERN.toString() + " > pattern.\n") +
                                "\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n" +
                                "\tThis will disable the lexer's first char optimizations.\n" +
                                "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                        }
                    }
                    else {
                        var optimizedCodes = (0,_reg_exp__WEBPACK_IMPORTED_MODULE_3__.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                        /* istanbul ignore if */
                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library
                        // the first should be a different validation and the second cannot be tested.
                        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(optimizedCodes)) {
                            // we cannot understand what codes may start possible matches
                            // The optimization correctness requires knowing start codes for ALL patterns.
                            // Not actually sure this is an error, no debug message
                            canBeOptimized = false;
                        }
                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(optimizedCodes, function (code) {
                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                        });
                    }
                }
                else {
                    if (options.ensureOptimizations) {
                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.PRINT_ERROR)("" + _reg_exp__WEBPACK_IMPORTED_MODULE_3__.failedOptimizationPrefixMsg +
                            ("\tTokenType: <" + currTokType.name + "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") +
                            "\tThis will disable the lexer's first char optimizations.\n" +
                            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
                    }
                    canBeOptimized = false;
                }
                return result;
            }, []);
        });
    }
    tracer("ArrayPacking", function () {
        charCodeToPatternIdxToConfig = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.packArray)(charCodeToPatternIdxToConfig);
    });
    return {
        emptyGroups: emptyGroups,
        patternIdxToConfig: patternIdxToConfig,
        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,
        hasCustom: hasCustom,
        canBeOptimized: canBeOptimized
    };
}
function validatePatterns(tokenTypes, validModesNames) {
    var errors = [];
    var missingResult = findMissingPatterns(tokenTypes);
    errors = errors.concat(missingResult.errors);
    var invalidResult = findInvalidPatterns(missingResult.valid);
    var validTokenTypes = invalidResult.valid;
    errors = errors.concat(invalidResult.errors);
    errors = errors.concat(validateRegExpPattern(validTokenTypes));
    errors = errors.concat(findInvalidGroupType(validTokenTypes));
    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
    errors = errors.concat(findUnreachablePatterns(validTokenTypes));
    return errors;
}
function validateRegExpPattern(tokenTypes) {
    var errors = [];
    var withRegExpPatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currTokType) {
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(currTokType[PATTERN]);
    });
    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
    return errors;
}
function findMissingPatterns(tokenTypes) {
    var tokenTypesWithMissingPattern = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {
        return !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(currType, PATTERN);
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(tokenTypesWithMissingPattern, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- missing static 'PATTERN' property",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MISSING_PATTERN,
            tokenTypes: [currType]
        };
    });
    var valid = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.difference)(tokenTypes, tokenTypesWithMissingPattern);
    return { errors: errors, valid: valid };
}
function findInvalidPatterns(tokenTypes) {
    var tokenTypesWithInvalidPattern = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern) &&
            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(pattern) &&
            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(pattern, "exec") &&
            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern));
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(tokenTypesWithInvalidPattern, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' can only be a RegExp, a" +
                " Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.INVALID_PATTERN,
            tokenTypes: [currType]
        };
    });
    var valid = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.difference)(tokenTypes, tokenTypesWithInvalidPattern);
    return { errors: errors, valid: valid };
}
var end_of_input = /[^\\][\$]/;
function findEndOfInputAnchor(tokenTypes) {
    var EndAnchorFinder = /** @class */ (function (_super) {
        __extends(EndAnchorFinder, _super);
        function EndAnchorFinder() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
        }
        EndAnchorFinder.prototype.visitEndAnchor = function (node) {
            this.found = true;
        };
        return EndAnchorFinder;
    }(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor));
    var invalidRegex = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        try {
            var regexpAst = (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__.getRegExpAst)(pattern);
            var endAnchorVisitor = new EndAnchorFinder();
            endAnchorVisitor.visit(regexpAst);
            return endAnchorVisitor.found;
        }
        catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
            return end_of_input.test(pattern.source);
        }
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidRegex, function (currType) {
        return {
            message: "Unexpected RegExp Anchor Error:\n" +
                "\tToken Type: ->" +
                currType.name +
                "<- static 'PATTERN' cannot contain end of input anchor '$'\n" +
                "\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS" +
                "\tfor details.",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findEmptyMatchRegExps(tokenTypes) {
    var matchesEmptyString = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return pattern.test("");
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(matchesEmptyString, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' must not match an empty string",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
            tokenTypes: [currType]
        };
    });
    return errors;
}
var start_of_input = /[^\\[][\^]|^\^/;
function findStartOfInputAnchor(tokenTypes) {
    var StartAnchorFinder = /** @class */ (function (_super) {
        __extends(StartAnchorFinder, _super);
        function StartAnchorFinder() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.found = false;
            return _this;
        }
        StartAnchorFinder.prototype.visitStartAnchor = function (node) {
            this.found = true;
        };
        return StartAnchorFinder;
    }(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor));
    var invalidRegex = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        try {
            var regexpAst = (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_4__.getRegExpAst)(pattern);
            var startAnchorVisitor = new StartAnchorFinder();
            startAnchorVisitor.visit(regexpAst);
            return startAnchorVisitor.found;
        }
        catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
            return start_of_input.test(pattern.source);
        }
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidRegex, function (currType) {
        return {
            message: "Unexpected RegExp Anchor Error:\n" +
                "\tToken Type: ->" +
                currType.name +
                "<- static 'PATTERN' cannot contain start of input anchor '^'\n" +
                "\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS" +
                "\tfor details.",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findUnsupportedFlags(tokenTypes) {
    var invalidFlags = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (currType) {
        var pattern = currType[PATTERN];
        return (pattern instanceof RegExp && (pattern.multiline || pattern.global));
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidFlags, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
// This can only test for identical duplicate RegExps, not semantically equivalent ones.
function findDuplicatePatterns(tokenTypes) {
    var found = [];
    var identicalPatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(tokenTypes, function (outerType) {
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reduce)(tokenTypes, function (result, innerType) {
            if (outerType.PATTERN.source === innerType.PATTERN.source &&
                !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.contains)(found, innerType) &&
                innerType.PATTERN !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA) {
                // this avoids duplicates in the result, each Token Type may only appear in one "set"
                // in essence we are creating Equivalence classes on equality relation.
                found.push(innerType);
                result.push(innerType);
                return result;
            }
            return result;
        }, []);
    });
    identicalPatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.compact)(identicalPatterns);
    var duplicatePatterns = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(identicalPatterns, function (currIdenticalSet) {
        return currIdenticalSet.length > 1;
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(duplicatePatterns, function (setOfIdentical) {
        var tokenTypeNames = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(setOfIdentical, function (currType) {
            return currType.name;
        });
        var dupPatternSrc = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.first)(setOfIdentical).PATTERN;
        return {
            message: "The same RegExp pattern ->" + dupPatternSrc + "<-" +
                ("has been used in all of the following Token Types: " + tokenTypeNames.join(", ") + " <-"),
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
            tokenTypes: setOfIdentical
        };
    });
    return errors;
}
function findInvalidGroupType(tokenTypes) {
    var invalidTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (clazz) {
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(clazz, "GROUP")) {
            return false;
        }
        var group = clazz.GROUP;
        return group !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED && group !== _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA && !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(group);
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidTypes, function (currType) {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
            tokenTypes: [currType]
        };
    });
    return errors;
}
function findModesThatDoNotExist(tokenTypes, validModes) {
    var invalidModes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.filter)(tokenTypes, function (clazz) {
        return (clazz.PUSH_MODE !== undefined &&
            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.contains)(validModes, clazz.PUSH_MODE));
    });
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(invalidModes, function (tokType) {
        var msg = "Token Type: ->" + tokType.name + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + tokType.PUSH_MODE + "<-" +
            "which does not exist";
        return {
            message: msg,
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
            tokenTypes: [tokType]
        };
    });
    return errors;
}
function findUnreachablePatterns(tokenTypes) {
    var errors = [];
    var canBeTested = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reduce)(tokenTypes, function (result, tokType, idx) {
        var pattern = tokType.PATTERN;
        if (pattern === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA) {
            return result;
        }
        // a more comprehensive validation for all forms of regExps would require
        // deeper regExp analysis capabilities
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern)) {
            result.push({ str: pattern, idx: idx, tokenType: tokType });
        }
        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern) && noMetaChar(pattern)) {
            result.push({ str: pattern.source, idx: idx, tokenType: tokType });
        }
        return result;
    }, []);
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(tokenTypes, function (tokType, testIdx) {
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(canBeTested, function (_a) {
            var str = _a.str, idx = _a.idx, tokenType = _a.tokenType;
            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
                var msg = "Token: ->" + tokenType.name + "<- can never be matched.\n" +
                    ("Because it appears AFTER the Token Type ->" + tokType.name + "<-") +
                    "in the lexer's definition.\n" +
                    "See https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
                errors.push({
                    message: msg,
                    type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
                    tokenTypes: [tokType, tokenType]
                });
            }
        });
    });
    return errors;
}
function testTokenType(str, pattern) {
    /* istanbul ignore else */
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern)) {
        var regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
    }
    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(pattern)) {
        // maintain the API of custom patterns
        return pattern(str, 0, [], {});
    }
    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(pattern, "exec")) {
        // maintain the API of custom patterns
        return pattern.exec(str, 0, [], {});
    }
    else if (typeof pattern === "string") {
        return pattern === str;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function noMetaChar(regExp) {
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
    var metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{"
    ];
    return ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.find)(metaChars, function (char) { return regExp.source.indexOf(char) !== -1; }) ===
        undefined);
}
function addStartOfInput(pattern) {
    var flags = pattern.ignoreCase ? "i" : "";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp("^(?:" + pattern.source + ")", flags);
}
function addStickyFlag(pattern) {
    var flags = pattern.ignoreCase ? "iy" : "y";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp("" + pattern.source, flags);
}
function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    var errors = [];
    // some run time checks to help the end users.
    if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, DEFAULT_MODE)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" +
                DEFAULT_MODE +
                "> property in its definition\n",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
        });
    }
    if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, MODES)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" +
                MODES +
                "> property in its definition\n",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
        });
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, MODES) &&
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, DEFAULT_MODE) &&
        !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized with a " + DEFAULT_MODE + ": <" + lexerDefinition.defaultMode + ">" +
                "which does not exist\n",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
        });
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(lexerDefinition, MODES)) {
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(lexerDefinition.modes, function (currModeValue, currModeName) {
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(currModeValue, function (currTokType, currIdx) {
                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(currTokType)) {
                    errors.push({
                        message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" +
                            ("<" + currModeName + "> at index: <" + currIdx + ">\n"),
                        type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
                    });
                }
            });
        });
    }
    return errors;
}
function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    var warnings = [];
    var hasAnyLineBreak = false;
    var allTokenTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.compact)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.flatten)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.mapValues)(lexerDefinition.modes, function (tokTypes) { return tokTypes; })));
    var concreteTokenTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.reject)(allTokenTypes, function (currType) { return currType[PATTERN] === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA; });
    var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
    if (trackLines) {
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(concreteTokenTypes, function (tokType) {
            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
            if (currIssue !== false) {
                var message = buildLineBreakIssueMessage(tokType, currIssue);
                var warningDescriptor = {
                    message: message,
                    type: currIssue.issue,
                    tokenType: tokType
                };
                warnings.push(warningDescriptor);
            }
            else {
                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.
                if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(tokType, "LINE_BREAKS")) {
                    if (tokType.LINE_BREAKS === true) {
                        hasAnyLineBreak = true;
                    }
                }
                else {
                    if ((0,_reg_exp__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                        hasAnyLineBreak = true;
                    }
                }
            }
        });
    }
    if (trackLines && !hasAnyLineBreak) {
        warnings.push({
            message: "Warning: No LINE_BREAKS Found.\n" +
                "\tThis Lexer has been defined to track line and column information,\n" +
                "\tBut none of the Token Types can be identified as matching a line terminator.\n" +
                "\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n" +
                "\tfor details.",
            type: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
        });
    }
    return warnings;
}
function cloneEmptyGroups(emptyGroups) {
    var clonedResult = {};
    var groupKeys = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.keys)(emptyGroups);
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.forEach)(groupKeys, function (currKey) {
        var currGroupValue = emptyGroups[currKey];
        /* istanbul ignore else */
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isArray)(currGroupValue)) {
            clonedResult[currKey] = [];
        }
        else {
            throw Error("non exhaustive match");
        }
    });
    return clonedResult;
}
// TODO: refactor to avoid duplication
function isCustomPattern(tokenType) {
    var pattern = tokenType.PATTERN;
    /* istanbul ignore else */
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(pattern)) {
        return false;
    }
    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isFunction)(pattern)) {
        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
        return true;
    }
    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(pattern, "exec")) {
        // ICustomPattern
        return true;
    }
    else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern)) {
        return false;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function isShortPattern(pattern) {
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
    }
    else {
        return false;
    }
}
/**
 * Faster than using a RegExp for default newline detection during lexing.
 */
var LineTerminatorOptimizedTester = {
    // implements /\n|\r\n?/g.test
    test: function (text) {
        var len = text.length;
        for (var i = this.lastIndex; i < len; i++) {
            var c = text.charCodeAt(i);
            if (c === 10) {
                this.lastIndex = i + 1;
                return true;
            }
            else if (c === 13) {
                if (text.charCodeAt(i + 1) === 10) {
                    this.lastIndex = i + 2;
                }
                else {
                    this.lastIndex = i + 1;
                }
                return true;
            }
        }
        return false;
    },
    lastIndex: 0
};
function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.has)(tokType, "LINE_BREAKS")) {
        // if the user explicitly declared the line_breaks option we will respect their choice
        // and assume it is correct.
        return false;
    }
    else {
        /* istanbul ignore else */
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isRegExp)(tokType.PATTERN)) {
            try {
                (0,_reg_exp__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            }
            catch (e) {
                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */
                return {
                    issue: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
                    errMsg: e.message
                };
            }
            return false;
        }
        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(tokType.PATTERN)) {
            // string literal patterns can always be analyzed to detect line terminator usage
            return false;
        }
        else if (isCustomPattern(tokType)) {
            // custom token types
            return { issue: _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
        }
        else {
            throw Error("non exhaustive match");
        }
    }
}
function buildLineBreakIssueMessage(tokType, details) {
    /* istanbul ignore else */
    if (details.issue === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return ("Warning: unable to identify line terminator usage in pattern.\n" +
            ("\tThe problem is in the <" + tokType.name + "> Token Type\n") +
            ("\t Root cause: " + details.errMsg + ".\n") +
            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR");
    }
    else if (details.issue === _lexer_public__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return ("Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" +
            ("\tThe problem is in the <" + tokType.name + "> Token Type\n") +
            "\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK");
    }
    else {
        throw Error("non exhaustive match");
    }
}
function getCharCodes(charsOrCodes) {
    var charCodes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.map)(charsOrCodes, function (numOrString) {
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isString)(numOrString) && numOrString.length > 0) {
            return numOrString.charCodeAt(0);
        }
        else {
            return numOrString;
        }
    });
    return charCodes;
}
function addToMapOfArrays(map, key, value) {
    if (map[key] === undefined) {
        map[key] = [value];
    }
    else {
        map[key].push(value);
    }
}
var minOptimizationVal = 256;
/**
 * We ae mapping charCode above ASCI (256) into buckets each in the size of 256.
 * This is because ASCI are the most common start chars so each one of those will get its own
 * possible token configs vector.
 *
 * Tokens starting with charCodes "above" ASCI are uncommon, so we can "afford"
 * to place these into buckets of possible token configs, What we gain from
 * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'
 * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).
 * Our 'charCodeToPatternIdxToConfig' max size will now be:
 * 256 + (2^16 / 2^8) - 1 === 511
 *
 * note the hack for fast division integer part extraction
 * See: https://stackoverflow.com/a/4228528
 */
function charCodeToOptimizedIndex(charCode) {
    return charCode < minOptimizationVal
        ? charCode
        : charCodeToOptimizedIdxMap[charCode];
}
/**
 * This is a compromise between cold start / hot running performance
 * Creating this array takes ~3ms on a modern machine,
 * But if we perform the computation at runtime as needed the CSS Lexer benchmark
 * performance degrades by ~10%
 *
 * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.
 */
var charCodeToOptimizedIdxMap = [];
function initCharCodeToOptimizedIndexMap() {
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (var i = 0; i < 65536; i++) {
            /* tslint:disable */
            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
            /* tslint:enable */
        }
    }
}
//# sourceMappingURL=lexer.js.map

/***/ }),
/* 24 */
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;;(function(root, factory) {
    // istanbul ignore next
    if (true) {
        // istanbul ignore next
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    } else {}
})(
    typeof self !== "undefined"
        ? // istanbul ignore next
          self
        : this,
    function() {
        // references
        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983
        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern
        function RegExpParser() {}

        RegExpParser.prototype.saveState = function() {
            return {
                idx: this.idx,
                input: this.input,
                groupIdx: this.groupIdx
            }
        }

        RegExpParser.prototype.restoreState = function(newState) {
            this.idx = newState.idx
            this.input = newState.input
            this.groupIdx = newState.groupIdx
        }

        RegExpParser.prototype.pattern = function(input) {
            // parser state
            this.idx = 0
            this.input = input
            this.groupIdx = 0

            this.consumeChar("/")
            var value = this.disjunction()
            this.consumeChar("/")

            var flags = {
                type: "Flags",
                global: false,
                ignoreCase: false,
                multiLine: false,
                unicode: false,
                sticky: false
            }

            while (this.isRegExpFlag()) {
                switch (this.popChar()) {
                    case "g":
                        addFlag(flags, "global")
                        break
                    case "i":
                        addFlag(flags, "ignoreCase")
                        break
                    case "m":
                        addFlag(flags, "multiLine")
                        break
                    case "u":
                        addFlag(flags, "unicode")
                        break
                    case "y":
                        addFlag(flags, "sticky")
                        break
                }
            }

            if (this.idx !== this.input.length) {
                throw Error(
                    "Redundant input: " + this.input.substring(this.idx)
                )
            }
            return { type: "Pattern", flags: flags, value: value }
        }

        RegExpParser.prototype.disjunction = function() {
            var alts = []
            alts.push(this.alternative())

            while (this.peekChar() === "|") {
                this.consumeChar("|")
                alts.push(this.alternative())
            }

            return { type: "Disjunction", value: alts }
        }

        RegExpParser.prototype.alternative = function() {
            var terms = []

            while (this.isTerm()) {
                terms.push(this.term())
            }

            return { type: "Alternative", value: terms }
        }

        RegExpParser.prototype.term = function() {
            if (this.isAssertion()) {
                return this.assertion()
            } else {
                return this.atom()
            }
        }

        RegExpParser.prototype.assertion = function() {
            switch (this.popChar()) {
                case "^":
                    return { type: "StartAnchor" }
                case "$":
                    return { type: "EndAnchor" }
                // '\b' or '\B'
                case "\\":
                    switch (this.popChar()) {
                        case "b":
                            return { type: "WordBoundary" }
                        case "B":
                            return { type: "NonWordBoundary" }
                    }
                    // istanbul ignore next
                    throw Error("Invalid Assertion Escape")
                // '(?=' or '(?!'
                case "(":
                    this.consumeChar("?")

                    var type
                    switch (this.popChar()) {
                        case "=":
                            type = "Lookahead"
                            break
                        case "!":
                            type = "NegativeLookahead"
                            break
                    }
                    ASSERT_EXISTS(type)

                    var disjunction = this.disjunction()

                    this.consumeChar(")")

                    return { type: type, value: disjunction }
            }
            // istanbul ignore next
            ASSERT_NEVER_REACH_HERE()
        }

        RegExpParser.prototype.quantifier = function(isBacktracking) {
            var range
            switch (this.popChar()) {
                case "*":
                    range = {
                        atLeast: 0,
                        atMost: Infinity
                    }
                    break
                case "+":
                    range = {
                        atLeast: 1,
                        atMost: Infinity
                    }
                    break
                case "?":
                    range = {
                        atLeast: 0,
                        atMost: 1
                    }
                    break
                case "{":
                    var atLeast = this.integerIncludingZero()
                    switch (this.popChar()) {
                        case "}":
                            range = {
                                atLeast: atLeast,
                                atMost: atLeast
                            }
                            break
                        case ",":
                            var atMost
                            if (this.isDigit()) {
                                atMost = this.integerIncludingZero()
                                range = {
                                    atLeast: atLeast,
                                    atMost: atMost
                                }
                            } else {
                                range = {
                                    atLeast: atLeast,
                                    atMost: Infinity
                                }
                            }
                            this.consumeChar("}")
                            break
                    }
                    // throwing exceptions from "ASSERT_EXISTS" during backtracking
                    // causes severe performance degradations
                    if (isBacktracking === true && range === undefined) {
                        return undefined
                    }
                    ASSERT_EXISTS(range)
                    break
            }

            // throwing exceptions from "ASSERT_EXISTS" during backtracking
            // causes severe performance degradations
            if (isBacktracking === true && range === undefined) {
                return undefined
            }

            ASSERT_EXISTS(range)

            if (this.peekChar(0) === "?") {
                this.consumeChar("?")
                range.greedy = false
            } else {
                range.greedy = true
            }

            range.type = "Quantifier"
            return range
        }

        RegExpParser.prototype.atom = function() {
            var atom
            switch (this.peekChar()) {
                case ".":
                    atom = this.dotAll()
                    break
                case "\\":
                    atom = this.atomEscape()
                    break
                case "[":
                    atom = this.characterClass()
                    break
                case "(":
                    atom = this.group()
                    break
            }

            if (atom === undefined && this.isPatternCharacter()) {
                atom = this.patternCharacter()
            }

            ASSERT_EXISTS(atom)

            if (this.isQuantifier()) {
                atom.quantifier = this.quantifier()
            }

            return atom
        }

        RegExpParser.prototype.dotAll = function() {
            this.consumeChar(".")
            return {
                type: "Set",
                complement: true,
                value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
            }
        }

        RegExpParser.prototype.atomEscape = function() {
            this.consumeChar("\\")

            switch (this.peekChar()) {
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    return this.decimalEscapeAtom()
                case "d":
                case "D":
                case "s":
                case "S":
                case "w":
                case "W":
                    return this.characterClassEscape()
                case "f":
                case "n":
                case "r":
                case "t":
                case "v":
                    return this.controlEscapeAtom()
                case "c":
                    return this.controlLetterEscapeAtom()
                case "0":
                    return this.nulCharacterAtom()
                case "x":
                    return this.hexEscapeSequenceAtom()
                case "u":
                    return this.regExpUnicodeEscapeSequenceAtom()
                default:
                    return this.identityEscapeAtom()
            }
        }

        RegExpParser.prototype.decimalEscapeAtom = function() {
            var value = this.positiveInteger()

            return { type: "GroupBackReference", value: value }
        }

        RegExpParser.prototype.characterClassEscape = function() {
            var set
            var complement = false
            switch (this.popChar()) {
                case "d":
                    set = digitsCharCodes
                    break
                case "D":
                    set = digitsCharCodes
                    complement = true
                    break
                case "s":
                    set = whitespaceCodes
                    break
                case "S":
                    set = whitespaceCodes
                    complement = true
                    break
                case "w":
                    set = wordCharCodes
                    break
                case "W":
                    set = wordCharCodes
                    complement = true
                    break
            }

            ASSERT_EXISTS(set)

            return { type: "Set", value: set, complement: complement }
        }

        RegExpParser.prototype.controlEscapeAtom = function() {
            var escapeCode
            switch (this.popChar()) {
                case "f":
                    escapeCode = cc("\f")
                    break
                case "n":
                    escapeCode = cc("\n")
                    break
                case "r":
                    escapeCode = cc("\r")
                    break
                case "t":
                    escapeCode = cc("\t")
                    break
                case "v":
                    escapeCode = cc("\v")
                    break
            }
            ASSERT_EXISTS(escapeCode)

            return { type: "Character", value: escapeCode }
        }

        RegExpParser.prototype.controlLetterEscapeAtom = function() {
            this.consumeChar("c")
            var letter = this.popChar()
            if (/[a-zA-Z]/.test(letter) === false) {
                throw Error("Invalid ")
            }

            var letterCode = letter.toUpperCase().charCodeAt(0) - 64
            return { type: "Character", value: letterCode }
        }

        RegExpParser.prototype.nulCharacterAtom = function() {
            // TODO implement '[lookahead ∉ DecimalDigit]'
            // TODO: for the deprecated octal escape sequence
            this.consumeChar("0")
            return { type: "Character", value: cc("\0") }
        }

        RegExpParser.prototype.hexEscapeSequenceAtom = function() {
            this.consumeChar("x")
            return this.parseHexDigits(2)
        }

        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
            this.consumeChar("u")
            return this.parseHexDigits(4)
        }

        RegExpParser.prototype.identityEscapeAtom = function() {
            // TODO: implement "SourceCharacter but not UnicodeIDContinue"
            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments
            var escapedChar = this.popChar()
            return { type: "Character", value: cc(escapedChar) }
        }

        RegExpParser.prototype.classPatternCharacterAtom = function() {
            switch (this.peekChar()) {
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                // istanbul ignore next
                case "\\":
                // istanbul ignore next
                case "]":
                    throw Error("TBD")
                default:
                    var nextChar = this.popChar()
                    return { type: "Character", value: cc(nextChar) }
            }
        }

        RegExpParser.prototype.characterClass = function() {
            var set = []
            var complement = false
            this.consumeChar("[")
            if (this.peekChar(0) === "^") {
                this.consumeChar("^")
                complement = true
            }

            while (this.isClassAtom()) {
                var from = this.classAtom()
                var isFromSingleChar = from.type === "Character"
                if (isFromSingleChar && this.isRangeDash()) {
                    this.consumeChar("-")
                    var to = this.classAtom()
                    var isToSingleChar = to.type === "Character"

                    // a range can only be used when both sides are single characters
                    if (isToSingleChar) {
                        if (to.value < from.value) {
                            throw Error("Range out of order in character class")
                        }
                        set.push({ from: from.value, to: to.value })
                    } else {
                        // literal dash
                        insertToSet(from.value, set)
                        set.push(cc("-"))
                        insertToSet(to.value, set)
                    }
                } else {
                    insertToSet(from.value, set)
                }
            }

            this.consumeChar("]")

            return { type: "Set", complement: complement, value: set }
        }

        RegExpParser.prototype.classAtom = function() {
            switch (this.peekChar()) {
                // istanbul ignore next
                case "]":
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                    throw Error("TBD")
                case "\\":
                    return this.classEscape()
                default:
                    return this.classPatternCharacterAtom()
            }
        }

        RegExpParser.prototype.classEscape = function() {
            this.consumeChar("\\")
            switch (this.peekChar()) {
                // Matches a backspace.
                // (Not to be confused with \b word boundary outside characterClass)
                case "b":
                    this.consumeChar("b")
                    return { type: "Character", value: cc("\u0008") }
                case "d":
                case "D":
                case "s":
                case "S":
                case "w":
                case "W":
                    return this.characterClassEscape()
                case "f":
                case "n":
                case "r":
                case "t":
                case "v":
                    return this.controlEscapeAtom()
                case "c":
                    return this.controlLetterEscapeAtom()
                case "0":
                    return this.nulCharacterAtom()
                case "x":
                    return this.hexEscapeSequenceAtom()
                case "u":
                    return this.regExpUnicodeEscapeSequenceAtom()
                default:
                    return this.identityEscapeAtom()
            }
        }

        RegExpParser.prototype.group = function() {
            var capturing = true
            this.consumeChar("(")
            switch (this.peekChar(0)) {
                case "?":
                    this.consumeChar("?")
                    this.consumeChar(":")
                    capturing = false
                    break
                default:
                    this.groupIdx++
                    break
            }
            var value = this.disjunction()
            this.consumeChar(")")

            var groupAst = {
                type: "Group",
                capturing: capturing,
                value: value
            }

            if (capturing) {
                groupAst.idx = this.groupIdx
            }

            return groupAst
        }

        RegExpParser.prototype.positiveInteger = function() {
            var number = this.popChar()

            // istanbul ignore next - can't ever get here due to previous lookahead checks
            // still implementing this error checking in case this ever changes.
            if (decimalPatternNoZero.test(number) === false) {
                throw Error("Expecting a positive integer")
            }

            while (decimalPattern.test(this.peekChar(0))) {
                number += this.popChar()
            }

            return parseInt(number, 10)
        }

        RegExpParser.prototype.integerIncludingZero = function() {
            var number = this.popChar()
            if (decimalPattern.test(number) === false) {
                throw Error("Expecting an integer")
            }

            while (decimalPattern.test(this.peekChar(0))) {
                number += this.popChar()
            }

            return parseInt(number, 10)
        }

        RegExpParser.prototype.patternCharacter = function() {
            var nextChar = this.popChar()
            switch (nextChar) {
                // istanbul ignore next
                case "\n":
                // istanbul ignore next
                case "\r":
                // istanbul ignore next
                case "\u2028":
                // istanbul ignore next
                case "\u2029":
                // istanbul ignore next
                case "^":
                // istanbul ignore next
                case "$":
                // istanbul ignore next
                case "\\":
                // istanbul ignore next
                case ".":
                // istanbul ignore next
                case "*":
                // istanbul ignore next
                case "+":
                // istanbul ignore next
                case "?":
                // istanbul ignore next
                case "(":
                // istanbul ignore next
                case ")":
                // istanbul ignore next
                case "[":
                // istanbul ignore next
                case "|":
                    // istanbul ignore next
                    throw Error("TBD")
                default:
                    return { type: "Character", value: cc(nextChar) }
            }
        }
        RegExpParser.prototype.isRegExpFlag = function() {
            switch (this.peekChar(0)) {
                case "g":
                case "i":
                case "m":
                case "u":
                case "y":
                    return true
                default:
                    return false
            }
        }

        RegExpParser.prototype.isRangeDash = function() {
            return this.peekChar() === "-" && this.isClassAtom(1)
        }

        RegExpParser.prototype.isDigit = function() {
            return decimalPattern.test(this.peekChar(0))
        }

        RegExpParser.prototype.isClassAtom = function(howMuch) {
            if (howMuch === undefined) {
                howMuch = 0
            }

            switch (this.peekChar(howMuch)) {
                case "]":
                case "\n":
                case "\r":
                case "\u2028":
                case "\u2029":
                    return false
                default:
                    return true
            }
        }

        RegExpParser.prototype.isTerm = function() {
            return this.isAtom() || this.isAssertion()
        }

        RegExpParser.prototype.isAtom = function() {
            if (this.isPatternCharacter()) {
                return true
            }

            switch (this.peekChar(0)) {
                case ".":
                case "\\": // atomEscape
                case "[": // characterClass
                // TODO: isAtom must be called before isAssertion - disambiguate
                case "(": // group
                    return true
                default:
                    return false
            }
        }

        RegExpParser.prototype.isAssertion = function() {
            switch (this.peekChar(0)) {
                case "^":
                case "$":
                    return true
                // '\b' or '\B'
                case "\\":
                    switch (this.peekChar(1)) {
                        case "b":
                        case "B":
                            return true
                        default:
                            return false
                    }
                // '(?=' or '(?!'
                case "(":
                    return (
                        this.peekChar(1) === "?" &&
                        (this.peekChar(2) === "=" || this.peekChar(2) === "!")
                    )
                default:
                    return false
            }
        }

        RegExpParser.prototype.isQuantifier = function() {
            var prevState = this.saveState()
            try {
                return this.quantifier(true) !== undefined
            } catch (e) {
                return false
            } finally {
                this.restoreState(prevState)
            }
        }

        RegExpParser.prototype.isPatternCharacter = function() {
            switch (this.peekChar()) {
                case "^":
                case "$":
                case "\\":
                case ".":
                case "*":
                case "+":
                case "?":
                case "(":
                case ")":
                case "[":
                case "|":
                case "/":
                case "\n":
                case "\r":
                case "\u2028":
                case "\u2029":
                    return false
                default:
                    return true
            }
        }

        RegExpParser.prototype.parseHexDigits = function(howMany) {
            var hexString = ""
            for (var i = 0; i < howMany; i++) {
                var hexChar = this.popChar()
                if (hexDigitPattern.test(hexChar) === false) {
                    throw Error("Expecting a HexDecimal digits")
                }
                hexString += hexChar
            }
            var charCode = parseInt(hexString, 16)
            return { type: "Character", value: charCode }
        }

        RegExpParser.prototype.peekChar = function(howMuch) {
            if (howMuch === undefined) {
                howMuch = 0
            }
            return this.input[this.idx + howMuch]
        }

        RegExpParser.prototype.popChar = function() {
            var nextChar = this.peekChar(0)
            this.consumeChar()
            return nextChar
        }

        RegExpParser.prototype.consumeChar = function(char) {
            if (char !== undefined && this.input[this.idx] !== char) {
                throw Error(
                    "Expected: '" +
                        char +
                        "' but found: '" +
                        this.input[this.idx] +
                        "' at offset: " +
                        this.idx
                )
            }

            if (this.idx >= this.input.length) {
                throw Error("Unexpected end of input")
            }
            this.idx++
        }

        // consts and utilities
        var hexDigitPattern = /[0-9a-fA-F]/
        var decimalPattern = /[0-9]/
        var decimalPatternNoZero = /[1-9]/

        function cc(char) {
            return char.charCodeAt(0)
        }

        function insertToSet(item, set) {
            if (item.length !== undefined) {
                item.forEach(function(subItem) {
                    set.push(subItem)
                })
            } else {
                set.push(item)
            }
        }

        function addFlag(flagObj, flagKey) {
            if (flagObj[flagKey] === true) {
                throw "duplicate flag " + flagKey
            }

            flagObj[flagKey] = true
        }

        function ASSERT_EXISTS(obj) {
            // istanbul ignore next
            if (obj === undefined) {
                throw Error("Internal Error - Should never get here!")
            }
        }

        // istanbul ignore next
        function ASSERT_NEVER_REACH_HERE() {
            throw Error("Internal Error - Should never get here!")
        }

        var i
        var digitsCharCodes = []
        for (i = cc("0"); i <= cc("9"); i++) {
            digitsCharCodes.push(i)
        }

        var wordCharCodes = [cc("_")].concat(digitsCharCodes)
        for (i = cc("a"); i <= cc("z"); i++) {
            wordCharCodes.push(i)
        }

        for (i = cc("A"); i <= cc("Z"); i++) {
            wordCharCodes.push(i)
        }

        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes
        var whitespaceCodes = [
            cc(" "),
            cc("\f"),
            cc("\n"),
            cc("\r"),
            cc("\t"),
            cc("\v"),
            cc("\t"),
            cc("\u00a0"),
            cc("\u1680"),
            cc("\u2000"),
            cc("\u2001"),
            cc("\u2002"),
            cc("\u2003"),
            cc("\u2004"),
            cc("\u2005"),
            cc("\u2006"),
            cc("\u2007"),
            cc("\u2008"),
            cc("\u2009"),
            cc("\u200a"),
            cc("\u2028"),
            cc("\u2029"),
            cc("\u202f"),
            cc("\u205f"),
            cc("\u3000"),
            cc("\ufeff")
        ]

        function BaseRegExpVisitor() {}

        BaseRegExpVisitor.prototype.visitChildren = function(node) {
            for (var key in node) {
                var child = node[key]
                /* istanbul ignore else */
                if (node.hasOwnProperty(key)) {
                    if (child.type !== undefined) {
                        this.visit(child)
                    } else if (Array.isArray(child)) {
                        child.forEach(function(subChild) {
                            this.visit(subChild)
                        }, this)
                    }
                }
            }
        }

        BaseRegExpVisitor.prototype.visit = function(node) {
            switch (node.type) {
                case "Pattern":
                    this.visitPattern(node)
                    break
                case "Flags":
                    this.visitFlags(node)
                    break
                case "Disjunction":
                    this.visitDisjunction(node)
                    break
                case "Alternative":
                    this.visitAlternative(node)
                    break
                case "StartAnchor":
                    this.visitStartAnchor(node)
                    break
                case "EndAnchor":
                    this.visitEndAnchor(node)
                    break
                case "WordBoundary":
                    this.visitWordBoundary(node)
                    break
                case "NonWordBoundary":
                    this.visitNonWordBoundary(node)
                    break
                case "Lookahead":
                    this.visitLookahead(node)
                    break
                case "NegativeLookahead":
                    this.visitNegativeLookahead(node)
                    break
                case "Character":
                    this.visitCharacter(node)
                    break
                case "Set":
                    this.visitSet(node)
                    break
                case "Group":
                    this.visitGroup(node)
                    break
                case "GroupBackReference":
                    this.visitGroupBackReference(node)
                    break
                case "Quantifier":
                    this.visitQuantifier(node)
                    break
            }

            this.visitChildren(node)
        }

        BaseRegExpVisitor.prototype.visitPattern = function(node) {}

        BaseRegExpVisitor.prototype.visitFlags = function(node) {}

        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}

        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}

        // Assertion
        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}

        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}

        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}

        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}

        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}

        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}

        // atoms
        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}

        BaseRegExpVisitor.prototype.visitSet = function(node) {}

        BaseRegExpVisitor.prototype.visitGroup = function(node) {}

        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}

        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}

        return {
            RegExpParser: RegExpParser,
            BaseRegExpVisitor: BaseRegExpVisitor,
            VERSION: "0.4.0"
        }
    }
)


/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canMatchCharCode: () => (/* binding */ canMatchCharCode),
/* harmony export */   failedOptimizationPrefixMsg: () => (/* binding */ failedOptimizationPrefixMsg),
/* harmony export */   firstCharOptimizedIndices: () => (/* binding */ firstCharOptimizedIndices),
/* harmony export */   getOptimizedStartCodesIndices: () => (/* binding */ getOptimizedStartCodesIndices)
/* harmony export */ });
/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _lexer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var complementErrorMessage = "Complement Sets are not supported for first char optimization";
var failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
    if (ensureOptimizations === void 0) { ensureOptimizations = false; }
    try {
        var ast = (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__.getRegExpAst)(regExp);
        var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
    }
    catch (e) {
        /* istanbul ignore next */
        // Testing this relies on the regexp-to-ast library having a bug... */
        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc
        if (e.message === complementErrorMessage) {
            if (ensureOptimizations) {
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_WARNING)("" + failedOptimizationPrefixMsg +
                    ("\tUnable to optimize: < " + regExp.toString() + " >\n") +
                    "\tComplement Sets cannot be automatically optimized.\n" +
                    "\tThis will disable the lexer's first char optimizations.\n" +
                    "\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
            }
        }
        else {
            var msgSuffix = "";
            if (ensureOptimizations) {
                msgSuffix =
                    "\n\tThis will disable the lexer's first char optimizations.\n" +
                        "\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
            }
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_ERROR)(failedOptimizationPrefixMsg + "\n" +
                ("\tFailed parsing: < " + regExp.toString() + " >\n") +
                ("\tUsing the regexp-to-ast library version: " + regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.VERSION + "\n") +
                "\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues" +
                msgSuffix);
        }
    }
    return [];
}
function firstCharOptimizedIndices(ast, result, ignoreCase) {
    switch (ast.type) {
        case "Disjunction":
            for (var i = 0; i < ast.value.length; i++) {
                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
            }
            break;
        case "Alternative":
            var terms = ast.value;
            for (var i = 0; i < terms.length; i++) {
                var term = terms[i];
                // skip terms that cannot effect the first char results
                switch (term.type) {
                    case "EndAnchor":
                    // A group back reference cannot affect potential starting char.
                    // because if a back reference is the first production than automatically
                    // the group being referenced has had to come BEFORE so its codes have already been added
                    case "GroupBackReference":
                    // assertions do not affect potential starting codes
                    case "Lookahead":
                    case "NegativeLookahead":
                    case "StartAnchor":
                    case "WordBoundary":
                    case "NonWordBoundary":
                        continue;
                }
                var atom = term;
                switch (atom.type) {
                    case "Character":
                        addOptimizedIdxToResult(atom.value, result, ignoreCase);
                        break;
                    case "Set":
                        if (atom.complement === true) {
                            throw Error(complementErrorMessage);
                        }
                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(atom.value, function (code) {
                            if (typeof code === "number") {
                                addOptimizedIdxToResult(code, result, ignoreCase);
                            }
                            else {
                                // range
                                var range = code;
                                // cannot optimize when ignoreCase is
                                if (ignoreCase === true) {
                                    for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    }
                                }
                                // Optimization (2 orders of magnitude less work for very large ranges)
                                else {
                                    // handle unoptimized values
                                    for (var rangeCode = range.from; rangeCode <= range.to &&
                                        rangeCode < _lexer__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal; rangeCode++) {
                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    }
                                    // Less common charCode where we optimize for faster init time, by using larger "buckets"
                                    if (range.to >= _lexer__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal) {
                                        var minUnOptVal = range.from >= _lexer__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal
                                            ? range.from
                                            : _lexer__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal;
                                        var maxUnOptVal = range.to;
                                        var minOptIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(minUnOptVal);
                                        var maxOptIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(maxUnOptVal);
                                        for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                                            result[currOptIdx] = currOptIdx;
                                        }
                                    }
                                }
                            }
                        });
                        break;
                    case "Group":
                        firstCharOptimizedIndices(atom.value, result, ignoreCase);
                        break;
                    /* istanbul ignore next */
                    default:
                        throw Error("Non Exhaustive Match");
                }
                // reached a mandatory production, no more **start** codes can be found on this alternative
                var isOptionalQuantifier = atom.quantifier !== undefined &&
                    atom.quantifier.atLeast === 0;
                if (
                // A group may be optional due to empty contents /(?:)/
                // or if everything inside it is optional /((a)?)/
                (atom.type === "Group" &&
                    isWholeOptional(atom) === false) ||
                    // If this term is not a group it may only be optional if it has an optional quantifier
                    (atom.type !== "Group" && isOptionalQuantifier === false)) {
                    break;
                }
            }
            break;
        /* istanbul ignore next */
        default:
            throw Error("non exhaustive match!");
    }
    // console.log(Object.keys(result).length)
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.values)(result);
}
function addOptimizedIdxToResult(code, result, ignoreCase) {
    var optimizedCharIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(code);
    result[optimizedCharIdx] = optimizedCharIdx;
    if (ignoreCase === true) {
        handleIgnoreCase(code, result);
    }
}
function handleIgnoreCase(code, result) {
    var char = String.fromCharCode(code);
    var upperChar = char.toUpperCase();
    /* istanbul ignore else */
    if (upperChar !== char) {
        var optimizedCharIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
    }
    else {
        var lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
            var optimizedCharIdx = (0,_lexer__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
            result[optimizedCharIdx] = optimizedCharIdx;
        }
    }
}
function findCode(setNode, targetCharCodes) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.find)(setNode.value, function (codeOrRange) {
        if (typeof codeOrRange === "number") {
            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(targetCharCodes, codeOrRange);
        }
        else {
            // range
            var range_1 = codeOrRange;
            return ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.find)(targetCharCodes, function (targetCode) {
                return range_1.from <= targetCode && targetCode <= range_1.to;
            }) !== undefined);
        }
    });
}
function isWholeOptional(ast) {
    if (ast.quantifier && ast.quantifier.atLeast === 0) {
        return true;
    }
    if (!ast.value) {
        return false;
    }
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isArray)(ast.value)
        ? (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.every)(ast.value, isWholeOptional)
        : isWholeOptional(ast.value);
}
var CharCodeFinder = /** @class */ (function (_super) {
    __extends(CharCodeFinder, _super);
    function CharCodeFinder(targetCharCodes) {
        var _this = _super.call(this) || this;
        _this.targetCharCodes = targetCharCodes;
        _this.found = false;
        return _this;
    }
    CharCodeFinder.prototype.visitChildren = function (node) {
        // No need to keep looking...
        if (this.found === true) {
            return;
        }
        // switch lookaheads as they do not actually consume any characters thus
        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.
        switch (node.type) {
            case "Lookahead":
                this.visitLookahead(node);
                return;
            case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                return;
        }
        _super.prototype.visitChildren.call(this, node);
    };
    CharCodeFinder.prototype.visitCharacter = function (node) {
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(this.targetCharCodes, node.value)) {
            this.found = true;
        }
    };
    CharCodeFinder.prototype.visitSet = function (node) {
        if (node.complement) {
            if (findCode(node, this.targetCharCodes) === undefined) {
                this.found = true;
            }
        }
        else {
            if (findCode(node, this.targetCharCodes) !== undefined) {
                this.found = true;
            }
        }
    };
    return CharCodeFinder;
}(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor));
function canMatchCharCode(charCodes, pattern) {
    if (pattern instanceof RegExp) {
        var ast = (0,_reg_exp_parser__WEBPACK_IMPORTED_MODULE_2__.getRegExpAst)(pattern);
        var charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
    }
    else {
        return ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.find)(pattern, function (char) {
            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(charCodes, char.charCodeAt(0));
        }) !== undefined);
    }
}
//# sourceMappingURL=reg_exp.js.map

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearRegExpParserCache: () => (/* binding */ clearRegExpParserCache),
/* harmony export */   getRegExpAst: () => (/* binding */ getRegExpAst)
/* harmony export */ });
/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var regexp_to_ast__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__);

var regExpAstCache = {};
var regExpParser = new regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.RegExpParser();
function getRegExpAst(regExp) {
    var regExpStr = regExp.toString();
    if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
    }
    else {
        var regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
    }
}
function clearRegExpParserCache() {
    regExpAstCache = {};
}
//# sourceMappingURL=reg_exp_parser.js.map

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assignCategoriesMapProp: () => (/* binding */ assignCategoriesMapProp),
/* harmony export */   assignCategoriesTokensProp: () => (/* binding */ assignCategoriesTokensProp),
/* harmony export */   assignTokenDefaultProps: () => (/* binding */ assignTokenDefaultProps),
/* harmony export */   augmentTokenTypes: () => (/* binding */ augmentTokenTypes),
/* harmony export */   expandCategories: () => (/* binding */ expandCategories),
/* harmony export */   hasCategoriesProperty: () => (/* binding */ hasCategoriesProperty),
/* harmony export */   hasExtendingTokensTypesMapProperty: () => (/* binding */ hasExtendingTokensTypesMapProperty),
/* harmony export */   hasExtendingTokensTypesProperty: () => (/* binding */ hasExtendingTokensTypesProperty),
/* harmony export */   hasShortKeyProperty: () => (/* binding */ hasShortKeyProperty),
/* harmony export */   isTokenType: () => (/* binding */ isTokenType),
/* harmony export */   singleAssignCategoriesToksMap: () => (/* binding */ singleAssignCategoriesToksMap),
/* harmony export */   tokenIdxToClass: () => (/* binding */ tokenIdxToClass),
/* harmony export */   tokenShortNameIdx: () => (/* binding */ tokenShortNameIdx),
/* harmony export */   tokenStructuredMatcher: () => (/* binding */ tokenStructuredMatcher),
/* harmony export */   tokenStructuredMatcherNoCategories: () => (/* binding */ tokenStructuredMatcherNoCategories)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);

function tokenStructuredMatcher(tokInstance, tokConstructor) {
    var instanceType = tokInstance.tokenTypeIdx;
    if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
    }
    else {
        return (tokConstructor.isParent === true &&
            tokConstructor.categoryMatchesMap[instanceType] === true);
    }
}
// Optimized tokenMatcher in case our grammar does not use token categories
// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead
function tokenStructuredMatcherNoCategories(token, tokType) {
    return token.tokenTypeIdx === tokType.tokenTypeIdx;
}
var tokenShortNameIdx = 1;
var tokenIdxToClass = {};
function augmentTokenTypes(tokenTypes) {
    // collect the parent Token Types as well.
    var tokenTypesAndParents = expandCategories(tokenTypes);
    // add required tokenType and categoryMatches properties
    assignTokenDefaultProps(tokenTypesAndParents);
    // fill up the categoryMatches
    assignCategoriesMapProp(tokenTypesAndParents);
    assignCategoriesTokensProp(tokenTypesAndParents);
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(tokenTypesAndParents, function (tokType) {
        tokType.isParent = tokType.categoryMatches.length > 0;
    });
}
function expandCategories(tokenTypes) {
    var result = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneArr)(tokenTypes);
    var categories = tokenTypes;
    var searching = true;
    while (searching) {
        categories = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.compact)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(categories, function (currTokType) { return currTokType.CATEGORIES; })));
        var newCategories = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.difference)(categories, result);
        result = result.concat(newCategories);
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(newCategories)) {
            searching = false;
        }
        else {
            categories = newCategories;
        }
    }
    return result;
}
function assignTokenDefaultProps(tokenTypes) {
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(tokenTypes, function (currTokType) {
        if (!hasShortKeyProperty(currTokType)) {
            tokenIdxToClass[tokenShortNameIdx] = currTokType;
            currTokType.tokenTypeIdx = tokenShortNameIdx++;
        }
        // CATEGORIES? : TokenType | TokenType[]
        if (hasCategoriesProperty(currTokType) &&
            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(currTokType.CATEGORIES)
        // &&
        // !isUndefined(currTokType.CATEGORIES.PATTERN)
        ) {
            currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
            currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
            currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
            currTokType.categoryMatchesMap = {};
        }
    });
}
function assignCategoriesTokensProp(tokenTypes) {
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(tokenTypes, function (currTokType) {
        // avoid duplications
        currTokType.categoryMatches = [];
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currTokType.categoryMatchesMap, function (val, key) {
            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);
        });
    });
}
function assignCategoriesMapProp(tokenTypes) {
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(tokenTypes, function (currTokType) {
        singleAssignCategoriesToksMap([], currTokType);
    });
}
function singleAssignCategoriesToksMap(path, nextNode) {
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, function (pathNode) {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
    });
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(nextNode.CATEGORIES, function (nextCategory) {
        var newPath = path.concat(nextNode);
        // avoids infinite loops due to cyclic categories.
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(newPath, nextCategory)) {
            singleAssignCategoriesToksMap(newPath, nextCategory);
        }
    });
}
function hasShortKeyProperty(tokType) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, "tokenTypeIdx");
}
function hasCategoriesProperty(tokType) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, "CATEGORIES");
}
function hasExtendingTokensTypesProperty(tokType) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, "categoryMatches");
}
function hasExtendingTokensTypesMapProperty(tokType) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, "categoryMatchesMap");
}
function isTokenType(tokType) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokType, "tokenTypeIdx");
}
//# sourceMappingURL=tokens.js.map

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultLexerErrorProvider: () => (/* binding */ defaultLexerErrorProvider)
/* harmony export */ });
var defaultLexerErrorProvider = {
    buildUnableToPopLexerModeMessage: function (token) {
        return "Unable to pop Lexer Mode after encountering Token ->" + token.image + "<- The Mode Stack is empty";
    },
    buildUnexpectedCharactersMessage: function (fullText, startOffset, length, line, column) {
        return ("unexpected character: ->" + fullText.charAt(startOffset) + "<- at offset: " + startOffset + "," + (" skipped " + length + " characters."));
    }
};
//# sourceMappingURL=lexer_errors_public.js.map

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   first: () => (/* binding */ first),
/* harmony export */   firstForBranching: () => (/* binding */ firstForBranching),
/* harmony export */   firstForSequence: () => (/* binding */ firstForSequence),
/* harmony export */   firstForTerminal: () => (/* binding */ firstForTerminal)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
/* harmony import */ var _gast_gast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);



function first(prod) {
    /* istanbul ignore else */
    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {
        // this could in theory cause infinite loops if
        // (1) prod A refs prod B.
        // (2) prod B refs prod A
        // (3) AB can match the empty set
        // in other words a cycle where everything is optional so the first will keep
        // looking ahead for the next optional part and will never exit
        // currently there is no safeguard for this unique edge case because
        // (1) not sure a grammar in which this can happen is useful for anything (productive)
        return first(prod.referencedRule);
    }
    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal) {
        return firstForTerminal(prod);
    }
    else if ((0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.isSequenceProd)(prod)) {
        return firstForSequence(prod);
    }
    else if ((0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.isBranchingProd)(prod)) {
        return firstForBranching(prod);
    }
    else {
        throw Error("non exhaustive match");
    }
}
function firstForSequence(prod) {
    var firstSet = [];
    var seq = prod.definition;
    var nextSubProdIdx = 0;
    var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    var currSubProd;
    // so we enter the loop at least once (if the definition is not empty
    var isLastInnerProdOptional = true;
    // scan a sequence until it's end or until we have found a NONE optional production in it
    while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = (0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.isOptionalProd)(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    }
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.uniq)(firstSet);
}
function firstForBranching(prod) {
    var allAlternativesFirsts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(prod.definition, function (innerProd) {
        return first(innerProd);
    });
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.uniq)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(allAlternativesFirsts));
}
function firstForTerminal(terminal) {
    return [terminal.terminalType];
}
//# sourceMappingURL=first.js.map

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DslMethodsCollectorVisitor: () => (/* binding */ DslMethodsCollectorVisitor),
/* harmony export */   collectMethods: () => (/* binding */ collectMethods),
/* harmony export */   getProductionDslName: () => (/* binding */ getProductionDslName),
/* harmony export */   isBranchingProd: () => (/* binding */ isBranchingProd),
/* harmony export */   isOptionalProd: () => (/* binding */ isOptionalProd),
/* harmony export */   isSequenceProd: () => (/* binding */ isSequenceProd)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
/* harmony import */ var _gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



function isSequenceProd(prod) {
    return (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Flat ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Option ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Rule);
}
function isOptionalProd(prod, alreadyVisited) {
    if (alreadyVisited === void 0) { alreadyVisited = []; }
    var isDirectlyOptional = prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Option ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition ||
        prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator;
    if (isDirectlyOptional) {
        return true;
    }
    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another
    // empty optional top rule
    // may be indirectly optional ((A?B?C?) | (D?E?F?))
    if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation) {
        // for OR its enough for just one of the alternatives to be optional
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.some)(prod.definition, function (subProd) {
            return isOptionalProd(subProd, alreadyVisited);
        });
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal && (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(alreadyVisited, prod)) {
        // avoiding stack overflow due to infinite recursion
        return false;
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.AbstractProduction) {
        if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {
            alreadyVisited.push(prod);
        }
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(prod.definition, function (subProd) {
            return isOptionalProd(subProd, alreadyVisited);
        });
    }
    else {
        return false;
    }
}
function isBranchingProd(prod) {
    return prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation;
}
function getProductionDslName(prod) {
    /* istanbul ignore else */
    if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {
        return "SUBRULE";
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Option) {
        return "OPTION";
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation) {
        return "OR";
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory) {
        return "AT_LEAST_ONE";
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator) {
        return "MANY_SEP";
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition) {
        return "MANY";
    }
    else if (prod instanceof _gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal) {
        return "CONSUME";
    }
    else {
        throw Error("non exhaustive match");
    }
}
var DslMethodsCollectorVisitor = /** @class */ (function (_super) {
    __extends(DslMethodsCollectorVisitor, _super);
    function DslMethodsCollectorVisitor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // A minus is never valid in an identifier name
        _this.separator = "-";
        _this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
        };
        return _this;
    }
    DslMethodsCollectorVisitor.prototype.reset = function () {
        this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: []
        };
    };
    DslMethodsCollectorVisitor.prototype.visitTerminal = function (terminal) {
        var key = terminal.terminalType.name + this.separator + "Terminal";
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(this.dslMethods, key)) {
            this.dslMethods[key] = [];
        }
        this.dslMethods[key].push(terminal);
    };
    DslMethodsCollectorVisitor.prototype.visitNonTerminal = function (subrule) {
        var key = subrule.nonTerminalName + this.separator + "Terminal";
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(this.dslMethods, key)) {
            this.dslMethods[key] = [];
        }
        this.dslMethods[key].push(subrule);
    };
    DslMethodsCollectorVisitor.prototype.visitOption = function (option) {
        this.dslMethods.option.push(option);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.dslMethods.repetitionWithSeparator.push(manySep);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.dslMethods.repetitionMandatory.push(atLeastOne);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
    };
    DslMethodsCollectorVisitor.prototype.visitRepetition = function (many) {
        this.dslMethods.repetition.push(many);
    };
    DslMethodsCollectorVisitor.prototype.visitAlternation = function (or) {
        this.dslMethods.alternation.push(or);
    };
    return DslMethodsCollectorVisitor;
}(_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__.GAstVisitor));

var collectorVisitor = new DslMethodsCollectorVisitor();
function collectMethods(rule) {
    collectorVisitor.reset();
    rule.accept(collectorVisitor);
    var dslMethods = collectorVisitor.dslMethods;
    // avoid uncleaned references
    collectorVisitor.reset();
    return dslMethods;
}
//# sourceMappingURL=gast.js.map

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GAstVisitor: () => (/* binding */ GAstVisitor)
/* harmony export */ });
/* harmony import */ var _gast_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

var GAstVisitor = /** @class */ (function () {
    function GAstVisitor() {
    }
    GAstVisitor.prototype.visit = function (node) {
        var nodeAny = node;
        switch (nodeAny.constructor) {
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.NonTerminal:
                return this.visitNonTerminal(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Flat:
                return this.visitFlat(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Option:
                return this.visitOption(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory:
                return this.visitRepetitionMandatory(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator:
                return this.visitRepetitionWithSeparator(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Repetition:
                return this.visitRepetition(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Alternation:
                return this.visitAlternation(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Terminal:
                return this.visitTerminal(nodeAny);
            case _gast_public__WEBPACK_IMPORTED_MODULE_0__.Rule:
                return this.visitRule(nodeAny);
            /* istanbul ignore next */
            default:
                throw Error("non exhaustive match");
        }
    };
    GAstVisitor.prototype.visitNonTerminal = function (node) { };
    GAstVisitor.prototype.visitFlat = function (node) { };
    GAstVisitor.prototype.visitOption = function (node) { };
    GAstVisitor.prototype.visitRepetition = function (node) { };
    GAstVisitor.prototype.visitRepetitionMandatory = function (node) { };
    GAstVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) { };
    GAstVisitor.prototype.visitRepetitionWithSeparator = function (node) { };
    GAstVisitor.prototype.visitAlternation = function (node) { };
    GAstVisitor.prototype.visitTerminal = function (node) { };
    GAstVisitor.prototype.visitRule = function (node) { };
    return GAstVisitor;
}());

//# sourceMappingURL=gast_visitor_public.js.map

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IN: () => (/* binding */ IN)
/* harmony export */ });
// TODO: can this be removed? where is it used?
var IN = "_~IN~_";
//# sourceMappingURL=constants.js.map

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NamedDSLMethodsCollectorVisitor: () => (/* binding */ NamedDSLMethodsCollectorVisitor),
/* harmony export */   addNoneTerminalToCst: () => (/* binding */ addNoneTerminalToCst),
/* harmony export */   addTerminalToCst: () => (/* binding */ addTerminalToCst),
/* harmony export */   expandAllNestedRuleNames: () => (/* binding */ expandAllNestedRuleNames),
/* harmony export */   setNodeLocationFull: () => (/* binding */ setNodeLocationFull),
/* harmony export */   setNodeLocationOnlyOffset: () => (/* binding */ setNodeLocationOnlyOffset)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34);
/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */
function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (both start/end offsets exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
    // Once the startOffset has been updated with a valid number it should never receive
    // any farther updates as the Token vector is sorted.
    // We still have to check this this condition for every new possible location info
    // because with error recovery enabled we may encounter invalid tokens (NaN location props)
    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
}
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */
function setNodeLocationFull(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (all start/end props exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
    // Once the start props has been updated with a valid number it should never receive
    // any farther updates as the Token vector is sorted.
    // We still have to check this this condition for every new possible location info
    // because with error recovery enabled we may encounter invalid tokens (NaN location props)
    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
}
function addTerminalToCst(node, token, tokenTypeName) {
    if (node.children[tokenTypeName] === undefined) {
        node.children[tokenTypeName] = [token];
    }
    else {
        node.children[tokenTypeName].push(token);
    }
}
function addNoneTerminalToCst(node, ruleName, ruleResult) {
    if (node.children[ruleName] === undefined) {
        node.children[ruleName] = [ruleResult];
    }
    else {
        node.children[ruleName].push(ruleResult);
    }
}
var NamedDSLMethodsCollectorVisitor = /** @class */ (function (_super) {
    __extends(NamedDSLMethodsCollectorVisitor, _super);
    function NamedDSLMethodsCollectorVisitor(ruleIdx) {
        var _this = _super.call(this) || this;
        _this.result = [];
        _this.ruleIdx = ruleIdx;
        return _this;
    }
    NamedDSLMethodsCollectorVisitor.prototype.collectNamedDSLMethod = function (node, newNodeConstructor, methodIdx) {
        // TODO: better hack to copy what we need here...
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(node.name)) {
            // copy without name so this will indeed be processed later.
            var nameLessNode
            /* istanbul ignore else */
            = void 0;
            /* istanbul ignore else */
            if (node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Option ||
                node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Repetition ||
                node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.RepetitionMandatory ||
                node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Alternation) {
                nameLessNode = new newNodeConstructor({
                    definition: node.definition,
                    idx: node.idx
                });
            }
            else if (node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.RepetitionMandatoryWithSeparator ||
                node instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.RepetitionWithSeparator) {
                nameLessNode = new newNodeConstructor({
                    definition: node.definition,
                    idx: node.idx,
                    separator: node.separator
                });
            }
            else {
                throw Error("non exhaustive match");
            }
            var def = [nameLessNode];
            var key = (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.getKeyForAutomaticLookahead)(this.ruleIdx, methodIdx, node.idx);
            this.result.push({ def: def, key: key, name: node.name, orgProd: node });
        }
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitOption = function (node) {
        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Option, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OPTION_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetition = function (node) {
        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Repetition, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatory = function (node) {
        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.RepetitionMandatory, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {
        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.RepetitionMandatoryWithSeparator, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitRepetitionWithSeparator = function (node) {
        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.RepetitionWithSeparator, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_SEP_IDX);
    };
    NamedDSLMethodsCollectorVisitor.prototype.visitAlternation = function (node) {
        var _this = this;
        this.collectNamedDSLMethod(node, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Alternation, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OR_IDX);
        var hasMoreThanOneAlternative = node.definition.length > 1;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(node.definition, function (currFlatAlt, altIdx) {
            if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(currFlatAlt.name)) {
                var def = currFlatAlt.definition;
                if (hasMoreThanOneAlternative) {
                    def = [new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Option({ definition: currFlatAlt.definition })];
                }
                else {
                    // mandatory
                    def = currFlatAlt.definition;
                }
                var key = (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.getKeyForAltIndex)(_this.ruleIdx, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OR_IDX, node.idx, altIdx);
                _this.result.push({
                    def: def,
                    key: key,
                    name: currFlatAlt.name,
                    orgProd: currFlatAlt
                });
            }
        });
    };
    return NamedDSLMethodsCollectorVisitor;
}(_grammar_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_3__.GAstVisitor));

function expandAllNestedRuleNames(topRules, fullToShortName) {
    var result = {
        allRuleNames: []
    };
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(topRules, function (currTopRule) {
        var currTopRuleShortName = fullToShortName[currTopRule.name];
        result.allRuleNames.push(currTopRule.name);
        var namedCollectorVisitor = new NamedDSLMethodsCollectorVisitor(currTopRuleShortName);
        currTopRule.accept(namedCollectorVisitor);
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(namedCollectorVisitor.result, function (_a) {
            var def = _a.def, key = _a.key, name = _a.name;
            result.allRuleNames.push(currTopRule.name + name);
        });
    });
    return result;
}
//# sourceMappingURL=cst.js.map

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AT_LEAST_ONE_IDX: () => (/* binding */ AT_LEAST_ONE_IDX),
/* harmony export */   AT_LEAST_ONE_SEP_IDX: () => (/* binding */ AT_LEAST_ONE_SEP_IDX),
/* harmony export */   BITS_FOR_ALT_IDX: () => (/* binding */ BITS_FOR_ALT_IDX),
/* harmony export */   BITS_FOR_METHOD_TYPE: () => (/* binding */ BITS_FOR_METHOD_TYPE),
/* harmony export */   BITS_FOR_OCCURRENCE_IDX: () => (/* binding */ BITS_FOR_OCCURRENCE_IDX),
/* harmony export */   BITS_FOR_RULE_IDX: () => (/* binding */ BITS_FOR_RULE_IDX),
/* harmony export */   MANY_IDX: () => (/* binding */ MANY_IDX),
/* harmony export */   MANY_SEP_IDX: () => (/* binding */ MANY_SEP_IDX),
/* harmony export */   OPTION_IDX: () => (/* binding */ OPTION_IDX),
/* harmony export */   OR_IDX: () => (/* binding */ OR_IDX),
/* harmony export */   getKeyForAltIndex: () => (/* binding */ getKeyForAltIndex),
/* harmony export */   getKeyForAutomaticLookahead: () => (/* binding */ getKeyForAutomaticLookahead)
/* harmony export */ });
// Lookahead keys are 32Bit integers in the form
// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX
// XXXX -> Occurrence Index bitmap.
// YYYY -> DSL Method Type bitmap.
// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.
// TTTTTTTTT -> alternation alternative index bitmap
var BITS_FOR_METHOD_TYPE = 4;
var BITS_FOR_OCCURRENCE_IDX = 8;
var BITS_FOR_RULE_IDX = 12;
// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.
var BITS_FOR_ALT_IDX = 8;
// short string used as part of mapping keys.
// being short improves the performance when composing KEYS for maps out of these
// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)
/* tslint:disable */
var OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;
var OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;
var MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;
var AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;
var MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;
var AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;
/* tslint:enable */
// this actually returns a number, but it is always used as a string (object prop key)
function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
    /* tslint:disable */
    return occurrence | dslMethodIdx | ruleIdx;
    /* tslint:enable */
}
var BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;
function getKeyForAltIndex(ruleIdx, dslMethodIdx, occurrence, altIdx) {
    /* tslint:disable */
    // alternative indices are zero based, thus must always add one (turn on one bit) to guarantee uniqueness.
    var altIdxBitMap = (altIdx + 1) << BITS_START_FOR_ALT_IDX;
    return (getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) |
        altIdxBitMap);
    /* tslint:enable */
}
//# sourceMappingURL=keys.js.map

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultGrammarResolverErrorProvider: () => (/* binding */ defaultGrammarResolverErrorProvider),
/* harmony export */   defaultGrammarValidatorErrorProvider: () => (/* binding */ defaultGrammarValidatorErrorProvider),
/* harmony export */   defaultParserErrorProvider: () => (/* binding */ defaultParserErrorProvider)
/* harmony export */ });
/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _grammar_checks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);






var defaultParserErrorProvider = {
    buildMismatchTokenMessage: function (_a) {
        var expected = _a.expected, actual = _a.actual, previous = _a.previous, ruleName = _a.ruleName;
        var hasLabel = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.hasTokenLabel)(expected);
        var expectedMsg = hasLabel
            ? "--> " + (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(expected) + " <--"
            : "token of type --> " + expected.name + " <--";
        var msg = "Expecting " + expectedMsg + " but found --> '" + actual.image + "' <--";
        return msg;
    },
    buildNotAllInputParsedMessage: function (_a) {
        var firstRedundant = _a.firstRedundant, ruleName = _a.ruleName;
        return ("Redundant input, expecting EOF but found: " + firstRedundant.image);
    },
    buildNoViableAltMessage: function (_a) {
        var expectedPathsPerAlt = _a.expectedPathsPerAlt, actual = _a.actual, previous = _a.previous, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        var actualText = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
        }
        else {
            var allLookAheadPaths = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.reduce)(expectedPathsPerAlt, function (result, currAltPaths) { return result.concat(currAltPaths); }, []);
            var nextValidTokenSequences = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(allLookAheadPaths, function (currPath) {
                return "[" + (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(currPath, function (currTokenType) {
                    return (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTokenType);
                }).join(", ") + "]";
            });
            var nextValidSequenceItems = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(nextValidTokenSequences, function (itemMsg, idx) { return "  " + (idx + 1) + ". " + itemMsg; });
            var calculatedDescription = "one of these possible Token sequences:\n" + nextValidSequenceItems.join("\n");
            return errPrefix + calculatedDescription + errSuffix;
        }
    },
    buildEarlyExitMessage: function (_a) {
        var expectedIterationPaths = _a.expectedIterationPaths, actual = _a.actual, customUserDescription = _a.customUserDescription, ruleName = _a.ruleName;
        var errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        var actualText = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(actual).image;
        var errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
        }
        else {
            var nextValidTokenSequences = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(expectedIterationPaths, function (currPath) {
                return "[" + (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(currPath, function (currTokenType) {
                    return (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTokenType);
                }).join(",") + "]";
            });
            var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " +
                ("<" + nextValidTokenSequences.join(" ,") + ">");
            return errPrefix + calculatedDescription + errSuffix;
        }
    }
};
Object.freeze(defaultParserErrorProvider);
var defaultGrammarResolverErrorProvider = {
    buildRuleNotFoundError: function (topLevelRule, undefinedRule) {
        var msg = "Invalid grammar, reference to a rule which is not defined: ->" +
            undefinedRule.nonTerminalName +
            "<-\n" +
            "inside top level rule: ->" +
            topLevelRule.name +
            "<-";
        return msg;
    }
};
var defaultGrammarValidatorErrorProvider = {
    buildDuplicateFoundError: function (topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
            if (prod instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Terminal) {
                return prod.terminalType.name;
            }
            else if (prod instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.NonTerminal) {
                return prod.nonTerminalName;
            }
            else {
                return "";
            }
        }
        var topLevelName = topLevelRule.name;
        var duplicateProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(duplicateProds);
        var index = duplicateProd.idx;
        var dslName = (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__.getProductionDslName)(duplicateProd);
        var extraArgument = getExtraProductionArgument(duplicateProd);
        var hasExplicitIndex = index > 0;
        var msg = "->" + dslName + (hasExplicitIndex ? index : "") + "<- " + (extraArgument ? "with argument: ->" + extraArgument + "<-" : "") + "\n                  appears more than once (" + duplicateProds.length + " times) in the top level rule: ->" + topLevelName + "<-.                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ";
        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
    },
    buildInvalidNestedRuleNameError: function (topLevelRule, nestedProd) {
        var msg = "Invalid nested rule name: ->" + nestedProd.name + "<- inside rule: ->" + topLevelRule.name + "<-\n" +
            ("it must match the pattern: ->" + _grammar_checks__WEBPACK_IMPORTED_MODULE_4__.validNestedRuleName.toString() + "<-.\n") +
            "Note that this means a nested rule name must start with the '$'(dollar) sign.";
        return msg;
    },
    buildDuplicateNestedRuleNameError: function (topLevelRule, nestedProd) {
        var duplicateName = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(nestedProd).name;
        var errMsg = "Duplicate nested rule name: ->" + duplicateName + "<- inside rule: ->" + topLevelRule.name + "<-\n" +
            "A nested name must be unique in the scope of a top level grammar rule.";
        return errMsg;
    },
    buildNamespaceConflictError: function (rule) {
        var errMsg = "Namespace conflict found in grammar.\n" +
            ("The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + rule.name + ">.\n") +
            "To resolve this make sure each Terminal and Non-Terminal names are unique\n" +
            "This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\n" +
            "and Non-Terminal names start with a lower case letter.";
        return errMsg;
    },
    buildAlternationPrefixAmbiguityError: function (options) {
        var pathMsg = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(options.prefixPath, function (currTok) {
            return (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var errMsg = "Ambiguous alternatives: <" + options.ambiguityIndices.join(" ,") + "> due to common lookahead prefix\n" +
            ("in <OR" + occurrence + "> inside <" + options.topLevelRule.name + "> Rule,\n") +
            ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n") +
            "See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\n" +
            "For Further details.";
        return errMsg;
    },
    buildAlternationAmbiguityError: function (options) {
        var pathMsg = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(options.prefixPath, function (currtok) {
            return (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currtok);
        }).join(", ");
        var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        var currMessage = "Ambiguous Alternatives Detected: <" + options.ambiguityIndices.join(" ,") + "> in <OR" + occurrence + ">" +
            (" inside <" + options.topLevelRule.name + "> Rule,\n") +
            ("<" + pathMsg + "> may appears as a prefix path in all these alternatives.\n");
        currMessage =
            currMessage +
                "See: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\n" +
                "For Further details.";
        return currMessage;
    },
    buildEmptyRepetitionError: function (options) {
        var dslName = (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_3__.getProductionDslName)(options.repetition);
        if (options.repetition.idx !== 0) {
            dslName += options.repetition.idx;
        }
        var errMsg = "The repetition <" + dslName + "> within Rule <" + options.topLevelRule.name + "> can never consume any tokens.\n" +
            "This could lead to an infinite loop.";
        return errMsg;
    },
    buildTokenNameError: function (options) {
        var tokTypeName = options.tokenType.name;
        var errMsg = "Invalid Grammar Token name: ->" + tokTypeName + "<- it must match the pattern: ->" + options.expectedPattern.toString() + "<-";
        return errMsg;
    },
    buildEmptyAlternationError: function (options) {
        var errMsg = "Ambiguous empty alternative: <" + (options.emptyChoiceIdx + 1) + ">" +
            (" in <OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n") +
            "Only the last alternative may be an empty alternative.";
        return errMsg;
    },
    buildTooManyAlternativesError: function (options) {
        var errMsg = "An Alternation cannot have more than 256 alternatives:\n" +
            ("<OR" + options.alternation.idx + "> inside <" + options.topLevelRule.name + "> Rule.\n has " + (options.alternation.definition.length +
                1) + " alternatives.");
        return errMsg;
    },
    buildLeftRecursionError: function (options) {
        var ruleName = options.topLevelRule.name;
        var pathNames = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.map(options.leftRecursionPath, function (currRule) { return currRule.name; });
        var leftRecursivePath = ruleName + " --> " + pathNames
            .concat([ruleName])
            .join(" --> ");
        var errMsg = "Left Recursion found in grammar.\n" +
            ("rule: <" + ruleName + "> can be invoked from itself (directly or indirectly)\n") +
            ("without consuming any Tokens. The grammar path that causes this is: \n " + leftRecursivePath + "\n") +
            " To fix this refactor your grammar to remove the left recursion.\n" +
            "see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.";
        return errMsg;
    },
    buildInvalidRuleNameError: function (options) {
        var ruleName = options.topLevelRule.name;
        var expectedPatternString = options.expectedPattern.toString();
        var errMsg = "Invalid grammar rule name: ->" + ruleName + "<- it must match the pattern: ->" + expectedPatternString + "<-";
        return errMsg;
    },
    buildDuplicateRuleNameError: function (options) {
        var ruleName;
        if (options.topLevelRule instanceof _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_2__.Rule) {
            ruleName = options.topLevelRule.name;
        }
        else {
            ruleName = options.topLevelRule;
        }
        var errMsg = "Duplicate definition, rule: ->" + ruleName + "<- is already defined in the grammar: ->" + options.grammarName + "<-";
        return errMsg;
    }
};
//# sourceMappingURL=errors_public.js.map

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OccurrenceValidationCollector: () => (/* binding */ OccurrenceValidationCollector),
/* harmony export */   RepetionCollector: () => (/* binding */ RepetionCollector),
/* harmony export */   checkPrefixAlternativesAmbiguities: () => (/* binding */ checkPrefixAlternativesAmbiguities),
/* harmony export */   getFirstNoneTerminal: () => (/* binding */ getFirstNoneTerminal),
/* harmony export */   identifyProductionForDuplicates: () => (/* binding */ identifyProductionForDuplicates),
/* harmony export */   validNestedRuleName: () => (/* binding */ validNestedRuleName),
/* harmony export */   validTermsPattern: () => (/* binding */ validTermsPattern),
/* harmony export */   validateAmbiguousAlternationAlternatives: () => (/* binding */ validateAmbiguousAlternationAlternatives),
/* harmony export */   validateEmptyOrAlternative: () => (/* binding */ validateEmptyOrAlternative),
/* harmony export */   validateGrammar: () => (/* binding */ validateGrammar),
/* harmony export */   validateNestedRuleName: () => (/* binding */ validateNestedRuleName),
/* harmony export */   validateNoLeftRecursion: () => (/* binding */ validateNoLeftRecursion),
/* harmony export */   validateRuleDoesNotAlreadyExist: () => (/* binding */ validateRuleDoesNotAlreadyExist),
/* harmony export */   validateRuleIsOverridden: () => (/* binding */ validateRuleIsOverridden),
/* harmony export */   validateRuleName: () => (/* binding */ validateRuleName),
/* harmony export */   validateSomeNonEmptyLookaheadPath: () => (/* binding */ validateSomeNonEmptyLookaheadPath),
/* harmony export */   validateTokenName: () => (/* binding */ validateTokenName),
/* harmony export */   validateTooManyAlts: () => (/* binding */ validateTooManyAlts)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _parser_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _gast_gast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _lookahead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
/* harmony import */ var _cst_cst__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38);
/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(20);
/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(31);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, ignoredIssues, errMsgProvider, grammarName) {
    var duplicateErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(topLevels, function (currTopLevel) {
        return validateDuplicateProductions(currTopLevel, errMsgProvider);
    });
    var leftRecursionErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(topLevels, function (currTopRule) {
        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);
    });
    var emptyAltErrors = [];
    var ambiguousAltsErrors = [];
    var emptyRepetitionErrors = [];
    // left recursion could cause infinite loops in the following validations.
    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(leftRecursionErrors, _utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)) {
        emptyAltErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (currTopRule) {
            return validateEmptyOrAlternative(currTopRule, errMsgProvider);
        });
        ambiguousAltsErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (currTopRule) {
            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, ignoredIssues, errMsgProvider);
        });
        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);
    }
    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
    var tokenNameErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(tokenTypes, function (currTokType) {
        return validateTokenName(currTokType, errMsgProvider);
    });
    var nestedRulesNameErrors = validateNestedRulesNames(topLevels, errMsgProvider);
    var nestedRulesDuplicateErrors = validateDuplicateNestedRules(topLevels, errMsgProvider);
    var tooManyAltsErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (curRule) {
        return validateTooManyAlts(curRule, errMsgProvider);
    });
    var ruleNameErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (curRule) {
        return validateRuleName(curRule, errMsgProvider);
    });
    var duplicateRulesError = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(topLevels, function (curRule) {
        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
    });
    return (_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten(duplicateErrors.concat(tokenNameErrors, nestedRulesNameErrors, nestedRulesDuplicateErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError)));
}
function validateNestedRulesNames(topLevels, errMsgProvider) {
    var result = [];
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(topLevels, function (curTopLevel) {
        var namedCollectorVisitor = new _cst_cst__WEBPACK_IMPORTED_MODULE_4__.NamedDSLMethodsCollectorVisitor("");
        curTopLevel.accept(namedCollectorVisitor);
        var nestedProds = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(namedCollectorVisitor.result, function (currItem) { return currItem.orgProd; });
        result.push((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(nestedProds, function (currNestedProd) {
            return validateNestedRuleName(curTopLevel, currNestedProd, errMsgProvider);
        }));
    });
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(result);
}
function validateDuplicateProductions(topLevelRule, errMsgProvider) {
    var collectorVisitor = new OccurrenceValidationCollector();
    topLevelRule.accept(collectorVisitor);
    var allRuleProductions = collectorVisitor.allProductions;
    var productionGroups = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.groupBy(allRuleProductions, identifyProductionForDuplicates);
    var duplicates = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick(productionGroups, function (currGroup) {
        return currGroup.length > 1;
    });
    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values(duplicates), function (currDuplicates) {
        var firstProd = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.first(currDuplicates);
        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        var dslName = (0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(firstProd);
        var defError = {
            message: msg,
            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
            ruleName: topLevelRule.name,
            dslName: dslName,
            occurrence: firstProd.idx
        };
        var param = getExtraProductionArgument(firstProd);
        if (param) {
            defError.parameter = param;
        }
        return defError;
    });
    return errors;
}
function identifyProductionForDuplicates(prod) {
    return (0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(prod) + "_#_" + prod.idx + "_#_" + getExtraProductionArgument(prod);
}
function getExtraProductionArgument(prod) {
    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.Terminal) {
        return prod.terminalType.name;
    }
    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.NonTerminal) {
        return prod.nonTerminalName;
    }
    else {
        return "";
    }
}
var OccurrenceValidationCollector = /** @class */ (function (_super) {
    __extends(OccurrenceValidationCollector, _super);
    function OccurrenceValidationCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
    }
    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {
        this.allProductions.push(subrule);
    };
    OccurrenceValidationCollector.prototype.visitOption = function (option) {
        this.allProductions.push(option);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.allProductions.push(manySep);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.allProductions.push(atLeastOne);
    };
    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    };
    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {
        this.allProductions.push(many);
    };
    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {
        this.allProductions.push(or);
    };
    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {
        this.allProductions.push(terminal);
    };
    return OccurrenceValidationCollector;
}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_7__.GAstVisitor));

var validTermsPattern = /^[a-zA-Z_]\w*$/;
var validNestedRuleName = new RegExp(validTermsPattern.source.replace("^", "^\\$"));
// TODO: remove this limitation now that we use recorders
function validateRuleName(rule, errMsgProvider) {
    var errors = [];
    var ruleName = rule.name;
    if (!ruleName.match(validTermsPattern)) {
        errors.push({
            message: errMsgProvider.buildInvalidRuleNameError({
                topLevelRule: rule,
                expectedPattern: validTermsPattern
            }),
            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.INVALID_RULE_NAME,
            ruleName: ruleName
        });
    }
    return errors;
}
// TODO: did the nested rule name regExp now change?
function validateNestedRuleName(topLevel, nestedProd, errMsgProvider) {
    var errors = [];
    var errMsg;
    if (!nestedProd.name.match(validNestedRuleName)) {
        errMsg = errMsgProvider.buildInvalidNestedRuleNameError(topLevel, nestedProd);
        errors.push({
            message: errMsg,
            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,
            ruleName: topLevel.name
        });
    }
    return errors;
}
// TODO: remove this limitation now that we use recorders
function validateTokenName(tokenType, errMsgProvider) {
    var errors = [];
    var tokTypeName = tokenType.name;
    if (!tokTypeName.match(validTermsPattern)) {
        errors.push({
            message: errMsgProvider.buildTokenNameError({
                tokenType: tokenType,
                expectedPattern: validTermsPattern
            }),
            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.INVALID_TOKEN_NAME
        });
    }
    return errors;
}
function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
    var errors = [];
    var occurrences = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(allRules, function (result, curRule) {
        if (curRule.name === rule.name) {
            return result + 1;
        }
        return result;
    }, 0);
    if (occurrences > 1) {
        var errMsg = errMsgProvider.buildDuplicateRuleNameError({
            topLevelRule: rule,
            grammarName: className
        });
        errors.push({
            message: errMsg,
            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
            ruleName: rule.name
        });
    }
    return errors;
}
// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?
// This is not part of the IGrammarErrorProvider because the validation cannot be performed on
// The grammar structure, only at runtime.
function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
    var errors = [];
    var errMsg;
    if (!_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains(definedRulesNames, ruleName)) {
        errMsg =
            "Invalid rule override, rule: ->" + ruleName + "<- cannot be overridden in the grammar: ->" + className + "<-" +
                "as it is not defined in any of the super grammars ";
        errors.push({
            message: errMsg,
            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
            ruleName: ruleName
        });
    }
    return errors;
}
function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {
    if (path === void 0) { path = []; }
    var errors = [];
    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
    if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty(nextNonTerminals)) {
        return [];
    }
    else {
        var ruleName = topRule.name;
        var foundLeftRecursion = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains(nextNonTerminals, topRule);
        if (foundLeftRecursion) {
            errors.push({
                message: errMsgProvider.buildLeftRecursionError({
                    topLevelRule: topRule,
                    leftRecursionPath: path
                }),
                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.LEFT_RECURSION,
                ruleName: ruleName
            });
        }
        // we are only looking for cyclic paths leading back to the specific topRule
        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...
        var validNextSteps = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.difference(nextNonTerminals, path.concat([topRule]));
        var errorsFromNextSteps = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(validNextSteps, function (currRefRule) {
            var newPath = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneArr(path);
            newPath.push(currRefRule);
            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten(errorsFromNextSteps));
    }
}
function getFirstNoneTerminal(definition) {
    var result = [];
    if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty(definition)) {
        return result;
    }
    var firstProd = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.first(definition);
    /* istanbul ignore else */
    if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.NonTerminal) {
        result.push(firstProd.referencedRule);
    }
    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.Flat ||
        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.Option ||
        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.RepetitionMandatory ||
        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.RepetitionMandatoryWithSeparator ||
        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.RepetitionWithSeparator ||
        firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.Repetition) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
    }
    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.Alternation) {
        // each sub definition in alternation is a FLAT
        result = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten(_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(firstProd.definition, function (currSubDef) {
            return getFirstNoneTerminal(currSubDef.definition);
        }));
    }
    else if (firstProd instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_6__.Terminal) {
        // nothing to see, move along
    }
    else {
        throw Error("non exhaustive match");
    }
    var isFirstOptional = (0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.isOptionalProd)(firstProd);
    var hasMore = definition.length > 1;
    if (isFirstOptional && hasMore) {
        var rest = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.drop(definition);
        return result.concat(getFirstNoneTerminal(rest));
    }
    else {
        return result;
    }
}
var OrCollector = /** @class */ (function (_super) {
    __extends(OrCollector, _super);
    function OrCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.alternations = [];
        return _this;
    }
    OrCollector.prototype.visitAlternation = function (node) {
        this.alternations.push(node);
    };
    return OrCollector;
}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_7__.GAstVisitor));
function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce(ors, function (errors, currOr) {
        var exceptLast = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.dropRight(currOr.definition);
        var currErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(exceptLast, function (currAlternative, currAltIdx) {
            var possibleFirstInAlt = (0,_interpreter__WEBPACK_IMPORTED_MODULE_5__.nextPossibleTokensAfter)([currAlternative], [], null, 1);
            if (_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty(possibleFirstInAlt)) {
                return {
                    message: errMsgProvider.buildEmptyAlternationError({
                        topLevelRule: topLevelRule,
                        alternation: currOr,
                        emptyChoiceIdx: currAltIdx
                    }),
                    type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                    ruleName: topLevelRule.name,
                    occurrence: currOr.idx,
                    alternative: currAltIdx + 1
                };
            }
            else {
                return null;
            }
        });
        return errors.concat(_utils_utils__WEBPACK_IMPORTED_MODULE_0__.compact(currErrors));
    }, []);
    return errors;
}
function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, ignoredIssues, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    // TODO: this filtering should be deprecated once we remove the ignoredIssues
    //  IParserConfig property
    var ignoredIssuesForCurrentRule = ignoredIssues[topLevelRule.name];
    if (ignoredIssuesForCurrentRule) {
        ors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reject)(ors, function (currOr) {
            return ignoredIssuesForCurrentRule[(0,_gast_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(currOr) +
                (currOr.idx === 0 ? "" : currOr.idx)];
        });
    }
    // New Handling of ignoring ambiguities
    // - https://github.com/SAP/chevrotain/issues/869
    ors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reject)(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });
    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce(ors, function (result, currOr) {
        var currOccurrence = currOr.idx;
        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        var alternatives = (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);
    }, []);
    return errors;
}
var RepetionCollector = /** @class */ (function (_super) {
    __extends(RepetionCollector, _super);
    function RepetionCollector() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.allProductions = [];
        return _this;
    }
    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {
        this.allProductions.push(manySep);
    };
    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {
        this.allProductions.push(atLeastOne);
    };
    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    };
    RepetionCollector.prototype.visitRepetition = function (many) {
        this.allProductions.push(many);
    };
    return RepetionCollector;
}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_7__.GAstVisitor));

function validateTooManyAlts(topLevelRule, errMsgProvider) {
    var orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    var ors = orCollector.alternations;
    var errors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce(ors, function (errors, currOr) {
        if (currOr.definition.length > 255) {
            errors.push({
                message: errMsgProvider.buildTooManyAlternativesError({
                    topLevelRule: topLevelRule,
                    alternation: currOr
                }),
                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.TOO_MANY_ALTS,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx
            });
        }
        return errors;
    }, []);
    return errors;
}
function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
    var errors = [];
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(topLevelRules, function (currTopRule) {
        var collectorVisitor = new RepetionCollector();
        currTopRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(allRuleProductions, function (currProd) {
            var prodType = (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.getProdType)(currProd);
            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
            var currOccurrence = currProd.idx;
            var paths = (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
            var pathsInsideProduction = paths[0];
            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(pathsInsideProduction))) {
                var errMsg = errMsgProvider.buildEmptyRepetitionError({
                    topLevelRule: currTopRule,
                    repetition: currProd
                });
                errors.push({
                    message: errMsg,
                    type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
                    ruleName: currTopRule.name
                });
            }
        });
    });
    return errors;
}
function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    var foundAmbiguousPaths = [];
    var identicalAmbiguities = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(alternatives, function (result, currAlt, currAltIdx) {
        // ignore (skip) ambiguities with this alternative
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
            return result;
        }
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currAlt, function (currPath) {
            var altsCurrPathAppearsIn = [currAltIdx];
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(alternatives, function (currOtherAlt, currOtherAltIdx) {
                if (currAltIdx !== currOtherAltIdx &&
                    (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.containsPath)(currOtherAlt, currPath) &&
                    // ignore (skip) ambiguities with this "other" alternative
                    alternation.definition[currOtherAltIdx]
                        .ignoreAmbiguities !== true) {
                    altsCurrPathAppearsIn.push(currOtherAltIdx);
                }
            });
            if (altsCurrPathAppearsIn.length > 1 &&
                !(0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.containsPath)(foundAmbiguousPaths, currPath)) {
                foundAmbiguousPaths.push(currPath);
                result.push({
                    alts: altsCurrPathAppearsIn,
                    path: currPath
                });
            }
        });
        return result;
    }, []);
    var currErrors = _utils_utils__WEBPACK_IMPORTED_MODULE_0__.map(identicalAmbiguities, function (currAmbDescriptor) {
        var ambgIndices = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });
        var currMessage = errMsgProvider.buildAlternationAmbiguityError({
            topLevelRule: rule,
            alternation: alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbDescriptor.path
        });
        return {
            message: currMessage,
            type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
            ruleName: rule.name,
            occurrence: alternation.idx,
            alternatives: [currAmbDescriptor.alts]
        };
    });
    return currErrors;
}
function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    var errors = [];
    // flatten
    var pathsAndIndices = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(alternatives, function (result, currAlt, idx) {
        var currPathsAndIdx = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(currAlt, function (currPath) {
            return { idx: idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
    }, []);
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(pathsAndIndices, function (currPathAndIdx) {
        var alternativeGast = alternation.definition[currPathAndIdx.idx];
        // ignore (skip) ambiguities with this alternative
        if (alternativeGast.ignoreAmbiguities === true) {
            return;
        }
        var targetIdx = currPathAndIdx.idx;
        var targetPath = currPathAndIdx.path;
        var prefixAmbiguitiesPathsAndIndices = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.findAll)(pathsAndIndices, function (searchPathAndIdx) {
            // prefix ambiguity can only be created from lower idx (higher priority) path
            return (
            // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx]
                .ignoreAmbiguities !== true &&
                searchPathAndIdx.idx < targetIdx &&
                // checking for strict prefix because identical lookaheads
                // will be be detected using a different validation.
                (0,_lookahead__WEBPACK_IMPORTED_MODULE_3__.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath));
        });
        var currPathPrefixErrors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {
            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
            var occurrence = alternation.idx === 0 ? "" : alternation.idx;
            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
                topLevelRule: rule,
                alternation: alternation,
                ambiguityIndices: ambgIndices,
                prefixPath: currAmbPathAndIdx.path
            });
            return {
                message: message,
                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
                ruleName: rule.name,
                occurrence: occurrence,
                alternatives: ambgIndices
            };
        });
        errors = errors.concat(currPathPrefixErrors);
    });
    return errors;
}
function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
    var errors = [];
    var tokenNames = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(tokenTypes, function (currToken) { return currToken.name; });
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(topLevels, function (currRule) {
        var currRuleName = currRule.name;
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(tokenNames, currRuleName)) {
            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
            errors.push({
                message: errMsg,
                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
                ruleName: currRuleName
            });
        }
    });
    return errors;
}
function validateDuplicateNestedRules(topLevelRules, errMsgProvider) {
    var errors = [];
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(topLevelRules, function (currTopRule) {
        var namedCollectorVisitor = new _cst_cst__WEBPACK_IMPORTED_MODULE_4__.NamedDSLMethodsCollectorVisitor("");
        currTopRule.accept(namedCollectorVisitor);
        var prodsByGroup = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.groupBy)(namedCollectorVisitor.result, function (item) { return item.name; });
        var duplicates = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.pick)(prodsByGroup, function (currGroup) {
            return currGroup.length > 1;
        });
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(duplicates), function (currDupGroup) {
            var currDupProds = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(currDupGroup, function (dupGroup) { return dupGroup.orgProd; });
            var errMsg = errMsgProvider.buildDuplicateNestedRuleNameError(currTopRule, currDupProds);
            errors.push({
                message: errMsg,
                type: _parser_parser__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,
                ruleName: currTopRule.name
            });
        });
    });
    return errors;
}
//# sourceMappingURL=checks.js.map

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PROD_TYPE: () => (/* binding */ PROD_TYPE),
/* harmony export */   areTokenCategoriesNotUsed: () => (/* binding */ areTokenCategoriesNotUsed),
/* harmony export */   buildAlternativesLookAheadFunc: () => (/* binding */ buildAlternativesLookAheadFunc),
/* harmony export */   buildLookaheadFuncForOptionalProd: () => (/* binding */ buildLookaheadFuncForOptionalProd),
/* harmony export */   buildLookaheadFuncForOr: () => (/* binding */ buildLookaheadFuncForOr),
/* harmony export */   buildSingleAlternativeLookaheadFunction: () => (/* binding */ buildSingleAlternativeLookaheadFunction),
/* harmony export */   containsPath: () => (/* binding */ containsPath),
/* harmony export */   getLookaheadPathsForOptionalProd: () => (/* binding */ getLookaheadPathsForOptionalProd),
/* harmony export */   getLookaheadPathsForOr: () => (/* binding */ getLookaheadPathsForOr),
/* harmony export */   getProdType: () => (/* binding */ getProdType),
/* harmony export */   isStrictPrefixOfPath: () => (/* binding */ isStrictPrefixOfPath),
/* harmony export */   lookAheadSequenceFromAlternatives: () => (/* binding */ lookAheadSequenceFromAlternatives)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _interpreter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19);
/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20);
/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(31);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var PROD_TYPE;
(function (PROD_TYPE) {
    PROD_TYPE[PROD_TYPE["OPTION"] = 0] = "OPTION";
    PROD_TYPE[PROD_TYPE["REPETITION"] = 1] = "REPETITION";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["ALTERNATION"] = 5] = "ALTERNATION";
})(PROD_TYPE || (PROD_TYPE = {}));
function getProdType(prod) {
    /* istanbul ignore else */
    if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Option) {
        return PROD_TYPE.OPTION;
    }
    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Repetition) {
        return PROD_TYPE.REPETITION;
    }
    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.RepetitionMandatory) {
        return PROD_TYPE.REPETITION_MANDATORY;
    }
    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.RepetitionMandatoryWithSeparator) {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
    }
    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.RepetitionWithSeparator) {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
    }
    else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Alternation) {
        return PROD_TYPE.ALTERNATION;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
    var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)
        ? _scan_tokens__WEBPACK_IMPORTED_MODULE_3__.tokenStructuredMatcherNoCategories
        : _scan_tokens__WEBPACK_IMPORTED_MODULE_3__.tokenStructuredMatcher;
    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
}
/**
 *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare
 *  the lookahead "inside" the production and the lookahead immediately "after" it in the same top level rule (context free).
 *
 *  Example: given a production:
 *  ABC(DE)?DF
 *
 *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two
 *  alternatives.
 *
 *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.
 */
function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
    var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
    var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)
        ? _scan_tokens__WEBPACK_IMPORTED_MODULE_3__.tokenStructuredMatcherNoCategories
        : _scan_tokens__WEBPACK_IMPORTED_MODULE_3__.tokenStructuredMatcher;
    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
}
function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
    var numOfAlts = alts.length;
    var areAllOneTokenLookahead = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(alts, function (currAlt) {
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(currAlt, function (currPath) {
            return currPath.length === 1;
        });
    });
    // This version takes into account the predicates as well.
    if (hasPredicates) {
        /**
         * @returns {number} - The chosen alternative index
         */
        return function (orAlts) {
            // unfortunately the predicates must be extracted every single time
            // as they cannot be cached due to references to parameters(vars) which are no longer valid.
            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)
            var predicates = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(orAlts, function (currAlt) { return currAlt.GATE; });
            for (var t = 0; t < numOfAlts; t++) {
                var currAlt = alts[t];
                var currNumOfPaths = currAlt.length;
                var currPredicate = predicates[t];
                if (currPredicate !== undefined &&
                    currPredicate.call(this) === false) {
                    // if the predicate does not match there is no point in checking the paths
                    continue;
                }
                nextPath: for (var j = 0; j < currNumOfPaths; j++) {
                    var currPath = currAlt[j];
                    var currPathLength = currPath.length;
                    for (var i = 0; i < currPathLength; i++) {
                        var nextToken = this.LA(i + 1);
                        if (tokenMatcher(nextToken, currPath[i]) === false) {
                            // mismatch in current path
                            // try the next pth
                            continue nextPath;
                        }
                    }
                    // found a full path that matches.
                    // this will also work for an empty ALT as the loop will be skipped
                    return t;
                }
                // none of the paths for the current alternative matched
                // try the next alternative
            }
            // none of the alternatives could be matched
            return undefined;
        };
    }
    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        // optimized (common) case of all the lookaheads paths requiring only
        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.
        var singleTokenAlts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(alts, function (currAlt) {
            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(currAlt);
        });
        var choiceToAlt_1 = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(singleTokenAlts, function (result, currAlt, idx) {
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currAlt, function (currTokType) {
                if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(result, currTokType.tokenTypeIdx)) {
                    result[currTokType.tokenTypeIdx] = idx;
                }
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currTokType.categoryMatches, function (currExtendingType) {
                    if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(result, currExtendingType)) {
                        result[currExtendingType] = idx;
                    }
                });
            });
            return result;
        }, []);
        /**
         * @returns {number} - The chosen alternative index
         */
        return function () {
            var nextToken = this.LA(1);
            return choiceToAlt_1[nextToken.tokenTypeIdx];
        };
    }
    else {
        // optimized lookahead without needing to check the predicates at all.
        // this causes code duplication which is intentional to improve performance.
        /**
         * @returns {number} - The chosen alternative index
         */
        return function () {
            for (var t = 0; t < numOfAlts; t++) {
                var currAlt = alts[t];
                var currNumOfPaths = currAlt.length;
                nextPath: for (var j = 0; j < currNumOfPaths; j++) {
                    var currPath = currAlt[j];
                    var currPathLength = currPath.length;
                    for (var i = 0; i < currPathLength; i++) {
                        var nextToken = this.LA(i + 1);
                        if (tokenMatcher(nextToken, currPath[i]) === false) {
                            // mismatch in current path
                            // try the next pth
                            continue nextPath;
                        }
                    }
                    // found a full path that matches.
                    // this will also work for an empty ALT as the loop will be skipped
                    return t;
                }
                // none of the paths for the current alternative matched
                // try the next alternative
            }
            // none of the alternatives could be matched
            return undefined;
        };
    }
}
function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
    var areAllOneTokenLookahead = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(alt, function (currPath) {
        return currPath.length === 1;
    });
    var numOfPaths = alt.length;
    // optimized (common) case of all the lookaheads paths requiring only
    // a single token lookahead.
    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        var singleTokensTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)(alt);
        if (singleTokensTypes.length === 1 &&
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(singleTokensTypes[0].categoryMatches)) {
            var expectedTokenType = singleTokensTypes[0];
            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
            return function () {
                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
            };
        }
        else {
            var choiceToAlt_2 = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(singleTokensTypes, function (result, currTokType, idx) {
                result[currTokType.tokenTypeIdx] = true;
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currTokType.categoryMatches, function (currExtendingType) {
                    result[currExtendingType] = true;
                });
                return result;
            }, []);
            return function () {
                var nextToken = this.LA(1);
                return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
            };
        }
    }
    else {
        return function () {
            nextPath: for (var j = 0; j < numOfPaths; j++) {
                var currPath = alt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) {
                        // mismatch in current path
                        // try the next pth
                        continue nextPath;
                    }
                }
                // found a full path that matches.
                return true;
            }
            // none of the paths matched
            return false;
        };
    }
}
var RestDefinitionFinderWalker = /** @class */ (function (_super) {
    __extends(RestDefinitionFinderWalker, _super);
    function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        return _this;
    }
    RestDefinitionFinderWalker.prototype.startWalking = function () {
        this.walk(this.topProd);
        return this.restDef;
    };
    RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {
        if (node.idx === this.targetOccurrence &&
            this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
        }
        // performance optimization, do not iterate over the entire Grammar ast after we have found the target
        return false;
    };
    RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {
        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
        }
    };
    RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
            _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
        }
    };
    return RestDefinitionFinderWalker;
}(_rest__WEBPACK_IMPORTED_MODULE_2__.RestWalker));
/**
 * Returns the definition of a target production in a top level level rule.
 */
var InsideDefinitionFinderVisitor = /** @class */ (function (_super) {
    __extends(InsideDefinitionFinderVisitor, _super);
    function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {
        var _this = _super.call(this) || this;
        _this.targetOccurrence = targetOccurrence;
        _this.targetProdType = targetProdType;
        _this.targetRef = targetRef;
        _this.result = [];
        return _this;
    }
    InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {
        if (node.idx === this.targetOccurrence &&
            this.targetProdType === expectedProdName &&
            (this.targetRef === undefined || node === this.targetRef)) {
            this.result = node.definition;
        }
    };
    InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {
        this.checkIsTarget(node, PROD_TYPE.OPTION);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
    };
    InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
    };
    InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {
        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
    };
    return InsideDefinitionFinderVisitor;
}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_5__.GAstVisitor));
function initializeArrayOfArrays(size) {
    var result = new Array(size);
    for (var i = 0; i < size; i++) {
        result[i] = [];
    }
    return result;
}
/**
 * A sort of hash function between a Path in the grammar and a string.
 * Note that this returns multiple "hashes" to support the scenario of token categories.
 * -  A single path with categories may match multiple **actual** paths.
 */
function pathToHashKeys(path) {
    var keys = [""];
    for (var i = 0; i < path.length; i++) {
        var tokType = path[i];
        var longerKeys = [];
        for (var j = 0; j < keys.length; j++) {
            var currShorterKey = keys[j];
            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
            for (var t = 0; t < tokType.categoryMatches.length; t++) {
                var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
                longerKeys.push(currShorterKey + categoriesKeySuffix);
            }
        }
        keys = longerKeys;
    }
    return keys;
}
/**
 * Imperative style due to being called from a hot spot
 */
function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
    for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        // We only want to test vs the other alternatives
        if (currAltIdx === idx) {
            continue;
        }
        var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
            var searchKey = searchPathKeys[searchIdx];
            if (otherAltKnownPathsKeys[searchKey] === true) {
                return false;
            }
        }
    }
    // None of the SearchPathKeys were found in any of the other alternatives
    return true;
}
function lookAheadSequenceFromAlternatives(altsDefs, k) {
    var partialAlts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(altsDefs, function (currAlt) { return (0,_interpreter__WEBPACK_IMPORTED_MODULE_1__.possiblePathsFrom)([currAlt], 1); });
    var finalResult = initializeArrayOfArrays(partialAlts.length);
    var altsHashes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(partialAlts, function (currAltPaths) {
        var dict = {};
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(currAltPaths, function (item) {
            var keys = pathToHashKeys(item.partialPath);
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(keys, function (currKey) {
                dict[currKey] = true;
            });
        });
        return dict;
    });
    var newData = partialAlts;
    // maxLookahead loop
    for (var pathLength = 1; pathLength <= k; pathLength++) {
        var currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        var _loop_1 = function (altIdx) {
            var currAltPathsAndSuffixes = currDataset[altIdx];
            // paths in current alternative loop
            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
                var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
                var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
                var prefixKeys = pathToHashKeys(currPathPrefix);
                var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);
                // End of the line for this path.
                if (isUnique ||
                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(suffixDef) ||
                    currPathPrefix.length === k) {
                    var currAltResult = finalResult[altIdx];
                    // TODO: Can we implement a containsPath using Maps/Dictionaries?
                    if (containsPath(currAltResult, currPathPrefix) === false) {
                        currAltResult.push(currPathPrefix);
                        // Update all new  keys for the current path.
                        for (var j = 0; j < prefixKeys.length; j++) {
                            var currKey = prefixKeys[j];
                            altsHashes[altIdx][currKey] = true;
                        }
                    }
                }
                // Expand longer paths
                else {
                    var newPartialPathsAndSuffixes = (0,_interpreter__WEBPACK_IMPORTED_MODULE_1__.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);
                    // Update keys for new known paths
                    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(newPartialPathsAndSuffixes, function (item) {
                        var prefixKeys = pathToHashKeys(item.partialPath);
                        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(prefixKeys, function (key) {
                            altsHashes[altIdx][key] = true;
                        });
                    });
                }
            }
        };
        // alternatives loop
        for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
            _loop_1(altIdx);
        }
    }
    return finalResult;
}
function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
    var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
    ruleGrammar.accept(visitor);
    return lookAheadSequenceFromAlternatives(visitor.result, k);
}
function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
    var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
    ruleGrammar.accept(insideDefVisitor);
    var insideDef = insideDefVisitor.result;
    var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
    var afterDef = afterDefWalker.startWalking();
    var insideFlat = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Flat({ definition: insideDef });
    var afterFlat = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_4__.Flat({ definition: afterDef });
    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
}
function containsPath(alternative, searchPath) {
    compareOtherPath: for (var i = 0; i < alternative.length; i++) {
        var otherPath = alternative[i];
        if (otherPath.length !== searchPath.length) {
            continue;
        }
        for (var j = 0; j < otherPath.length; j++) {
            var searchTok = searchPath[j];
            var otherTok = otherPath[j];
            var matchingTokens = searchTok === otherTok ||
                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !==
                    undefined;
            if (matchingTokens === false) {
                continue compareOtherPath;
            }
        }
        return true;
    }
    return false;
}
function isStrictPrefixOfPath(prefix, other) {
    return (prefix.length < other.length &&
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(prefix, function (tokType, idx) {
            var otherTokType = other[idx];
            return (tokType === otherTokType ||
                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);
        }));
}
function areTokenCategoriesNotUsed(lookAheadPaths) {
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(lookAheadPaths, function (singleAltPaths) {
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(singleAltPaths, function (singlePath) {
            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)(singlePath, function (token) { return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(token.categoryMatches); });
        });
    });
}
//# sourceMappingURL=lookahead.js.map

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractNextPossibleTokensWalker: () => (/* binding */ AbstractNextPossibleTokensWalker),
/* harmony export */   AbstractNextTerminalAfterProductionWalker: () => (/* binding */ AbstractNextTerminalAfterProductionWalker),
/* harmony export */   NextAfterTokenWalker: () => (/* binding */ NextAfterTokenWalker),
/* harmony export */   NextTerminalAfterAtLeastOneSepWalker: () => (/* binding */ NextTerminalAfterAtLeastOneSepWalker),
/* harmony export */   NextTerminalAfterAtLeastOneWalker: () => (/* binding */ NextTerminalAfterAtLeastOneWalker),
/* harmony export */   NextTerminalAfterManySepWalker: () => (/* binding */ NextTerminalAfterManySepWalker),
/* harmony export */   NextTerminalAfterManyWalker: () => (/* binding */ NextTerminalAfterManyWalker),
/* harmony export */   nextPossibleTokensAfter: () => (/* binding */ nextPossibleTokensAfter),
/* harmony export */   possiblePathsFrom: () => (/* binding */ possiblePathsFrom)
/* harmony export */ });
/* harmony import */ var _rest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _first__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
/* harmony import */ var _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var AbstractNextPossibleTokensWalker = /** @class */ (function (_super) {
    __extends(AbstractNextPossibleTokensWalker, _super);
    function AbstractNextPossibleTokensWalker(topProd, path) {
        var _this = _super.call(this) || this;
        _this.topProd = topProd;
        _this.path = path;
        _this.possibleTokTypes = [];
        _this.nextProductionName = "";
        _this.nextProductionOccurrence = 0;
        _this.found = false;
        _this.isAtEndOfPath = false;
        return _this;
    }
    AbstractNextPossibleTokensWalker.prototype.startWalking = function () {
        this.found = false;
        if (this.path.ruleStack[0] !== this.topProd.name) {
            throw Error("The path does not start with the walker's top Rule!");
        }
        // immutable for the win
        this.ruleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this.path.ruleStack).reverse(); // intelij bug requires assertion
        this.occurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this.path.occurrenceStack).reverse(); // intelij bug requires assertion
        // already verified that the first production is valid, we now seek the 2nd production
        this.ruleStack.pop();
        this.occurrenceStack.pop();
        this.updateExpectedNext();
        this.walk(this.topProd);
        return this.possibleTokTypes;
    };
    AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {
        if (prevRest === void 0) { prevRest = []; }
        // stop scanning once we found the path
        if (!this.found) {
            _super.prototype.walk.call(this, prod, prevRest);
        }
    };
    AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {
        // found the next production, need to keep walking in it
        if (refProd.referencedRule.name === this.nextProductionName &&
            refProd.idx === this.nextProductionOccurrence) {
            var fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
        }
    };
    AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {
        // need to consume the Terminal
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.ruleStack)) {
            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are
            // really seeking is the last Terminal...
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
        }
        else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
        }
    };
    return AbstractNextPossibleTokensWalker;
}(_rest__WEBPACK_IMPORTED_MODULE_0__.RestWalker));

var NextAfterTokenWalker = /** @class */ (function (_super) {
    __extends(NextAfterTokenWalker, _super);
    function NextAfterTokenWalker(topProd, path) {
        var _this = _super.call(this, topProd, path) || this;
        _this.path = path;
        _this.nextTerminalName = "";
        _this.nextTerminalOccurrence = 0;
        _this.nextTerminalName = _this.path.lastTok.name;
        _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
        return _this;
    }
    NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {
        if (this.isAtEndOfPath &&
            terminal.terminalType.name === this.nextTerminalName &&
            terminal.idx === this.nextTerminalOccurrence &&
            !this.found) {
            var fullRest = currRest.concat(prevRest);
            var restProd = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Flat({ definition: fullRest });
            this.possibleTokTypes = (0,_first__WEBPACK_IMPORTED_MODULE_2__.first)(restProd);
            this.found = true;
        }
    };
    return NextAfterTokenWalker;
}(AbstractNextPossibleTokensWalker));

/**
 * This walker only "walks" a single "TOP" level in the Grammar Ast, this means
 * it never "follows" production refs
 */
var AbstractNextTerminalAfterProductionWalker = /** @class */ (function (_super) {
    __extends(AbstractNextTerminalAfterProductionWalker, _super);
    function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {
        var _this = _super.call(this) || this;
        _this.topRule = topRule;
        _this.occurrence = occurrence;
        _this.result = {
            token: undefined,
            occurrence: undefined,
            isEndOfRule: undefined
        };
        return _this;
    }
    AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {
        this.walk(this.topRule);
        return this.result;
    };
    return AbstractNextTerminalAfterProductionWalker;
}(_rest__WEBPACK_IMPORTED_MODULE_0__.RestWalker));

var NextTerminalAfterManyWalker = /** @class */ (function (_super) {
    __extends(NextTerminalAfterManyWalker, _super);
    function NextTerminalAfterManyWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {
        if (manyProd.idx === this.occurrence) {
            var firstAfterMany = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === undefined;
            if (firstAfterMany instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {
                this.result.token = firstAfterMany.terminalType;
                this.result.occurrence = firstAfterMany.idx;
            }
        }
        else {
            _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterManyWalker;
}(AbstractNextTerminalAfterProductionWalker));

var NextTerminalAfterManySepWalker = /** @class */ (function (_super) {
    __extends(NextTerminalAfterManySepWalker, _super);
    function NextTerminalAfterManySepWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {
        if (manySepProd.idx === this.occurrence) {
            var firstAfterManySep = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === undefined;
            if (firstAfterManySep instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {
                this.result.token = firstAfterManySep.terminalType;
                this.result.occurrence = firstAfterManySep.idx;
            }
        }
        else {
            _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterManySepWalker;
}(AbstractNextTerminalAfterProductionWalker));

var NextTerminalAfterAtLeastOneWalker = /** @class */ (function (_super) {
    __extends(NextTerminalAfterAtLeastOneWalker, _super);
    function NextTerminalAfterAtLeastOneWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {
        if (atLeastOneProd.idx === this.occurrence) {
            var firstAfterAtLeastOne = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;
            if (firstAfterAtLeastOne instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {
                this.result.token = firstAfterAtLeastOne.terminalType;
                this.result.occurrence = firstAfterAtLeastOne.idx;
            }
        }
        else {
            _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterAtLeastOneWalker;
}(AbstractNextTerminalAfterProductionWalker));

// TODO: reduce code duplication in the AfterWalkers
var NextTerminalAfterAtLeastOneSepWalker = /** @class */ (function (_super) {
    __extends(NextTerminalAfterAtLeastOneSepWalker, _super);
    function NextTerminalAfterAtLeastOneSepWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {
        if (atleastOneSepProd.idx === this.occurrence) {
            var firstAfterfirstAfterAtLeastOneSep = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(currRest.concat(prevRest));
            this.result.isEndOfRule =
                firstAfterfirstAfterAtLeastOneSep === undefined;
            if (firstAfterfirstAfterAtLeastOneSep instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {
                this.result.token =
                    firstAfterfirstAfterAtLeastOneSep.terminalType;
                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
        }
        else {
            _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
        }
    };
    return NextTerminalAfterAtLeastOneSepWalker;
}(AbstractNextTerminalAfterProductionWalker));

function possiblePathsFrom(targetDef, maxLength, currPath) {
    if (currPath === void 0) { currPath = []; }
    // avoid side effects
    currPath = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currPath);
    var result = [];
    var i = 0;
    // TODO: avoid inner funcs
    function remainingPathWith(nextDef) {
        return nextDef.concat((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(targetDef, i + 1));
    }
    // TODO: avoid inner funcs
    function getAlternativesForProd(definition) {
        var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
    }
    /**
     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the
     * following (rest) of the targetDef.
     *
     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the
     * the optional production.
     */
    while (currPath.length < maxLength && i < targetDef.length) {
        var prod = targetDef[i];
        /* istanbul ignore else */
        if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Flat) {
            return getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.NonTerminal) {
            return getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Option) {
            result = getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatory) {
            var newDef = prod.definition.concat([
                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({
                    definition: prod.definition
                })
            ]);
            return getAlternativesForProd(newDef);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatoryWithSeparator) {
            var newDef = [
                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Flat({ definition: prod.definition }),
                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({
                    definition: [
                        new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal({ terminalType: prod.separator })
                    ].concat(prod.definition)
                })
            ];
            return getAlternativesForProd(newDef);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionWithSeparator) {
            var newDef = prod.definition.concat([
                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({
                    definition: [
                        new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal({ terminalType: prod.separator })
                    ].concat(prod.definition)
                })
            ]);
            result = getAlternativesForProd(newDef);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition) {
            var newDef = prod.definition.concat([
                new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({
                    definition: prod.definition
                })
            ]);
            result = getAlternativesForProd(newDef);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Alternation) {
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(prod.definition, function (currAlt) {
                result = getAlternativesForProd(currAlt.definition);
            });
            return result;
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {
            currPath.push(prod.terminalType);
        }
        else {
            throw Error("non exhaustive match");
        }
        i++;
    }
    result.push({
        partialPath: currPath,
        suffixDef: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(targetDef, i)
    });
    return result;
}
function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
    var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
    // to avoid creating a new Array each time.
    var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
    var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
    var foundCompletePath = false;
    var tokenVectorLength = tokenVector.length;
    var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
    var result = [];
    var possiblePaths = [];
    possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: []
    });
    while (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(possiblePaths)) {
        var currPath = possiblePaths.pop();
        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)
        if (currPath === EXIT_ALTERNATIVE) {
            if (foundCompletePath &&
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.last)(possiblePaths).idx <= minimalAlternativesIndex) {
                // remove irrelevant alternative
                possiblePaths.pop();
            }
            continue;
        }
        var currDef = currPath.def;
        var currIdx = currPath.idx;
        var currRuleStack = currPath.ruleStack;
        var currOccurrenceStack = currPath.occurrenceStack;
        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(currDef)) {
            continue;
        }
        var prod = currDef[0];
        /* istanbul ignore else */
        if (prod === EXIT_NON_TERMINAL) {
            var nextPath = {
                idx: currIdx,
                def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),
                ruleStack: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.dropRight)(currRuleStack),
                occurrenceStack: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.dropRight)(currOccurrenceStack)
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal) {
            /* istanbul ignore else */
            if (currIdx < tokenVectorLength - 1) {
                var nextIdx = currIdx + 1;
                var actualToken = tokenVector[nextIdx];
                if (tokMatcher(actualToken, prod.terminalType)) {
                    var nextPath = {
                        idx: nextIdx,
                        def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),
                        ruleStack: currRuleStack,
                        occurrenceStack: currOccurrenceStack
                    };
                    possiblePaths.push(nextPath);
                }
                // end of the line
            }
            else if (currIdx === tokenVectorLength - 1) {
                // IGNORE ABOVE ELSE
                result.push({
                    nextTokenType: prod.terminalType,
                    nextTokenOccurrence: prod.idx,
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack
                });
                foundCompletePath = true;
            }
            else {
                throw Error("non exhaustive match");
            }
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.NonTerminal) {
            var newRuleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currRuleStack);
            newRuleStack.push(prod.nonTerminalName);
            var newOccurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currOccurrenceStack);
            newOccurrenceStack.push(prod.idx);
            var nextPath = {
                idx: currIdx,
                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef)),
                ruleStack: newRuleStack,
                occurrenceStack: newOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Option) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nextPathWith = {
                idx: currIdx,
                def: prod.definition.concat((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatory) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            var secondIteration = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({
                definition: prod.definition,
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef));
            var nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatoryWithSeparator) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            var separatorGast = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal({
                terminalType: prod.separator
            });
            var secondIteration = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({
                definition: [separatorGast].concat(prod.definition),
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef));
            var nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.RepetitionWithSeparator) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            var separatorGast = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Terminal({
                terminalType: prod.separator
            });
            var nthRepetition = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({
                definition: [separatorGast].concat(prod.definition),
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef));
            var nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            var nextPathWithout = {
                idx: currIdx,
                def: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?
            var nthRepetition = new _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Repetition({
                definition: prod.definition,
                idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef));
            var nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Alternation) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            for (var i = prod.definition.length - 1; i >= 0; i--) {
                var currAlt = prod.definition[i];
                var currAltPath = {
                    idx: currIdx,
                    def: currAlt.definition.concat((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef)),
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack
                };
                possiblePaths.push(currAltPath);
                possiblePaths.push(EXIT_ALTERNATIVE);
            }
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Flat) {
            possiblePaths.push({
                idx: currIdx,
                def: prod.definition.concat((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.drop)(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
            });
        }
        else if (prod instanceof _gast_gast_public__WEBPACK_IMPORTED_MODULE_3__.Rule) {
            // last because we should only encounter at most a single one of these per invocation.
            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        }
        else {
            throw Error("non exhaustive match");
        }
    }
    return result;
}
function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
    var newRuleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currRuleStack);
    newRuleStack.push(topRule.name);
    var newCurrOccurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(currOccurrenceStack);
    // top rule is always assumed to have been called with occurrence index 1
    newCurrOccurrenceStack.push(1);
    return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack
    };
}
//# sourceMappingURL=interpreter.js.map

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assignOccurrenceIndices: () => (/* binding */ assignOccurrenceIndices),
/* harmony export */   resolveGrammar: () => (/* binding */ resolveGrammar),
/* harmony export */   validateGrammar: () => (/* binding */ validateGrammar)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _resolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _checks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);
/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
/* harmony import */ var _gast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);





function resolveGrammar(options) {
    options = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.defaults)(options, {
        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultGrammarResolverErrorProvider
    });
    var topRulesTable = {};
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(options.rules, function (rule) {
        topRulesTable[rule.name] = rule;
    });
    return (0,_resolver__WEBPACK_IMPORTED_MODULE_1__.resolveGrammar)(topRulesTable, options.errMsgProvider);
}
function validateGrammar(options) {
    options = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.defaults)(options, {
        errMsgProvider: _errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultGrammarValidatorErrorProvider,
        ignoredIssues: {}
    });
    return (0,_checks__WEBPACK_IMPORTED_MODULE_2__.validateGrammar)(options.rules, options.maxLookahead, options.tokenTypes, options.ignoredIssues, options.errMsgProvider, options.grammarName);
}
function assignOccurrenceIndices(options) {
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(options.rules, function (currRule) {
        var methodsCollector = new _gast__WEBPACK_IMPORTED_MODULE_4__.DslMethodsCollectorVisitor();
        currRule.accept(methodsCollector);
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(methodsCollector.dslMethods, function (methods) {
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(methods, function (currMethod, arrIdx) {
                currMethod.idx = arrIdx + 1;
            });
        });
    });
}
//# sourceMappingURL=gast_resolver_public.js.map

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GastRefResolverVisitor: () => (/* binding */ GastRefResolverVisitor),
/* harmony export */   resolveGrammar: () => (/* binding */ resolveGrammar)
/* harmony export */ });
/* harmony import */ var _parser_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



function resolveGrammar(topLevels, errMsgProvider) {
    var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
    refResolver.resolveRefs();
    return refResolver.errors;
}
var GastRefResolverVisitor = /** @class */ (function (_super) {
    __extends(GastRefResolverVisitor, _super);
    function GastRefResolverVisitor(nameToTopRule, errMsgProvider) {
        var _this = _super.call(this) || this;
        _this.nameToTopRule = nameToTopRule;
        _this.errMsgProvider = errMsgProvider;
        _this.errors = [];
        return _this;
    }
    GastRefResolverVisitor.prototype.resolveRefs = function () {
        var _this = this;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.values)(this.nameToTopRule), function (prod) {
            _this.currTopLevel = prod;
            prod.accept(_this);
        });
    };
    GastRefResolverVisitor.prototype.visitNonTerminal = function (node) {
        var ref = this.nameToTopRule[node.nonTerminalName];
        if (!ref) {
            var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
                message: msg,
                type: _parser_parser__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
                ruleName: this.currTopLevel.name,
                unresolvedRefName: node.nonTerminalName
            });
        }
        else {
            node.referencedRule = ref;
        }
    };
    return GastRefResolverVisitor;
}(_gast_gast_visitor_public__WEBPACK_IMPORTED_MODULE_2__.GAstVisitor));

//# sourceMappingURL=resolver.js.map

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EOF_FOLLOW_KEY: () => (/* binding */ EOF_FOLLOW_KEY),
/* harmony export */   IN_RULE_RECOVERY_EXCEPTION: () => (/* binding */ IN_RULE_RECOVERY_EXCEPTION),
/* harmony export */   InRuleRecoveryException: () => (/* binding */ InRuleRecoveryException),
/* harmony export */   Recoverable: () => (/* binding */ Recoverable),
/* harmony export */   attemptInRepetitionRecovery: () => (/* binding */ attemptInRepetitionRecovery)
/* harmony export */ });
/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);





var EOF_FOLLOW_KEY = {};
var IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
function InRuleRecoveryException(message) {
    this.name = IN_RULE_RECOVERY_EXCEPTION;
    this.message = message;
}
InRuleRecoveryException.prototype = Error.prototype;
/**
 * This trait is responsible for the error recovery and fault tolerant logic
 */
var Recoverable = /** @class */ (function () {
    function Recoverable() {
    }
    Recoverable.prototype.initRecoverable = function (config) {
        this.firstAfterRepMap = {};
        this.resyncFollows = {};
        this.recoveryEnabled = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, "recoveryEnabled")
            ? config.recoveryEnabled
            : _parser__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_PARSER_CONFIG.recoveryEnabled;
        // performance optimization, NOOP will be inlined which
        // effectively means that this optional feature does not exist
        // when not used.
        if (this.recoveryEnabled) {
            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
        }
    };
    Recoverable.prototype.getTokenToInsert = function (tokType) {
        var tokToInsert = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
        tokToInsert.isInsertedInRecovery = true;
        return tokToInsert;
    };
    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {
        return true;
    };
    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
        var _this = this;
        // TODO: can the resyncTokenType be cached?
        var reSyncTokType = this.findReSyncTokenType();
        var savedLexerState = this.exportLexerState();
        var resyncedTokens = [];
        var passedResyncPoint = false;
        var nextTokenWithoutResync = this.LA(1);
        var currToken = this.LA(1);
        var generateErrorMessage = function () {
            var previousToken = _this.LA(0);
            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce
            // the error that would have been thrown
            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
                expected: expectedTokType,
                actual: nextTokenWithoutResync,
                previous: previousToken,
                ruleName: _this.getCurrRuleFullName()
            });
            var error = new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.
            error.resyncedTokens = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.dropRight)(resyncedTokens);
            _this.SAVE_ERROR(error);
        };
        while (!passedResyncPoint) {
            // re-synced to a point where we can safely exit the repetition/
            if (this.tokenMatcher(currToken, expectedTokType)) {
                generateErrorMessage();
                return; // must return here to avoid reverting the inputIdx
            }
            else if (lookAheadFunc.call(this)) {
                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule
                generateErrorMessage();
                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule
                grammarRule.apply(this, grammarRuleArgs);
                return; // must return here to avoid reverting the inputIdx
            }
            else if (this.tokenMatcher(currToken, reSyncTokType)) {
                passedResyncPoint = true;
            }
            else {
                currToken = this.SKIP_TOKEN();
                this.addToResyncTokens(currToken, resyncedTokens);
            }
        }
        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.
        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by
        // "between rules" resync recovery later in the flow.
        this.importLexerState(savedLexerState);
    };
    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {
        // Edge case of arriving from a MANY repetition which is stuck
        // Attempting recovery in this case could cause an infinite loop
        if (notStuck === false) {
            return false;
        }
        // arguments to try and perform resync into the next iteration of the many are missing
        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {
            return false;
        }
        // no need to recover, next token is what we expect...
        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
            return false;
        }
        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path
        // and prefer some backtracking path that includes recovered errors.
        if (this.isBackTracking()) {
            return false;
        }
        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm
        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)
        //noinspection RedundantIfStatementJS
        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
            return false;
        }
        return true;
    };
    // Error Recovery functionality
    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {
        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
        var follows = this.getNextPossibleTokenTypes(grammarPath);
        return follows;
    };
    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {
        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            var tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
        }
        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            var nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
        }
        throw new InRuleRecoveryException("sad sad panda");
    };
    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {
        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||
            this.canRecoverWithSingleTokenDeletion(expectedToken));
    };
    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {
        var _this = this;
        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
            return false;
        }
        // must know the possible following tokens to perform single token insertion
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(follows)) {
            return false;
        }
        var mismatchedTok = this.LA(1);
        var isMisMatchedTokInFollows = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.find)(follows, function (possibleFollowsTokType) {
            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
        }) !== undefined;
        return isMisMatchedTokInFollows;
    };
    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {
        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
        return isNextTokenWhatIsExpected;
    };
    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {
        var followKey = this.getCurrFollowKey();
        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(currentRuleReSyncSet, tokenTypeIdx);
    };
    Recoverable.prototype.findReSyncTokenType = function () {
        var allPossibleReSyncTokTypes = this.flattenFollowSet();
        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input
        var nextToken = this.LA(1);
        var k = 2;
        while (true) {
            var nextTokenType = nextToken.tokenType;
            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.contains)(allPossibleReSyncTokTypes, nextTokenType)) {
                return nextTokenType;
            }
            nextToken = this.LA(k);
            k++;
        }
    };
    Recoverable.prototype.getCurrFollowKey = function () {
        // the length is at least one as we always add the ruleName to the stack before invoking the rule.
        if (this.RULE_STACK.length === 1) {
            return EOF_FOLLOW_KEY;
        }
        var currRuleShortName = this.getLastExplicitRuleShortName();
        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
        var prevRuleShortName = this.getPreviousExplicitRuleShortName();
        return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName)
        };
    };
    Recoverable.prototype.buildFullFollowKeyStack = function () {
        var _this = this;
        var explicitRuleStack = this.RULE_STACK;
        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.LAST_EXPLICIT_RULE_STACK)) {
            explicitRuleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_STACK[idx]; });
            explicitOccurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.LAST_EXPLICIT_RULE_STACK, function (idx) { return _this.RULE_OCCURRENCE_STACK[idx]; });
        }
        // TODO: only iterate over explicit rules here
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(explicitRuleStack, function (ruleName, idx) {
            if (idx === 0) {
                return EOF_FOLLOW_KEY;
            }
            return {
                ruleName: _this.shortRuleNameToFullName(ruleName),
                idxInCallingRule: explicitOccurrenceStack[idx],
                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
            };
        });
    };
    Recoverable.prototype.flattenFollowSet = function () {
        var _this = this;
        var followStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.buildFullFollowKeyStack(), function (currKey) {
            return _this.getFollowSetFromFollowKey(currKey);
        });
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.flatten)(followStack);
    };
    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {
        if (followKey === EOF_FOLLOW_KEY) {
            return [_scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.EOF];
        }
        var followName = followKey.ruleName +
            followKey.idxInCallingRule +
            _constants__WEBPACK_IMPORTED_MODULE_3__.IN +
            followKey.inRule;
        return this.resyncFollows[followName];
    };
    // It does not make any sense to include a virtual EOF token in the list of resynced tokens
    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {
        if (!this.tokenMatcher(token, _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.EOF)) {
            resyncTokens.push(token);
        }
        return resyncTokens;
    };
    Recoverable.prototype.reSyncTo = function (tokType) {
        var resyncedTokens = [];
        var nextTok = this.LA(1);
        while (this.tokenMatcher(nextTok, tokType) === false) {
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
        }
        // the last token is not part of the error.
        return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.dropRight)(resyncedTokens);
    };
    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        // by default this is a NO-OP
        // The actual implementation is with the function(not method) below
    };
    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {
        var pathRuleStack = this.getHumanReadableRuleStack();
        var pathOccurrenceStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this.RULE_OCCURRENCE_STACK);
        var grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule
        };
        return grammarPath;
    };
    Recoverable.prototype.getHumanReadableRuleStack = function () {
        var _this = this;
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(this.LAST_EXPLICIT_RULE_STACK)) {
            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.LAST_EXPLICIT_RULE_STACK, function (currIdx) {
                return _this.shortRuleNameToFullName(_this.RULE_STACK[currIdx]);
            });
        }
        else {
            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.map)(this.RULE_STACK, function (currShortName) {
                return _this.shortRuleNameToFullName(currShortName);
            });
        }
    };
    return Recoverable;
}());

function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
    var firstAfterRepInfo = this.firstAfterRepMap[key];
    if (firstAfterRepInfo === undefined) {
        var currRuleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[currRuleName];
        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
    }
    var expectTokAfterLastMatch = firstAfterRepInfo.token;
    var nextTokIdx = firstAfterRepInfo.occurrence;
    var isEndOfRule = firstAfterRepInfo.isEndOfRule;
    // special edge case of a TOP most repetition after which the input should END.
    // this will force an attempt for inRule recovery in that scenario.
    if (this.RULE_STACK.length === 1 &&
        isEndOfRule &&
        expectTokAfterLastMatch === undefined) {
        expectTokAfterLastMatch = _scan_tokens_public__WEBPACK_IMPORTED_MODULE_0__.EOF;
        nextTokIdx = 1;
    }
    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        // TODO: performance optimization: instead of passing the original args here, we modify
        // the args param (or create a new one) and make sure the lookahead func is explicitly provided
        // to avoid searching the cache for it once more.
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
    }
}
//# sourceMappingURL=recoverable.js.map

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EarlyExitException: () => (/* binding */ EarlyExitException),
/* harmony export */   MismatchedTokenException: () => (/* binding */ MismatchedTokenException),
/* harmony export */   NoViableAltException: () => (/* binding */ NoViableAltException),
/* harmony export */   NotAllInputParsedException: () => (/* binding */ NotAllInputParsedException),
/* harmony export */   isRecognitionException: () => (/* binding */ isRecognitionException)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);

var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
var EARLY_EXIT_EXCEPTION = "EarlyExitException";
var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
var RECOGNITION_EXCEPTION_NAMES = [
    MISMATCHED_TOKEN_EXCEPTION,
    NO_VIABLE_ALT_EXCEPTION,
    EARLY_EXIT_EXCEPTION,
    NOT_ALL_INPUT_PARSED_EXCEPTION
];
Object.freeze(RECOGNITION_EXCEPTION_NAMES);
// hacks to bypass no support for custom Errors in javascript/typescript
function isRecognitionException(error) {
    // can't do instanceof on hacked custom js exceptions
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(RECOGNITION_EXCEPTION_NAMES, error.name);
}
function MismatchedTokenException(message, token, previousToken) {
    this.name = MISMATCHED_TOKEN_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
// must use the "Error.prototype" instead of "new Error"
// because the stack trace points to where "new Error" was invoked"
MismatchedTokenException.prototype = Error.prototype;
function NoViableAltException(message, token, previousToken) {
    this.name = NO_VIABLE_ALT_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
NoViableAltException.prototype = Error.prototype;
function NotAllInputParsedException(message, token) {
    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
    this.message = message;
    this.token = token;
    this.resyncedTokens = [];
}
NotAllInputParsedException.prototype = Error.prototype;
function EarlyExitException(message, token, previousToken) {
    this.name = EARLY_EXIT_EXCEPTION;
    this.message = message;
    this.token = token;
    this.previousToken = previousToken;
    this.resyncedTokens = [];
}
EarlyExitException.prototype = Error.prototype;
//# sourceMappingURL=exceptions_public.js.map

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LooksAhead: () => (/* binding */ LooksAhead)
/* harmony export */ });
/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);
/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34);
/* harmony import */ var _grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);





/**
 * Trait responsible for the lookahead related utilities and optimizations.
 */
var LooksAhead = /** @class */ (function () {
    function LooksAhead() {
    }
    LooksAhead.prototype.initLooksAhead = function (config) {
        this.dynamicTokensEnabled = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, "dynamicTokensEnabled")
            ? config.dynamicTokensEnabled
            : _parser__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
        this.maxLookahead = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, "maxLookahead")
            ? config.maxLookahead
            : _parser__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_PARSER_CONFIG.maxLookahead;
        /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
        this.lookAheadFuncsCache = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isES2015MapSupported)() ? new Map() : [];
        // Performance optimization on newer engines that support ES6 Map
        // For larger Maps this is slightly faster than using a plain object (array in our case).
        /* istanbul ignore else - The else branch will be tested on older node.js versions and IE11 */
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isES2015MapSupported)()) {
            this.getLaFuncFromCache = this.getLaFuncFromMap;
            this.setLaFuncCache = this.setLaFuncCacheUsingMap;
        }
        else {
            this.getLaFuncFromCache = this.getLaFuncFromObj;
            this.setLaFuncCache = this.setLaFuncUsingObj;
        }
    };
    LooksAhead.prototype.preComputeLookaheadFunctions = function (rules) {
        var _this = this;
        (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(rules, function (currRule) {
            _this.TRACE_INIT(currRule.name + " Rule Lookahead", function () {
                var _a = (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.collectMethods)(currRule), alternation = _a.alternation, repetition = _a.repetition, option = _a.option, repetitionMandatory = _a.repetitionMandatory, repetitionMandatoryWithSeparator = _a.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a.repetitionWithSeparator;
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(alternation, function (currProd) {
                    var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                    _this.TRACE_INIT("" + (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd) + prodIdx, function () {
                        var laFunc = (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.buildLookaheadFuncForOr)(currProd.idx, currRule, currProd.maxLookahead || _this.maxLookahead, currProd.hasPredicates, _this.dynamicTokensEnabled, _this.lookAheadBuilderForAlternatives);
                        var key = (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_3__.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.OR_IDX, currProd.idx);
                        _this.setLaFuncCache(key, laFunc);
                    });
                });
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(repetition, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.MANY_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.REPETITION, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));
                });
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(option, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.OPTION_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.OPTION, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));
                });
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(repetitionMandatory, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.AT_LEAST_ONE_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.REPETITION_MANDATORY, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));
                });
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(repetitionMandatoryWithSeparator, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.AT_LEAST_ONE_SEP_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));
                });
                (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.forEach)(repetitionWithSeparator, function (currProd) {
                    _this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys__WEBPACK_IMPORTED_MODULE_3__.MANY_SEP_IDX, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.PROD_TYPE.REPETITION_WITH_SEPARATOR, currProd.maxLookahead, (0,_grammar_gast_gast__WEBPACK_IMPORTED_MODULE_4__.getProductionDslName)(currProd));
                });
            });
        });
    };
    LooksAhead.prototype.computeLookaheadFunc = function (rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
        var _this = this;
        this.TRACE_INIT("" + dslMethodName + (prodOccurrence === 0 ? "" : prodOccurrence), function () {
            var laFunc = (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.buildLookaheadFuncForOptionalProd)(prodOccurrence, rule, prodMaxLookahead || _this.maxLookahead, _this.dynamicTokensEnabled, prodType, _this.lookAheadBuilderForOptional);
            var key = (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_3__.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            _this.setLaFuncCache(key, laFunc);
        });
    };
    LooksAhead.prototype.lookAheadBuilderForOptional = function (alt, tokenMatcher, dynamicTokensEnabled) {
        return (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.buildSingleAlternativeLookaheadFunction)(alt, tokenMatcher, dynamicTokensEnabled);
    };
    LooksAhead.prototype.lookAheadBuilderForAlternatives = function (alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
        return (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_0__.buildAlternativesLookAheadFunc)(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled);
    };
    // this actually returns a number, but it is always used as a string (object prop key)
    LooksAhead.prototype.getKeyForAutomaticLookahead = function (dslMethodIdx, occurrence) {
        var currRuleShortName = this.getLastExplicitRuleShortName();
        return (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_3__.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
    };
    /* istanbul ignore next */
    LooksAhead.prototype.getLaFuncFromCache = function (key) {
        return undefined;
    };
    LooksAhead.prototype.getLaFuncFromMap = function (key) {
        return this.lookAheadFuncsCache.get(key);
    };
    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
    LooksAhead.prototype.getLaFuncFromObj = function (key) {
        return this.lookAheadFuncsCache[key];
    };
    /* istanbul ignore next */
    LooksAhead.prototype.setLaFuncCache = function (key, value) { };
    LooksAhead.prototype.setLaFuncCacheUsingMap = function (key, value) {
        this.lookAheadFuncsCache.set(key, value);
    };
    /* istanbul ignore next - Using plain array as dictionary will be tested on older node.js versions and IE11 */
    LooksAhead.prototype.setLaFuncUsingObj = function (key, value) {
        this.lookAheadFuncsCache[key] = value;
    };
    return LooksAhead;
}());

//# sourceMappingURL=looksahead.js.map

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TreeBuilder: () => (/* binding */ TreeBuilder)
/* harmony export */ });
/* harmony import */ var _cst_cst__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);





/**
 * This trait is responsible for the CST building logic.
 */
var TreeBuilder = /** @class */ (function () {
    function TreeBuilder() {
    }
    TreeBuilder.prototype.initTreeBuilder = function (config) {
        this.LAST_EXPLICIT_RULE_STACK = [];
        this.CST_STACK = [];
        this.outputCst = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, "outputCst")
            ? config.outputCst
            : _parser__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_PARSER_CONFIG.outputCst;
        this.nodeLocationTracking = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.has)(config, "nodeLocationTracking")
            ? config.nodeLocationTracking
            : _parser__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
        if (!this.outputCst) {
            this.cstInvocationStateUpdate = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            this.cstFinallyStateUpdate = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            this.cstPostTerminal = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            this.cstPostNonTerminal = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            this.getLastExplicitRuleShortName = this.getLastExplicitRuleShortNameNoCst;
            this.getPreviousExplicitRuleShortName = this.getPreviousExplicitRuleShortNameNoCst;
            this.getLastExplicitRuleOccurrenceIndex = this.getLastExplicitRuleOccurrenceIndexNoCst;
            this.manyInternal = this.manyInternalNoCst;
            this.orInternal = this.orInternalNoCst;
            this.optionInternal = this.optionInternalNoCst;
            this.atLeastOneInternal = this.atLeastOneInternalNoCst;
            this.manySepFirstInternal = this.manySepFirstInternalNoCst;
            this.atLeastOneSepFirstInternal = this.atLeastOneSepFirstInternalNoCst;
        }
        else {
            if (/full/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = _cst_cst__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationFull;
                    this.setNodeLocationFromNode = _cst_cst__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationFull;
                    this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
                }
                else {
                    this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                    this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                    this.cstPostRule = this.cstPostRuleFull;
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
                }
            }
            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = (_cst_cst__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationOnlyOffset);
                    this.setNodeLocationFromNode = (_cst_cst__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationOnlyOffset);
                    this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
                }
                else {
                    this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                    this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                    this.cstPostRule = this.cstPostRuleOnlyOffset;
                    this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
                }
            }
            else if (/none/i.test(this.nodeLocationTracking)) {
                this.setNodeLocationFromToken = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                this.setNodeLocationFromNode = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                this.cstPostRule = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
                this.setInitialNodeLocation = _utils_utils__WEBPACK_IMPORTED_MODULE_1__.NOOP;
            }
            else {
                throw Error("Invalid <nodeLocationTracking> config option: \"" + config.nodeLocationTracking + "\"");
            }
        }
    };
    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {
        cstNode.location = {
            startOffset: NaN,
            endOffset: NaN
        };
    };
    TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {
        cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN
        };
    };
    TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {
        cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
        };
    };
    /**
     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work

     * @param cstNode
     */
    TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {
        var nextToken = this.LA(1);
        cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN
        };
    };
    // CST
    TreeBuilder.prototype.cstNestedInvocationStateUpdate = function (nestedName, shortName) {
        var cstNode = {
            name: nestedName,
            fullName: this.shortRuleNameToFull[this.getLastExplicitRuleShortName()] +
                nestedName,
            children: {}
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
    };
    TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName, shortName) {
        this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length - 1);
        var cstNode = {
            name: fullRuleName,
            children: {}
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
    };
    TreeBuilder.prototype.cstFinallyStateUpdate = function () {
        this.LAST_EXPLICIT_RULE_STACK.pop();
        this.CST_STACK.pop();
    };
    TreeBuilder.prototype.cstNestedFinallyStateUpdate = function () {
        var lastCstNode = this.CST_STACK.pop();
        // TODO: the naming is bad, this should go directly to the
        //       (correct) cstLocation update method
        //       e.g if we put other logic in postRule...
        this.cstPostRule(lastCstNode);
    };
    TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode or its nested children.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
        }
        // "empty" CstNode edge case
        else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
        }
    };
    TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {
        var prevToken = this.LA(0);
        var loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode or its nested children.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
        }
        // "empty" CstNode edge case
        else {
            loc.startOffset = NaN;
        }
    };
    TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {
        var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
        (0,_cst_cst__WEBPACK_IMPORTED_MODULE_0__.addTerminalToCst)(rootCst, consumedToken, key);
        // This is only used when **both** error recovery and CST Output are enabled.
        this.setNodeLocationFromToken(rootCst.location, consumedToken);
    };
    TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {
        // Avoid side effects due to back tracking
        // TODO: This costs a 2-3% in performance, A flag on IParserConfig
        //   could be used to get rid of this conditional, but not sure its worth the effort
        //   and API complexity.
        if (this.isBackTracking() !== true) {
            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
            (0,_cst_cst__WEBPACK_IMPORTED_MODULE_0__.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
            // This is only used when **both** error recovery and CST Output are enabled.
            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
        }
    };
    TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(this.baseCstVisitorConstructor)) {
            var newBaseCstVisitorConstructor = (0,_cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__.createBaseSemanticVisitorConstructor)(this.className, this.allRuleNames);
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
        }
        return this.baseCstVisitorConstructor;
    };
    TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(this.baseCstVisitorWithDefaultsConstructor)) {
            var newConstructor = (0,_cst_cst_visitor__WEBPACK_IMPORTED_MODULE_2__.createBaseVisitorConstructorWithDefaults)(this.className, this.allRuleNames, this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
        }
        return this.baseCstVisitorWithDefaultsConstructor;
    };
    TreeBuilder.prototype.nestedRuleBeforeClause = function (methodOpts, laKey) {
        var nestedName;
        if (methodOpts.NAME !== undefined) {
            nestedName = methodOpts.NAME;
            this.nestedRuleInvocationStateUpdate(nestedName, laKey);
            return nestedName;
        }
        else {
            return undefined;
        }
    };
    TreeBuilder.prototype.nestedAltBeforeClause = function (methodOpts, occurrence, methodKeyIdx, altIdx) {
        var ruleIdx = this.getLastExplicitRuleShortName();
        var shortName = (0,_grammar_keys__WEBPACK_IMPORTED_MODULE_3__.getKeyForAltIndex)(ruleIdx, methodKeyIdx, occurrence, altIdx);
        var nestedName;
        if (methodOpts.NAME !== undefined) {
            nestedName = methodOpts.NAME;
            this.nestedRuleInvocationStateUpdate(nestedName, shortName);
            return {
                shortName: shortName,
                nestedName: nestedName
            };
        }
        else {
            return undefined;
        }
    };
    TreeBuilder.prototype.nestedRuleFinallyClause = function (laKey, nestedName) {
        var cstStack = this.CST_STACK;
        var nestedRuleCst = cstStack[cstStack.length - 1];
        this.nestedRuleFinallyStateUpdate();
        // this return a different result than the previous invocation because "nestedRuleFinallyStateUpdate" pops the cst stack
        var parentCstNode = cstStack[cstStack.length - 1];
        (0,_cst_cst__WEBPACK_IMPORTED_MODULE_0__.addNoneTerminalToCst)(parentCstNode, nestedName, nestedRuleCst);
        this.setNodeLocationFromNode(parentCstNode.location, nestedRuleCst.location);
    };
    TreeBuilder.prototype.getLastExplicitRuleShortName = function () {
        var lastExplictIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];
        return this.RULE_STACK[lastExplictIndex];
    };
    TreeBuilder.prototype.getLastExplicitRuleShortNameNoCst = function () {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 1];
    };
    TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {
        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 2];
        return this.RULE_STACK[lastExplicitIndex];
    };
    TreeBuilder.prototype.getPreviousExplicitRuleShortNameNoCst = function () {
        var ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 2];
    };
    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {
        var lastExplicitIndex = this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length - 1];
        return this.RULE_OCCURRENCE_STACK[lastExplicitIndex];
    };
    TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndexNoCst = function () {
        var occurrenceStack = this.RULE_OCCURRENCE_STACK;
        return occurrenceStack[occurrenceStack.length - 1];
    };
    TreeBuilder.prototype.nestedRuleInvocationStateUpdate = function (nestedRuleName, shortNameKey) {
        this.RULE_OCCURRENCE_STACK.push(1);
        this.RULE_STACK.push(shortNameKey);
        this.cstNestedInvocationStateUpdate(nestedRuleName, shortNameKey);
    };
    TreeBuilder.prototype.nestedRuleFinallyStateUpdate = function () {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        // NOOP when cst is disabled
        this.cstNestedFinallyStateUpdate();
    };
    return TreeBuilder;
}());

//# sourceMappingURL=tree_builder.js.map

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CstVisitorDefinitionError: () => (/* binding */ CstVisitorDefinitionError),
/* harmony export */   createBaseSemanticVisitorConstructor: () => (/* binding */ createBaseSemanticVisitorConstructor),
/* harmony export */   createBaseVisitorConstructorWithDefaults: () => (/* binding */ createBaseVisitorConstructorWithDefaults),
/* harmony export */   defaultVisit: () => (/* binding */ defaultVisit),
/* harmony export */   validateMissingCstMethods: () => (/* binding */ validateMissingCstMethods),
/* harmony export */   validateRedundantMethods: () => (/* binding */ validateRedundantMethods),
/* harmony export */   validateVisitor: () => (/* binding */ validateVisitor)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _grammar_checks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);



function defaultVisit(ctx, param) {
    var childrenNames = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.keys)(ctx);
    var childrenNamesLength = childrenNames.length;
    for (var i = 0; i < childrenNamesLength; i++) {
        var currChildName = childrenNames[i];
        var currChildArray = ctx[currChildName];
        var currChildArrayLength = currChildArray.length;
        for (var j = 0; j < currChildArrayLength; j++) {
            var currChild = currChildArray[j];
            // distinction between Tokens Children and CstNode children
            if (currChild.tokenTypeIdx === undefined) {
                if (currChild.fullName !== undefined) {
                    this[currChild.fullName](currChild.children, param);
                }
                else {
                    this[currChild.name](currChild.children, param);
                }
            }
        }
    }
    // defaultVisit does not support generic out param
    return undefined;
}
function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
    var derivedConstructor = function () { };
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
    var semanticProto = {
        visit: function (cstNode, param) {
            // enables writing more concise visitor methods when CstNode has only a single child
            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(cstNode)) {
                // A CST Node's children dictionary can never have empty arrays as values
                // If a key is defined there will be at least one element in the corresponding value array.
                cstNode = cstNode[0];
            }
            // enables passing optional CstNodes concisely.
            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(cstNode)) {
                return undefined;
            }
            if (cstNode.fullName !== undefined) {
                return this[cstNode.fullName](cstNode.children, param);
            }
            else {
                return this[cstNode.name](cstNode.children, param);
            }
        },
        validateVisitor: function () {
            var semanticDefinitionErrors = validateVisitor(this, ruleNames);
            if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(semanticDefinitionErrors)) {
                var errorMessages = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(semanticDefinitionErrors, function (currDefError) { return currDefError.msg; });
                throw Error("Errors Detected in CST Visitor <" + (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.functionName)(this.constructor) + ">:\n\t" +
                    ("" + errorMessages.join("\n\n").replace(/\n/g, "\n\t")));
            }
        }
    };
    derivedConstructor.prototype = semanticProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    derivedConstructor._RULE_NAMES = ruleNames;
    return derivedConstructor;
}
function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
    var derivedConstructor = function () { };
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
    var withDefaultsProto = Object.create(baseConstructor.prototype);
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(ruleNames, function (ruleName) {
        withDefaultsProto[ruleName] = defaultVisit;
    });
    derivedConstructor.prototype = withDefaultsProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    return derivedConstructor;
}
var CstVisitorDefinitionError;
(function (CstVisitorDefinitionError) {
    CstVisitorDefinitionError[CstVisitorDefinitionError["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
    CstVisitorDefinitionError[CstVisitorDefinitionError["MISSING_METHOD"] = 1] = "MISSING_METHOD";
})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));
function validateVisitor(visitorInstance, ruleNames) {
    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
    var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);
    return missingErrors.concat(redundantErrors);
}
function validateMissingCstMethods(visitorInstance, ruleNames) {
    var errors = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(ruleNames, function (currRuleName) {
        if (!(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(visitorInstance[currRuleName])) {
            return {
                msg: "Missing visitor method: <" + currRuleName + "> on " + (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.functionName)(visitorInstance.constructor) + " CST Visitor.",
                type: CstVisitorDefinitionError.MISSING_METHOD,
                methodName: currRuleName
            };
        }
    });
    return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.compact)(errors);
}
var VALID_PROP_NAMES = ["constructor", "visit", "validateVisitor"];
function validateRedundantMethods(visitorInstance, ruleNames) {
    var errors = [];
    for (var prop in visitorInstance) {
        if (_grammar_checks__WEBPACK_IMPORTED_MODULE_2__.validTermsPattern.test(prop) &&
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(visitorInstance[prop]) &&
            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(VALID_PROP_NAMES, prop) &&
            !(0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(ruleNames, prop)) {
            errors.push({
                msg: "Redundant visitor method: <" + prop + "> on " + (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_1__.functionName)(visitorInstance.constructor) + " CST Visitor\n" +
                    "There is no Grammar Rule corresponding to this method's name.\n" +
                    ("For utility methods on visitor classes use methods names that do not match /" + _grammar_checks__WEBPACK_IMPORTED_MODULE_2__.validTermsPattern.source + "/."),
                type: CstVisitorDefinitionError.REDUNDANT_METHOD,
                methodName: prop
            });
        }
    }
    return errors;
}
//# sourceMappingURL=cst_visitor.js.map

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   classNameFromInstance: () => (/* binding */ classNameFromInstance),
/* harmony export */   defineNameProp: () => (/* binding */ defineNameProp),
/* harmony export */   functionName: () => (/* binding */ functionName)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);

function classNameFromInstance(instance) {
    return functionName(instance.constructor);
}
var FUNC_NAME_REGEXP = /^\s*function\s*(\S*)\s*\(/;
var NAME = "name";
/* istanbul ignore next too many hacks for IE/old versions of node.js here*/
function functionName(func) {
    // Engines that support Function.prototype.name OR the nth (n>1) time after
    // the name has been computed in the following else block.
    var existingNameProp = func.name;
    if (existingNameProp) {
        return existingNameProp;
    }
    // hack for IE and engines that do not support Object.defineProperty on function.name (Node.js 0.10 && 0.12)
    var computedName = func.toString().match(FUNC_NAME_REGEXP)[1];
    return computedName;
}
/**
 * @returns {boolean} - has the property been successfully defined
 */
function defineNameProp(obj, nameValue) {
    var namePropDescriptor = Object.getOwnPropertyDescriptor(obj, NAME);
    /* istanbul ignore else -> will only run in old versions of node.js */
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(namePropDescriptor) || namePropDescriptor.configurable) {
        Object.defineProperty(obj, NAME, {
            enumerable: false,
            configurable: true,
            writable: false,
            value: nameValue
        });
        return true;
    }
    /* istanbul ignore next -> will only run in old versions of node.js */
    return false;
}
//# sourceMappingURL=lang_extensions.js.map

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LexerAdapter: () => (/* binding */ LexerAdapter)
/* harmony export */ });
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);

/**
 * Trait responsible abstracting over the interaction with Lexer output (Token vector).
 *
 * This could be generalized to support other kinds of lexers, e.g.
 * - Just in Time Lexing / Lexer-Less parsing.
 * - Streaming Lexer.
 */
var LexerAdapter = /** @class */ (function () {
    function LexerAdapter() {
    }
    LexerAdapter.prototype.initLexerAdapter = function () {
        this.tokVector = [];
        this.tokVectorLength = 0;
        this.currIdx = -1;
    };
    Object.defineProperty(LexerAdapter.prototype, "input", {
        get: function () {
            return this.tokVector;
        },
        set: function (newInput) {
            if (this.selfAnalysisDone !== true) {
                throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
            }
            this.reset();
            this.tokVector = newInput;
            this.tokVectorLength = newInput.length;
        },
        enumerable: true,
        configurable: true
    });
    // skips a token and returns the next token
    LexerAdapter.prototype.SKIP_TOKEN = function () {
        if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
        }
        else {
            return _parser__WEBPACK_IMPORTED_MODULE_0__.END_OF_FILE;
        }
    };
    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
    // or lexers dependent on parser context.
    LexerAdapter.prototype.LA = function (howMuch) {
        var soughtIdx = this.currIdx + howMuch;
        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
            return _parser__WEBPACK_IMPORTED_MODULE_0__.END_OF_FILE;
        }
        else {
            return this.tokVector[soughtIdx];
        }
    };
    LexerAdapter.prototype.consumeToken = function () {
        this.currIdx++;
    };
    LexerAdapter.prototype.exportLexerState = function () {
        return this.currIdx;
    };
    LexerAdapter.prototype.importLexerState = function (newState) {
        this.currIdx = newState;
    };
    LexerAdapter.prototype.resetLexerState = function () {
        this.currIdx = -1;
    };
    LexerAdapter.prototype.moveToTerminatedState = function () {
        this.currIdx = this.tokVector.length - 1;
    };
    LexerAdapter.prototype.getLexerPosition = function () {
        return this.exportLexerState();
    };
    return LexerAdapter;
}());

//# sourceMappingURL=lexer_adapter.js.map

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RecognizerApi: () => (/* binding */ RecognizerApi)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);
/* harmony import */ var _errors_public__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
/* harmony import */ var _grammar_checks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);
/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20);






/**
 * This trait is responsible for implementing the public API
 * for defining Chevrotain parsers, i.e:
 * - CONSUME
 * - RULE
 * - OPTION
 * - ...
 */
var RecognizerApi = /** @class */ (function () {
    function RecognizerApi() {
    }
    RecognizerApi.prototype.ACTION = function (impl) {
        return impl.call(this);
    };
    RecognizerApi.prototype.consume = function (idx, tokType, options) {
        return this.consumeInternal(tokType, idx, options);
    };
    RecognizerApi.prototype.subrule = function (idx, ruleToCall, options) {
        return this.subruleInternal(ruleToCall, idx, options);
    };
    RecognizerApi.prototype.option = function (idx, actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, idx);
    };
    RecognizerApi.prototype.or = function (idx, altsOrOpts) {
        return this.orInternal(altsOrOpts, idx);
    };
    RecognizerApi.prototype.many = function (idx, actionORMethodDef) {
        return this.manyInternal(idx, actionORMethodDef);
    };
    RecognizerApi.prototype.atLeastOne = function (idx, actionORMethodDef) {
        return this.atLeastOneInternal(idx, actionORMethodDef);
    };
    RecognizerApi.prototype.CONSUME = function (tokType, options) {
        return this.consumeInternal(tokType, 0, options);
    };
    RecognizerApi.prototype.CONSUME1 = function (tokType, options) {
        return this.consumeInternal(tokType, 1, options);
    };
    RecognizerApi.prototype.CONSUME2 = function (tokType, options) {
        return this.consumeInternal(tokType, 2, options);
    };
    RecognizerApi.prototype.CONSUME3 = function (tokType, options) {
        return this.consumeInternal(tokType, 3, options);
    };
    RecognizerApi.prototype.CONSUME4 = function (tokType, options) {
        return this.consumeInternal(tokType, 4, options);
    };
    RecognizerApi.prototype.CONSUME5 = function (tokType, options) {
        return this.consumeInternal(tokType, 5, options);
    };
    RecognizerApi.prototype.CONSUME6 = function (tokType, options) {
        return this.consumeInternal(tokType, 6, options);
    };
    RecognizerApi.prototype.CONSUME7 = function (tokType, options) {
        return this.consumeInternal(tokType, 7, options);
    };
    RecognizerApi.prototype.CONSUME8 = function (tokType, options) {
        return this.consumeInternal(tokType, 8, options);
    };
    RecognizerApi.prototype.CONSUME9 = function (tokType, options) {
        return this.consumeInternal(tokType, 9, options);
    };
    RecognizerApi.prototype.SUBRULE = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 0, options);
    };
    RecognizerApi.prototype.SUBRULE1 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 1, options);
    };
    RecognizerApi.prototype.SUBRULE2 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 2, options);
    };
    RecognizerApi.prototype.SUBRULE3 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 3, options);
    };
    RecognizerApi.prototype.SUBRULE4 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 4, options);
    };
    RecognizerApi.prototype.SUBRULE5 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 5, options);
    };
    RecognizerApi.prototype.SUBRULE6 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 6, options);
    };
    RecognizerApi.prototype.SUBRULE7 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 7, options);
    };
    RecognizerApi.prototype.SUBRULE8 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 8, options);
    };
    RecognizerApi.prototype.SUBRULE9 = function (ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 9, options);
    };
    RecognizerApi.prototype.OPTION = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 0);
    };
    RecognizerApi.prototype.OPTION1 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 1);
    };
    RecognizerApi.prototype.OPTION2 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 2);
    };
    RecognizerApi.prototype.OPTION3 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 3);
    };
    RecognizerApi.prototype.OPTION4 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 4);
    };
    RecognizerApi.prototype.OPTION5 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 5);
    };
    RecognizerApi.prototype.OPTION6 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 6);
    };
    RecognizerApi.prototype.OPTION7 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 7);
    };
    RecognizerApi.prototype.OPTION8 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 8);
    };
    RecognizerApi.prototype.OPTION9 = function (actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 9);
    };
    RecognizerApi.prototype.OR = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 0);
    };
    RecognizerApi.prototype.OR1 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 1);
    };
    RecognizerApi.prototype.OR2 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 2);
    };
    RecognizerApi.prototype.OR3 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 3);
    };
    RecognizerApi.prototype.OR4 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 4);
    };
    RecognizerApi.prototype.OR5 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 5);
    };
    RecognizerApi.prototype.OR6 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 6);
    };
    RecognizerApi.prototype.OR7 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 7);
    };
    RecognizerApi.prototype.OR8 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 8);
    };
    RecognizerApi.prototype.OR9 = function (altsOrOpts) {
        return this.orInternal(altsOrOpts, 9);
    };
    RecognizerApi.prototype.MANY = function (actionORMethodDef) {
        this.manyInternal(0, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY1 = function (actionORMethodDef) {
        this.manyInternal(1, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY2 = function (actionORMethodDef) {
        this.manyInternal(2, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY3 = function (actionORMethodDef) {
        this.manyInternal(3, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY4 = function (actionORMethodDef) {
        this.manyInternal(4, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY5 = function (actionORMethodDef) {
        this.manyInternal(5, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY6 = function (actionORMethodDef) {
        this.manyInternal(6, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY7 = function (actionORMethodDef) {
        this.manyInternal(7, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY8 = function (actionORMethodDef) {
        this.manyInternal(8, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY9 = function (actionORMethodDef) {
        this.manyInternal(9, actionORMethodDef);
    };
    RecognizerApi.prototype.MANY_SEP = function (options) {
        this.manySepFirstInternal(0, options);
    };
    RecognizerApi.prototype.MANY_SEP1 = function (options) {
        this.manySepFirstInternal(1, options);
    };
    RecognizerApi.prototype.MANY_SEP2 = function (options) {
        this.manySepFirstInternal(2, options);
    };
    RecognizerApi.prototype.MANY_SEP3 = function (options) {
        this.manySepFirstInternal(3, options);
    };
    RecognizerApi.prototype.MANY_SEP4 = function (options) {
        this.manySepFirstInternal(4, options);
    };
    RecognizerApi.prototype.MANY_SEP5 = function (options) {
        this.manySepFirstInternal(5, options);
    };
    RecognizerApi.prototype.MANY_SEP6 = function (options) {
        this.manySepFirstInternal(6, options);
    };
    RecognizerApi.prototype.MANY_SEP7 = function (options) {
        this.manySepFirstInternal(7, options);
    };
    RecognizerApi.prototype.MANY_SEP8 = function (options) {
        this.manySepFirstInternal(8, options);
    };
    RecognizerApi.prototype.MANY_SEP9 = function (options) {
        this.manySepFirstInternal(9, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE = function (actionORMethodDef) {
        this.atLeastOneInternal(0, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE1 = function (actionORMethodDef) {
        return this.atLeastOneInternal(1, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE2 = function (actionORMethodDef) {
        this.atLeastOneInternal(2, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE3 = function (actionORMethodDef) {
        this.atLeastOneInternal(3, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE4 = function (actionORMethodDef) {
        this.atLeastOneInternal(4, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE5 = function (actionORMethodDef) {
        this.atLeastOneInternal(5, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE6 = function (actionORMethodDef) {
        this.atLeastOneInternal(6, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE7 = function (actionORMethodDef) {
        this.atLeastOneInternal(7, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE8 = function (actionORMethodDef) {
        this.atLeastOneInternal(8, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE9 = function (actionORMethodDef) {
        this.atLeastOneInternal(9, actionORMethodDef);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP = function (options) {
        this.atLeastOneSepFirstInternal(0, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP1 = function (options) {
        this.atLeastOneSepFirstInternal(1, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP2 = function (options) {
        this.atLeastOneSepFirstInternal(2, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP3 = function (options) {
        this.atLeastOneSepFirstInternal(3, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP4 = function (options) {
        this.atLeastOneSepFirstInternal(4, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP5 = function (options) {
        this.atLeastOneSepFirstInternal(5, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP6 = function (options) {
        this.atLeastOneSepFirstInternal(6, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP7 = function (options) {
        this.atLeastOneSepFirstInternal(7, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP8 = function (options) {
        this.atLeastOneSepFirstInternal(8, options);
    };
    RecognizerApi.prototype.AT_LEAST_ONE_SEP9 = function (options) {
        this.atLeastOneSepFirstInternal(9, options);
    };
    RecognizerApi.prototype.RULE = function (name, implementation, config) {
        if (config === void 0) { config = _parser__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_RULE_CONFIG; }
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.contains)(this.definedRulesNames, name)) {
            var errMsg = _errors_public__WEBPACK_IMPORTED_MODULE_3__.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
                topLevelRule: name,
                grammarName: this.className
            });
            var error = {
                message: errMsg,
                type: _parser__WEBPACK_IMPORTED_MODULE_2__.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
                ruleName: name
            };
            this.definitionErrors.push(error);
        }
        this.definedRulesNames.push(name);
        var ruleImplementation = this.defineRule(name, implementation, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    };
    RecognizerApi.prototype.OVERRIDE_RULE = function (name, impl, config) {
        if (config === void 0) { config = _parser__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_RULE_CONFIG; }
        var ruleErrors = [];
        ruleErrors = ruleErrors.concat((0,_grammar_checks__WEBPACK_IMPORTED_MODULE_4__.validateRuleIsOverridden)(name, this.definedRulesNames, this.className));
        this.definitionErrors.push.apply(this.definitionErrors, ruleErrors); // mutability for the win
        var ruleImplementation = this.defineRule(name, impl, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    };
    RecognizerApi.prototype.BACKTRACK = function (grammarRule, args) {
        return function () {
            // save org state
            this.isBackTrackingStack.push(1);
            var orgState = this.saveRecogState();
            try {
                grammarRule.apply(this, args);
                // if no exception was thrown we have succeed parsing the rule.
                return true;
            }
            catch (e) {
                if ((0,_exceptions_public__WEBPACK_IMPORTED_MODULE_1__.isRecognitionException)(e)) {
                    return false;
                }
                else {
                    throw e;
                }
            }
            finally {
                this.reloadRecogState(orgState);
                this.isBackTrackingStack.pop();
            }
        };
    };
    // GAST export APIs
    RecognizerApi.prototype.getGAstProductions = function () {
        return this.gastProductionsCache;
    };
    RecognizerApi.prototype.getSerializedGastProductions = function () {
        return (0,_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_5__.serializeGrammar)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(this.gastProductionsCache));
    };
    return RecognizerApi;
}());

//# sourceMappingURL=recognizer_api.js.map

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RecognizerEngine: () => (/* binding */ RecognizerEngine)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34);
/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(37);
/* harmony import */ var _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(16);
/* harmony import */ var _recoverable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(41);
/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(21);
/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(27);
/* harmony import */ var _lang_lang_extensions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(46);










/**
 * This trait is responsible for the runtime parsing engine
 * Used by the official API (recognizer_api.ts)
 */
var RecognizerEngine = /** @class */ (function () {
    function RecognizerEngine() {
    }
    RecognizerEngine.prototype.initRecognizerEngine = function (tokenVocabulary, config) {
        this.className = (0,_lang_lang_extensions__WEBPACK_IMPORTED_MODULE_9__.classNameFromInstance)(this);
        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)
        this.shortRuleNameToFull = {};
        this.fullRuleNameToShort = {};
        this.ruleShortNameIdx = 256;
        this.tokenMatcher = _scan_tokens__WEBPACK_IMPORTED_MODULE_8__.tokenStructuredMatcherNoCategories;
        this.definedRulesNames = [];
        this.tokensMap = {};
        this.allRuleNames = [];
        this.isBackTrackingStack = [];
        this.RULE_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
        this.gastProductionsCache = {};
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, "serializedGrammar")) {
            throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n" +
                "\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_6-0-0\n" +
                "\tFor Further details.");
        }
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(tokenVocabulary)) {
            // This only checks for Token vocabularies provided as arrays.
            // That is good enough because the main objective is to detect users of pre-V4.0 APIs
            // rather than all edge cases of empty Token vocabularies.
            if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(tokenVocabulary)) {
                throw Error("A Token Vocabulary cannot be empty.\n" +
                    "\tNote that the first argument for the parser constructor\n" +
                    "\tis no longer a Token vector (since v4.0).");
            }
            if (typeof tokenVocabulary[0].startOffset === "number") {
                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n" +
                    "\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\n" +
                    "\tFor Further details.");
            }
        }
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(tokenVocabulary)) {
            this.tokensMap = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(tokenVocabulary, function (acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        }
        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(tokenVocabulary, "modes") &&
            (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(tokenVocabulary.modes)), _scan_tokens__WEBPACK_IMPORTED_MODULE_8__.isTokenType)) {
            var allTokenTypes = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.flatten)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(tokenVocabulary.modes));
            var uniqueTokens = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.uniq)(allTokenTypes);
            this.tokensMap = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.reduce)(uniqueTokens, function (acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        }
        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isObject)(tokenVocabulary)) {
            this.tokensMap = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneObj)(tokenVocabulary);
        }
        else {
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors," +
                " A dictionary of Token constructors or an IMultiModeLexerDefinition");
        }
        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been
        // parsed with a clear error message ("expecting EOF but found ...")
        /* tslint:disable */
        this.tokensMap["EOF"] = _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__.EOF;
        // TODO: This check may not be accurate for multi mode lexers
        var noTokenCategoriesUsed = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.every)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(tokenVocabulary), function (tokenConstructor) { return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(tokenConstructor.categoryMatches); });
        this.tokenMatcher = noTokenCategoriesUsed
            ? _scan_tokens__WEBPACK_IMPORTED_MODULE_8__.tokenStructuredMatcherNoCategories
            : _scan_tokens__WEBPACK_IMPORTED_MODULE_8__.tokenStructuredMatcher;
        // Because ES2015+ syntax should be supported for creating Token classes
        // We cannot assume that the Token classes were created using the "extendToken" utilities
        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization
        (0,_scan_tokens__WEBPACK_IMPORTED_MODULE_8__.augmentTokenTypes)((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.values)(this.tokensMap));
    };
    RecognizerEngine.prototype.defineRule = function (ruleName, impl, config) {
        if (this.selfAnalysisDone) {
            throw Error("Grammar rule <" + ruleName + "> may not be defined after the 'performSelfAnalysis' method has been called'\n" +
                "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
        }
        var resyncEnabled = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, "resyncEnabled")
            ? config.resyncEnabled
            : _parser__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_RULE_CONFIG.resyncEnabled;
        var recoveryValueFunc = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, "recoveryValueFunc")
            ? config.recoveryValueFunc
            : _parser__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_RULE_CONFIG.recoveryValueFunc;
        // performance optimization: Use small integers as keys for the longer human readable "full" rule names.
        // this greatly improves Map access time (as much as 8% for some performance benchmarks).
        /* tslint:disable */
        var shortName = this.ruleShortNameIdx <<
            (_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.BITS_FOR_METHOD_TYPE + _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.BITS_FOR_OCCURRENCE_IDX);
        /* tslint:enable */
        this.ruleShortNameIdx++;
        this.shortRuleNameToFull[shortName] = ruleName;
        this.fullRuleNameToShort[ruleName] = shortName;
        function invokeRuleWithTry(args) {
            try {
                if (this.outputCst === true) {
                    impl.apply(this, args);
                    var cst = this.CST_STACK[this.CST_STACK.length - 1];
                    this.cstPostRule(cst);
                    return cst;
                }
                else {
                    return impl.apply(this, args);
                }
            }
            catch (e) {
                return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
            }
            finally {
                this.ruleFinallyStateUpdate();
            }
        }
        var wrappedGrammarRule;
        wrappedGrammarRule = function (idxInCallingRule, args) {
            if (idxInCallingRule === void 0) { idxInCallingRule = 0; }
            this.ruleInvocationStateUpdate(shortName, ruleName, idxInCallingRule);
            return invokeRuleWithTry.call(this, args);
        };
        var ruleNamePropName = "ruleName";
        wrappedGrammarRule[ruleNamePropName] = ruleName;
        wrappedGrammarRule["originalGrammarAction"] = impl;
        return wrappedGrammarRule;
    };
    RecognizerEngine.prototype.invokeRuleCatch = function (e, resyncEnabledConfig, recoveryValueFunc) {
        var isFirstInvokedRule = this.RULE_STACK.length === 1;
        // note the reSync is always enabled for the first rule invocation, because we must always be able to
        // reSync with EOF and just output some INVALID ParseTree
        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking
        // path is really the most valid one
        var reSyncEnabled = resyncEnabledConfig &&
            !this.isBackTracking() &&
            this.recoveryEnabled;
        if ((0,_exceptions_public__WEBPACK_IMPORTED_MODULE_2__.isRecognitionException)(e)) {
            var recogError = e;
            if (reSyncEnabled) {
                var reSyncTokType = this.findReSyncTokenType();
                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                    if (this.outputCst) {
                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        return partialCstResult;
                    }
                    else {
                        return recoveryValueFunc();
                    }
                }
                else {
                    if (this.outputCst) {
                        var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        recogError.partialCstResult = partialCstResult;
                    }
                    // to be handled Further up the call stack
                    throw recogError;
                }
            }
            else if (isFirstInvokedRule) {
                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case
                this.moveToTerminatedState();
                // the parser should never throw one of its own errors outside its flow.
                // even if error recovery is disabled
                return recoveryValueFunc();
            }
            else {
                // to be recovered Further up the call stack
                throw recogError;
            }
        }
        else {
            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)
            throw e;
        }
    };
    // Implementation of parsing DSL
    RecognizerEngine.prototype.optionInternal = function (actionORMethodDef, occurrence) {
        var key = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OPTION_IDX, occurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, key);
        try {
            return this.optionInternalLogic(actionORMethodDef, occurrence, key);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(key, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.optionInternalNoCst = function (actionORMethodDef, occurrence) {
        var key = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OPTION_IDX, occurrence);
        return this.optionInternalLogic(actionORMethodDef, occurrence, key);
    };
    RecognizerEngine.prototype.optionInternalLogic = function (actionORMethodDef, occurrence, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_1 = lookAheadFunc;
                lookAheadFunc = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_1.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
            return action.call(this);
        }
        return undefined;
    };
    RecognizerEngine.prototype.atLeastOneInternal = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_IDX, prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);
        try {
            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.atLeastOneInternalNoCst = function (prodOccurrence, actionORMethodDef) {
        var key = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_IDX, prodOccurrence);
        this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key);
    };
    RecognizerEngine.prototype.atLeastOneInternalLogic = function (prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookAheadFunc = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_2 = lookAheadFunc;
                lookAheadFunc = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_2.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
            var notStuck = this.doSingleRepetition(action);
            while (lookAheadFunc.call(this) === true &&
                notStuck === true) {
                notStuck = this.doSingleRepetition(action);
            }
        }
        else {
            throw this.raiseEarlyExitException(prodOccurrence, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
        }
        // note that while it may seem that this can cause an error because by using a recursive call to
        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call
        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_IDX, prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterAtLeastOneWalker);
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternal = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(options, laKey);
        try {
            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternalNoCst = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
    };
    RecognizerEngine.prototype.atLeastOneSepFirstInternalLogic = function (prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLookaheadFunc.call(this) === true) {
            ;
            action.call(this);
            //  TODO: Optimization can move this function construction into "attemptInRepetitionRecovery"
            //  because it is only needed in error recovery scenarios.
            var separatorLookAheadFunc = function () {
                return _this.tokenMatcher(_this.LA(1), separator);
            };
            // 2nd..nth iterations
            while (this.tokenMatcher(this.LA(1), separator) === true) {
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterAtLeastOneSepWalker
            ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX, prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterAtLeastOneSepWalker);
        }
        else {
            throw this.raiseEarlyExitException(prodOccurrence, _grammar_lookahead__WEBPACK_IMPORTED_MODULE_3__.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
        }
    };
    RecognizerEngine.prototype.manyInternal = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_IDX, prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(actionORMethodDef, laKey);
        try {
            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.manyInternalNoCst = function (prodOccurrence, actionORMethodDef) {
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_IDX, prodOccurrence);
        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    };
    RecognizerEngine.prototype.manyInternalLogic = function (prodOccurrence, actionORMethodDef, key) {
        var _this = this;
        var lookaheadFunction = this.getLaFuncFromCache(key);
        var action;
        var predicate;
        if (actionORMethodDef.DEF !== undefined) {
            action = actionORMethodDef.DEF;
            predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                var orgLookaheadFunction_3 = lookaheadFunction;
                lookaheadFunction = function () {
                    return (predicate.call(_this) && orgLookaheadFunction_3.call(_this));
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        var notStuck = true;
        while (lookaheadFunction.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
        }
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_IDX, prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterManyWalker,
        // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
        // An infinite loop cannot occur as:
        // - Either the lookahead is guaranteed to consume something (Single Token Separator)
        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
        notStuck);
    };
    RecognizerEngine.prototype.manySepFirstInternal = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_SEP_IDX, prodOccurrence);
        var nestedName = this.nestedRuleBeforeClause(options, laKey);
        try {
            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.manySepFirstInternalNoCst = function (prodOccurrence, options) {
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_SEP_IDX, prodOccurrence);
        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
    };
    RecognizerEngine.prototype.manySepFirstInternalLogic = function (prodOccurrence, options, key) {
        var _this = this;
        var action = options.DEF;
        var separator = options.SEP;
        var firstIterationLaFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            var separatorLookAheadFunc = function () {
                return _this.tokenMatcher(_this.LA(1), separator);
            };
            // 2nd..nth iterations
            while (this.tokenMatcher(this.LA(1), separator) === true) {
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                // No need for checking infinite loop here due to consuming the separator.
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterManySepWalker
            ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.MANY_SEP_IDX, prodOccurrence, _grammar_interpreter__WEBPACK_IMPORTED_MODULE_4__.NextTerminalAfterManySepWalker);
        }
    };
    RecognizerEngine.prototype.repetitionSepSecondInternal = function (prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
        while (separatorLookAheadFunc()) {
            // note that this CONSUME will never enter recovery because
            // the separatorLookAheadFunc checks that the separator really does exist.
            this.CONSUME(separator);
            action.call(this);
        }
        // we can only arrive to this function after an error
        // has occurred (hence the name 'second') so the following
        // IF will always be entered, its possible to remove it...
        // however it is kept to avoid confusion and be consistent.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        /* istanbul ignore else */
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker
        ], separatorLookAheadFunc, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
    };
    RecognizerEngine.prototype.doSingleRepetition = function (action) {
        var beforeIteration = this.getLexerPosition();
        action.call(this);
        var afterIteration = this.getLexerPosition();
        // This boolean will indicate if this repetition progressed
        // or if we are "stuck" (potential infinite loop in the repetition).
        return afterIteration > beforeIteration;
    };
    RecognizerEngine.prototype.orInternalNoCst = function (altsOrOpts, occurrence) {
        var alts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(altsOrOpts)
            ? altsOrOpts
            : altsOrOpts.DEF;
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OR_IDX, occurrence);
        var laFunc = this.getLaFuncFromCache(laKey);
        var altIdxToTake = laFunc.call(this, alts);
        if (altIdxToTake !== undefined) {
            var chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
        }
        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
    };
    RecognizerEngine.prototype.orInternal = function (altsOrOpts, occurrence) {
        var laKey = this.getKeyForAutomaticLookahead(_grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OR_IDX, occurrence);
        var nestedName = this.nestedRuleBeforeClause(altsOrOpts, laKey);
        try {
            var alts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(altsOrOpts)
                ? altsOrOpts
                : altsOrOpts.DEF;
            var laFunc = this.getLaFuncFromCache(laKey);
            var altIdxToTake = laFunc.call(this, alts);
            if (altIdxToTake !== undefined) {
                var chosenAlternative = alts[altIdxToTake];
                var nestedAltBeforeClauseResult = this.nestedAltBeforeClause(chosenAlternative, occurrence, _grammar_keys__WEBPACK_IMPORTED_MODULE_1__.OR_IDX, altIdxToTake);
                try {
                    return chosenAlternative.ALT.call(this);
                }
                finally {
                    if (nestedAltBeforeClauseResult !== undefined) {
                        this.nestedRuleFinallyClause(nestedAltBeforeClauseResult.shortName, nestedAltBeforeClauseResult.nestedName);
                    }
                }
            }
            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
        }
        finally {
            if (nestedName !== undefined) {
                this.nestedRuleFinallyClause(laKey, nestedName);
            }
        }
    };
    RecognizerEngine.prototype.ruleFinallyStateUpdate = function () {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        // NOOP when cst is disabled
        this.cstFinallyStateUpdate();
        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            var firstRedundantTok = this.LA(1);
            var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: firstRedundantTok,
                ruleName: this.getCurrRuleFullName()
            });
            this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__.NotAllInputParsedException(errMsg, firstRedundantTok));
        }
    };
    RecognizerEngine.prototype.subruleInternal = function (ruleToCall, idx, options) {
        var ruleResult;
        try {
            var args = options !== undefined ? options.ARGS : undefined;
            ruleResult = ruleToCall.call(this, idx, args);
            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined
                ? options.LABEL
                : ruleToCall.ruleName);
            return ruleResult;
        }
        catch (e) {
            this.subruleInternalError(e, options, ruleToCall.ruleName);
        }
    };
    RecognizerEngine.prototype.subruleInternalError = function (e, options, ruleName) {
        if ((0,_exceptions_public__WEBPACK_IMPORTED_MODULE_2__.isRecognitionException)(e) && e.partialCstResult !== undefined) {
            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined
                ? options.LABEL
                : ruleName);
            delete e.partialCstResult;
        }
        throw e;
    };
    RecognizerEngine.prototype.consumeInternal = function (tokType, idx, options) {
        var consumedToken;
        try {
            var nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
                this.consumeToken();
                consumedToken = nextToken;
            }
            else {
                this.consumeInternalError(tokType, nextToken, options);
            }
        }
        catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
        }
        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined
            ? options.LABEL
            : tokType.name, consumedToken);
        return consumedToken;
    };
    RecognizerEngine.prototype.consumeInternalError = function (tokType, nextToken, options) {
        var msg;
        var previousToken = this.LA(0);
        if (options !== undefined && options.ERR_MSG) {
            msg = options.ERR_MSG;
        }
        else {
            msg = this.errorMessageProvider.buildMismatchTokenMessage({
                expected: tokType,
                actual: nextToken,
                previous: previousToken,
                ruleName: this.getCurrRuleFullName()
            });
        }
        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_2__.MismatchedTokenException(msg, nextToken, previousToken));
    };
    RecognizerEngine.prototype.consumeInternalRecovery = function (tokType, idx, eFromConsumption) {
        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it
        // but the original syntax could have been parsed successfully without any backtracking + recovery
        if (this.recoveryEnabled &&
            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
            eFromConsumption.name === "MismatchedTokenException" &&
            !this.isBackTracking()) {
            var follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
                return this.tryInRuleRecovery(tokType, follows);
            }
            catch (eFromInRuleRecovery) {
                if (eFromInRuleRecovery.name === _recoverable__WEBPACK_IMPORTED_MODULE_6__.IN_RULE_RECOVERY_EXCEPTION) {
                    // failed in RuleRecovery.
                    // throw the original error in order to trigger reSync error recovery
                    throw eFromConsumption;
                }
                else {
                    throw eFromInRuleRecovery;
                }
            }
        }
        else {
            throw eFromConsumption;
        }
    };
    RecognizerEngine.prototype.saveRecogState = function () {
        // errors is a getter which will clone the errors array
        var savedErrors = this.errors;
        var savedRuleStack = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.cloneArr)(this.RULE_STACK);
        return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK,
            LAST_EXPLICIT_RULE_STACK: this.LAST_EXPLICIT_RULE_STACK
        };
    };
    RecognizerEngine.prototype.reloadRecogState = function (newState) {
        this.errors = newState.errors;
        this.importLexerState(newState.lexerState);
        this.RULE_STACK = newState.RULE_STACK;
    };
    RecognizerEngine.prototype.ruleInvocationStateUpdate = function (shortName, fullName, idxInCallingRule) {
        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
        this.RULE_STACK.push(shortName);
        // NOOP when cst is disabled
        this.cstInvocationStateUpdate(fullName, shortName);
    };
    RecognizerEngine.prototype.isBackTracking = function () {
        return this.isBackTrackingStack.length !== 0;
    };
    RecognizerEngine.prototype.getCurrRuleFullName = function () {
        var shortName = this.getLastExplicitRuleShortName();
        return this.shortRuleNameToFull[shortName];
    };
    RecognizerEngine.prototype.shortRuleNameToFullName = function (shortName) {
        return this.shortRuleNameToFull[shortName];
    };
    RecognizerEngine.prototype.isAtEndOfInput = function () {
        return this.tokenMatcher(this.LA(1), _scan_tokens_public__WEBPACK_IMPORTED_MODULE_7__.EOF);
    };
    RecognizerEngine.prototype.reset = function () {
        this.resetLexerState();
        this.isBackTrackingStack = [];
        this.errors = [];
        this.RULE_STACK = [];
        this.LAST_EXPLICIT_RULE_STACK = [];
        // TODO: extract a specific rest for TreeBuilder trait
        this.CST_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
    };
    return RecognizerEngine;
}());

//# sourceMappingURL=recognizer_engine.js.map

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorHandler: () => (/* binding */ ErrorHandler)
/* harmony export */ });
/* harmony import */ var _exceptions_public__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);




/**
 * Trait responsible for runtime parsing errors.
 */
var ErrorHandler = /** @class */ (function () {
    function ErrorHandler() {
    }
    ErrorHandler.prototype.initErrorHandler = function (config) {
        this._errors = [];
        this.errorMessageProvider = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.defaults)(config.errorMessageProvider, _parser__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_PARSER_CONFIG.errorMessageProvider);
    };
    ErrorHandler.prototype.SAVE_ERROR = function (error) {
        if ((0,_exceptions_public__WEBPACK_IMPORTED_MODULE_0__.isRecognitionException)(error)) {
            error.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this.RULE_OCCURRENCE_STACK)
            };
            this._errors.push(error);
            return error;
        }
        else {
            throw Error("Trying to save an Error which is not a RecognitionException");
        }
    };
    Object.defineProperty(ErrorHandler.prototype, "errors", {
        // TODO: extract these methods to ErrorHandler Trait?
        get: function () {
            return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.cloneArr)(this._errors);
        },
        set: function (newErrors) {
            this._errors = newErrors;
        },
        enumerable: true,
        configurable: true
    });
    // TODO: consider caching the error message computed information
    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        var lookAheadPathsPerAlternative = (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
        var insideProdPaths = lookAheadPathsPerAlternative[0];
        var actualTokens = [];
        for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
        }
        var msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName: ruleName
        });
        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_0__.EarlyExitException(msg, this.LA(1), this.LA(0)));
    };
    // TODO: consider caching the error message computed information
    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {
        var ruleName = this.getCurrRuleFullName();
        var ruleGrammar = this.getGAstProductions()[ruleName];
        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?
        var lookAheadPathsPerAlternative = (0,_grammar_lookahead__WEBPACK_IMPORTED_MODULE_2__.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
        var actualTokens = [];
        for (var i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
        }
        var previousToken = this.LA(0);
        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName()
        });
        throw this.SAVE_ERROR(new _exceptions_public__WEBPACK_IMPORTED_MODULE_0__.NoViableAltException(errMsg, this.LA(1), previousToken));
    };
    return ErrorHandler;
}());

//# sourceMappingURL=error_handler.js.map

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContentAssist: () => (/* binding */ ContentAssist)
/* harmony export */ });
/* harmony import */ var _grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);


var ContentAssist = /** @class */ (function () {
    function ContentAssist() {
    }
    ContentAssist.prototype.initContentAssist = function () { };
    ContentAssist.prototype.computeContentAssist = function (startRuleName, precedingInput) {
        var startRuleGast = this.gastProductionsCache[startRuleName];
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(startRuleGast)) {
            throw Error("Rule ->" + startRuleName + "<- does not exist in this grammar.");
        }
        return (0,_grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
    };
    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
    // TODO: should this be more explicitly part of the public API?
    ContentAssist.prototype.getNextPossibleTokenTypes = function (grammarPath) {
        var topRuleName = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_1__.first)(grammarPath.ruleStack);
        var gastProductions = this.getGAstProductions();
        var topProduction = gastProductions[topRuleName];
        var nextPossibleTokenTypes = new _grammar_interpreter__WEBPACK_IMPORTED_MODULE_0__.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
        return nextPossibleTokenTypes;
    };
    return ContentAssist;
}());

//# sourceMappingURL=context_assist.js.map

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GastRecorder: () => (/* binding */ GastRecorder)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
/* harmony import */ var _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _scan_tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(16);
/* harmony import */ var _grammar_keys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34);







var RECORDING_NULL_OBJECT = {
    description: "This Object indicates the Parser is during Recording Phase"
};
Object.freeze(RECORDING_NULL_OBJECT);
var HANDLE_SEPARATOR = true;
var MAX_METHOD_IDX = Math.pow(2, _grammar_keys__WEBPACK_IMPORTED_MODULE_6__.BITS_FOR_OCCURRENCE_IDX) - 1;
var RFT = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: _scan_lexer_public__WEBPACK_IMPORTED_MODULE_2__.Lexer.NA });
(0,_scan_tokens__WEBPACK_IMPORTED_MODULE_3__.augmentTokenTypes)([RFT]);
var RECORDING_PHASE_TOKEN = (0,_scan_tokens_public__WEBPACK_IMPORTED_MODULE_4__.createTokenInstance)(RFT, "This IToken indicates the Parser is in Recording Phase\n\t" +
    "" +
    "See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details",
// Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
-1, -1, -1, -1, -1, -1);
Object.freeze(RECORDING_PHASE_TOKEN);
var RECORDING_PHASE_CSTNODE = {
    name: "This CSTNode indicates the Parser is in Recording Phase\n\t" +
        "See: https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording for details",
    children: {}
};
/**
 * This trait handles the creation of the GAST structure for Chevrotain Grammars
 */
var GastRecorder = /** @class */ (function () {
    function GastRecorder() {
    }
    GastRecorder.prototype.initGastRecorder = function (config) {
        this.recordingProdStack = [];
        this.RECORDING_PHASE = false;
    };
    GastRecorder.prototype.enableRecording = function () {
        var _this = this;
        this.RECORDING_PHASE = true;
        this.TRACE_INIT("Enable Recording", function () {
            var _loop_1 = function (i) {
                var idx = i > 0 ? i : "";
                _this["CONSUME" + idx] = function (arg1, arg2) {
                    return this.consumeInternalRecord(arg1, i, arg2);
                };
                _this["SUBRULE" + idx] = function (arg1, arg2) {
                    return this.subruleInternalRecord(arg1, i, arg2);
                };
                _this["OPTION" + idx] = function (arg1) {
                    return this.optionInternalRecord(arg1, i);
                };
                _this["OR" + idx] = function (arg1) {
                    return this.orInternalRecord(arg1, i);
                };
                _this["MANY" + idx] = function (arg1) {
                    this.manyInternalRecord(i, arg1);
                };
                _this["MANY_SEP" + idx] = function (arg1) {
                    this.manySepFirstInternalRecord(i, arg1);
                };
                _this["AT_LEAST_ONE" + idx] = function (arg1) {
                    this.atLeastOneInternalRecord(i, arg1);
                };
                _this["AT_LEAST_ONE_SEP" + idx] = function (arg1) {
                    this.atLeastOneSepFirstInternalRecord(i, arg1);
                };
            };
            /**
             * Warning Dark Voodoo Magic upcoming!
             * We are "replacing" the public parsing DSL methods API
             * With **new** alternative implementations on the Parser **instance**
             *
             * So far this is the only way I've found to avoid performance regressions during parsing time.
             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the "internal"
             *   implementations directly instead.
             */
            for (var i = 0; i < 10; i++) {
                _loop_1(i);
            }
            // DSL methods with the idx(suffix) as an argument
            _this["consume"] = function (idx, arg1, arg2) {
                return this.consumeInternalRecord(arg1, idx, arg2);
            };
            _this["subrule"] = function (idx, arg1, arg2) {
                return this.subruleInternalRecord(arg1, idx, arg2);
            };
            _this["option"] = function (idx, arg1) {
                return this.optionInternalRecord(arg1, idx);
            };
            _this["or"] = function (idx, arg1) {
                return this.orInternalRecord(arg1, idx);
            };
            _this["many"] = function (idx, arg1) {
                this.manyInternalRecord(idx, arg1);
            };
            _this["atLeastOne"] = function (idx, arg1) {
                this.atLeastOneInternalRecord(idx, arg1);
            };
            _this.ACTION = _this.ACTION_RECORD;
            _this.BACKTRACK = _this.BACKTRACK_RECORD;
            _this.LA = _this.LA_RECORD;
        });
    };
    GastRecorder.prototype.disableRecording = function () {
        var _this = this;
        this.RECORDING_PHASE = false;
        // By deleting these **instance** properties, any future invocation
        // will be deferred to the original methods on the **prototype** object
        // This seems to get rid of any incorrect optimizations that V8 may
        // do during the recording phase.
        this.TRACE_INIT("Deleting Recording methods", function () {
            for (var i = 0; i < 10; i++) {
                var idx = i > 0 ? i : "";
                delete _this["CONSUME" + idx];
                delete _this["SUBRULE" + idx];
                delete _this["OPTION" + idx];
                delete _this["OR" + idx];
                delete _this["MANY" + idx];
                delete _this["MANY_SEP" + idx];
                delete _this["AT_LEAST_ONE" + idx];
                delete _this["AT_LEAST_ONE_SEP" + idx];
            }
            delete _this["consume"];
            delete _this["subrule"];
            delete _this["option"];
            delete _this["or"];
            delete _this["many"];
            delete _this["atLeastOne"];
            delete _this.ACTION;
            delete _this.BACKTRACK;
            delete _this.LA;
        });
    };
    // TODO: is there any way to use this method to check no
    //   Parser methods are called inside an ACTION?
    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
    GastRecorder.prototype.ACTION_RECORD = function (impl) {
        // NO-OP during recording
        return;
    };
    // Executing backtracking logic will break our recording logic assumptions
    GastRecorder.prototype.BACKTRACK_RECORD = function (grammarRule, args) {
        return function () { return true; };
    };
    // LA is part of the official API and may be used for custom lookahead logic
    // by end users who may forget to wrap it in ACTION or inside a GATE
    GastRecorder.prototype.LA_RECORD = function (howMuch) {
        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend
        // On LA return EOF at the end of the input so an infinite loop may occur.
        return _parser__WEBPACK_IMPORTED_MODULE_5__.END_OF_FILE;
    };
    GastRecorder.prototype.topLevelRuleRecord = function (name, def) {
        try {
            var newTopLevelRule = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Rule({ definition: [], name: name });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
        }
        catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) {
                try {
                    originalError.message =
                        originalError.message +
                            '\n\t This error was thrown during the "grammar recording phase" For more info see:\n\t' +
                            "https://sap.github.io/chevrotain/docs/guide/internals.html#grammar-recording";
                }
                catch (mutabilityError) {
                    // We may not be able to modify the original error object
                    throw originalError;
                }
            }
            throw originalError;
        }
    };
    // Implementation of parsing DSL
    GastRecorder.prototype.optionInternalRecord = function (actionORMethodDef, occurrence) {
        return recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option, actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.atLeastOneInternalRecord = function (occurrence, actionORMethodDef) {
        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory, actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.atLeastOneSepFirstInternalRecord = function (occurrence, options) {
        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
    };
    GastRecorder.prototype.manyInternalRecord = function (occurrence, actionORMethodDef) {
        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition, actionORMethodDef, occurrence);
    };
    GastRecorder.prototype.manySepFirstInternalRecord = function (occurrence, options) {
        recordProd.call(this, _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
    };
    GastRecorder.prototype.orInternalRecord = function (altsOrOpts, occurrence) {
        return recordOrProd.call(this, altsOrOpts, occurrence);
    };
    GastRecorder.prototype.subruleInternalRecord = function (ruleToCall, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!ruleToCall || (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(ruleToCall, "ruleName") === false) {
            var error = new Error("<SUBRULE" + getIdxSuffix(occurrence) + "> argument is invalid" +
                (" expecting a Parser method reference but got: <" + JSON.stringify(ruleToCall) + ">") +
                ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        var prevProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.peek)(this.recordingProdStack);
        var ruleName = ruleToCall["ruleName"];
        var newNoneTerminal = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal({
            idx: occurrence,
            nonTerminalName: ruleName,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: undefined
        });
        prevProd.definition.push(newNoneTerminal);
        return this.outputCst
            ? RECORDING_PHASE_CSTNODE
            : RECORDING_NULL_OBJECT;
    };
    GastRecorder.prototype.consumeInternalRecord = function (tokType, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!(0,_scan_tokens__WEBPACK_IMPORTED_MODULE_3__.hasShortKeyProperty)(tokType)) {
            var error = new Error("<CONSUME" + getIdxSuffix(occurrence) + "> argument is invalid" +
                (" expecting a TokenType reference but got: <" + JSON.stringify(tokType) + ">") +
                ("\n inside top level rule: <" + this.recordingProdStack[0].name + ">"));
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        var prevProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.peek)(this.recordingProdStack);
        var newNoneTerminal = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal({
            idx: occurrence,
            terminalType: tokType
        });
        prevProd.definition.push(newNoneTerminal);
        return RECORDING_PHASE_TOKEN;
    };
    return GastRecorder;
}());

function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
    if (handleSep === void 0) { handleSep = false; }
    assertMethodIdxIsValid(occurrence);
    var prevProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.peek)(this.recordingProdStack);
    var grammarAction = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(mainProdArg)
        ? mainProdArg
        : mainProdArg.DEF;
    var newProd = new prodConstructor({ definition: [], idx: occurrence });
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(mainProdArg, "NAME")) {
        newProd.name = mainProdArg.NAME;
    }
    if (handleSep) {
        newProd.separator = mainProdArg.SEP;
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    this.recordingProdStack.push(newProd);
    grammarAction.call(this);
    prevProd.definition.push(newProd);
    this.recordingProdStack.pop();
    return RECORDING_NULL_OBJECT;
}
function recordOrProd(mainProdArg, occurrence) {
    var _this = this;
    assertMethodIdxIsValid(occurrence);
    var prevProd = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.peek)(this.recordingProdStack);
    // Only an array of alternatives
    var hasOptions = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isArray)(mainProdArg) === false;
    var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
    var newOrProd = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
    });
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(mainProdArg, "NAME")) {
        newOrProd.name = mainProdArg.NAME;
    }
    if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    var hasPredicates = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.some)(alts, function (currAlt) { return (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.isFunction)(currAlt.GATE); });
    newOrProd.hasPredicates = hasPredicates;
    prevProd.definition.push(newOrProd);
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(alts, function (currAlt) {
        var currAltFlat = new _grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Flat({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(currAlt, "NAME")) {
            currAltFlat.name = currAlt.NAME;
        }
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(currAlt, "IGNORE_AMBIGUITIES")) {
            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
        }
        // **implicit** ignoreAmbiguities due to usage of gate
        else if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(currAlt, "GATE")) {
            currAltFlat.ignoreAmbiguities = true;
        }
        _this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(_this);
        _this.recordingProdStack.pop();
    });
    return RECORDING_NULL_OBJECT;
}
function getIdxSuffix(idx) {
    return idx === 0 ? "" : "" + idx;
}
function assertMethodIdxIsValid(idx) {
    if (idx < 0 || idx > MAX_METHOD_IDX) {
        var error = new Error(
        // The stack trace will contain all the needed details
        "Invalid DSL Method idx value: <" + idx + ">\n\t" +
            ("Idx value must be a none negative value smaller than " + (MAX_METHOD_IDX +
                1)));
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
    }
}
//# sourceMappingURL=gast_recorder.js.map

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerformanceTracer: () => (/* binding */ PerformanceTracer)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);


/**
 * Trait responsible for runtime parsing errors.
 */
var PerformanceTracer = /** @class */ (function () {
    function PerformanceTracer() {
    }
    PerformanceTracer.prototype.initPerformanceTracer = function (config) {
        if ((0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.has)(config, "traceInitPerf")) {
            var userTraceInitPerf = config.traceInitPerf;
            var traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber
                ? userTraceInitPerf
                : Infinity;
            this.traceInitPerf = traceIsNumber
                ? userTraceInitPerf > 0
                : userTraceInitPerf;
        }
        else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = _parser__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PARSER_CONFIG.traceInitPerf;
        }
        this.traceInitIndent = -1;
    };
    PerformanceTracer.prototype.TRACE_INIT = function (phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            var indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(indent + "--> <" + phaseDesc + ">");
            }
            var _a = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.timer)(phaseImpl), time = _a.time, value = _a.value;
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */
            var traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(indent + "<-- <" + phaseDesc + "> time: " + time + "ms");
            }
            this.traceInitIndent--;
            return value;
        }
        else {
            return phaseImpl();
        }
    };
    return PerformanceTracer;
}());

//# sourceMappingURL=perf_tracer.js.map

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSyntaxDiagramsCode: () => (/* binding */ createSyntaxDiagramsCode)
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);

function createSyntaxDiagramsCode(grammar, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@" + _version__WEBPACK_IMPORTED_MODULE_0__.VERSION + "/diagrams/" : _c, _d = _b.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@" + _version__WEBPACK_IMPORTED_MODULE_0__.VERSION + "/diagrams/diagrams.css" : _d;
    var header = "\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n";
    var cssHtml = "\n<link rel='stylesheet' href='" + css + "'>\n";
    var scripts = "\n<script src='" + resourceBase + "vendor/railroad-diagrams.js'></script>\n<script src='" + resourceBase + "src/diagrams_builder.js'></script>\n<script src='" + resourceBase + "src/diagrams_behavior.js'></script>\n<script src='" + resourceBase + "src/main.js'></script>\n";
    var diagramsDiv = "\n<div id=\"diagrams\" align=\"center\"></div>    \n";
    var serializedGrammar = "\n<script>\n    window.serializedGrammar = " + JSON.stringify(grammar, null, "  ") + ";\n</script>\n";
    var initLogic = "\n<script>\n    var diagramsDiv = document.getElementById(\"diagrams\");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n";
    return (header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic);
}
//# sourceMappingURL=render_public.js.map

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateParserFactory: () => (/* binding */ generateParserFactory),
/* harmony export */   generateParserModule: () => (/* binding */ generateParserModule)
/* harmony export */ });
/* harmony import */ var _generate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);

function generateParserFactory(options) {
    var wrapperText = (0,_generate__WEBPACK_IMPORTED_MODULE_0__.genWrapperFunction)({
        name: options.name,
        rules: options.rules
    });
    var constructorWrapper = new Function("tokenVocabulary", "config", "chevrotain", wrapperText);
    return function (config) {
        return constructorWrapper(options.tokenVocabulary, config,
        // TODO: check how the require is transpiled/webpacked
        __webpack_require__(14));
    };
}
function generateParserModule(options) {
    return (0,_generate__WEBPACK_IMPORTED_MODULE_0__.genUmdModule)({ name: options.name, rules: options.rules });
}
//# sourceMappingURL=generate_public.js.map

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   genAllRules: () => (/* binding */ genAllRules),
/* harmony export */   genAlternation: () => (/* binding */ genAlternation),
/* harmony export */   genClass: () => (/* binding */ genClass),
/* harmony export */   genNonTerminal: () => (/* binding */ genNonTerminal),
/* harmony export */   genRule: () => (/* binding */ genRule),
/* harmony export */   genSingleAlt: () => (/* binding */ genSingleAlt),
/* harmony export */   genTerminal: () => (/* binding */ genTerminal),
/* harmony export */   genUmdModule: () => (/* binding */ genUmdModule),
/* harmony export */   genWrapperFunction: () => (/* binding */ genWrapperFunction)
/* harmony export */ });
/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);


/**
 * Missing features
 * 1. Rule arguments
 * 2. Gates
 * 3. embedded actions
 */
var NL = "\n";
function genUmdModule(options) {
    return "\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n" + genClass(options) + "\n    \nreturn {\n    " + options.name + ": " + options.name + " \n}\n}));\n";
}
function genWrapperFunction(options) {
    return "    \n" + genClass(options) + "\nreturn new " + options.name + "(tokenVocabulary, config)    \n";
}
function genClass(options) {
    // TODO: how to pass the token vocabulary? Constructor? other?
    var result = "\nfunction " + options.name + "(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    " + genAllRules(options.rules) + "\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n" + options.name + ".prototype = Object.create(chevrotain.CstParser.prototype)\n" + options.name + ".prototype.constructor = " + options.name + "    \n    ";
    return result;
}
function genAllRules(rules) {
    var rulesText = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(rules, function (currRule) {
        return genRule(currRule, 1);
    });
    return rulesText.join("\n");
}
function genRule(prod, n) {
    var result = indent(n, "$.RULE(\"" + prod.name + "\", function() {") + NL;
    result += genDefinition(prod.definition, n + 1);
    result += indent(n + 1, "})") + NL;
    return result;
}
function genTerminal(prod, n) {
    var name = prod.terminalType.name;
    // TODO: potential performance optimization, avoid tokenMap Dictionary access
    return indent(n, "$.CONSUME" + prod.idx + "(this.tokensMap." + name + ")" + NL);
}
function genNonTerminal(prod, n) {
    return indent(n, "$.SUBRULE" + prod.idx + "($." + prod.nonTerminalName + ")" + NL);
}
function genAlternation(prod, n) {
    var result = indent(n, "$.OR" + prod.idx + "([") + NL;
    var alts = (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.map)(prod.definition, function (altDef) { return genSingleAlt(altDef, n + 1); });
    result += alts.join("," + NL);
    result += NL + indent(n, "])" + NL);
    return result;
}
function genSingleAlt(prod, n) {
    var result = indent(n, "{") + NL;
    if (prod.name) {
        result += indent(n + 1, "NAME: \"" + prod.name + "\",") + NL;
    }
    result += indent(n + 1, "ALT: function() {") + NL;
    result += genDefinition(prod.definition, n + 1);
    result += indent(n + 1, "}") + NL;
    result += indent(n, "}");
    return result;
}
function genProd(prod, n) {
    /* istanbul ignore else */
    if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {
        return genNonTerminal(prod, n);
    }
    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Option) {
        return genDSLRule("OPTION", prod, n);
    }
    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory) {
        return genDSLRule("AT_LEAST_ONE", prod, n);
    }
    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator) {
        return genDSLRule("AT_LEAST_ONE_SEP", prod, n);
    }
    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator) {
        return genDSLRule("MANY_SEP", prod, n);
    }
    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Repetition) {
        return genDSLRule("MANY", prod, n);
    }
    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Alternation) {
        return genAlternation(prod, n);
    }
    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Terminal) {
        return genTerminal(prod, n);
    }
    else if (prod instanceof _parse_grammar_gast_gast_public__WEBPACK_IMPORTED_MODULE_1__.Flat) {
        return genDefinition(prod.definition, n);
    }
    else {
        throw Error("non exhaustive match");
    }
}
function genDSLRule(dslName, prod, n) {
    var result = indent(n, "$." + (dslName + prod.idx) + "(");
    if (prod.name || prod.separator) {
        result += "{" + NL;
        if (prod.name) {
            result += indent(n + 1, "NAME: \"" + prod.name + "\"") + "," + NL;
        }
        if (prod.separator) {
            result +=
                indent(n + 1, "SEP: this.tokensMap." + prod.separator.name) +
                    "," +
                    NL;
        }
        result += "DEF: " + genDefFunction(prod.definition, n + 2) + NL;
        result += indent(n, "}") + NL;
    }
    else {
        result += genDefFunction(prod.definition, n + 1);
    }
    result += indent(n, ")") + NL;
    return result;
}
function genDefFunction(definition, n) {
    var def = "function() {" + NL;
    def += genDefinition(definition, n);
    def += indent(n, "}") + NL;
    return def;
}
function genDefinition(def, n) {
    var result = "";
    (0,_utils_utils__WEBPACK_IMPORTED_MODULE_0__.forEach)(def, function (prod) {
        result += genProd(prod, n + 1);
    });
    return result;
}
function indent(howMuch, text) {
    var spaces = Array(howMuch * 4 + 1).join(" ");
    return spaces + text;
}
//# sourceMappingURL=generate.js.map

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AstNodeType: () => (/* binding */ AstNodeType),
/* harmony export */   ParsingErrorType: () => (/* binding */ ParsingErrorType),
/* harmony export */   RangeSheetReferenceType: () => (/* binding */ RangeSheetReferenceType),
/* harmony export */   buildArrayAst: () => (/* binding */ buildArrayAst),
/* harmony export */   buildCellErrorAst: () => (/* binding */ buildCellErrorAst),
/* harmony export */   buildCellRangeAst: () => (/* binding */ buildCellRangeAst),
/* harmony export */   buildCellReferenceAst: () => (/* binding */ buildCellReferenceAst),
/* harmony export */   buildColumnRangeAst: () => (/* binding */ buildColumnRangeAst),
/* harmony export */   buildConcatenateOpAst: () => (/* binding */ buildConcatenateOpAst),
/* harmony export */   buildDivOpAst: () => (/* binding */ buildDivOpAst),
/* harmony export */   buildEmptyArgAst: () => (/* binding */ buildEmptyArgAst),
/* harmony export */   buildEqualsOpAst: () => (/* binding */ buildEqualsOpAst),
/* harmony export */   buildErrorWithRawInputAst: () => (/* binding */ buildErrorWithRawInputAst),
/* harmony export */   buildGreaterThanOpAst: () => (/* binding */ buildGreaterThanOpAst),
/* harmony export */   buildGreaterThanOrEqualOpAst: () => (/* binding */ buildGreaterThanOrEqualOpAst),
/* harmony export */   buildLessThanOpAst: () => (/* binding */ buildLessThanOpAst),
/* harmony export */   buildLessThanOrEqualOpAst: () => (/* binding */ buildLessThanOrEqualOpAst),
/* harmony export */   buildMinusOpAst: () => (/* binding */ buildMinusOpAst),
/* harmony export */   buildMinusUnaryOpAst: () => (/* binding */ buildMinusUnaryOpAst),
/* harmony export */   buildNamedExpressionAst: () => (/* binding */ buildNamedExpressionAst),
/* harmony export */   buildNotEqualOpAst: () => (/* binding */ buildNotEqualOpAst),
/* harmony export */   buildNumberAst: () => (/* binding */ buildNumberAst),
/* harmony export */   buildParenthesisAst: () => (/* binding */ buildParenthesisAst),
/* harmony export */   buildParsingErrorAst: () => (/* binding */ buildParsingErrorAst),
/* harmony export */   buildPercentOpAst: () => (/* binding */ buildPercentOpAst),
/* harmony export */   buildPlusOpAst: () => (/* binding */ buildPlusOpAst),
/* harmony export */   buildPlusUnaryOpAst: () => (/* binding */ buildPlusUnaryOpAst),
/* harmony export */   buildPowerOpAst: () => (/* binding */ buildPowerOpAst),
/* harmony export */   buildProcedureAst: () => (/* binding */ buildProcedureAst),
/* harmony export */   buildRowRangeAst: () => (/* binding */ buildRowRangeAst),
/* harmony export */   buildStringAst: () => (/* binding */ buildStringAst),
/* harmony export */   buildTimesOpAst: () => (/* binding */ buildTimesOpAst),
/* harmony export */   imageWithWhitespace: () => (/* binding */ imageWithWhitespace),
/* harmony export */   parsingError: () => (/* binding */ parsingError)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const parsingError = (type, message) => ({
  type,
  message
});
/**
 * Represents types of parsing errors.
 */
var ParsingErrorType;
(function (ParsingErrorType) {
  ParsingErrorType["LexingError"] = "LexingError";
  ParsingErrorType["ParserError"] = "ParsingError";
  ParsingErrorType["StaticOffsetError"] = "StaticOffsetError";
  ParsingErrorType["StaticOffsetOutOfRangeError"] = "StaticOffsetOutOfRangeError";
  ParsingErrorType["RangeOffsetNotAllowed"] = "RangeOffsetNotAllowed";
  ParsingErrorType["InvalidRangeSize"] = "InvalidRangeSize";
})(ParsingErrorType || (ParsingErrorType = {}));
var AstNodeType;
(function (AstNodeType) {
  AstNodeType["EMPTY"] = "EMPTY";
  AstNodeType["NUMBER"] = "NUMBER";
  AstNodeType["STRING"] = "STRING";
  AstNodeType["MINUS_UNARY_OP"] = "MINUS_UNARY_OP";
  AstNodeType["PLUS_UNARY_OP"] = "PLUS_UNARY_OP";
  AstNodeType["PERCENT_OP"] = "PERCENT_OP";
  AstNodeType["CONCATENATE_OP"] = "CONCATENATE_OP";
  AstNodeType["EQUALS_OP"] = "EQUALS_OP";
  AstNodeType["NOT_EQUAL_OP"] = "NOT_EQUAL_OP";
  AstNodeType["GREATER_THAN_OP"] = "GREATER_THAN_OP";
  AstNodeType["LESS_THAN_OP"] = "LESS_THAN_OP";
  AstNodeType["GREATER_THAN_OR_EQUAL_OP"] = "GREATER_THAN_OR_EQUAL_OP";
  AstNodeType["LESS_THAN_OR_EQUAL_OP"] = "LESS_THAN_OR_EQUAL_OP";
  AstNodeType["PLUS_OP"] = "PLUS_OP";
  AstNodeType["MINUS_OP"] = "MINUS_OP";
  AstNodeType["TIMES_OP"] = "TIMES_OP";
  AstNodeType["DIV_OP"] = "DIV_OP";
  AstNodeType["POWER_OP"] = "POWER_OP";
  AstNodeType["FUNCTION_CALL"] = "FUNCTION_CALL";
  AstNodeType["NAMED_EXPRESSION"] = "NAMED_EXPRESSION";
  AstNodeType["PARENTHESIS"] = "PARENTHESES";
  AstNodeType["CELL_REFERENCE"] = "CELL_REFERENCE";
  AstNodeType["CELL_RANGE"] = "CELL_RANGE";
  AstNodeType["COLUMN_RANGE"] = "COLUMN_RANGE";
  AstNodeType["ROW_RANGE"] = "ROW_RANGE";
  AstNodeType["ERROR"] = "ERROR";
  AstNodeType["ERROR_WITH_RAW_INPUT"] = "ERROR_WITH_RAW_INPUT";
  AstNodeType["ARRAY"] = "ARRAY";
})(AstNodeType || (AstNodeType = {}));
var RangeSheetReferenceType;
(function (RangeSheetReferenceType) {
  RangeSheetReferenceType[RangeSheetReferenceType["RELATIVE"] = 0] = "RELATIVE";
  RangeSheetReferenceType[RangeSheetReferenceType["START_ABSOLUTE"] = 1] = "START_ABSOLUTE";
  RangeSheetReferenceType[RangeSheetReferenceType["BOTH_ABSOLUTE"] = 2] = "BOTH_ABSOLUTE";
})(RangeSheetReferenceType || (RangeSheetReferenceType = {}));
const buildEmptyArgAst = leadingWhitespace => ({
  type: AstNodeType.EMPTY,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildNumberAst = (value, leadingWhitespace) => ({
  type: AstNodeType.NUMBER,
  value: value,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildStringAst = token => {
  var _a;
  return {
    type: AstNodeType.STRING,
    value: token.image.slice(1, -1),
    leadingWhitespace: (_a = token.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image
  };
};
const buildCellReferenceAst = (reference, leadingWhitespace) => ({
  type: AstNodeType.CELL_REFERENCE,
  reference,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildCellRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {
  assertRangeConsistency(start, end, sheetReferenceType);
  return {
    type: AstNodeType.CELL_RANGE,
    start,
    end,
    sheetReferenceType,
    leadingWhitespace
  };
};
const buildColumnRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {
  assertRangeConsistency(start, end, sheetReferenceType);
  return {
    type: AstNodeType.COLUMN_RANGE,
    start,
    end,
    sheetReferenceType,
    leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
  };
};
const buildRowRangeAst = (start, end, sheetReferenceType, leadingWhitespace) => {
  assertRangeConsistency(start, end, sheetReferenceType);
  return {
    type: AstNodeType.ROW_RANGE,
    start,
    end,
    sheetReferenceType,
    leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
  };
};
const buildConcatenateOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.CONCATENATE_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildEqualsOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.EQUALS_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildNotEqualOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.NOT_EQUAL_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildGreaterThanOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.GREATER_THAN_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildLessThanOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.LESS_THAN_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildGreaterThanOrEqualOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.GREATER_THAN_OR_EQUAL_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildLessThanOrEqualOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.LESS_THAN_OR_EQUAL_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildPlusOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.PLUS_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildMinusOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.MINUS_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildTimesOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.TIMES_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildDivOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.DIV_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildPowerOpAst = (left, right, leadingWhitespace) => ({
  type: AstNodeType.POWER_OP,
  left,
  right,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildMinusUnaryOpAst = (value, leadingWhitespace) => ({
  type: AstNodeType.MINUS_UNARY_OP,
  value,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildPlusUnaryOpAst = (value, leadingWhitespace) => ({
  type: AstNodeType.PLUS_UNARY_OP,
  value,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildPercentOpAst = (value, leadingWhitespace) => ({
  type: AstNodeType.PERCENT_OP,
  value,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildProcedureAst = (procedureName, args, leadingWhitespace, internalWhitespace, hyperlink) => ({
  type: AstNodeType.FUNCTION_CALL,
  procedureName,
  args,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,
  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image,
  hyperlink
});
const buildArrayAst = (args, leadingWhitespace, internalWhitespace) => ({
  type: AstNodeType.ARRAY,
  args,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,
  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image
});
const buildNamedExpressionAst = (expressionName, leadingWhitespace) => ({
  type: AstNodeType.NAMED_EXPRESSION,
  expressionName,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildParenthesisAst = (expression, leadingWhitespace, internalWhitespace) => ({
  type: AstNodeType.PARENTHESIS,
  expression,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image,
  internalWhitespace: internalWhitespace === null || internalWhitespace === void 0 ? void 0 : internalWhitespace.image
});
const buildCellErrorAst = (error, leadingWhitespace) => ({
  type: AstNodeType.ERROR,
  error,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildErrorWithRawInputAst = (rawInput, error, leadingWhitespace) => ({
  type: AstNodeType.ERROR_WITH_RAW_INPUT,
  error,
  rawInput,
  leadingWhitespace: leadingWhitespace === null || leadingWhitespace === void 0 ? void 0 : leadingWhitespace.image
});
const buildParsingErrorAst = () => ({
  type: AstNodeType.ERROR,
  error: _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError.parsingError()
});
function assertRangeConsistency(start, end, sheetReferenceType) {
  if (start.sheet !== undefined && end.sheet === undefined || start.sheet === undefined && end.sheet !== undefined) {
    throw new Error('Start address inconsistent with end address');
  }
  if (start.sheet === undefined && sheetReferenceType !== RangeSheetReferenceType.RELATIVE || start.sheet !== undefined && sheetReferenceType === RangeSheetReferenceType.RELATIVE) {
    throw new Error('Sheet address inconsistent with sheet reference type');
  }
}
function imageWithWhitespace(image, leadingWhitespace) {
  return (leadingWhitespace !== null && leadingWhitespace !== void 0 ? leadingWhitespace : '') + image;
}

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   binaryOpTokenMap: () => (/* binding */ binaryOpTokenMap)
/* harmony export */ });
/* harmony import */ var _Ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const binaryOpTokenMap = {
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PLUS_OP]: '+',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.MINUS_OP]: '-',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.TIMES_OP]: '*',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.DIV_OP]: '/',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.CONCATENATE_OP]: '&',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.POWER_OP]: '^',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.EQUALS_OP]: '=',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.NOT_EQUAL_OP]: '<>',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.GREATER_THAN_OP]: '>',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.GREATER_THAN_OR_EQUAL_OP]: '>=',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.LESS_THAN_OP]: '<',
  [_Ast__WEBPACK_IMPORTED_MODULE_0__.AstNodeType.LESS_THAN_OR_EQUAL_OP]: '<='
};

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cache: () => (/* binding */ Cache),
/* harmony export */   doesContainFunctions: () => (/* binding */ doesContainFunctions)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const buildCacheEntry = (ast, relativeDependencies, hasVolatileFunction, hasStructuralChangeFunction) => ({
  ast,
  relativeDependencies,
  hasVolatileFunction,
  hasStructuralChangeFunction
});
class Cache {
  constructor(functionRegistry) {
    this.functionRegistry = functionRegistry;
    this.cache = new Map();
  }
  set(hash, ast) {
    const astRelativeDependencies = (0,___WEBPACK_IMPORTED_MODULE_0__.collectDependencies)(ast, this.functionRegistry);
    const cacheEntry = buildCacheEntry(ast, astRelativeDependencies, doesContainFunctions(ast, this.functionRegistry.isFunctionVolatile), doesContainFunctions(ast, this.functionRegistry.isFunctionDependentOnSheetStructureChange));
    this.cache.set(hash, cacheEntry);
    return cacheEntry;
  }
  get(hash) {
    return this.cache.get(hash);
  }
  maybeSetAndThenGet(hash, ast) {
    const entryFromCache = this.cache.get(hash);
    if (entryFromCache !== undefined) {
      return entryFromCache.ast;
    } else {
      this.set(hash, ast);
      return ast;
    }
  }
}
const doesContainFunctions = (ast, functionCriterion) => {
  switch (ast.type) {
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.EMPTY:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.NUMBER:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.STRING:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.ERROR:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.ERROR_WITH_RAW_INPUT:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.CELL_REFERENCE:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.CELL_RANGE:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.COLUMN_RANGE:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.ROW_RANGE:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.NAMED_EXPRESSION:
      return false;
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PERCENT_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PLUS_UNARY_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.MINUS_UNARY_OP:
      {
        return doesContainFunctions(ast.value, functionCriterion);
      }
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.CONCATENATE_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.EQUALS_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.NOT_EQUAL_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.LESS_THAN_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.GREATER_THAN_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.LESS_THAN_OR_EQUAL_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.GREATER_THAN_OR_EQUAL_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.MINUS_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PLUS_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.TIMES_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.DIV_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.POWER_OP:
      return doesContainFunctions(ast.left, functionCriterion) || doesContainFunctions(ast.right, functionCriterion);
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PARENTHESIS:
      return doesContainFunctions(ast.expression, functionCriterion);
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.FUNCTION_CALL:
      {
        if (functionCriterion(ast.procedureName)) {
          return true;
        }
        return ast.args.some(arg => doesContainFunctions(arg, functionCriterion));
      }
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.ARRAY:
      {
        return ast.args.some(row => row.some(arg => doesContainFunctions(arg, functionCriterion)));
      }
  }
};

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormulaLexer: () => (/* binding */ FormulaLexer),
/* harmony export */   FormulaParser: () => (/* binding */ FormulaParser)
/* harmony export */ });
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _Ast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/* harmony import */ var _CellAddress__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _LexerConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(62);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







/**
 * LL(k) formula parser described using Chevrotain DSL
 *
 * It is equivalent to the grammar below:
 *
 * F -> '=' E <br/>
 * B -> K < B | K >= B ... | K <br/>
 * K -> E & K | E <br/>
 * E -> M + E | M - E | M <br/>
 * M -> W * M | W / M | W <br/>
 * W -> C * W | C <br/>
 * C -> N | R | O | A | P | num <br/>
 * N -> '(' E ')' <br/>
 * R -> A:OFFSET(..) | A:A <br/>
 * O -> OFFSET(..) | OFFSET(..):A | OFFSET(..):OFFSET(..) <br/>
 * A -> A1 | $A1 | A$1 | $A$1 <br/>
 * P -> SUM(..) <br/>
 */
class FormulaParser extends chevrotain__WEBPACK_IMPORTED_MODULE_0__.EmbeddedActionsParser {
  constructor(lexerConfig, sheetMapping) {
    super(lexerConfig.allTokens, {
      outputCst: false,
      maxLookahead: 7
    });
    this.booleanExpressionOrEmpty = this.RULE('booleanExpressionOrEmpty', () => {
      return this.OR([{
        ALT: () => this.SUBRULE(this.booleanExpression)
      }, {
        ALT: (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ALT)((0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildEmptyArgAst)())
      }]);
    });
    /**
     * Rule for procedure expressions: SUM(1,A1)
     */
    this.procedureExpression = this.RULE('procedureExpression', () => {
      var _a;
      const procedureNameToken = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.ProcedureName);
      const procedureName = procedureNameToken.image.toUpperCase().slice(0, -1);
      const canonicalProcedureName = (_a = this.lexerConfig.functionMapping[procedureName]) !== null && _a !== void 0 ? _a : procedureName;
      const args = [];
      let argument = this.SUBRULE(this.booleanExpressionOrEmpty);
      this.MANY(() => {
        var _a;
        const separator = this.CONSUME(this.lexerConfig.ArgSeparator);
        if (argument.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.EMPTY) {
          argument.leadingWhitespace = (_a = separator.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image;
        }
        args.push(argument);
        argument = this.SUBRULE2(this.booleanExpressionOrEmpty);
      });
      args.push(argument);
      if (args.length === 1 && args[0].type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.EMPTY) {
        args.length = 0;
      }
      const rParenToken = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.RParen);
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildProcedureAst)(canonicalProcedureName, args, procedureNameToken.leadingWhitespace, rParenToken.leadingWhitespace);
    });
    this.namedExpressionExpression = this.RULE('namedExpressionExpression', () => {
      const name = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.NamedExpression);
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildNamedExpressionAst)(name.image, name.leadingWhitespace);
    });
    /**
     * Rule for OFFSET() function expression
     */
    this.offsetProcedureExpression = this.RULE('offsetProcedureExpression', () => {
      const args = [];
      this.CONSUME(this.lexerConfig.OffsetProcedureName);
      this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.LParen);
      this.MANY_SEP({
        SEP: this.lexerConfig.ArgSeparator,
        DEF: () => {
          args.push(this.SUBRULE(this.booleanExpression));
        }
      });
      this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.RParen);
      return this.handleOffsetHeuristic(args);
    });
    /**
     * Rule for column range, e.g., A:B, Sheet1!A:B, Sheet1!A:Sheet1!B
     */
    this.columnRangeExpression = this.RULE('columnRangeExpression', () => {
      const range = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.ColumnRange);
      const [startImage, endImage] = range.image.split(':');
      const firstAddress = this.ACTION(() => (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.columnAddressFromString)(this.sheetMapping, startImage, this.formulaAddress));
      const secondAddress = this.ACTION(() => (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.columnAddressFromString)(this.sheetMapping, endImage, this.formulaAddress));
      if (firstAddress === undefined || secondAddress === undefined) {
        return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF));
      }
      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns)) {
        return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildErrorWithRawInputAst)(range.image, new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NAME), range.leadingWhitespace);
      }
      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {
        return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.ParserError, 'Malformed range expression');
      }
      const {
        firstEnd,
        secondEnd,
        sheetRefType
      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildColumnRangeAst)(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);
    });
    /**
     * Rule for row range, e.g., 1:2, Sheet1!1:2, Sheet1!1:Sheet1!2
     */
    this.rowRangeExpression = this.RULE('rowRangeExpression', () => {
      const range = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.RowRange);
      const [startImage, endImage] = range.image.split(':');
      const firstAddress = this.ACTION(() => (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.rowAddressFromString)(this.sheetMapping, startImage, this.formulaAddress));
      const secondAddress = this.ACTION(() => (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.rowAddressFromString)(this.sheetMapping, endImage, this.formulaAddress));
      if (firstAddress === undefined || secondAddress === undefined) {
        return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF));
      }
      if (firstAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows) || secondAddress.exceedsSheetSizeLimits(this.lexerConfig.maxRows)) {
        return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildErrorWithRawInputAst)(range.image, new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NAME), range.leadingWhitespace);
      }
      if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {
        return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.ParserError, 'Malformed range expression');
      }
      const {
        firstEnd,
        secondEnd,
        sheetRefType
      } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildRowRangeAst)(firstEnd, secondEnd, sheetRefType, range.leadingWhitespace);
    });
    /**
     * Rule for cell reference expression (e.g., A1, $A1, A$1, $A$1, $Sheet42!A$17)
     */
    this.cellReference = this.RULE('cellReference', () => {
      const cell = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.CellReference);
      const address = this.ACTION(() => {
        return (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.cellAddressFromString)(this.sheetMapping, cell.image, this.formulaAddress);
      });
      if (address === undefined) {
        return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildErrorWithRawInputAst)(cell.image, new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF), cell.leadingWhitespace);
      } else if (address.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {
        return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildErrorWithRawInputAst)(cell.image, new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NAME), cell.leadingWhitespace);
      } else {
        return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellReferenceAst)(address, cell.leadingWhitespace);
      }
    });
    /**
     * Rule for end range reference expression with additional checks considering range start
     */
    this.endRangeReference = this.RULE('endRangeReference', start => {
      var _a;
      const end = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.CellReference);
      const startAddress = this.ACTION(() => {
        return (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.cellAddressFromString)(this.sheetMapping, start.image, this.formulaAddress);
      });
      const endAddress = this.ACTION(() => {
        return (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.cellAddressFromString)(this.sheetMapping, end.image, this.formulaAddress);
      });
      if (startAddress === undefined || endAddress === undefined) {
        return this.ACTION(() => {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildErrorWithRawInputAst)(`${start.image}:${end.image}`, new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF), start.leadingWhitespace);
        });
      } else if (startAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows) || endAddress.exceedsSheetSizeLimits(this.lexerConfig.maxColumns, this.lexerConfig.maxRows)) {
        return this.ACTION(() => {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildErrorWithRawInputAst)(`${start.image}:${end.image}`, new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NAME), start.leadingWhitespace);
        });
      }
      return this.buildCellRange(startAddress, endAddress, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);
    });
    /**
     * Rule for end of range expression
     *
     * End of range may be a cell reference or OFFSET() function call
     */
    this.endOfRangeExpression = this.RULE('endOfRangeExpression', start => {
      return this.OR([{
        ALT: () => {
          return this.SUBRULE(this.endRangeReference, {
            ARGS: [start]
          });
        }
      }, {
        ALT: () => {
          var _a;
          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);
          const startAddress = this.ACTION(() => {
            return (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.cellAddressFromString)(this.sheetMapping, start.image, this.formulaAddress);
          });
          if (startAddress === undefined) {
            return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF));
          }
          if (offsetProcedure.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CELL_REFERENCE) {
            return this.buildCellRange(startAddress, offsetProcedure.reference, (_a = start.leadingWhitespace) === null || _a === void 0 ? void 0 : _a.image);
          } else {
            return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');
          }
        }
      }]);
    });
    /**
     * Rule for cell ranges (e.g., A1:B$3, A1:OFFSET())
     */
    this.cellRangeExpression = this.RULE('cellRangeExpression', () => {
      const start = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.CellReference);
      this.CONSUME2(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.RangeSeparator);
      return this.SUBRULE(this.endOfRangeExpression, {
        ARGS: [start]
      });
    });
    /**
     * Rule for end range reference expression starting with offset procedure with additional checks considering range start
     */
    this.endRangeWithOffsetStartReference = this.RULE('endRangeWithOffsetStartReference', start => {
      const end = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.CellReference);
      const endAddress = this.ACTION(() => {
        return (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_3__.cellAddressFromString)(this.sheetMapping, end.image, this.formulaAddress);
      });
      if (endAddress === undefined) {
        return this.ACTION(() => {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF));
        });
      }
      return this.buildCellRange(start.reference, endAddress, start.leadingWhitespace);
    });
    /**
     * Rule for end of range expression
     *
     * End of range may be a cell reference or OFFSET() function call
     */
    this.endOfRangeWithOffsetStartExpression = this.RULE('endOfRangeWithOffsetStartExpression', start => {
      return this.OR([{
        ALT: () => {
          return this.SUBRULE(this.endRangeWithOffsetStartReference, {
            ARGS: [start]
          });
        }
      }, {
        ALT: () => {
          const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);
          if (offsetProcedure.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CELL_REFERENCE) {
            return this.buildCellRange(start.reference, offsetProcedure.reference, start.leadingWhitespace);
          } else {
            return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');
          }
        }
      }]);
    });
    /**
     * Rule for expressions that start with the OFFSET function.
     *
     * The OFFSET function can occur as a cell reference, or as a part of a cell range.
     * To preserve LL(k) properties, expressions that start with the OFFSET function need a separate rule.
     *
     * Depending on the presence of the {@link RangeSeparator}, a proper {@link Ast} node type is built.
     */
    this.offsetExpression = this.RULE('offsetExpression', () => {
      const offsetProcedure = this.SUBRULE(this.offsetProcedureExpression);
      let end;
      this.OPTION(() => {
        this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.RangeSeparator);
        if (offsetProcedure.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CELL_RANGE) {
          end = this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.RangeOffsetNotAllowed, 'Range offset not allowed here');
        } else {
          end = this.SUBRULE(this.endOfRangeWithOffsetStartExpression, {
            ARGS: [offsetProcedure]
          });
        }
      });
      if (end !== undefined) {
        return end;
      }
      return offsetProcedure;
    });
    this.insideArrayExpression = this.RULE('insideArrayExpression', () => {
      const ret = [[]];
      ret[ret.length - 1].push(this.SUBRULE(this.booleanExpression));
      this.MANY(() => {
        this.OR([{
          ALT: () => {
            this.CONSUME(this.lexerConfig.ArrayColSeparator);
            ret[ret.length - 1].push(this.SUBRULE2(this.booleanExpression));
          }
        }, {
          ALT: () => {
            this.CONSUME(this.lexerConfig.ArrayRowSeparator);
            ret.push([]);
            ret[ret.length - 1].push(this.SUBRULE3(this.booleanExpression));
          }
        }]);
      });
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildArrayAst)(ret);
    });
    /**
     * Rule for parenthesis expression
     */
    this.parenthesisExpression = this.RULE('parenthesisExpression', () => {
      const lParenToken = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.LParen);
      const expression = this.SUBRULE(this.booleanExpression);
      const rParenToken = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.RParen);
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildParenthesisAst)(expression, lParenToken.leadingWhitespace, rParenToken.leadingWhitespace);
    });
    this.arrayExpression = this.RULE('arrayExpression', () => {
      return this.OR([{
        ALT: () => {
          const ltoken = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.ArrayLParen);
          const ret = this.SUBRULE(this.insideArrayExpression);
          const rtoken = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.ArrayRParen);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildArrayAst)(ret.args, ltoken.leadingWhitespace, rtoken.leadingWhitespace);
        }
      }, {
        ALT: () => this.SUBRULE(this.parenthesisExpression)
      }]);
    });
    this.numericStringToNumber = input => {
      const normalized = input.replace(this.lexerConfig.decimalSeparator, '.');
      return Number(normalized);
    };
    /**
     * Rule for positive atomic expressions
     */
    this.positiveAtomicExpression = this.RULE('positiveAtomicExpression', () => {
      var _a;
      return this.OR((_a = this.atomicExpCache) !== null && _a !== void 0 ? _a : this.atomicExpCache = [{
        ALT: () => this.SUBRULE(this.arrayExpression)
      }, {
        ALT: () => this.SUBRULE(this.cellRangeExpression)
      }, {
        ALT: () => this.SUBRULE(this.columnRangeExpression)
      }, {
        ALT: () => this.SUBRULE(this.rowRangeExpression)
      }, {
        ALT: () => this.SUBRULE(this.offsetExpression)
      }, {
        ALT: () => this.SUBRULE(this.cellReference)
      }, {
        ALT: () => this.SUBRULE(this.procedureExpression)
      }, {
        ALT: () => this.SUBRULE(this.namedExpressionExpression)
      }, {
        ALT: () => {
          const number = this.CONSUME(this.lexerConfig.NumberLiteral);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildNumberAst)(this.numericStringToNumber(number.image), number.leadingWhitespace);
        }
      }, {
        ALT: () => {
          const str = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.StringLiteral);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildStringAst)(str);
        }
      }, {
        ALT: () => {
          const token = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.ErrorLiteral);
          const errString = token.image.toUpperCase();
          const errorType = this.lexerConfig.errorMapping[errString];
          if (errorType) {
            return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(errorType), token.leadingWhitespace);
          } else {
            return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.ParserError, 'Unknown error literal');
          }
        }
      }]);
    });
    this.rightUnaryOpAtomicExpression = this.RULE('rightUnaryOpAtomicExpression', () => {
      const positiveAtomicExpression = this.SUBRULE(this.positiveAtomicExpression);
      const percentage = this.OPTION(() => {
        return this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.PercentOp);
      });
      if (percentage) {
        return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildPercentOpAst)(positiveAtomicExpression, percentage.leadingWhitespace);
      }
      return positiveAtomicExpression;
    });
    /**
     * Rule for atomic expressions, which is positive atomic expression or negation of it
     */
    this.atomicExpression = this.RULE('atomicExpression', () => {
      return this.OR([{
        ALT: () => {
          const op = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.AdditionOp);
          const value = this.SUBRULE(this.atomicExpression);
          if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.PlusOp)) {
            return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildPlusUnaryOpAst)(value, op.leadingWhitespace);
          } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.MinusOp)) {
            return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildMinusUnaryOpAst)(value, op.leadingWhitespace);
          } else {
            this.customParsingError = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.parsingError)(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.ParserError, 'Mismatched token type');
            return this.customParsingError;
          }
        }
      }, {
        ALT: () => this.SUBRULE2(this.rightUnaryOpAtomicExpression)
      }]);
    });
    /**
     * Rule for power expression
     */
    this.powerExpression = this.RULE('powerExpression', () => {
      let lhs = this.SUBRULE(this.atomicExpression);
      this.MANY(() => {
        const op = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.PowerOp);
        const rhs = this.SUBRULE2(this.atomicExpression);
        if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.PowerOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildPowerOpAst)(lhs, rhs, op.leadingWhitespace);
        } else {
          this.ACTION(() => {
            throw Error('Operator not supported');
          });
        }
      });
      return lhs;
    });
    /**
     * Rule for multiplication category operators (e.g., 1 * A1, 1 / A1)
     */
    this.multiplicationExpression = this.RULE('multiplicationExpression', () => {
      let lhs = this.SUBRULE(this.powerExpression);
      this.MANY(() => {
        const op = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.MultiplicationOp);
        const rhs = this.SUBRULE2(this.powerExpression);
        if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.TimesOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildTimesOpAst)(lhs, rhs, op.leadingWhitespace);
        } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.DivOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildDivOpAst)(lhs, rhs, op.leadingWhitespace);
        } else {
          this.ACTION(() => {
            throw Error('Operator not supported');
          });
        }
      });
      return lhs;
    });
    /**
     * Rule for addition category operators (e.g., 1 + A1, 1 - A1)
     */
    this.additionExpression = this.RULE('additionExpression', () => {
      let lhs = this.SUBRULE(this.multiplicationExpression);
      this.MANY(() => {
        const op = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.AdditionOp);
        const rhs = this.SUBRULE2(this.multiplicationExpression);
        if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.PlusOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildPlusOpAst)(lhs, rhs, op.leadingWhitespace);
        } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.MinusOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildMinusOpAst)(lhs, rhs, op.leadingWhitespace);
        } else {
          this.ACTION(() => {
            throw Error('Operator not supported');
          });
        }
      });
      return lhs;
    });
    /**
     * Rule for concatenation operator expression (e.g., "=" & A1)
     */
    this.concatenateExpression = this.RULE('concatenateExpression', () => {
      let lhs = this.SUBRULE(this.additionExpression);
      this.MANY(() => {
        const op = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.ConcatenateOp);
        const rhs = this.SUBRULE2(this.additionExpression);
        lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildConcatenateOpAst)(lhs, rhs, op.leadingWhitespace);
      });
      return lhs;
    });
    /**
     * Rule for boolean expression (e.g., 1 <= A1)
     */
    this.booleanExpression = this.RULE('booleanExpression', () => {
      let lhs = this.SUBRULE(this.concatenateExpression);
      this.MANY(() => {
        const op = this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.BooleanOp);
        const rhs = this.SUBRULE2(this.concatenateExpression);
        if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.EqualsOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildEqualsOpAst)(lhs, rhs, op.leadingWhitespace);
        } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.NotEqualOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildNotEqualOpAst)(lhs, rhs, op.leadingWhitespace);
        } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.GreaterThanOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildGreaterThanOpAst)(lhs, rhs, op.leadingWhitespace);
        } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.LessThanOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildLessThanOpAst)(lhs, rhs, op.leadingWhitespace);
        } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.GreaterThanOrEqualOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildGreaterThanOrEqualOpAst)(lhs, rhs, op.leadingWhitespace);
        } else if ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(op, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.LessThanOrEqualOp)) {
          lhs = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildLessThanOrEqualOpAst)(lhs, rhs, op.leadingWhitespace);
        } else {
          this.ACTION(() => {
            throw Error('Operator not supported');
          });
        }
      });
      return lhs;
    });
    /**
     * Entry rule
     */
    this.formula = this.RULE('formula', () => {
      this.CONSUME(_LexerConfig__WEBPACK_IMPORTED_MODULE_6__.EqualsOp);
      return this.SUBRULE(this.booleanExpression);
    });
    this.lexerConfig = lexerConfig;
    this.sheetMapping = sheetMapping;
    this.formulaAddress = (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(0, 0, 0);
    this.performSelfAnalysis();
  }
  /**
   * Parses tokenized formula and builds abstract syntax tree
   *
   * @param {ExtendedToken[]} tokens - tokenized formula
   * @param {SimpleCellAddress} formulaAddress - address of the cell in which formula is located
   */
  parseFromTokens(tokens, formulaAddress) {
    this.input = tokens;
    let ast = this.formulaWithContext(formulaAddress);
    let errors = [];
    if (this.customParsingError) {
      errors.push(this.customParsingError);
    }
    errors = errors.concat(this.errors.map(e => ({
      type: _Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.ParserError,
      message: e.message
    })));
    if (errors.length > 0) {
      ast = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildParsingErrorAst)();
    }
    return {
      ast,
      errors
    };
  }
  reset() {
    super.reset();
    this.customParsingError = undefined;
  }
  /**
   * Entry rule wrapper that sets formula address
   *
   * @param {SimpleCellAddress} address - address of the cell in which formula is located
   */
  formulaWithContext(address) {
    this.formulaAddress = address;
    return this.formula();
  }
  buildCellRange(firstAddress, secondAddress, leadingWhitespace) {
    if (firstAddress.sheet === undefined && secondAddress.sheet !== undefined) {
      return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.ParserError, 'Malformed range expression');
    }
    const {
      firstEnd,
      secondEnd,
      sheetRefType
    } = FormulaParser.fixSheetIdsForRangeEnds(firstAddress, secondAddress);
    return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellRangeAst)(firstEnd, secondEnd, sheetRefType, leadingWhitespace);
  }
  static fixSheetIdsForRangeEnds(firstEnd, secondEnd) {
    const sheetRefType = FormulaParser.rangeSheetReferenceType(firstEnd.sheet, secondEnd.sheet);
    const secondEndFixed = firstEnd.sheet !== undefined && secondEnd.sheet === undefined ? secondEnd.withSheet(firstEnd.sheet) : secondEnd;
    return {
      firstEnd,
      secondEnd: secondEndFixed,
      sheetRefType
    };
  }
  /**
   * Returns {@link CellReferenceAst} or {@link CellRangeAst} based on OFFSET function arguments
   *
   * @param {Ast[]} args - OFFSET function arguments
   */
  handleOffsetHeuristic(args) {
    const cellArg = args[0];
    if (cellArg.type !== _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CELL_REFERENCE) {
      return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'First argument to OFFSET is not a reference');
    }
    const rowsArg = args[1];
    let rowShift;
    if (rowsArg.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER && Number.isInteger(rowsArg.value)) {
      rowShift = rowsArg.value;
    } else if (rowsArg.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.PLUS_UNARY_OP && rowsArg.value.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {
      rowShift = rowsArg.value.value;
    } else if (rowsArg.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.MINUS_UNARY_OP && rowsArg.value.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER && Number.isInteger(rowsArg.value.value)) {
      rowShift = -rowsArg.value.value;
    } else {
      return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'Second argument to OFFSET is not a static number');
    }
    const columnsArg = args[2];
    let colShift;
    if (columnsArg.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER && Number.isInteger(columnsArg.value)) {
      colShift = columnsArg.value;
    } else if (columnsArg.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.PLUS_UNARY_OP && columnsArg.value.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {
      colShift = columnsArg.value.value;
    } else if (columnsArg.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.MINUS_UNARY_OP && columnsArg.value.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER && Number.isInteger(columnsArg.value.value)) {
      colShift = -columnsArg.value.value;
    } else {
      return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'Third argument to OFFSET is not a static number');
    }
    const heightArg = args[3];
    let height;
    if (heightArg === undefined) {
      height = 1;
    } else if (heightArg.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER) {
      height = heightArg.value;
      if (height < 1) {
        return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is too small number');
      } else if (!Number.isInteger(height)) {
        return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not integer');
      }
    } else {
      return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'Fourth argument to OFFSET is not a static number');
    }
    const widthArg = args[4];
    let width;
    if (widthArg === undefined) {
      width = 1;
    } else if (widthArg.type === _Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER) {
      width = widthArg.value;
      if (width < 1) {
        return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is too small number');
      } else if (!Number.isInteger(width)) {
        return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not integer');
      }
    } else {
      return this.parsingError(_Ast__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorType.StaticOffsetError, 'Fifth argument to OFFSET is not a static number');
    }
    const topLeftCorner = new _CellAddress__WEBPACK_IMPORTED_MODULE_5__.CellAddress(cellArg.reference.col + colShift, cellArg.reference.row + rowShift, cellArg.reference.type);
    let absoluteCol = topLeftCorner.col;
    let absoluteRow = topLeftCorner.row;
    if (cellArg.reference.type === _CellAddress__WEBPACK_IMPORTED_MODULE_5__.CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === _CellAddress__WEBPACK_IMPORTED_MODULE_5__.CellReferenceType.CELL_REFERENCE_ABSOLUTE_COL) {
      absoluteRow = absoluteRow + this.formulaAddress.row;
    }
    if (cellArg.reference.type === _CellAddress__WEBPACK_IMPORTED_MODULE_5__.CellReferenceType.CELL_REFERENCE_RELATIVE || cellArg.reference.type === _CellAddress__WEBPACK_IMPORTED_MODULE_5__.CellReferenceType.CELL_REFERENCE_ABSOLUTE_ROW) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      absoluteCol = absoluteCol + this.formulaAddress.col;
    }
    if (absoluteCol < 0 || absoluteRow < 0) {
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.OutOfSheet));
    }
    if (width === 1 && height === 1) {
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellReferenceAst)(topLeftCorner);
    } else {
      const bottomRightCorner = new _CellAddress__WEBPACK_IMPORTED_MODULE_5__.CellAddress(topLeftCorner.col + width - 1, topLeftCorner.row + height - 1, topLeftCorner.type);
      return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildCellRangeAst)(topLeftCorner, bottomRightCorner, _Ast__WEBPACK_IMPORTED_MODULE_4__.RangeSheetReferenceType.RELATIVE);
    }
  }
  parsingError(type, message) {
    this.customParsingError = (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.parsingError)(type, message);
    return (0,_Ast__WEBPACK_IMPORTED_MODULE_4__.buildParsingErrorAst)();
  }
  static rangeSheetReferenceType(start, end) {
    if (start === undefined) {
      return _Ast__WEBPACK_IMPORTED_MODULE_4__.RangeSheetReferenceType.RELATIVE;
    } else if (end === undefined) {
      return _Ast__WEBPACK_IMPORTED_MODULE_4__.RangeSheetReferenceType.START_ABSOLUTE;
    } else {
      return _Ast__WEBPACK_IMPORTED_MODULE_4__.RangeSheetReferenceType.BOTH_ABSOLUTE;
    }
  }
}
class FormulaLexer {
  constructor(lexerConfig) {
    this.lexerConfig = lexerConfig;
    this.lexer = new chevrotain__WEBPACK_IMPORTED_MODULE_0__.Lexer(lexerConfig.allTokens, {
      ensureOptimizations: true
    });
  }
  /**
   * Returns Lexer tokens from formula string
   *
   * @param {string} text - string representation of a formula
   */
  tokenizeFormula(text) {
    const lexingResult = this.lexer.tokenize(text);
    let tokens = lexingResult.tokens;
    tokens = this.trimTrailingWhitespaces(tokens);
    tokens = this.skipWhitespacesInsideRanges(tokens);
    tokens = this.skipWhitespacesBeforeArgSeparators(tokens);
    lexingResult.tokens = tokens;
    return lexingResult;
  }
  skipWhitespacesInsideRanges(tokens) {
    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {
      return ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(previous, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.CellReference) || (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(previous, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.RangeSeparator)) && (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(current, this.lexerConfig.WhiteSpace) && ((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(next, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.CellReference) || (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(next, _LexerConfig__WEBPACK_IMPORTED_MODULE_6__.RangeSeparator));
    });
  }
  skipWhitespacesBeforeArgSeparators(tokens) {
    return FormulaLexer.filterTokensByNeighbors(tokens, (previous, current, next) => {
      return !(0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(previous, this.lexerConfig.ArgSeparator) && (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(current, this.lexerConfig.WhiteSpace) && (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(next, this.lexerConfig.ArgSeparator);
    });
  }
  static filterTokensByNeighbors(tokens, shouldBeSkipped) {
    if (tokens.length < 3) {
      return tokens;
    }
    let i = 0;
    const filteredTokens = [tokens[i++]];
    while (i < tokens.length - 1) {
      if (!shouldBeSkipped(tokens[i - 1], tokens[i], tokens[i + 1])) {
        filteredTokens.push(tokens[i]);
      }
      ++i;
    }
    filteredTokens.push(tokens[i]);
    return filteredTokens;
  }
  trimTrailingWhitespaces(tokens) {
    if (tokens.length > 0 && (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(tokens[tokens.length - 1], this.lexerConfig.WhiteSpace)) {
      tokens.pop();
    }
    return tokens;
  }
}

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorMessage: () => (/* binding */ ErrorMessage)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * This is a class for detailed error messages across HyperFormula.
 */
class ErrorMessage {}
ErrorMessage.DistinctSigns = 'Distinct signs.';
ErrorMessage.WrongArgNumber = 'Wrong number of arguments.';
ErrorMessage.EmptyArg = 'Empty function argument.';
ErrorMessage.EmptyArray = 'Empty array not allowed.';
ErrorMessage.ArrayDimensions = 'Array dimensions are not compatible.';
ErrorMessage.NoSpaceForArrayResult = 'No space for array result.';
ErrorMessage.ValueSmall = 'Value too small.';
ErrorMessage.ValueLarge = 'Value too large.';
ErrorMessage.BadCriterion = 'Incorrect criterion.';
ErrorMessage.RangeManySheets = 'Range spans more than one sheet.';
ErrorMessage.CellRangeExpected = 'Cell range expected.';
ErrorMessage.WrongDimension = 'Wrong range dimension.';
ErrorMessage.ScalarExpected = 'Cell range not allowed.';
ErrorMessage.NumberCoercion = 'Value cannot be coerced to number.';
ErrorMessage.NumberExpected = 'Number argument expected.';
ErrorMessage.IntegerExpected = 'Value needs to be an integer.';
ErrorMessage.BadMode = 'Mode not recognized.';
ErrorMessage.DateBounds = 'Date outside of bounds.';
ErrorMessage.OutOfSheet = 'Resulting reference is out of the sheet.';
ErrorMessage.WrongType = 'Wrong type of argument.';
ErrorMessage.NaN = 'NaN or infinite value encountered.';
ErrorMessage.EqualLength = 'Ranges need to be of equal length.';
ErrorMessage.Negative = 'Value cannot be negative.';
ErrorMessage.NotBinary = 'String does not represent a binary number.';
ErrorMessage.NotOctal = 'String does not represent an octal number.';
ErrorMessage.NotHex = 'String does not represent a hexadecimal number.';
ErrorMessage.EndStartPeriod = 'End period needs to be at least start period.';
ErrorMessage.CellRefExpected = 'Cell reference expected.';
ErrorMessage.EmptyRange = 'Empty range not allowed.';
ErrorMessage.BadRef = 'Address is not correct.';
ErrorMessage.NumberRange = 'Number-only range expected.';
ErrorMessage.ValueNotFound = 'Value not found.';
ErrorMessage.ValueBaseLarge = 'Value in base too large.';
ErrorMessage.ValueBaseSmall = 'Value in base too small.';
ErrorMessage.ValueBaseLong = 'Value in base too long.';
ErrorMessage.NegativeLength = 'Length cannot be negative.';
ErrorMessage.PatternNotFound = 'Pattern not found.';
ErrorMessage.OneValue = 'Needs at least one value.';
ErrorMessage.TwoValues = 'Range needs to contain at least two elements.';
ErrorMessage.ThreeValues = 'Range needs to contain at least three elements.';
ErrorMessage.IndexBounds = 'Index out of bounds.';
ErrorMessage.IndexLarge = 'Index too large.';
ErrorMessage.Formula = 'Expected formula.';
ErrorMessage.NegativeCount = 'Count cannot be negative.';
ErrorMessage.ParseError = 'Parsing error.';
ErrorMessage.SheetRef = 'Sheet does not exist.';
ErrorMessage.PeriodLong = 'Period number cannot exceed life length.';
ErrorMessage.InvalidDate = 'Invalid date.';
ErrorMessage.BitshiftLong = 'Result of bitshift is too long.';
ErrorMessage.EmptyString = 'Empty-string argument not allowed.';
ErrorMessage.LengthBounds = 'Length out of bounds.';
ErrorMessage.NegativeTime = 'Time cannot be negative.';
ErrorMessage.NoDefault = 'No default option.';
ErrorMessage.NoConditionMet = 'None of the conditions were met.';
ErrorMessage.Selector = 'Selector cannot exceed the number of arguments.';
ErrorMessage.StartEndDate = 'Start date needs to be earlier than end date.';
ErrorMessage.IncorrectDateTime = 'String does not represent correct DateTime.';
ErrorMessage.CharacterCodeBounds = 'Character code out of bounds.';
ErrorMessage.NonZero = 'Argument cannot be 0.';
ErrorMessage.LessThanOne = 'Argument cannot be less than 1.';
ErrorMessage.WeekendString = 'Incorrect weekend bitmask string.';
ErrorMessage.InvalidRoman = 'Invalid roman numeral.';
ErrorMessage.WrongOrder = 'Wrong order of values.';
ErrorMessage.ComplexNumberExpected = 'Complex number expected.';
ErrorMessage.ShouldBeIorJ = 'Should be \'i\' or \'j\'.';
ErrorMessage.SizeMismatch = 'Array dimensions mismatched.';
ErrorMessage.FunctionName = arg => `Function name ${arg} not recognized.`;
ErrorMessage.NamedExpressionName = arg => `Named expression ${arg} not recognized.`;
ErrorMessage.LicenseKey = arg => `License key is ${arg}.`;

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AdditionOp: () => (/* binding */ AdditionOp),
/* harmony export */   ArrayLParen: () => (/* binding */ ArrayLParen),
/* harmony export */   ArrayRParen: () => (/* binding */ ArrayRParen),
/* harmony export */   BooleanOp: () => (/* binding */ BooleanOp),
/* harmony export */   CellReference: () => (/* binding */ CellReference),
/* harmony export */   ColumnRange: () => (/* binding */ ColumnRange),
/* harmony export */   ConcatenateOp: () => (/* binding */ ConcatenateOp),
/* harmony export */   DivOp: () => (/* binding */ DivOp),
/* harmony export */   EqualsOp: () => (/* binding */ EqualsOp),
/* harmony export */   ErrorLiteral: () => (/* binding */ ErrorLiteral),
/* harmony export */   GreaterThanOp: () => (/* binding */ GreaterThanOp),
/* harmony export */   GreaterThanOrEqualOp: () => (/* binding */ GreaterThanOrEqualOp),
/* harmony export */   LParen: () => (/* binding */ LParen),
/* harmony export */   LessThanOp: () => (/* binding */ LessThanOp),
/* harmony export */   LessThanOrEqualOp: () => (/* binding */ LessThanOrEqualOp),
/* harmony export */   MinusOp: () => (/* binding */ MinusOp),
/* harmony export */   MultiplicationOp: () => (/* binding */ MultiplicationOp),
/* harmony export */   NamedExpression: () => (/* binding */ NamedExpression),
/* harmony export */   NotEqualOp: () => (/* binding */ NotEqualOp),
/* harmony export */   PercentOp: () => (/* binding */ PercentOp),
/* harmony export */   PlusOp: () => (/* binding */ PlusOp),
/* harmony export */   PowerOp: () => (/* binding */ PowerOp),
/* harmony export */   ProcedureName: () => (/* binding */ ProcedureName),
/* harmony export */   RParen: () => (/* binding */ RParen),
/* harmony export */   RangeSeparator: () => (/* binding */ RangeSeparator),
/* harmony export */   RowRange: () => (/* binding */ RowRange),
/* harmony export */   StringLiteral: () => (/* binding */ StringLiteral),
/* harmony export */   TimesOp: () => (/* binding */ TimesOp),
/* harmony export */   buildLexerConfig: () => (/* binding */ buildLexerConfig)
/* harmony export */ });
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _parser_consts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _CellReferenceMatcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63);
/* harmony import */ var _NamedExpressionMatcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(64);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




const AdditionOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'AdditionOp',
  pattern: chevrotain__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA
});
const PlusOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'PlusOp',
  pattern: /\+/,
  categories: AdditionOp
});
const MinusOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'MinusOp',
  pattern: /-/,
  categories: AdditionOp
});
const MultiplicationOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'MultiplicationOp',
  pattern: chevrotain__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA
});
const TimesOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'TimesOp',
  pattern: /\*/,
  categories: MultiplicationOp
});
const DivOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'DivOp',
  pattern: /\//,
  categories: MultiplicationOp
});
const PowerOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'PowerOp',
  pattern: /\^/
});
const PercentOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'PercentOp',
  pattern: /%/
});
const BooleanOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'BooleanOp',
  pattern: chevrotain__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA
});
const EqualsOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'EqualsOp',
  pattern: /=/,
  categories: BooleanOp
});
const NotEqualOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'NotEqualOp',
  pattern: /<>/,
  categories: BooleanOp
});
const GreaterThanOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'GreaterThanOp',
  pattern: />/,
  categories: BooleanOp
});
const LessThanOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'LessThanOp',
  pattern: /</,
  categories: BooleanOp
});
const GreaterThanOrEqualOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'GreaterThanOrEqualOp',
  pattern: />=/,
  categories: BooleanOp
});
const LessThanOrEqualOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'LessThanOrEqualOp',
  pattern: /<=/,
  categories: BooleanOp
});
const ConcatenateOp = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'ConcatenateOp',
  pattern: /&/
});
const LParen = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'LParen',
  pattern: /\(/
});
const RParen = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'RParen',
  pattern: /\)/
});
const ArrayLParen = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'ArrayLParen',
  pattern: /{/
});
const ArrayRParen = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'ArrayRParen',
  pattern: /}/
});
const StringLiteral = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'StringLiteral',
  pattern: /"([^"\\]*(\\.[^"\\]*)*)"/
});
const ErrorLiteral = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'ErrorLiteral',
  pattern: /#[A-Za-z0-9\/]+[?!]?/
});
const RangeSeparator = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'RangeSeparator',
  pattern: new RegExp(_parser_consts__WEBPACK_IMPORTED_MODULE_1__.RANGE_OPERATOR)
});
const ColumnRange = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'ColumnRange',
  pattern: new RegExp(`${_parser_consts__WEBPACK_IMPORTED_MODULE_1__.COLUMN_REFERENCE_PATTERN}${_parser_consts__WEBPACK_IMPORTED_MODULE_1__.RANGE_OPERATOR}${_parser_consts__WEBPACK_IMPORTED_MODULE_1__.COLUMN_REFERENCE_PATTERN}`)
});
const RowRange = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'RowRange',
  pattern: new RegExp(`${_parser_consts__WEBPACK_IMPORTED_MODULE_1__.ROW_REFERENCE_PATTERN}${_parser_consts__WEBPACK_IMPORTED_MODULE_1__.RANGE_OPERATOR}${_parser_consts__WEBPACK_IMPORTED_MODULE_1__.ROW_REFERENCE_PATTERN}`)
});
const ProcedureName = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'ProcedureName',
  pattern: new RegExp(`([${_parser_consts__WEBPACK_IMPORTED_MODULE_1__.UNICODE_LETTER_PATTERN}][${_parser_consts__WEBPACK_IMPORTED_MODULE_1__.NON_RESERVED_CHARACTER_PATTERN}]*)\\(`)
});
const cellReferenceMatcher = new _CellReferenceMatcher__WEBPACK_IMPORTED_MODULE_2__.CellReferenceMatcher();
const CellReference = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'CellReference',
  pattern: cellReferenceMatcher.match.bind(cellReferenceMatcher),
  start_chars_hint: cellReferenceMatcher.POSSIBLE_START_CHARACTERS,
  line_breaks: false
});
const namedExpressionMatcher = new _NamedExpressionMatcher__WEBPACK_IMPORTED_MODULE_3__.NamedExpressionMatcher();
const NamedExpression = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
  name: 'NamedExpression',
  pattern: namedExpressionMatcher.match.bind(namedExpressionMatcher),
  start_chars_hint: namedExpressionMatcher.POSSIBLE_START_CHARACTERS,
  line_breaks: false
});
/**
 * Builds the configuration object for the lexer
 */
const buildLexerConfig = config => {
  const offsetProcedureNameLiteral = config.translationPackage.getFunctionTranslation('OFFSET');
  const errorMapping = config.errorMapping;
  const functionMapping = config.translationPackage.buildFunctionMapping();
  const whitespaceTokenRegexp = new RegExp(config.ignoreWhiteSpace === 'standard' ? _parser_consts__WEBPACK_IMPORTED_MODULE_1__.ODFF_WHITESPACE_PATTERN : _parser_consts__WEBPACK_IMPORTED_MODULE_1__.ALL_WHITESPACE_PATTERN);
  const WhiteSpace = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
    name: 'WhiteSpace',
    pattern: whitespaceTokenRegexp
  });
  const ArrayRowSeparator = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
    name: 'ArrayRowSep',
    pattern: config.arrayRowSeparator
  });
  const ArrayColSeparator = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
    name: 'ArrayColSep',
    pattern: config.arrayColumnSeparator
  });
  const NumberLiteral = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
    name: 'NumberLiteral',
    pattern: new RegExp(`(([${config.decimalSeparator}]\\d+)|(\\d+([${config.decimalSeparator}]\\d*)?))(e[+-]?\\d+)?`)
  });
  const OffsetProcedureName = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
    name: 'OffsetProcedureName',
    pattern: new RegExp(offsetProcedureNameLiteral, 'i')
  });
  let ArgSeparator;
  let inject;
  if (config.functionArgSeparator === config.arrayColumnSeparator) {
    ArgSeparator = ArrayColSeparator;
    inject = [];
  } else if (config.functionArgSeparator === config.arrayRowSeparator) {
    ArgSeparator = ArrayRowSeparator;
    inject = [];
  } else {
    ArgSeparator = (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.createToken)({
      name: 'ArgSeparator',
      pattern: config.functionArgSeparator
    });
    inject = [ArgSeparator];
  }
  /* order is important, first pattern is used */
  const allTokens = [WhiteSpace, PlusOp, MinusOp, TimesOp, DivOp, PowerOp, EqualsOp, NotEqualOp, PercentOp, GreaterThanOrEqualOp, LessThanOrEqualOp, GreaterThanOp, LessThanOp, LParen, RParen, ArrayLParen, ArrayRParen, OffsetProcedureName, ProcedureName, RangeSeparator, ...inject, ColumnRange, RowRange, NumberLiteral, StringLiteral, ErrorLiteral, ConcatenateOp, BooleanOp, AdditionOp, MultiplicationOp, CellReference, NamedExpression, ArrayRowSeparator, ArrayColSeparator];
  return {
    ArgSeparator,
    NumberLiteral,
    OffsetProcedureName,
    ArrayRowSeparator,
    ArrayColSeparator,
    WhiteSpace,
    allTokens,
    errorMapping,
    functionMapping,
    decimalSeparator: config.decimalSeparator,
    maxColumns: config.maxColumns,
    maxRows: config.maxRows
  };
};

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellReferenceMatcher: () => (/* binding */ CellReferenceMatcher)
/* harmony export */ });
/* harmony import */ var _parser_consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Helper class for recognizing CellReference token in text
 */
class CellReferenceMatcher {
  constructor() {
    this.POSSIBLE_START_CHARACTERS = [..._parser_consts__WEBPACK_IMPORTED_MODULE_0__.ALL_UNICODE_LETTERS_ARRAY, ..._parser_consts__WEBPACK_IMPORTED_MODULE_0__.ALL_DIGITS_ARRAY, _parser_consts__WEBPACK_IMPORTED_MODULE_0__.ABSOLUTE_OPERATOR, "'", '_'];
    this.cellReferenceRegexp = new RegExp(_parser_consts__WEBPACK_IMPORTED_MODULE_0__.CELL_REFERENCE_WITH_NEXT_CHARACTER_PATTERN, 'y');
  }
  /**
   * Method used by the lexer to recognize CellReference token in text
   *
   * Note: using 'y' sticky flag for a named expression which is not supported on IE11...
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky
   */
  match(text, startOffset) {
    this.cellReferenceRegexp.lastIndex = startOffset;
    const execResult = this.cellReferenceRegexp.exec(text + '@');
    if (execResult == null || execResult[1] == null) {
      return null;
    }
    execResult[0] = execResult[1];
    return execResult;
  }
}

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NamedExpressionMatcher: () => (/* binding */ NamedExpressionMatcher)
/* harmony export */ });
/* harmony import */ var _parser_consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Helper class for recognizing NamedExpression token in text
 */
class NamedExpressionMatcher {
  constructor() {
    this.POSSIBLE_START_CHARACTERS = [..._parser_consts__WEBPACK_IMPORTED_MODULE_0__.ALL_UNICODE_LETTERS_ARRAY, '_'];
    this.namedExpressionRegexp = new RegExp(_parser_consts__WEBPACK_IMPORTED_MODULE_0__.NAMED_EXPRESSION_PATTERN, 'y');
    this.r1c1CellRefRegexp = new RegExp(`^${_parser_consts__WEBPACK_IMPORTED_MODULE_0__.R1C1_CELL_REFERENCE_PATTERN}$`);
  }
  /**
   * Method used by the lexer to recognize NamedExpression token in text
   *
   * Note: using 'y' sticky flag for a named expression which is not supported on IE11...
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky
   */
  match(text, startOffset) {
    this.namedExpressionRegexp.lastIndex = startOffset;
    const execResult = this.namedExpressionRegexp.exec(text);
    if (execResult == null || execResult[0] == null) {
      return null;
    }
    if (this.r1c1CellRefRegexp.test(execResult[0])) {
      return null;
    }
    return execResult;
  }
}

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Unparser: () => (/* binding */ Unparser),
/* harmony export */   formatNumber: () => (/* binding */ formatNumber)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8);
/* harmony import */ var _Ast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57);
/* harmony import */ var _binaryOpTokenMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





class Unparser {
  constructor(config, lexerConfig, sheetMappingFn, namedExpressions) {
    this.config = config;
    this.lexerConfig = lexerConfig;
    this.sheetMappingFn = sheetMappingFn;
    this.namedExpressions = namedExpressions;
  }
  unparse(ast, address) {
    return '=' + this.unparseAst(ast, address);
  }
  unparseAst(ast, address) {
    var _a, _b;
    switch (ast.type) {
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.EMPTY:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)('', ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.NUMBER:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(formatNumber(ast.value, this.config.decimalSeparator), ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.STRING:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)('"' + ast.value + '"', ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.FUNCTION_CALL:
        {
          const args = ast.args.map(arg => arg !== undefined ? this.unparseAst(arg, address) : '').join(this.config.functionArgSeparator);
          const procedureName = this.config.translationPackage.isFunctionTranslated(ast.procedureName) ? this.config.translationPackage.getFunctionTranslation(ast.procedureName) : ast.procedureName;
          const rightPart = procedureName + '(' + args + (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(')', ast.internalWhitespace);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(rightPart, ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.NAMED_EXPRESSION:
        {
          const originalNamedExpressionName = (_a = this.namedExpressions.nearestNamedExpression(ast.expressionName, address.sheet)) === null || _a === void 0 ? void 0 : _a.displayName;
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(originalNamedExpressionName || ast.expressionName, ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_REFERENCE:
        {
          let image;
          if (ast.reference.sheet !== undefined) {
            image = this.unparseSheetName(ast.reference.sheet) + '!';
          } else {
            image = '';
          }
          image += (_b = ast.reference.unparse(address)) !== null && _b !== void 0 ? _b : this.config.translationPackage.getErrorTranslation(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(image, ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.COLUMN_RANGE:
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ROW_RANGE:
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_RANGE:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(this.formatRange(ast, address), ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PLUS_UNARY_OP:
        {
          const unparsedExpr = this.unparseAst(ast.value, address);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)('+', ast.leadingWhitespace) + unparsedExpr;
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.MINUS_UNARY_OP:
        {
          const unparsedExpr = this.unparseAst(ast.value, address);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)('-', ast.leadingWhitespace) + unparsedExpr;
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PERCENT_OP:
        {
          return this.unparseAst(ast.value, address) + (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)('%', ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ERROR:
        {
          const image = this.config.translationPackage.getErrorTranslation(ast.error ? ast.error.type : _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.ERROR);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(image, ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ERROR_WITH_RAW_INPUT:
        {
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(ast.rawInput, ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PARENTHESIS:
        {
          const expression = this.unparseAst(ast.expression, address);
          const rightPart = '(' + expression + (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(')', ast.internalWhitespace);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(rightPart, ast.leadingWhitespace);
        }
      case _Ast__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ARRAY:
        {
          const ret = '{' + ast.args.map(row => row.map(val => this.unparseAst(val, address)).join(this.config.arrayColumnSeparator)).join(this.config.arrayRowSeparator) + (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)('}', ast.internalWhitespace);
          return (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(ret, ast.leadingWhitespace);
        }
      default:
        {
          const left = this.unparseAst(ast.left, address);
          const right = this.unparseAst(ast.right, address);
          return left + (0,_Ast__WEBPACK_IMPORTED_MODULE_3__.imageWithWhitespace)(_binaryOpTokenMap__WEBPACK_IMPORTED_MODULE_4__.binaryOpTokenMap[ast.type], ast.leadingWhitespace) + right;
        }
    }
  }
  unparseSheetName(sheetId) {
    const sheetName = (0,_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_2__.sheetIndexToString)(sheetId, this.sheetMappingFn);
    if (sheetName === undefined) {
      throw new _index__WEBPACK_IMPORTED_MODULE_1__.NoSheetWithIdError(sheetId);
    }
    return sheetName;
  }
  formatRange(ast, baseAddress) {
    let startSheeet = '';
    let endSheet = '';
    if (ast.start.sheet !== undefined && ast.sheetReferenceType !== _Ast__WEBPACK_IMPORTED_MODULE_3__.RangeSheetReferenceType.RELATIVE) {
      startSheeet = this.unparseSheetName(ast.start.sheet) + '!';
    }
    if (ast.end.sheet !== undefined && ast.sheetReferenceType === _Ast__WEBPACK_IMPORTED_MODULE_3__.RangeSheetReferenceType.BOTH_ABSOLUTE) {
      endSheet = this.unparseSheetName(ast.end.sheet) + '!';
    }
    const unparsedStart = ast.start.unparse(baseAddress);
    const unparsedEnd = ast.end.unparse(baseAddress);
    if (unparsedStart === undefined || unparsedEnd === undefined) {
      return this.config.translationPackage.getErrorTranslation(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF);
    }
    return `${startSheeet}${unparsedStart}:${endSheet}${unparsedEnd}`;
  }
}
function formatNumber(number, decimalSeparator) {
  const numericString = number.toString();
  return numericString.replace('.', decimalSeparator);
}

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   collectDependencies: () => (/* binding */ collectDependencies)
/* harmony export */ });
/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const collectDependenciesFn = (ast, functionRegistry, dependenciesSet, needArgument) => {
  switch (ast.type) {
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.EMPTY:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.NUMBER:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.STRING:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.ERROR:
      return;
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.NAMED_EXPRESSION:
      {
        if (needArgument) {
          dependenciesSet.push(new ___WEBPACK_IMPORTED_MODULE_0__.NamedExpressionDependency(ast.expressionName));
        }
        return;
      }
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.CELL_REFERENCE:
      {
        if (needArgument) {
          dependenciesSet.push(new ___WEBPACK_IMPORTED_MODULE_0__.AddressDependency(ast.reference));
        }
        return;
      }
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.CELL_RANGE:
      {
        if (needArgument && ast.start.sheet === ast.end.sheet) {
          dependenciesSet.push(new ___WEBPACK_IMPORTED_MODULE_0__.CellRangeDependency(ast.start, ast.end));
        }
        return;
      }
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.COLUMN_RANGE:
      {
        if (needArgument && ast.start.sheet === ast.end.sheet) {
          dependenciesSet.push(new ___WEBPACK_IMPORTED_MODULE_0__.ColumnRangeDependency(ast.start, ast.end));
        }
        return;
      }
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.ROW_RANGE:
      {
        if (needArgument && ast.start.sheet === ast.end.sheet) {
          dependenciesSet.push(new ___WEBPACK_IMPORTED_MODULE_0__.RowRangeDependency(ast.start, ast.end));
        }
        return;
      }
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PERCENT_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PLUS_UNARY_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.MINUS_UNARY_OP:
      {
        collectDependenciesFn(ast.value, functionRegistry, dependenciesSet, true);
        return;
      }
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.CONCATENATE_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.EQUALS_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.NOT_EQUAL_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.LESS_THAN_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.GREATER_THAN_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.LESS_THAN_OR_EQUAL_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.GREATER_THAN_OR_EQUAL_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.MINUS_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PLUS_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.TIMES_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.DIV_OP:
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.POWER_OP:
      collectDependenciesFn(ast.left, functionRegistry, dependenciesSet, true);
      collectDependenciesFn(ast.right, functionRegistry, dependenciesSet, true);
      return;
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.PARENTHESIS:
      collectDependenciesFn(ast.expression, functionRegistry, dependenciesSet, needArgument);
      return;
    case ___WEBPACK_IMPORTED_MODULE_0__.AstNodeType.FUNCTION_CALL:
      {
        const functionNeedArgument = !functionRegistry.doesFunctionNeedArgumentToBeComputed(ast.procedureName);
        ast.args.forEach(argAst => collectDependenciesFn(argAst, functionRegistry, dependenciesSet, functionNeedArgument));
        return;
      }
  }
};
const collectDependencies = (ast, functionRegistry) => {
  const result = new Array();
  collectDependenciesFn(ast, functionRegistry, result, true);
  return result;
};

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddressDependency: () => (/* binding */ AddressDependency),
/* harmony export */   CellRangeDependency: () => (/* binding */ CellRangeDependency),
/* harmony export */   ColumnRangeDependency: () => (/* binding */ ColumnRangeDependency),
/* harmony export */   NamedExpressionDependency: () => (/* binding */ NamedExpressionDependency),
/* harmony export */   RowRangeDependency: () => (/* binding */ RowRangeDependency)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class AddressDependency {
  constructor(dependency) {
    this.dependency = dependency;
  }
  absolutize(baseAddress) {
    return this.dependency.toSimpleCellAddress(baseAddress);
  }
}
class CellRangeDependency {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  absolutize(baseAddress) {
    return new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(this.start.toSimpleCellAddress(baseAddress), this.end.toSimpleCellAddress(baseAddress));
  }
}
class ColumnRangeDependency {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  absolutize(baseAddress) {
    const start = this.start.toSimpleColumnAddress(baseAddress);
    const end = this.end.toSimpleColumnAddress(baseAddress);
    return new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteColumnRange(start.sheet, start.col, end.col);
  }
}
class RowRangeDependency {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  absolutize(baseAddress) {
    const start = this.start.toSimpleRowAddress(baseAddress);
    const end = this.end.toSimpleRowAddress(baseAddress);
    return new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteRowRange(start.sheet, start.row, end.row);
  }
}
class NamedExpressionDependency {
  constructor(name) {
    this.name = name;
  }
  absolutize(_baseAddress) {
    return this;
  }
}

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContentChanges: () => (/* binding */ ContentChanges)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(69);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class ContentChanges {
  constructor() {
    this.changes = new Map();
  }
  static empty() {
    return new ContentChanges();
  }
  addAll(other) {
    for (const change of other.changes.values()) {
      this.add(change.address, change);
    }
    return this;
  }
  addChange(newValue, address, oldValue) {
    this.addInterpreterValue(newValue, address, oldValue);
  }
  exportChanges(exporter) {
    let ret = [];
    this.changes.forEach(e => {
      const change = exporter.exportChange(e);
      if (Array.isArray(change)) {
        ret = ret.concat(change);
      } else {
        ret.push(change);
      }
    });
    return ret;
  }
  getChanges() {
    return Array.from(this.changes.values());
  }
  isEmpty() {
    return this.changes.size === 0;
  }
  add(address, change) {
    const value = change.value;
    if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_1__.SimpleRangeValue) {
      for (const cellAddress of value.effectiveAddressesFromData(address)) {
        this.changes.delete((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.addressKey)(cellAddress));
      }
    }
    this.changes.set((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.addressKey)(address), change);
  }
  addInterpreterValue(value, address, oldValue) {
    this.add(address, {
      address,
      value,
      oldValue
    });
  }
}

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SimpleRangeValue: () => (/* binding */ SimpleRangeValue)
/* harmony export */ });
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/**
 * A class that represents a range of data.
 */
class SimpleRangeValue {
  /**
   * In most cases, it's more convenient to create a `SimpleRangeValue` object
   * by calling one of the [static factory methods](#fromrange).
   */
  constructor(_data,
  /**
   * A property that represents the address of the range.
   */
  range, dependencyGraph, _hasOnlyNumbers) {
    this._data = _data;
    this.range = range;
    this.dependencyGraph = dependencyGraph;
    this._hasOnlyNumbers = _hasOnlyNumbers;
    this.size = _data === undefined ? new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize(range.effectiveWidth(dependencyGraph), range.effectiveHeight(dependencyGraph)) : new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize(_data[0].length, _data.length);
  }
  /**
   * Returns the range data as a 2D array.
   */
  get data() {
    this.ensureThatComputed();
    return this._data;
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object with the provided range address and the provided data.
   */
  static fromRange(data, range, dependencyGraph) {
    return new SimpleRangeValue(data, range, dependencyGraph, true);
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object with the provided numeric data.
   */
  static onlyNumbers(data) {
    return new SimpleRangeValue(data, undefined, undefined, true);
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object with the provided data.
   */
  static onlyValues(data) {
    return new SimpleRangeValue(data, undefined, undefined, undefined);
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object with the provided range address.
   */
  static onlyRange(range, dependencyGraph) {
    return new SimpleRangeValue(undefined, range, dependencyGraph, undefined);
  }
  /**
   * A factory method. Returns a `SimpleRangeValue` object that contains a single value.
   */
  static fromScalar(scalar) {
    return new SimpleRangeValue([[scalar]], undefined, undefined, undefined);
  }
  /**
   * Returns `true` if and only if the `SimpleRangeValue` has no address set.
   */
  isAdHoc() {
    return this.range === undefined;
  }
  /**
   * Returns the number of columns contained in the range.
   */
  width() {
    return this.size.width;
  }
  /**
   * Returns the number of rows contained in the range.
   */
  height() {
    return this.size.height;
  }
  /**
   * Returns the range data as a 1D array.
   */
  valuesFromTopLeftCorner() {
    this.ensureThatComputed();
    const ret = [];
    for (let i = 0; i < this._data.length; i++) {
      for (let j = 0; j < this._data[0].length; j++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        ret.push(this._data[i][j]);
      }
    }
    return ret;
  }
  /**
   * Generates the addresses of the cells contained in the range assuming the provided address is the left corner of the range.
   */
  *effectiveAddressesFromData(leftCorner) {
    for (let row = 0; row < this.data.length; ++row) {
      const rowData = this.data[row];
      for (let col = 0; col < rowData.length; ++col) {
        yield (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row);
      }
    }
  }
  /**
   * Generates values and addresses of the cells contained in the range assuming the provided address is the left corner of the range.
   *
   * This method combines the functionalities of [`iterateValuesFromTopLeftCorner()`](#iteratevaluesfromtopleftcorner) and [`effectiveAddressesFromData()`](#effectiveaddressesfromdata).
   */
  *entriesFromTopLeftCorner(leftCorner) {
    this.ensureThatComputed();
    for (let row = 0; row < this.size.height; ++row) {
      for (let col = 0; col < this.size.width; ++col) {
        yield [this._data[row][col], (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(leftCorner.sheet, leftCorner.col + col, leftCorner.row + row)];
      }
    }
  }
  /**
   * Generates the values of the cells contained in the range assuming the provided address is the left corner of the range.
   */
  *iterateValuesFromTopLeftCorner() {
    yield* this.valuesFromTopLeftCorner();
  }
  /**
   * Returns the number of cells contained in the range.
   */
  numberOfElements() {
    return this.size.width * this.size.height;
  }
  /**
   * Returns `true` if and only if the range contains only numeric values.
   */
  hasOnlyNumbers() {
    if (this._hasOnlyNumbers === undefined) {
      this._hasOnlyNumbers = true;
      for (const row of this.data) {
        for (const v of row) {
          if (typeof v !== 'number') {
            this._hasOnlyNumbers = false;
            return false;
          }
        }
      }
    }
    return this._hasOnlyNumbers;
  }
  /**
   * Returns the range data as a 2D array of numbers.
   *
   * Internal use only.
   */
  rawNumbers() {
    return this._data;
  }
  /**
   * Returns the range data as a 2D array.
   *
   * Internal use only.
   */
  rawData() {
    var _a;
    this.ensureThatComputed();
    return (_a = this._data) !== null && _a !== void 0 ? _a : [];
  }
  /**
   * Returns `true` if and only if the range has the same width and height as the `other` range object.
   */
  sameDimensionsAs(other) {
    return this.width() === other.width() && this.height() === other.height();
  }
  /**
   * Computes the range data if it is not computed yet.
   */
  ensureThatComputed() {
    if (this._data !== undefined) {
      return;
    }
    this._hasOnlyNumbers = true;
    this._data = this.range.addressesArrayMap(this.dependencyGraph, cellFromRange => {
      const value = this.dependencyGraph.getCellValue(cellFromRange);
      if (value instanceof SimpleRangeValue) {
        this._hasOnlyNumbers = false;
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ScalarExpected);
      } else if ((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(value)) {
        return value;
      } else {
        this._hasOnlyNumbers = false;
        return value;
      }
    });
  }
}

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CurrencyNumber: () => (/* binding */ CurrencyNumber),
/* harmony export */   DateNumber: () => (/* binding */ DateNumber),
/* harmony export */   DateTimeNumber: () => (/* binding */ DateTimeNumber),
/* harmony export */   EmptyValue: () => (/* binding */ EmptyValue),
/* harmony export */   NumberType: () => (/* binding */ NumberType),
/* harmony export */   PercentNumber: () => (/* binding */ PercentNumber),
/* harmony export */   RichNumber: () => (/* binding */ RichNumber),
/* harmony export */   TimeNumber: () => (/* binding */ TimeNumber),
/* harmony export */   cloneNumber: () => (/* binding */ cloneNumber),
/* harmony export */   getFormatOfExtendedNumber: () => (/* binding */ getFormatOfExtendedNumber),
/* harmony export */   getRawValue: () => (/* binding */ getRawValue),
/* harmony export */   getTypeFormatOfExtendedNumber: () => (/* binding */ getTypeFormatOfExtendedNumber),
/* harmony export */   getTypeOfExtendedNumber: () => (/* binding */ getTypeOfExtendedNumber),
/* harmony export */   isExtendedNumber: () => (/* binding */ isExtendedNumber)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * A symbol representing an empty cell value.
 */
const EmptyValue = Symbol('Empty value');
function getRawValue(num) {
  if (num instanceof RichNumber) {
    return num.val;
  } else {
    return num;
  }
}
class RichNumber {
  constructor(val, format) {
    this.val = val;
    this.format = format;
  }
  fromNumber(val) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    return new this.constructor(val);
  }
}
function cloneNumber(val, newVal) {
  if (typeof val === 'number') {
    return newVal;
  } else {
    const ret = val.fromNumber(newVal);
    ret.format = val.format;
    return ret;
  }
}
class DateNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_DATE;
  }
}
class CurrencyNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_CURRENCY;
  }
}
class TimeNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_TIME;
  }
}
class DateTimeNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_DATETIME;
  }
}
class PercentNumber extends RichNumber {
  getDetailedType() {
    return NumberType.NUMBER_PERCENT;
  }
}
function isExtendedNumber(val) {
  return typeof val === 'number' || val instanceof RichNumber;
}
var NumberType;
(function (NumberType) {
  NumberType["NUMBER_RAW"] = "NUMBER_RAW";
  NumberType["NUMBER_DATE"] = "NUMBER_DATE";
  NumberType["NUMBER_TIME"] = "NUMBER_TIME";
  NumberType["NUMBER_DATETIME"] = "NUMBER_DATETIME";
  NumberType["NUMBER_CURRENCY"] = "NUMBER_CURRENCY";
  NumberType["NUMBER_PERCENT"] = "NUMBER_PERCENT";
})(NumberType || (NumberType = {}));
function getTypeOfExtendedNumber(num) {
  if (num instanceof RichNumber) {
    return num.getDetailedType();
  } else {
    return NumberType.NUMBER_RAW;
  }
}
function getFormatOfExtendedNumber(num) {
  if (num instanceof RichNumber) {
    return num.format;
  } else {
    return undefined;
  }
}
function getTypeFormatOfExtendedNumber(num) {
  if (num instanceof RichNumber) {
    return {
      type: num.getDetailedType(),
      format: num.format
    };
  } else {
    return {
      type: NumberType.NUMBER_RAW
    };
  }
}

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColumnsSpan: () => (/* binding */ ColumnsSpan),
/* harmony export */   RowsSpan: () => (/* binding */ RowsSpan)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/*
 * A class representing a set of rows in specific sheet
 */
class RowsSpan {
  constructor(sheet, rowStart, rowEnd) {
    this.sheet = sheet;
    this.rowStart = rowStart;
    this.rowEnd = rowEnd;
    if (rowStart < 0) {
      throw Error('Starting row cant be less than 0');
    }
    if (rowEnd < rowStart) {
      throw Error('Row span cant end before start');
    }
  }
  get numberOfRows() {
    return this.rowEnd - this.rowStart + 1;
  }
  get start() {
    return this.rowStart;
  }
  get end() {
    return this.rowEnd;
  }
  static fromNumberOfRows(sheet, rowStart, numberOfRows) {
    return new RowsSpan(sheet, rowStart, rowStart + numberOfRows - 1);
  }
  static fromRowStartAndEnd(sheet, rowStart, rowEnd) {
    return new RowsSpan(sheet, rowStart, rowEnd);
  }
  *rows() {
    for (let col = this.rowStart; col <= this.rowEnd; ++col) {
      yield col;
    }
  }
  intersect(otherSpan) {
    if (this.sheet !== otherSpan.sheet) {
      throw Error('Can\'t intersect spans from different sheets');
    }
    const start = Math.max(this.rowStart, otherSpan.rowStart);
    const end = Math.min(this.rowEnd, otherSpan.rowEnd);
    if (start > end) {
      return null;
    }
    return new RowsSpan(this.sheet, start, end);
  }
  firstRow() {
    return new RowsSpan(this.sheet, this.rowStart, this.rowStart);
  }
}
/*
 * A class representing a set of columns in specific sheet
 */
class ColumnsSpan {
  constructor(sheet, columnStart, columnEnd) {
    this.sheet = sheet;
    this.columnStart = columnStart;
    this.columnEnd = columnEnd;
    if (columnStart < 0) {
      throw Error('Starting column cant be less than 0');
    }
    if (columnEnd < columnStart) {
      throw Error('Column span cant end before start');
    }
  }
  get numberOfColumns() {
    return this.columnEnd - this.columnStart + 1;
  }
  get start() {
    return this.columnStart;
  }
  get end() {
    return this.columnEnd;
  }
  static fromNumberOfColumns(sheet, columnStart, numberOfColumns) {
    return new ColumnsSpan(sheet, columnStart, columnStart + numberOfColumns - 1);
  }
  static fromColumnStartAndEnd(sheet, columnStart, columnEnd) {
    return new ColumnsSpan(sheet, columnStart, columnEnd);
  }
  *columns() {
    for (let col = this.columnStart; col <= this.columnEnd; ++col) {
      yield col;
    }
  }
  intersect(otherSpan) {
    if (this.sheet !== otherSpan.sheet) {
      throw Error('Can\'t intersect spans from different sheets');
    }
    const start = Math.max(this.columnStart, otherSpan.columnStart);
    const end = Math.min(this.columnEnd, otherSpan.columnEnd);
    if (start > end) {
      return null;
    }
    return new ColumnsSpan(this.sheet, start, end);
  }
  firstColumn() {
    return new ColumnsSpan(this.sheet, this.columnStart, this.columnStart);
  }
}

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyStatistics: () => (/* reexport safe */ _EmptyStatistics__WEBPACK_IMPORTED_MODULE_0__.EmptyStatistics),
/* harmony export */   StatType: () => (/* reexport safe */ _StatType__WEBPACK_IMPORTED_MODULE_2__.StatType),
/* harmony export */   Statistics: () => (/* reexport safe */ _Statistics__WEBPACK_IMPORTED_MODULE_1__.Statistics)
/* harmony export */ });
/* harmony import */ var _EmptyStatistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);
/* harmony import */ var _Statistics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(74);
/* harmony import */ var _StatType__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyStatistics: () => (/* binding */ EmptyStatistics)
/* harmony export */ });
/* harmony import */ var _Statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/** Do not store stats in the memory. Stats are not needed on daily basis */
class EmptyStatistics extends _Statistics__WEBPACK_IMPORTED_MODULE_0__.Statistics {
  /** @inheritDoc */
  incrementCriterionFunctionFullCacheUsed() {
    // do nothing
  }
  /** @inheritDoc */
  incrementCriterionFunctionPartialCacheUsed() {
    // do nothing
  }
  /** @inheritDoc */
  start(_name) {
    // do nothing
  }
  /** @inheritDoc */
  end(_name) {
    // do nothing
  }
}

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Statistics: () => (/* binding */ Statistics)
/* harmony export */ });
/* harmony import */ var _StatType__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Provides tracking performance statistics to the engine
 */
class Statistics {
  constructor() {
    this.stats = new Map([[_StatType__WEBPACK_IMPORTED_MODULE_0__.StatType.CRITERION_FUNCTION_FULL_CACHE_USED, 0], [_StatType__WEBPACK_IMPORTED_MODULE_0__.StatType.CRITERION_FUNCTION_PARTIAL_CACHE_USED, 0]]);
    this.startTimes = new Map();
  }
  incrementCriterionFunctionFullCacheUsed() {
    var _a;
    const newValue = ((_a = this.stats.get(_StatType__WEBPACK_IMPORTED_MODULE_0__.StatType.CRITERION_FUNCTION_FULL_CACHE_USED)) !== null && _a !== void 0 ? _a : 0) + 1;
    this.stats.set(_StatType__WEBPACK_IMPORTED_MODULE_0__.StatType.CRITERION_FUNCTION_FULL_CACHE_USED, newValue);
  }
  incrementCriterionFunctionPartialCacheUsed() {
    var _a;
    const newValue = ((_a = this.stats.get(_StatType__WEBPACK_IMPORTED_MODULE_0__.StatType.CRITERION_FUNCTION_PARTIAL_CACHE_USED)) !== null && _a !== void 0 ? _a : 0) + 1;
    this.stats.set(_StatType__WEBPACK_IMPORTED_MODULE_0__.StatType.CRITERION_FUNCTION_PARTIAL_CACHE_USED, newValue);
  }
  /**
   * Resets statistics
   */
  reset() {
    this.stats.clear();
    this.startTimes.clear();
    this.stats.set(_StatType__WEBPACK_IMPORTED_MODULE_0__.StatType.CRITERION_FUNCTION_FULL_CACHE_USED, 0);
    this.stats.set(_StatType__WEBPACK_IMPORTED_MODULE_0__.StatType.CRITERION_FUNCTION_PARTIAL_CACHE_USED, 0);
  }
  /**
   * Starts tracking particular statistic.
   *
   * @param name - statistic to start tracking
   */
  start(name) {
    if (this.startTimes.get(name)) {
      throw Error(`Statistics ${name} already started`);
    } else {
      this.startTimes.set(name, Date.now());
    }
  }
  /**
   * Stops tracking particular statistic.
   * Raise error if tracking statistic wasn't started.
   *
   * @param name - statistic to stop tracking
   */
  end(name) {
    var _a;
    const now = Date.now();
    const startTime = this.startTimes.get(name);
    if (startTime) {
      let values = (_a = this.stats.get(name)) !== null && _a !== void 0 ? _a : 0;
      values += now - startTime;
      this.stats.set(name, values);
      this.startTimes.delete(name);
    } else {
      throw Error(`Statistics ${name} not started`);
    }
  }
  /**
   * Measure given statistic as execution of given function.
   *
   * @param name - statistic to track
   * @param func - function to call
   * @returns result of the function call
   */
  measure(name, func) {
    this.start(name);
    const result = func();
    this.end(name);
    return result;
  }
  /**
   * Returns the snapshot of current results
   */
  snapshot() {
    return new Map(this.stats);
  }
}

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StatType: () => (/* binding */ StatType)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
var StatType;
(function (StatType) {
  /* build engine */
  StatType["BUILD_ENGINE_TOTAL"] = "BUILD_ENGINE_TOTAL";
  StatType["PARSER"] = "PARSER";
  StatType["GRAPH_BUILD"] = "GRAPH_BUILD";
  StatType["COLLECT_DEPENDENCIES"] = "COLLECT_DEPENDENCIES";
  StatType["PROCESS_DEPENDENCIES"] = "PROCESS_DEPENDENCIES";
  StatType["TOP_SORT"] = "TOP_SORT";
  StatType["BUILD_COLUMN_INDEX"] = "BUILD_COLUMN_INDEX";
  StatType["EVALUATION"] = "EVALUATION";
  StatType["VLOOKUP"] = "VLOOKUP";
  /* crud adjustments */
  StatType["TRANSFORM_ASTS"] = "TRANSFORM_ASTS";
  StatType["TRANSFORM_ASTS_POSTPONED"] = "TRANSFORM_ASTS_POSTPONED";
  StatType["ADJUSTING_ADDRESS_MAPPING"] = "ADJUSTING_ADDRESS_MAPPING";
  StatType["ADJUSTING_ARRAY_MAPPING"] = "ADJUSTING_ARRAY_MAPPING";
  StatType["ADJUSTING_RANGES"] = "ADJUSTING_RANGES";
  StatType["ADJUSTING_GRAPH"] = "ADJUSTING_GRAPH";
  /* criterion cache */
  StatType["CRITERION_FUNCTION_FULL_CACHE_USED"] = "CRITERION_FUNCTION_FULL_CACHE_USED";
  StatType["CRITERION_FUNCTION_PARTIAL_CACHE_USED"] = "CRITERION_FUNCTION_PARTIAL_CACHE_USED";
})(StatType || (StatType = {}));

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddressMapping: () => (/* binding */ AddressMapping)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class AddressMapping {
  constructor(policy) {
    this.policy = policy;
    this.mapping = new Map();
  }
  /** @inheritDoc */
  getCell(address) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (sheetMapping === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(address.sheet);
    }
    return sheetMapping.getCell(address);
  }
  fetchCell(address) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (sheetMapping === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(address.sheet);
    }
    const vertex = sheetMapping.getCell(address);
    if (!vertex) {
      throw Error('Vertex for address missing in AddressMapping');
    }
    return vertex;
  }
  strategyFor(sheetId) {
    const strategy = this.mapping.get(sheetId);
    if (strategy === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(sheetId);
    }
    return strategy;
  }
  addSheet(sheetId, strategy) {
    if (this.mapping.has(sheetId)) {
      throw Error('Sheet already added');
    }
    this.mapping.set(sheetId, strategy);
  }
  autoAddSheet(sheetId, sheetBoundaries) {
    const {
      height,
      width,
      fill
    } = sheetBoundaries;
    const strategyConstructor = this.policy.call(fill);
    this.addSheet(sheetId, new strategyConstructor(width, height));
  }
  getCellValue(address) {
    const vertex = this.getCell(address);
    if (vertex === undefined) {
      return _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.EmptyValue;
    } else if (vertex instanceof _index__WEBPACK_IMPORTED_MODULE_2__.ArrayVertex) {
      return vertex.getArrayCellValue(address);
    } else {
      return vertex.getCellValue();
    }
  }
  getRawValue(address) {
    const vertex = this.getCell(address);
    if (vertex instanceof _index__WEBPACK_IMPORTED_MODULE_2__.ValueCellVertex) {
      return vertex.getValues().rawValue;
    } else if (vertex instanceof _index__WEBPACK_IMPORTED_MODULE_2__.ArrayVertex) {
      return vertex.getArrayCellRawValue(address);
    } else {
      return null;
    }
  }
  /** @inheritDoc */
  setCell(address, newVertex) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (!sheetMapping) {
      throw Error('Sheet not initialized');
    }
    sheetMapping.setCell(address, newVertex);
  }
  moveCell(source, destination) {
    const sheetMapping = this.mapping.get(source.sheet);
    if (!sheetMapping) {
      throw Error('Sheet not initialized.');
    }
    if (source.sheet !== destination.sheet) {
      throw Error('Cannot move cells between sheets.');
    }
    if (sheetMapping.has(destination)) {
      throw new Error('Cannot move cell. Destination already occupied.');
    }
    const vertex = sheetMapping.getCell(source);
    if (vertex === undefined) {
      throw new Error('Cannot move cell. No cell with such address.');
    }
    this.setCell(destination, vertex);
    this.removeCell(source);
  }
  removeCell(address) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (!sheetMapping) {
      throw Error('Sheet not initialized');
    }
    sheetMapping.removeCell(address);
  }
  /** @inheritDoc */
  has(address) {
    const sheetMapping = this.mapping.get(address.sheet);
    if (sheetMapping === undefined) {
      return false;
    }
    return sheetMapping.has(address);
  }
  /** @inheritDoc */
  getHeight(sheetId) {
    const sheetMapping = this.mapping.get(sheetId);
    if (sheetMapping === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(sheetId);
    }
    return sheetMapping.getHeight();
  }
  /** @inheritDoc */
  getWidth(sheetId) {
    const sheetMapping = this.mapping.get(sheetId);
    if (!sheetMapping) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(sheetId);
    }
    return sheetMapping.getWidth();
  }
  addRows(sheet, row, numberOfRows) {
    const sheetMapping = this.mapping.get(sheet);
    if (sheetMapping === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(sheet);
    }
    sheetMapping.addRows(row, numberOfRows);
  }
  removeRows(removedRows) {
    const sheetMapping = this.mapping.get(removedRows.sheet);
    if (sheetMapping === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(removedRows.sheet);
    }
    sheetMapping.removeRows(removedRows);
  }
  removeSheet(sheetId) {
    this.mapping.delete(sheetId);
  }
  addColumns(sheet, column, numberOfColumns) {
    const sheetMapping = this.mapping.get(sheet);
    if (sheetMapping === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(sheet);
    }
    sheetMapping.addColumns(column, numberOfColumns);
  }
  removeColumns(removedColumns) {
    const sheetMapping = this.mapping.get(removedColumns.sheet);
    if (sheetMapping === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(removedColumns.sheet);
    }
    sheetMapping.removeColumns(removedColumns);
  }
  *verticesFromRowsSpan(rowsSpan) {
    yield* this.mapping.get(rowsSpan.sheet).verticesFromRowsSpan(rowsSpan); // eslint-disable-line @typescript-eslint/no-non-null-assertion
  }
  *verticesFromColumnsSpan(columnsSpan) {
    yield* this.mapping.get(columnsSpan.sheet).verticesFromColumnsSpan(columnsSpan); // eslint-disable-line @typescript-eslint/no-non-null-assertion
  }
  *entriesFromRowsSpan(rowsSpan) {
    yield* this.mapping.get(rowsSpan.sheet).entriesFromRowsSpan(rowsSpan);
  }
  *entriesFromColumnsSpan(columnsSpan) {
    yield* this.mapping.get(columnsSpan.sheet).entriesFromColumnsSpan(columnsSpan);
  }
  *entries() {
    for (const [sheet, mapping] of this.mapping.entries()) {
      yield* mapping.getEntries(sheet);
    }
  }
  *sheetEntries(sheet) {
    const sheetMapping = this.mapping.get(sheet);
    if (sheetMapping !== undefined) {
      yield* sheetMapping.getEntries(sheet);
    } else {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(sheet);
    }
  }
}

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AliasAlreadyExisting: () => (/* binding */ AliasAlreadyExisting),
/* harmony export */   ConfigValueEmpty: () => (/* binding */ ConfigValueEmpty),
/* harmony export */   ConfigValueTooBigError: () => (/* binding */ ConfigValueTooBigError),
/* harmony export */   ConfigValueTooSmallError: () => (/* binding */ ConfigValueTooSmallError),
/* harmony export */   EvaluationSuspendedError: () => (/* binding */ EvaluationSuspendedError),
/* harmony export */   ExpectedOneOfValuesError: () => (/* binding */ ExpectedOneOfValuesError),
/* harmony export */   ExpectedValueOfTypeError: () => (/* binding */ ExpectedValueOfTypeError),
/* harmony export */   FunctionPluginValidationError: () => (/* binding */ FunctionPluginValidationError),
/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),
/* harmony export */   InvalidArgumentsError: () => (/* binding */ InvalidArgumentsError),
/* harmony export */   LanguageAlreadyRegisteredError: () => (/* binding */ LanguageAlreadyRegisteredError),
/* harmony export */   LanguageNotRegisteredError: () => (/* binding */ LanguageNotRegisteredError),
/* harmony export */   MissingTranslationError: () => (/* binding */ MissingTranslationError),
/* harmony export */   NamedExpressionDoesNotExistError: () => (/* binding */ NamedExpressionDoesNotExistError),
/* harmony export */   NamedExpressionNameIsAlreadyTakenError: () => (/* binding */ NamedExpressionNameIsAlreadyTakenError),
/* harmony export */   NamedExpressionNameIsInvalidError: () => (/* binding */ NamedExpressionNameIsInvalidError),
/* harmony export */   NoOperationToRedoError: () => (/* binding */ NoOperationToRedoError),
/* harmony export */   NoOperationToUndoError: () => (/* binding */ NoOperationToUndoError),
/* harmony export */   NoRelativeAddressesAllowedError: () => (/* binding */ NoRelativeAddressesAllowedError),
/* harmony export */   NoSheetWithIdError: () => (/* binding */ NoSheetWithIdError),
/* harmony export */   NoSheetWithNameError: () => (/* binding */ NoSheetWithNameError),
/* harmony export */   NotAFormulaError: () => (/* binding */ NotAFormulaError),
/* harmony export */   NothingToPasteError: () => (/* binding */ NothingToPasteError),
/* harmony export */   ProtectedFunctionError: () => (/* binding */ ProtectedFunctionError),
/* harmony export */   ProtectedFunctionTranslationError: () => (/* binding */ ProtectedFunctionTranslationError),
/* harmony export */   SheetNameAlreadyTakenError: () => (/* binding */ SheetNameAlreadyTakenError),
/* harmony export */   SheetSizeLimitExceededError: () => (/* binding */ SheetSizeLimitExceededError),
/* harmony export */   SheetsNotEqual: () => (/* binding */ SheetsNotEqual),
/* harmony export */   SourceLocationHasArrayError: () => (/* binding */ SourceLocationHasArrayError),
/* harmony export */   TargetLocationHasArrayError: () => (/* binding */ TargetLocationHasArrayError),
/* harmony export */   UnableToParseError: () => (/* binding */ UnableToParseError)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * Error thrown when the sheet of a given ID does not exist.
 */
class NoSheetWithIdError extends Error {
  constructor(sheetId) {
    super(`There's no sheet with id = ${sheetId}`);
  }
}
/**
 * Error thrown when the sheet of a given name does not exist.
 */
class NoSheetWithNameError extends Error {
  constructor(sheetName) {
    super(`There's no sheet with name '${sheetName}'`);
  }
}
/**
 * Error thrown when the sheet of a given name already exists.
 */
class SheetNameAlreadyTakenError extends Error {
  constructor(sheetName) {
    super(`Sheet with name ${sheetName} already exists`);
  }
}
/**
 * Error thrown when loaded sheet size exceeds configured limits.
 */
class SheetSizeLimitExceededError extends Error {
  constructor() {
    super('Sheet size limit exceeded');
  }
}
/**
 * Error thrown when the the provided string is not a valid formula, i.e does not start with "="
 */
class NotAFormulaError extends Error {
  constructor() {
    super('This is not a formula');
  }
}
/**
 * Error thrown when the given address is invalid.
 */
class InvalidAddressError extends Error {
  constructor(address) {
    super(`Address (row = ${address.row}, col = ${address.col}) is invalid`);
  }
}
/**
 * Error thrown when the given arguments are invalid
 */
class InvalidArgumentsError extends Error {
  constructor(expectedArguments) {
    super(`Invalid arguments, expected ${expectedArguments}`);
  }
}
/**
 * Error thrown when the given sheets are not equal.
 */
class SheetsNotEqual extends Error {
  constructor(sheet1, sheet2) {
    super(`Sheets ${sheet1} and ${sheet2} are not equal.`);
  }
}
/**
 * Error thrown when the given named expression already exists in the workbook and therefore it cannot be added.
 */
class NamedExpressionNameIsAlreadyTakenError extends Error {
  constructor(expressionName) {
    super(`Name of Named Expression '${expressionName}' is already present`);
  }
}
/**
 * Error thrown when the name given for the named expression is invalid.
 */
class NamedExpressionNameIsInvalidError extends Error {
  constructor(expressionName) {
    super(`Name of Named Expression '${expressionName}' is invalid`);
  }
}
/**
 * Error thrown when the given named expression does not exist.
 */
class NamedExpressionDoesNotExistError extends Error {
  constructor(expressionName) {
    super(`Named Expression '${expressionName}' does not exist`);
  }
}
/**
 * Error thrown when there are no operations to be undone by the [[undo]] method.
 */
class NoOperationToUndoError extends Error {
  constructor() {
    super('There is no operation to undo');
  }
}
/**
 * Error thrown when there are no operations to redo by the [[redo]] method.
 */
class NoOperationToRedoError extends Error {
  constructor() {
    super('There is no operation to redo');
  }
}
/**
 * Error thrown when there is nothing to paste by the [[paste]] method.
 */
class NothingToPasteError extends Error {
  constructor() {
    super('There is nothing to paste');
  }
}
function replacer(key, val) {
  switch (typeof val) {
    case 'function':
    case 'symbol':
      return val.toString();
    case 'bigint':
      return 'BigInt(' + val.toString() + ')';
    default:
      {
        if (val instanceof RegExp) {
          return 'RegExp(' + val.toString() + ')';
        } else {
          return val;
        }
      }
  }
}
/**
 * Error thrown when the given value cannot be parsed.
 *
 * Checks against the validity in:
 *
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[setCellsContents]]
 */
class UnableToParseError extends Error {
  constructor(value) {
    super(`Unable to parse value: ${JSON.stringify(value, replacer, 4)}`);
  }
}
/**
 * Error thrown when the expected value type differs from the given value type.
 * It also displays the expected type.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ExpectedValueOfTypeError extends Error {
  constructor(expectedType, paramName) {
    super(`Expected value of type: ${expectedType} for config parameter: ${paramName}`);
  }
}
/**
 * Error thrown when supplied config parameter value is an empty string.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ConfigValueEmpty extends Error {
  constructor(paramName) {
    super(`Config parameter ${paramName} cannot be empty.`);
  }
}
/**
 * Error thrown when supplied config parameter value is too small.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ConfigValueTooSmallError extends Error {
  constructor(paramName, minimum) {
    super(`Config parameter ${paramName} should be at least ${minimum}`);
  }
}
/**
 * Error thrown when supplied config parameter value is too big.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ConfigValueTooBigError extends Error {
  constructor(paramName, maximum) {
    super(`Config parameter ${paramName} should be at most ${maximum}`);
  }
}
/**
 * Error thrown when the value was expected to be set for a config parameter.
 * It also displays the expected value.
 * This error might be thrown while setting or updating the [[ConfigParams]].
 * The following methods accept [[ConfigParams]] as a parameter:
 *
 * @see [[buildEmpty]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 * @see [[updateConfig]]
 */
class ExpectedOneOfValuesError extends Error {
  constructor(values, paramName) {
    super(`Expected one of ${values} for config parameter: ${paramName}`);
  }
}
/**
 * Error thrown when computations become suspended.
 * To perform any other action wait for the batch to complete or resume the evaluation.
 * Relates to:
 *
 * @see [[batch]]
 * @see [[suspendEvaluation]]
 * @see [[resumeEvaluation]]
 */
class EvaluationSuspendedError extends Error {
  constructor() {
    super('Computations are suspended');
  }
}
/**
 * Error thrown when translation is missing in translation package.
 */
class MissingTranslationError extends Error {
  constructor(key) {
    super(`Translation for ${key} is missing in the translation package you're using.`);
  }
}
/**
 * Error thrown when trying to override protected translation.
 *
 * @see [[registerLanguage]]
 * @see [[registerFunction]]
 * @see [[registerFunctionPlugin]]
 */
class ProtectedFunctionTranslationError extends Error {
  constructor(key) {
    super(`Cannot register translation for function with id: ${key}`);
  }
}
/**
 * Error thrown when trying to retrieve not registered language
 *
 * @see [[getLanguage]]
 * @see [[unregisterLanguage]]
 */
class LanguageNotRegisteredError extends Error {
  constructor() {
    super('Language not registered.');
  }
}
/**
 * Error thrown when trying to register already registered language
 *
 * @see [[registerLanguage]]
 */
class LanguageAlreadyRegisteredError extends Error {
  constructor() {
    super('Language already registered.');
  }
}
/**
 * Error thrown when function plugin is invalid.
 *
 * @see [[registerFunction]]
 * @see [[registerFunctionPlugin]]
 * @see [[buildFromArray]]
 * @see [[buildFromSheets]]
 */
class FunctionPluginValidationError extends Error {
  static functionNotDeclaredInPlugin(functionId, pluginName) {
    return new FunctionPluginValidationError(`Function with id ${functionId} not declared in plugin ${pluginName}`);
  }
  static functionMethodNotFound(functionName, pluginName) {
    return new FunctionPluginValidationError(`Function method ${functionName} not found in plugin ${pluginName}`);
  }
}
/**
 * Error thrown when trying to register, override or remove function with reserved id.
 *
 * @see [[registerFunctionPlugin]]
 * @see [[registerFunction]]
 * @see [[unregisterFunction]]
 */
class ProtectedFunctionError extends Error {
  static cannotRegisterFunctionWithId(functionId) {
    return new ProtectedFunctionError(`Cannot register function with id ${functionId}`);
  }
  static cannotUnregisterFunctionWithId(functionId) {
    return new ProtectedFunctionError(`Cannot unregister function with id ${functionId}`);
  }
  static cannotUnregisterProtectedPlugin() {
    return new ProtectedFunctionError('Cannot unregister protected plugin');
  }
}
/**
 * Error thrown when selected source location has an array.
 */
class SourceLocationHasArrayError extends Error {
  constructor() {
    super('Cannot perform this operation, source location has an array inside.');
  }
}
/**
 * Error thrown when selected target location has an array.
 *
 * @see [[addRows]]
 * @see [[addColumns]]
 * @see [[moveCells]]
 * @see [[moveRows]]
 * @see [[moveColumns]]
 * @see [[paste]]
 */
class TargetLocationHasArrayError extends Error {
  constructor() {
    super('Cannot perform this operation, target location has an array inside.');
  }
}
/**
 * Error thrown when named expression contains relative addresses.
 *
 * @see [[addNamedExpression]]
 * @see [[changeNamedExpression]]
 */
class NoRelativeAddressesAllowedError extends Error {
  constructor() {
    super('Relative addresses not allowed in named expressions.');
  }
}
/**
 * Error thrown when alias to a function is already defined.
 *
 * @see [[registerFunctionPlugin]]
 * @see [[registerFunction]]
 */
class AliasAlreadyExisting extends Error {
  constructor(name, pluginName) {
    super(`Alias id ${name} in plugin ${pluginName} already defined as a function or alias.`);
  }
}

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayMapping: () => (/* binding */ ArrayMapping)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class ArrayMapping {
  constructor() {
    this.arrayMapping = new Map();
  }
  getArray(range) {
    const array = this.getArrayByCorner(range.start);
    if (array === null || array === void 0 ? void 0 : array.getRange().sameAs(range)) {
      return array;
    }
    return;
  }
  getArrayByCorner(address) {
    return this.arrayMapping.get((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.addressKey)(address));
  }
  setArray(range, vertex) {
    this.arrayMapping.set((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.addressKey)(range.start), vertex);
  }
  removeArray(range) {
    if (typeof range === 'string') {
      this.arrayMapping.delete(range);
    } else {
      this.arrayMapping.delete((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.addressKey)(range.start));
    }
  }
  count() {
    return this.arrayMapping.size;
  }
  *arraysInRows(rowsSpan) {
    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {
      if (mtx.spansThroughSheetRows(rowsSpan.sheet, rowsSpan.rowStart, rowsSpan.rowEnd)) {
        yield [mtxKey, mtx];
      }
    }
  }
  *arraysInCols(col) {
    for (const [mtxKey, mtx] of this.arrayMapping.entries()) {
      if (mtx.spansThroughSheetColumn(col.sheet, col.columnStart, col.columnEnd)) {
        yield [mtxKey, mtx];
      }
    }
  }
  isFormulaArrayInRow(sheet, row) {
    for (const mtx of this.arrayMapping.values()) {
      if (mtx.spansThroughSheetRows(sheet, row)) {
        return true;
      }
    }
    return false;
  }
  isFormulaArrayInAllRows(span) {
    let result = true;
    for (const row of span.rows()) {
      if (!this.isFormulaArrayInRow(span.sheet, row)) {
        result = false;
      }
    }
    return result;
  }
  isFormulaArrayInColumn(sheet, column) {
    for (const mtx of this.arrayMapping.values()) {
      if (mtx.spansThroughSheetColumn(sheet, column)) {
        return true;
      }
    }
    return false;
  }
  isFormulaArrayInAllColumns(span) {
    let result = true;
    for (const col of span.columns()) {
      if (!this.isFormulaArrayInColumn(span.sheet, col)) {
        result = false;
      }
    }
    return result;
  }
  isFormulaArrayInRange(range) {
    for (const mtx of this.arrayMapping.values()) {
      if (mtx.getRange().doesOverlap(range)) {
        return true;
      }
    }
    return false;
  }
  isFormulaArrayAtAddress(address) {
    for (const mtx of this.arrayMapping.values()) {
      if (mtx.getRange().addressInRange(address)) {
        return true;
      }
    }
    return false;
  }
  moveArrayVerticesAfterRowByRows(sheet, row, numberOfRows) {
    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {
      const range = vertex.getRange();
      return row <= range.start.row ? [range.shifted(0, numberOfRows), vertex] : undefined;
    });
  }
  moveArrayVerticesAfterColumnByColumns(sheet, column, numberOfColumns) {
    this.updateArrayVerticesInSheet(sheet, (key, vertex) => {
      const range = vertex.getRange();
      return column <= range.start.col ? [range.shifted(numberOfColumns, 0), vertex] : undefined;
    });
  }
  updateArrayVerticesInSheet(sheet, fn) {
    const updated = Array();
    for (const [key, vertex] of this.arrayMapping.entries()) {
      if (vertex.sheet !== sheet) {
        continue;
      }
      const result = fn(key, vertex);
      if (result !== undefined) {
        this.removeArray(key);
        updated.push(result);
      }
    }
    updated.forEach(([range, array]) => {
      this.setArray(range, array);
    });
  }
}

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   collectAddressesDependentToRange: () => (/* binding */ collectAddressesDependentToRange)
/* harmony export */ });
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
/* harmony import */ var _RangeVertex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



const collectAddressesDependentToRange = (functionRegistry, vertex, range, lazilyTransformingAstService, dependencyGraph) => {
  if (vertex instanceof _RangeVertex__WEBPACK_IMPORTED_MODULE_2__.RangeVertex) {
    const intersection = vertex.range.intersectionWith(range);
    if (intersection !== undefined) {
      return Array.from(intersection.addresses(dependencyGraph));
    } else {
      return [];
    }
  }
  let formula;
  let address;
  if (vertex instanceof _FormulaCellVertex__WEBPACK_IMPORTED_MODULE_1__.FormulaVertex) {
    formula = vertex.getFormula(lazilyTransformingAstService);
    address = vertex.getAddress(lazilyTransformingAstService);
  } else {
    return [];
  }
  return (0,_parser__WEBPACK_IMPORTED_MODULE_0__.collectDependencies)(formula, functionRegistry).filter(d => d instanceof _parser__WEBPACK_IMPORTED_MODULE_0__.AddressDependency).map(d => d.dependency.toSimpleCellAddress(address)).filter(d => range.addressInRange(d));
};

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayVertex: () => (/* binding */ ArrayVertex),
/* harmony export */   FormulaCellVertex: () => (/* binding */ FormulaCellVertex),
/* harmony export */   FormulaVertex: () => (/* binding */ FormulaVertex)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _ArrayValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(81);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(61);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70);
/* harmony import */ var _Span__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







class FormulaVertex {
  constructor(formula, cellAddress, version) {
    this.formula = formula;
    this.cellAddress = cellAddress;
    this.version = version;
  }
  get width() {
    return 1;
  }
  get height() {
    return 1;
  }
  static fromAst(formula, address, size, version) {
    if (size.isScalar()) {
      return new FormulaCellVertex(formula, address, version);
    } else {
      return new ArrayVertex(formula, address, size, version);
    }
  }
  /**
   * Returns formula stored in this vertex
   */
  getFormula(updatingService) {
    this.ensureRecentData(updatingService);
    return this.formula;
  }
  ensureRecentData(updatingService) {
    if (this.version != updatingService.version()) {
      const [newAst, newAddress, newVersion] = updatingService.applyTransformations(this.formula, this.cellAddress, this.version);
      this.formula = newAst;
      this.cellAddress = newAddress;
      this.version = newVersion;
    }
  }
  /**
   * Returns address of the cell associated with vertex
   */
  getAddress(updatingService) {
    this.ensureRecentData(updatingService);
    return this.cellAddress;
  }
}
class ArrayVertex extends FormulaVertex {
  constructor(formula, cellAddress, size, version = 0) {
    super(formula, cellAddress, version);
    if (size.isRef) {
      this.array = new _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.ErroredArray(new _Cell__WEBPACK_IMPORTED_MODULE_3__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_3__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage.NoSpaceForArrayResult), _ArraySize__WEBPACK_IMPORTED_MODULE_1__.ArraySize.error());
    } else {
      this.array = new _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.NotComputedArray(size);
    }
  }
  get width() {
    return this.array.width();
  }
  get height() {
    return this.array.height();
  }
  get sheet() {
    return this.cellAddress.sheet;
  }
  get leftCorner() {
    return this.cellAddress;
  }
  setCellValue(value) {
    if (value instanceof _Cell__WEBPACK_IMPORTED_MODULE_3__.CellError) {
      this.setErrorValue(value);
      return value;
    }
    const array = _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.ArrayValue.fromInterpreterValue(value);
    array.resize(this.array.size);
    this.array = array;
    return value;
  }
  getCellValue() {
    if (this.array instanceof _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.NotComputedArray) {
      throw Error('Array not computed yet.');
    }
    return this.array.simpleRangeValue();
  }
  valueOrUndef() {
    if (this.array instanceof _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.NotComputedArray) {
      return undefined;
    }
    return this.array.simpleRangeValue();
  }
  getArrayCellValue(address) {
    const col = address.col - this.cellAddress.col;
    const row = address.row - this.cellAddress.row;
    try {
      return this.array.get(col, row);
    } catch (e) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_3__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_3__.ErrorType.REF);
    }
  }
  getArrayCellRawValue(address) {
    const val = this.getArrayCellValue(address);
    if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_3__.CellError || val === _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.EmptyValue) {
      return undefined;
    } else {
      return (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.getRawValue)(val);
    }
  }
  setArrayCellValue(address, value) {
    const col = address.col - this.cellAddress.col;
    const row = address.row - this.cellAddress.row;
    if (this.array instanceof _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.ArrayValue) {
      this.array.set(col, row, value);
    }
  }
  setNoSpace() {
    this.array = new _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.ErroredArray(new _Cell__WEBPACK_IMPORTED_MODULE_3__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_3__.ErrorType.SPILL, _error_message__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage.NoSpaceForArrayResult), _ArraySize__WEBPACK_IMPORTED_MODULE_1__.ArraySize.error());
    return this.getCellValue();
  }
  getRange() {
    return _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(this.cellAddress, this.width, this.height);
  }
  getRangeOrUndef() {
    return _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFromOrUndef(this.cellAddress, this.width, this.height);
  }
  setAddress(address) {
    this.cellAddress = address;
  }
  setFormula(newFormula) {
    this.formula = newFormula;
  }
  spansThroughSheetRows(sheet, startRow, endRow = startRow) {
    return this.cellAddress.sheet === sheet && this.cellAddress.row <= endRow && startRow < this.cellAddress.row + this.height;
  }
  spansThroughSheetColumn(sheet, col, columnEnd = col) {
    return this.cellAddress.sheet === sheet && this.cellAddress.col <= columnEnd && col < this.cellAddress.col + this.width;
  }
  isComputed() {
    return !(this.array instanceof _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.NotComputedArray);
  }
  columnsFromArray() {
    return _Span__WEBPACK_IMPORTED_MODULE_6__.ColumnsSpan.fromNumberOfColumns(this.cellAddress.sheet, this.cellAddress.col, this.width);
  }
  rowsFromArray() {
    return _Span__WEBPACK_IMPORTED_MODULE_6__.RowsSpan.fromNumberOfRows(this.cellAddress.sheet, this.cellAddress.row, this.height);
  }
  /**
   * No-op as array vertices are transformed eagerly.
   */
  ensureRecentData(_updatingService) {}
  isLeftCorner(address) {
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.equalSimpleCellAddress)(this.cellAddress, address);
  }
  setErrorValue(error) {
    this.array = new _ArrayValue__WEBPACK_IMPORTED_MODULE_2__.ErroredArray(error, this.array.size);
  }
}
/**
 * Represents vertex which keeps formula
 */
class FormulaCellVertex extends FormulaVertex {
  constructor( /** Formula in AST format */
  formula, /** Address which this vertex represents */
  address, version) {
    super(formula, address, version);
  }
  valueOrUndef() {
    return this.cachedCellValue;
  }
  /**
   * Sets computed cell value stored in this vertex
   */
  setCellValue(cellValue) {
    this.cachedCellValue = cellValue;
    return this.cachedCellValue;
  }
  /**
   * Returns cell value stored in vertex
   */
  getCellValue() {
    if (this.cachedCellValue !== undefined) {
      return this.cachedCellValue;
    } else {
      throw Error('Value of the formula cell is not computed.');
    }
  }
  isComputed() {
    return this.cachedCellValue !== undefined;
  }
}

/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayValue: () => (/* binding */ ArrayValue),
/* harmony export */   ErroredArray: () => (/* binding */ ErroredArray),
/* harmony export */   NotComputedArray: () => (/* binding */ NotComputedArray)
/* harmony export */ });
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class NotComputedArray {
  constructor(size) {
    this.size = size;
  }
  width() {
    return this.size.width;
  }
  height() {
    return this.size.height;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  get(col, row) {
    throw Error('Array not computed yet.');
  }
  simpleRangeValue() {
    throw Error('Array not computed yet.');
  }
}
class ArrayValue {
  constructor(array) {
    this.size = new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize(array.length > 0 ? array[0].length : 0, array.length);
    this.array = array;
    if (this.size.width <= 0 || this.size.height <= 0) {
      throw Error('Incorrect array size');
    }
  }
  static fromInterpreterValue(value) {
    if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_2__.SimpleRangeValue) {
      return new ArrayValue(value.data);
    } else {
      return new ArrayValue([[value]]);
    }
  }
  simpleRangeValue() {
    return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_2__.SimpleRangeValue.onlyValues(this.array);
  }
  addRows(aboveRow, numberOfRows) {
    this.array.splice(aboveRow, 0, ...this.nullArrays(numberOfRows, this.width()));
    this.size.height += numberOfRows;
  }
  addColumns(aboveColumn, numberOfColumns) {
    for (let i = 0; i < this.height(); i++) {
      this.array[i].splice(aboveColumn, 0, ...new Array(numberOfColumns).fill(_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.EmptyValue));
    }
    this.size.width += numberOfColumns;
  }
  removeRows(startRow, endRow) {
    if (this.outOfBound(0, startRow) || this.outOfBound(0, endRow)) {
      throw Error('Array index out of bound');
    }
    const numberOfRows = endRow - startRow + 1;
    this.array.splice(startRow, numberOfRows);
    this.size.height -= numberOfRows;
  }
  removeColumns(leftmostColumn, rightmostColumn) {
    if (this.outOfBound(leftmostColumn, 0) || this.outOfBound(rightmostColumn, 0)) {
      throw Error('Array index out of bound');
    }
    const numberOfColumns = rightmostColumn - leftmostColumn + 1;
    for (const row of this.array) {
      row.splice(leftmostColumn, numberOfColumns);
    }
    this.size.width -= numberOfColumns;
  }
  nullArrays(count, size) {
    const result = [];
    for (let i = 0; i < count; ++i) {
      result.push(new Array(size).fill(_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.EmptyValue));
    }
    return result;
  }
  get(col, row) {
    if (this.outOfBound(col, row)) {
      throw Error('Array index out of bound');
    }
    return this.array[row][col];
  }
  set(col, row, value) {
    if (this.outOfBound(col, row)) {
      throw Error('Array index out of bound');
    }
    this.array[row][col] = value;
  }
  width() {
    return this.size.width;
  }
  height() {
    return this.size.height;
  }
  raw() {
    return this.array;
  }
  resize(newSize) {
    if (this.height() < newSize.height && isFinite(newSize.height)) {
      this.addRows(this.height(), newSize.height - this.height());
    }
    if (this.height() > newSize.height) {
      throw Error('Resizing to smaller array');
    }
    if (this.width() < newSize.width && isFinite(newSize.width)) {
      this.addColumns(this.width(), newSize.width - this.width());
    }
    if (this.width() > newSize.width) {
      throw Error('Resizing to smaller array');
    }
  }
  outOfBound(col, row) {
    return col < 0 || row < 0 || row > this.size.height - 1 || col > this.size.width - 1;
  }
}
class ErroredArray {
  constructor(error, size) {
    this.error = error;
    this.size = size;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  get(col, row) {
    return this.error;
  }
  width() {
    return this.size.width;
  }
  height() {
    return this.size.height;
  }
  simpleRangeValue() {
    return this.error;
  }
}

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RangeVertex: () => (/* binding */ RangeVertex)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * Represents vertex bound to range
 */
class RangeVertex {
  constructor(range) {
    this.range = range;
    this.functionCache = new Map();
    this.criterionFunctionCache = new Map();
    this.dependentCacheRanges = new Set();
    this.bruteForce = false;
  }
  get start() {
    return this.range.start;
  }
  get end() {
    return this.range.end;
  }
  get sheet() {
    return this.range.start.sheet;
  }
  /**
   * Returns cached value stored for given function
   *
   * @param functionName - name of the function
   */
  getFunctionValue(functionName) {
    return this.functionCache.get(functionName);
  }
  /**
   * Stores cached value for given function
   *
   * @param functionName - name of the function
   * @param value - cached value
   */
  setFunctionValue(functionName, value) {
    this.functionCache.set(functionName, value);
  }
  /**
   * Returns cached value for given cache key and criterion text representation
   *
   * @param cacheKey - key to retrieve from the cache
   * @param criterionString - criterion text (ex. '<=5')
   */
  getCriterionFunctionValue(cacheKey, criterionString) {
    var _a;
    return (_a = this.getCriterionFunctionValues(cacheKey).get(criterionString)) === null || _a === void 0 ? void 0 : _a[0];
  }
  /**
   * Returns all cached values stored for given criterion function
   *
   * @param cacheKey - key to retrieve from the cache
   */
  getCriterionFunctionValues(cacheKey) {
    var _a;
    return (_a = this.criterionFunctionCache.get(cacheKey)) !== null && _a !== void 0 ? _a : new Map();
  }
  /**
   * Stores all values for given criterion function
   *
   * @param cacheKey - key to store in the cache
   * @param values - map with values
   */
  setCriterionFunctionValues(cacheKey, values) {
    this.criterionFunctionCache.set(cacheKey, values);
  }
  addDependentCacheRange(dependentRange) {
    if (dependentRange !== this) {
      this.dependentCacheRanges.add(dependentRange);
    }
  }
  /**
   * Clears function cache
   */
  clearCache() {
    this.functionCache.clear();
    this.criterionFunctionCache.clear();
    this.dependentCacheRanges.forEach(range => range.criterionFunctionCache.clear());
    this.dependentCacheRanges.clear();
  }
  /**
   * Returns start of the range (it's top-left corner)
   */
  getStart() {
    return this.start;
  }
  /**
   * Returns end of the range (it's bottom-right corner)
   */
  getEnd() {
    return this.end;
  }
}

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graph: () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var _TopSort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var _ProcessableValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


/**
 * Provides directed graph structure.
 *
 * Idea for performance improvement:
 * - use Set<Node>[] instead of NodeId[][] for edgesSparseArray
 */
class Graph {
  constructor(dependencyQuery) {
    this.dependencyQuery = dependencyQuery;
    /**
     * A sparse array. The value nodesSparseArray[n] exists if and only if node n is in the graph.
     * @private
     */
    this.nodesSparseArray = [];
    /**
     * A sparse array. The value edgesSparseArray[n] exists if and only if node n is in the graph.
     * The edgesSparseArray[n] is also a sparse array. It may contain removed nodes. To make sure check nodesSparseArray.
     * @private
     */
    this.edgesSparseArray = [];
    /**
     * A mapping from node to its id. The value nodesIds.get(node) exists if and only if node is in the graph.
     * @private
     */
    this.nodesIds = new Map();
    /**
     * A ProcessableValue object.
     * @private
     */
    this.dirtyAndVolatileNodeIds = new _ProcessableValue__WEBPACK_IMPORTED_MODULE_1__.ProcessableValue({
      dirty: [],
      volatile: []
    }, r => this.processDirtyAndVolatileNodeIds(r));
    /**
     * A set of node ids. The value infiniteRangeIds.get(nodeId) exists if and only if node is in the graph.
     * @private
     */
    this.infiniteRangeIds = new Set();
    /**
     * A dense array. It may contain duplicates and removed nodes.
     * @private
     */
    this.changingWithStructureNodeIds = [];
    this.nextId = 0;
  }
  /**
   * Iterate over all nodes the in graph
   */
  getNodes() {
    return this.nodesSparseArray.filter(node => node !== undefined);
  }
  /**
   * Checks whether a node is present in graph
   *
   * @param node - node to check
   */
  hasNode(node) {
    return this.nodesIds.has(node);
  }
  /**
   * Checks whether exists edge between nodes. If one or both of nodes are not present in graph, returns false.
   *
   * @param fromNode - node from which edge is outcoming
   * @param toNode - node to which edge is incoming
   */
  existsEdge(fromNode, toNode) {
    const fromId = this.getNodeId(fromNode);
    const toId = this.getNodeId(toNode);
    if (fromId === undefined || toId === undefined) {
      return false;
    }
    return this.edgesSparseArray[fromId].includes(toId);
  }
  /**
   * Returns nodes adjacent to given node. May contain removed nodes.
   *
   * @param node - node to which adjacent nodes we want to retrieve
   *
   * Idea for performance improvement:
   * - return an array instead of set
   */
  adjacentNodes(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      throw this.missingNodeError(node);
    }
    return new Set(this.edgesSparseArray[id].filter(id => id !== undefined).map(id => this.nodesSparseArray[id]));
  }
  /**
   * Returns number of nodes adjacent to given node. Contrary to adjacentNodes(), this method returns only nodes that are present in graph.
   *
   * @param node - node to which adjacent nodes we want to retrieve
   */
  adjacentNodesCount(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      throw this.missingNodeError(node);
    }
    return this.fixEdgesArrayForNode(id).length;
  }
  /**
   * Adds node to a graph
   *
   * @param node - a node to be added
   */
  addNodeAndReturnId(node) {
    const idOfExistingNode = this.nodesIds.get(node);
    if (idOfExistingNode !== undefined) {
      return idOfExistingNode;
    }
    const newId = this.nextId;
    this.nextId++;
    this.nodesSparseArray[newId] = node;
    this.edgesSparseArray[newId] = [];
    this.nodesIds.set(node, newId);
    return newId;
  }
  /**
   * Adds edge between nodes.
   *
   * The nodes had to be added to the graph before, or the error will be raised
   *
   * @param fromNode - node from which edge is outcoming
   * @param toNode - node to which edge is incoming
   */
  addEdge(fromNode, toNode) {
    const fromId = this.getNodeIdIfNotNumber(fromNode);
    const toId = this.getNodeIdIfNotNumber(toNode);
    if (fromId === undefined) {
      throw this.missingNodeError(fromNode);
    }
    if (toId === undefined) {
      throw this.missingNodeError(toNode);
    }
    if (this.edgesSparseArray[fromId].includes(toId)) {
      return;
    }
    this.edgesSparseArray[fromId].push(toId);
  }
  /**
   * Removes node from graph
   */
  removeNode(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      throw this.missingNodeError(node);
    }
    if (this.edgesSparseArray[id].length > 0) {
      this.edgesSparseArray[id].forEach(adjacentId => this.dirtyAndVolatileNodeIds.rawValue.dirty.push(adjacentId));
      this.dirtyAndVolatileNodeIds.markAsModified();
    }
    const dependencies = this.removeDependencies(node);
    delete this.nodesSparseArray[id];
    delete this.edgesSparseArray[id];
    this.infiniteRangeIds.delete(id);
    this.nodesIds.delete(node);
    return dependencies;
  }
  /**
   * Removes edge between nodes.
   */
  removeEdge(fromNode, toNode) {
    const fromId = this.getNodeIdIfNotNumber(fromNode);
    const toId = this.getNodeIdIfNotNumber(toNode);
    if (fromId === undefined) {
      throw this.missingNodeError(fromNode);
    }
    if (toId === undefined) {
      throw this.missingNodeError(toNode);
    }
    const indexOfToId = this.edgesSparseArray[fromId].indexOf(toId);
    if (indexOfToId === -1) {
      throw new Error('Edge does not exist');
    }
    delete this.edgesSparseArray[fromId][indexOfToId];
  }
  /**
   * Removes edge between nodes if it exists.
   */
  removeEdgeIfExists(fromNode, toNode) {
    const fromId = this.getNodeId(fromNode);
    const toId = this.getNodeId(toNode);
    if (fromId === undefined) {
      return;
    }
    if (toId === undefined) {
      return;
    }
    const indexOfToId = this.edgesSparseArray[fromId].indexOf(toId);
    if (indexOfToId === -1) {
      return;
    }
    delete this.edgesSparseArray[fromId][indexOfToId];
  }
  /**
   * Sorts the whole graph topologically. Nodes that are on cycles are kept separate.
   */
  topSortWithScc() {
    return this.getTopSortedWithSccSubgraphFrom(this.getNodes(), () => true, () => {});
  }
  /**
   * Sorts the graph topologically. Nodes that are on cycles are kept separate.
   *
   * @param modifiedNodes - seed for computation. The algorithm assumes that only these nodes have changed since the last run.
   * @param operatingFunction - recomputes value of a node, and returns whether a change occurred
   * @param onCycle - action to be performed when node is on cycle
   */
  getTopSortedWithSccSubgraphFrom(modifiedNodes, operatingFunction, onCycle) {
    const topSortAlgorithm = new _TopSort__WEBPACK_IMPORTED_MODULE_0__.TopSort(this.nodesSparseArray, this.edgesSparseArray);
    const modifiedNodesIds = modifiedNodes.map(node => this.getNodeId(node)).filter(id => id !== undefined);
    return topSortAlgorithm.getTopSortedWithSccSubgraphFrom(modifiedNodesIds, operatingFunction, onCycle);
  }
  /**
   * Marks node as volatile.
   */
  markNodeAsVolatile(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      return;
    }
    this.dirtyAndVolatileNodeIds.rawValue.volatile.push(id);
    this.dirtyAndVolatileNodeIds.markAsModified();
  }
  /**
   * Marks node as dirty.
   */
  markNodeAsDirty(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      return;
    }
    this.dirtyAndVolatileNodeIds.rawValue.dirty.push(id);
    this.dirtyAndVolatileNodeIds.markAsModified();
  }
  /**
   * Returns an array of nodes that are marked as dirty and/or volatile.
   */
  getDirtyAndVolatileNodes() {
    return this.dirtyAndVolatileNodeIds.getProcessedValue();
  }
  /**
   * Clears dirty nodes.
   */
  clearDirtyNodes() {
    this.dirtyAndVolatileNodeIds.rawValue.dirty = [];
    this.dirtyAndVolatileNodeIds.markAsModified();
  }
  /**
   * Marks node as changingWithStructure.
   */
  markNodeAsChangingWithStructure(node) {
    const id = this.getNodeId(node);
    if (id === undefined) {
      return;
    }
    this.changingWithStructureNodeIds.push(id);
  }
  /**
   * Marks all nodes marked as changingWithStructure as dirty.
   */
  markChangingWithStructureNodesAsDirty() {
    if (this.changingWithStructureNodeIds.length <= 0) {
      return;
    }
    this.dirtyAndVolatileNodeIds.rawValue.dirty = [...this.dirtyAndVolatileNodeIds.rawValue.dirty, ...this.changingWithStructureNodeIds];
    this.dirtyAndVolatileNodeIds.markAsModified();
  }
  /**
   * Marks node as infinite range.
   */
  markNodeAsInfiniteRange(node) {
    const id = this.getNodeIdIfNotNumber(node);
    if (id === undefined) {
      return;
    }
    this.infiniteRangeIds.add(id);
  }
  /**
   * Returns an array of nodes marked as infinite ranges
   */
  getInfiniteRanges() {
    return [...this.infiniteRangeIds].map(id => ({
      node: this.nodesSparseArray[id],
      id
    }));
  }
  /**
   * Returns the internal id of a node.
   */
  getNodeId(node) {
    return this.nodesIds.get(node);
  }
  /**
   *
   */
  getNodeIdIfNotNumber(node) {
    return typeof node === 'number' ? node : this.nodesIds.get(node);
  }
  /**
   * Removes invalid neighbors of a given node from the edges array and returns adjacent nodes for the input node.
   */
  fixEdgesArrayForNode(id) {
    const adjacentNodeIds = this.edgesSparseArray[id];
    this.edgesSparseArray[id] = adjacentNodeIds.filter(adjacentId => adjacentId !== undefined && this.nodesSparseArray[adjacentId]);
    return this.edgesSparseArray[id];
  }
  /**
   * Removes edges from the given node to its dependencies based on the dependencyQuery function.
   */
  removeDependencies(node) {
    const dependencies = this.dependencyQuery(node);
    dependencies.forEach(([_, dependency]) => {
      this.removeEdgeIfExists(dependency, node);
    });
    return dependencies;
  }
  /**
   * processFn for dirtyAndVolatileNodeIds ProcessableValue instance
   * @private
   */
  processDirtyAndVolatileNodeIds({
    dirty,
    volatile
  }) {
    return [...new Set([...dirty, ...volatile])].map(id => this.nodesSparseArray[id]).filter(node => node !== undefined);
  }
  /**
   * Returns error for missing node.
   */
  missingNodeError(node) {
    return new Error(`Unknown node ${node}`);
  }
}

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TopSort: () => (/* binding */ TopSort)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
// node status life cycle: undefined -> ON_STACK -> PROCESSED -> POPPED
var NodeVisitStatus;
(function (NodeVisitStatus) {
  NodeVisitStatus[NodeVisitStatus["ON_STACK"] = 0] = "ON_STACK";
  NodeVisitStatus[NodeVisitStatus["PROCESSED"] = 1] = "PROCESSED";
  NodeVisitStatus[NodeVisitStatus["POPPED"] = 2] = "POPPED";
})(NodeVisitStatus || (NodeVisitStatus = {}));
/**
 * An algorithm class. Provides an iterative implementation of Tarjan's algorithm for finding strongly connected components
 */
class TopSort {
  constructor(nodesSparseArray = [], edgesSparseArray = []) {
    this.nodesSparseArray = nodesSparseArray;
    this.edgesSparseArray = edgesSparseArray;
    this.entranceTime = [];
    this.low = [];
    this.parent = [];
    this.inSCC = [];
    this.nodeStatus = [];
    this.order = [];
    this.sccNonSingletons = [];
    this.timeCounter = 0;
  }
  /**
   * An iterative implementation of Tarjan's algorithm for finding strongly connected components.
   * Returns vertices in order of topological sort, but vertices that are on cycles are kept separate.
   *
   * @param modifiedNodes - seed for computation. During engine init run, all of the vertices of grap. In recomputation run, changed vertices.
   * @param operatingFunction - recomputes value of a node, and returns whether a change occured
   * @param onCycle - action to be performed when node is on cycle
   */
  getTopSortedWithSccSubgraphFrom(modifiedNodeIds, operatingFunction, onCycle) {
    const modifiedNodeIdsReversed = modifiedNodeIds.reverse();
    modifiedNodeIdsReversed.forEach(id => this.runDFS(id));
    return this.postprocess(modifiedNodeIdsReversed, onCycle, operatingFunction);
  }
  /**
   * Returns adjacent nodes of a given node.
   */
  getAdjacentNodeIds(id) {
    return this.edgesSparseArray[id].filter(adjacentId => adjacentId !== undefined && this.nodesSparseArray[adjacentId]);
  }
  /**
   * Runs DFS starting from a given node.
   */
  runDFS(v) {
    if (this.nodeStatus[v] !== undefined) {
      return;
    }
    this.nodeStatus[v] = NodeVisitStatus.ON_STACK;
    const DFSstack = [v];
    const SCCstack = [];
    while (DFSstack.length > 0) {
      const u = DFSstack[DFSstack.length - 1];
      switch (this.nodeStatus[u]) {
        case NodeVisitStatus.ON_STACK:
          {
            this.handleOnStack(u, SCCstack, DFSstack);
            break;
          }
        case NodeVisitStatus.PROCESSED:
          {
            // leaving this DFS subtree
            this.handleProcessed(u, SCCstack, DFSstack);
            break;
          }
        case NodeVisitStatus.POPPED:
          {
            // it's a 'shadow' copy, we already processed this vertex and can ignore it
            DFSstack.pop();
            break;
          }
      }
    }
  }
  /**
   * Handles a node that is on stack.
   */
  handleOnStack(u, SCCstack, DFSstack) {
    this.entranceTime[u] = this.timeCounter;
    this.low[u] = this.timeCounter;
    this.timeCounter++;
    SCCstack.push(u);
    this.getAdjacentNodeIds(u).forEach(t => {
      if (this.entranceTime[t] === undefined) {
        DFSstack.push(t);
        this.parent[t] = u;
        this.nodeStatus[t] = NodeVisitStatus.ON_STACK;
      }
    });
    this.nodeStatus[u] = NodeVisitStatus.PROCESSED;
  }
  /**
   * Handles a node that is already processed.
   */
  handleProcessed(u, SCCstack, DFSstack) {
    let uLow = this.entranceTime[u];
    this.getAdjacentNodeIds(u).forEach(t => {
      if (this.inSCC[t]) {
        return;
      }
      uLow = this.parent[t] === u ? Math.min(uLow, this.low[t]) : Math.min(uLow, this.entranceTime[t]);
    });
    this.low[u] = uLow;
    if (uLow === this.entranceTime[u]) {
      const currentSCC = [];
      do {
        currentSCC.push(SCCstack[SCCstack.length - 1]);
        SCCstack.pop();
      } while (currentSCC[currentSCC.length - 1] !== u);
      currentSCC.forEach(t => {
        this.inSCC[t] = true;
      });
      this.order.push(...currentSCC);
      if (currentSCC.length > 1) {
        currentSCC.forEach(t => {
          this.sccNonSingletons[t] = true;
        });
      }
    }
    DFSstack.pop();
    this.nodeStatus[u] = NodeVisitStatus.POPPED;
  }
  /**
   * Postprocesses the result of Tarjan's algorithm.
   */
  postprocess(modifiedNodeIds, onCycle, operatingFunction) {
    const shouldBeUpdatedMapping = [];
    modifiedNodeIds.forEach(t => {
      shouldBeUpdatedMapping[t] = true;
    });
    const sorted = [];
    const cycled = [];
    this.order.reverse();
    this.order.forEach(t => {
      const adjacentNodes = this.getAdjacentNodeIds(t);
      // The following line is a potential performance bottleneck.
      // Array.includes() is O(n) operation, which makes the whole algorithm O(n^2).
      // Idea for improvement: use Set<T>[] instead of number[][] for edgesSparseArray.
      if (this.sccNonSingletons[t] || adjacentNodes.includes(t)) {
        cycled.push(this.nodesSparseArray[t]);
        onCycle(this.nodesSparseArray[t]);
        adjacentNodes.forEach(s => shouldBeUpdatedMapping[s] = true);
      } else {
        sorted.push(this.nodesSparseArray[t]);
        if (shouldBeUpdatedMapping[t] && operatingFunction(this.nodesSparseArray[t])) {
          adjacentNodes.forEach(s => shouldBeUpdatedMapping[s] = true);
        }
      }
    });
    return {
      sorted,
      cycled
    };
  }
}

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ProcessableValue: () => (/* binding */ ProcessableValue)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class ProcessableValue {
  constructor(rawValue, processFn) {
    this.rawValue = rawValue;
    this.processFn = processFn;
    this.processedValue = null;
  }
  getProcessedValue() {
    if (this.processedValue === null) {
      this.processedValue = this.processFn(this.rawValue);
    }
    return this.processedValue;
  }
  markAsModified() {
    this.processedValue = null;
  }
}

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RangeMapping: () => (/* binding */ RangeMapping)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


/**
 * Mapping from address ranges to range vertices
 */
class RangeMapping {
  constructor() {
    /** Map in which actual data is stored. */
    this.rangeMapping = new Map();
  }
  getMappingSize(sheet) {
    var _a, _b;
    return (_b = (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
  }
  /**
   * Saves range vertex
   *
   * @param vertex - vertex to save
   */
  setRange(vertex) {
    let sheetMap = this.rangeMapping.get(vertex.getStart().sheet);
    if (sheetMap === undefined) {
      sheetMap = new Map();
      this.rangeMapping.set(vertex.getStart().sheet, sheetMap);
    }
    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());
    sheetMap.set(key, vertex);
  }
  removeRange(vertex) {
    const sheet = vertex.getStart().sheet;
    const sheetMap = this.rangeMapping.get(sheet);
    if (sheetMap === undefined) {
      return;
    }
    const key = keyFromAddresses(vertex.getStart(), vertex.getEnd());
    sheetMap.delete(key);
    if (sheetMap.size === 0) {
      this.rangeMapping.delete(sheet);
    }
  }
  /**
   * Returns associated vertex for given range
   *
   * @param start - top-left corner of the range
   * @param end - bottom-right corner of the range
   */
  getRange(start, end) {
    const sheetMap = this.rangeMapping.get(start.sheet);
    const key = keyFromAddresses(start, end);
    return sheetMap === null || sheetMap === void 0 ? void 0 : sheetMap.get(key);
  }
  fetchRange(start, end) {
    const maybeRange = this.getRange(start, end);
    if (!maybeRange) {
      throw Error('Range does not exist');
    }
    return maybeRange;
  }
  truncateRanges(span, coordinate) {
    const verticesToRemove = Array();
    const updated = Array();
    const verticesWithChangedSize = Array();
    const sheet = span.sheet;
    for (const [key, vertex] of this.entriesFromSheet(span.sheet)) {
      const range = vertex.range;
      if (span.start <= coordinate(vertex.range.end)) {
        range.removeSpan(span);
        if (range.shouldBeRemoved()) {
          this.removeByKey(sheet, key);
          verticesToRemove.push(vertex);
        } else {
          updated.push([key, vertex]);
        }
        verticesWithChangedSize.push(vertex);
      }
    }
    const verticesToMerge = [];
    updated.sort((left, right) => compareBy(left[1], right[1], coordinate));
    for (const [oldKey, vertex] of updated) {
      const newKey = keyFromRange(vertex.range);
      if (newKey === oldKey) {
        continue;
      }
      const existingVertex = this.getByKey(sheet, newKey);
      this.removeByKey(sheet, oldKey);
      if (existingVertex !== undefined && vertex != existingVertex) {
        verticesToMerge.push([existingVertex, vertex]);
      } else {
        this.setRange(vertex);
      }
    }
    return {
      verticesToRemove,
      verticesToMerge,
      verticesWithChangedSize
    };
  }
  moveAllRangesInSheetAfterRowByRows(sheet, row, numberOfRows) {
    return this.updateVerticesFromSheet(sheet, (key, vertex) => {
      if (row <= vertex.start.row) {
        vertex.range.shiftByRows(numberOfRows);
        return {
          changedSize: false,
          vertex: vertex
        };
      } else if (row > vertex.start.row && row <= vertex.end.row) {
        vertex.range.expandByRows(numberOfRows);
        return {
          changedSize: true,
          vertex: vertex
        };
      } else {
        return undefined;
      }
    });
  }
  moveAllRangesInSheetAfterColumnByColumns(sheet, column, numberOfColumns) {
    return this.updateVerticesFromSheet(sheet, (key, vertex) => {
      if (column <= vertex.start.col) {
        vertex.range.shiftByColumns(numberOfColumns);
        return {
          changedSize: false,
          vertex: vertex
        };
      } else if (column > vertex.start.col && column <= vertex.end.col) {
        vertex.range.expandByColumns(numberOfColumns);
        return {
          changedSize: true,
          vertex: vertex
        };
      } else {
        return undefined;
      }
    });
  }
  moveRangesInsideSourceRange(sourceRange, toRight, toBottom, toSheet) {
    this.updateVerticesFromSheet(sourceRange.sheet, (key, vertex) => {
      if (sourceRange.containsRange(vertex.range)) {
        vertex.range.shiftByColumns(toRight);
        vertex.range.shiftByRows(toBottom);
        vertex.range.moveToSheet(toSheet);
        return {
          changedSize: false,
          vertex: vertex
        };
      } else {
        return undefined;
      }
    });
  }
  removeRangesInSheet(sheet) {
    if (this.rangeMapping.has(sheet)) {
      const ranges = this.rangeMapping.get(sheet).values();
      this.rangeMapping.delete(sheet);
      return ranges;
    }
    return [][Symbol.iterator]();
  }
  *rangesInSheet(sheet) {
    const sheetMap = this.rangeMapping.get(sheet);
    if (!sheetMap) {
      return;
    }
    yield* sheetMap.values();
  }
  *rangeVerticesContainedInRange(sourceRange) {
    for (const rangeVertex of this.rangesInSheet(sourceRange.sheet)) {
      if (sourceRange.containsRange(rangeVertex.range)) {
        yield rangeVertex;
      }
    }
  }
  /**
   * Finds smaller range does have own vertex.
   *
   * @param range
   */
  findSmallerRange(range) {
    if (range.height() > 1 && Number.isFinite(range.height())) {
      const valuesRangeEndRowLess = (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(range.end.sheet, range.end.col, range.end.row - 1);
      const rowLessVertex = this.getRange(range.start, valuesRangeEndRowLess);
      if (rowLessVertex !== undefined) {
        const restRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.fromSimpleCellAddresses((0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(range.start.sheet, range.start.col, range.end.row), range.end);
        return {
          smallerRangeVertex: rowLessVertex,
          restRange
        };
      }
    }
    return {
      restRange: range
    };
  }
  *entriesFromSheet(sheet) {
    const sheetMap = this.rangeMapping.get(sheet);
    if (!sheetMap) {
      return;
    }
    yield* sheetMap.entries();
  }
  removeByKey(sheet, key) {
    this.rangeMapping.get(sheet).delete(key);
  }
  getByKey(sheet, key) {
    var _a;
    return (_a = this.rangeMapping.get(sheet)) === null || _a === void 0 ? void 0 : _a.get(key);
  }
  updateVerticesFromSheet(sheet, fn) {
    const updated = Array();
    for (const [key, vertex] of this.entriesFromSheet(sheet)) {
      const result = fn(key, vertex);
      if (result !== undefined) {
        this.removeByKey(sheet, key);
        updated.push(result);
      }
    }
    updated.forEach(entry => {
      this.setRange(entry.vertex);
    });
    return {
      verticesWithChangedSize: updated.filter(entry => entry.changedSize).map(entry => entry.vertex)
    };
  }
}
function keyFromAddresses(start, end) {
  return `${start.col},${start.row},${end.col},${end.row}`;
}
function keyFromRange(range) {
  return keyFromAddresses(range.start, range.end);
}
const compareBy = (left, right, coordinate) => {
  const leftStart = coordinate(left.range.start);
  const rightStart = coordinate(left.range.start);
  if (leftStart === rightStart) {
    const leftEnd = coordinate(left.range.end);
    const rightEnd = coordinate(right.range.end);
    return leftEnd - rightEnd;
  } else {
    return leftStart - rightStart;
  }
};

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SheetMapping: () => (/* binding */ SheetMapping)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/* harmony import */ var _i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


function canonicalize(sheetDisplayName) {
  return sheetDisplayName.toLowerCase();
}
class Sheet {
  constructor(id, displayName) {
    this.id = id;
    this.displayName = displayName;
  }
  get canonicalName() {
    return canonicalize(this.displayName);
  }
}
class SheetMapping {
  constructor(languages) {
    this.languages = languages;
    this.mappingFromCanonicalName = new Map();
    this.mappingFromId = new Map();
    this.lastSheetId = -1;
    this.fetch = sheetName => {
      const sheet = this.mappingFromCanonicalName.get(canonicalize(sheetName));
      if (sheet === undefined) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithNameError(sheetName);
      }
      return sheet.id;
    };
    this.get = sheetName => {
      var _a;
      return (_a = this.mappingFromCanonicalName.get(canonicalize(sheetName))) === null || _a === void 0 ? void 0 : _a.id;
    };
    this.fetchDisplayName = sheetId => {
      return this.fetchSheetById(sheetId).displayName;
    };
    this.sheetNamePrefix = languages.getUITranslation(_i18n__WEBPACK_IMPORTED_MODULE_1__.UIElement.NEW_SHEET_PREFIX);
  }
  addSheet(newSheetDisplayName = `${this.sheetNamePrefix}${this.lastSheetId + 2}`) {
    const newSheetCanonicalName = canonicalize(newSheetDisplayName);
    if (this.mappingFromCanonicalName.has(newSheetCanonicalName)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.SheetNameAlreadyTakenError(newSheetDisplayName);
    }
    this.lastSheetId++;
    const sheet = new Sheet(this.lastSheetId, newSheetDisplayName);
    this.store(sheet);
    return sheet.id;
  }
  removeSheet(sheetId) {
    const sheet = this.fetchSheetById(sheetId);
    if (sheetId == this.lastSheetId) {
      --this.lastSheetId;
    }
    this.mappingFromCanonicalName.delete(sheet.canonicalName);
    this.mappingFromId.delete(sheet.id);
  }
  getDisplayName(sheetId) {
    var _a;
    return (_a = this.mappingFromId.get(sheetId)) === null || _a === void 0 ? void 0 : _a.displayName;
  }
  *displayNames() {
    for (const sheet of this.mappingFromCanonicalName.values()) {
      yield sheet.displayName;
    }
  }
  numberOfSheets() {
    return this.mappingFromCanonicalName.size;
  }
  hasSheetWithId(sheetId) {
    return this.mappingFromId.has(sheetId);
  }
  hasSheetWithName(sheetName) {
    return this.mappingFromCanonicalName.has(canonicalize(sheetName));
  }
  renameSheet(sheetId, newDisplayName) {
    const sheet = this.fetchSheetById(sheetId);
    const currentDisplayName = sheet.displayName;
    if (currentDisplayName === newDisplayName) {
      return undefined;
    }
    const sheetWithThisCanonicalName = this.mappingFromCanonicalName.get(canonicalize(newDisplayName));
    if (sheetWithThisCanonicalName !== undefined && sheetWithThisCanonicalName.id !== sheet.id) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.SheetNameAlreadyTakenError(newDisplayName);
    }
    const currentCanonicalName = sheet.canonicalName;
    this.mappingFromCanonicalName.delete(currentCanonicalName);
    sheet.displayName = newDisplayName;
    this.store(sheet);
    return currentDisplayName;
  }
  sheetNames() {
    return Array.from(this.mappingFromId.values()).map(s => s.displayName);
  }
  store(sheet) {
    this.mappingFromId.set(sheet.id, sheet);
    this.mappingFromCanonicalName.set(sheet.canonicalName, sheet);
  }
  fetchSheetById(sheetId) {
    const sheet = this.mappingFromId.get(sheetId);
    if (sheet === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.NoSheetWithIdError(sheetId);
    }
    return sheet;
  }
}

/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TranslationPackage: () => (/* reexport safe */ _TranslationPackage__WEBPACK_IMPORTED_MODULE_0__.TranslationPackage),
/* harmony export */   UIElement: () => (/* binding */ UIElement),
/* harmony export */   buildTranslationPackage: () => (/* reexport safe */ _TranslationPackage__WEBPACK_IMPORTED_MODULE_0__.buildTranslationPackage)
/* harmony export */ });
/* harmony import */ var _TranslationPackage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


var UIElement;
(function (UIElement) {
  UIElement["NEW_SHEET_PREFIX"] = "NEW_SHEET_PREFIX";
})(UIElement || (UIElement = {}));

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TranslationPackage: () => (/* binding */ TranslationPackage),
/* harmony export */   buildTranslationPackage: () => (/* binding */ buildTranslationPackage)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class TranslationPackage {
  constructor(functions, errors, ui) {
    this.functions = functions;
    this.errors = errors;
    this.ui = ui;
    this._protectedTranslations = {
      'VERSION': 'VERSION'
    };
    this.checkUI();
    this.checkErrors();
    this.checkFunctionTranslations(this.functions);
    Object.assign(this.functions, this._protectedTranslations);
  }
  extendFunctions(additionalFunctionTranslations) {
    this.checkFunctionTranslations(additionalFunctionTranslations);
    Object.assign(this.functions, additionalFunctionTranslations);
  }
  buildFunctionMapping() {
    return Object.keys(this.functions).reduce((ret, key) => {
      ret[this.functions[key]] = key;
      return ret;
    }, {});
  }
  buildErrorMapping() {
    return Object.keys(this.errors).reduce((ret, key) => {
      ret[this.errors[key]] = key;
      return ret;
    }, {});
  }
  isFunctionTranslated(key) {
    return this.functions[key] !== undefined;
  }
  getFunctionTranslations(functionIds) {
    const translations = [];
    for (const functionId of functionIds) {
      if (this.isFunctionTranslated(functionId)) {
        translations.push(this.functions[functionId]);
      }
    }
    return translations;
  }
  getFunctionTranslation(key) {
    const val = this.functions[key];
    if (val === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.MissingTranslationError(`functions.${key}`);
    } else {
      return val;
    }
  }
  getMaybeFunctionTranslation(key) {
    return this.functions[key];
  }
  getErrorTranslation(key) {
    if (key === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.LIC) {
      return `#${_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.LIC}!`;
    }
    const val = this.errors[key];
    if (val === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.MissingTranslationError(`errors.${key}`);
    } else {
      return val;
    }
  }
  getUITranslation(key) {
    const val = this.ui[key];
    if (val === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.MissingTranslationError(`ui.${key}`);
    } else {
      return val;
    }
  }
  checkUI() {
    for (const key of Object.values(_index__WEBPACK_IMPORTED_MODULE_2__.UIElement)) {
      if (!(key in this.ui)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.MissingTranslationError(`ui.${key}`);
      }
    }
  }
  checkErrors() {
    for (const key of Object.values(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType)) {
      if (!(key in this.errors) && key !== _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.LIC) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.MissingTranslationError(`errors.${key}`);
      }
    }
  }
  checkFunctionTranslations(functions) {
    const functionNames = new Set(Object.getOwnPropertyNames(functions));
    for (const protectedTranslation of Object.getOwnPropertyNames(this._protectedTranslations)) {
      if (functionNames.has(protectedTranslation)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ProtectedFunctionTranslationError(protectedTranslation);
      }
    }
  }
}
function buildTranslationPackage(rawTranslationPackage) {
  return new TranslationPackage(Object.assign({}, rawTranslationPackage.functions), Object.assign({}, rawTranslationPackage.errors), Object.assign({}, rawTranslationPackage.ui));
}

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyCellVertex: () => (/* binding */ EmptyCellVertex)
/* harmony export */ });
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Represents singleton vertex bound to all empty cells
 */
class EmptyCellVertex {
  constructor() {}
  /**
   * Retrieves cell value bound to that singleton
   */
  getCellValue() {
    return _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.EmptyValue;
  }
}

/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ValueCellVertex: () => (/* binding */ ValueCellVertex)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
/**
 * Represents vertex which keeps static cell value
 */
class ValueCellVertex {
  /** Static cell value. */
  constructor(parsedValue, rawValue) {
    this.parsedValue = parsedValue;
    this.rawValue = rawValue;
  }
  getValues() {
    return {
      parsedValue: this.parsedValue,
      rawValue: this.rawValue
    };
  }
  setValues(values) {
    this.parsedValue = values.parsedValue;
    this.rawValue = values.rawValue;
  }
  /**
   * Returns cell value stored in vertex
   */
  getCellValue() {
    return this.parsedValue;
  }
  setCellValue(_cellValue) {
    throw Error('SetCellValue is deprecated for ValueCellVertex');
  }
}

/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParsingErrorVertex: () => (/* binding */ ParsingErrorVertex)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Represents a cell that contains a parsing error.
 */
class ParsingErrorVertex {
  /**
   * Constructor
   */
  constructor(errors, rawInput) {
    this.errors = errors;
    this.rawInput = rawInput;
  }
  /**
   * Returns the value of the cell.
   */
  getCellValue() {
    const firstNonemptyMessage = this.errors.map(error => error.message).find(msg => msg);
    return _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError.parsingError(firstNonemptyMessage);
  }
  /**
   * Returns the formula of the cell.
   */
  getFormula() {
    return this.rawInput;
  }
}

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SparseStrategy: () => (/* binding */ SparseStrategy)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Mapping from cell addresses to vertices
 *
 * Uses Map to store addresses, having minimal memory usage for sparse sheets but not necessarily constant set/lookup.
 */
class SparseStrategy {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    /**
     * Map of Maps in which actual data is stored.
     *
     * Key of map in first level is column number.
     * Key of map in second level is row number.
     */
    this.mapping = new Map();
  }
  /** @inheritDoc */
  getCell(address) {
    var _a;
    return (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row);
  }
  /** @inheritDoc */
  setCell(address, newVertex) {
    this.width = Math.max(this.width, address.col + 1);
    this.height = Math.max(this.height, address.row + 1);
    let colMapping = this.mapping.get(address.col);
    if (!colMapping) {
      colMapping = new Map();
      this.mapping.set(address.col, colMapping);
    }
    colMapping.set(address.row, newVertex);
  }
  /** @inheritDoc */
  has(address) {
    var _a;
    return !!((_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.get(address.row));
  }
  /** @inheritDoc */
  getHeight() {
    return this.height;
  }
  /** @inheritDoc */
  getWidth() {
    return this.width;
  }
  removeCell(address) {
    var _a;
    (_a = this.mapping.get(address.col)) === null || _a === void 0 ? void 0 : _a.delete(address.row);
  }
  addRows(row, numberOfRows) {
    this.mapping.forEach(rowMapping => {
      const tmpMapping = new Map();
      rowMapping.forEach((vertex, rowNumber) => {
        if (rowNumber >= row) {
          tmpMapping.set(rowNumber + numberOfRows, vertex);
          rowMapping.delete(rowNumber);
        }
      });
      tmpMapping.forEach((vertex, rowNumber) => {
        rowMapping.set(rowNumber, vertex);
      });
    });
    this.height += numberOfRows;
  }
  addColumns(column, numberOfColumns) {
    const tmpMapping = new Map();
    this.mapping.forEach((rowMapping, colNumber) => {
      if (colNumber >= column) {
        tmpMapping.set(colNumber + numberOfColumns, rowMapping);
        this.mapping.delete(colNumber);
      }
    });
    tmpMapping.forEach((rowMapping, colNumber) => {
      this.mapping.set(colNumber, rowMapping);
    });
    this.width += numberOfColumns;
  }
  removeRows(removedRows) {
    this.mapping.forEach(rowMapping => {
      const tmpMapping = new Map();
      rowMapping.forEach((vertex, rowNumber) => {
        if (rowNumber >= removedRows.rowStart) {
          rowMapping.delete(rowNumber);
          if (rowNumber > removedRows.rowEnd) {
            tmpMapping.set(rowNumber - removedRows.numberOfRows, vertex);
          }
        }
      });
      tmpMapping.forEach((vertex, rowNumber) => {
        rowMapping.set(rowNumber, vertex);
      });
    });
    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);
    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);
    this.height = Math.max(0, this.height - numberOfRowsRemoved);
  }
  removeColumns(removedColumns) {
    const tmpMapping = new Map();
    this.mapping.forEach((rowMapping, colNumber) => {
      if (colNumber >= removedColumns.columnStart) {
        this.mapping.delete(colNumber);
        if (colNumber > removedColumns.columnEnd) {
          tmpMapping.set(colNumber - removedColumns.numberOfColumns, rowMapping);
        }
      }
    });
    tmpMapping.forEach((rowMapping, colNumber) => {
      this.mapping.set(colNumber, rowMapping);
    });
    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);
    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);
    this.width = Math.max(0, this.width - numberOfColumnsRemoved);
  }
  *getEntries(sheet) {
    for (const [colNumber, col] of this.mapping) {
      for (const [rowNumber, value] of col) {
        yield [(0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, colNumber, rowNumber), value];
      }
    }
  }
  *verticesFromColumn(column) {
    const colMapping = this.mapping.get(column);
    if (colMapping === undefined) {
      return;
    }
    for (const [_, vertex] of colMapping) {
      yield vertex;
    }
  }
  *verticesFromRow(row) {
    for (const colMapping of this.mapping.values()) {
      const rowVertex = colMapping.get(row);
      if (rowVertex !== undefined) {
        yield rowVertex;
      }
    }
  }
  *verticesFromColumnsSpan(columnsSpan) {
    for (const column of columnsSpan.columns()) {
      const colMapping = this.mapping.get(column);
      if (colMapping === undefined) {
        continue;
      }
      for (const [_, vertex] of colMapping) {
        yield vertex;
      }
    }
  }
  *verticesFromRowsSpan(rowsSpan) {
    for (const colMapping of this.mapping.values()) {
      for (const row of rowsSpan.rows()) {
        const rowVertex = colMapping.get(row);
        if (rowVertex !== undefined) {
          yield rowVertex;
        }
      }
    }
  }
  *entriesFromRowsSpan(rowsSpan) {
    for (const [col, colMapping] of this.mapping.entries()) {
      for (const row of rowsSpan.rows()) {
        const rowVertex = colMapping.get(row);
        if (rowVertex !== undefined) {
          yield [(0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(rowsSpan.sheet, col, row), rowVertex];
        }
      }
    }
  }
  *entriesFromColumnsSpan(columnsSpan) {
    for (const col of columnsSpan.columns()) {
      const colMapping = this.mapping.get(col);
      if (colMapping !== undefined) {
        for (const [row, vertex] of colMapping.entries()) {
          yield [(0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(columnsSpan.sheet, col, row), vertex];
        }
      }
    }
  }
  *vertices() {
    for (const [_, col] of this.mapping) {
      for (const [_, value] of col) {
        if (value !== undefined) {
          yield value;
        }
      }
    }
  }
}

/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DenseStrategy: () => (/* binding */ DenseStrategy)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * Mapping from cell addresses to vertices
 *
 * Uses Array to store addresses, having minimal memory usage for dense sheets and constant set/lookup.
 */
class DenseStrategy {
  /**
   * @param width - width of the stored sheet
   * @param height - height of the stored sheet
   */
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.mapping = new Array(height);
    for (let i = 0; i < height; i++) {
      this.mapping[i] = new Array(width);
    }
  }
  /** @inheritDoc */
  getCell(address) {
    return this.getCellVertex(address.col, address.row);
  }
  /** @inheritDoc */
  setCell(address, newVertex) {
    this.width = Math.max(this.width, address.col + 1);
    this.height = Math.max(this.height, address.row + 1);
    const rowMapping = this.mapping[address.row];
    if (!rowMapping) {
      this.mapping[address.row] = new Array(this.width);
    }
    this.mapping[address.row][address.col] = newVertex;
  }
  /** @inheritDoc */
  has(address) {
    const row = this.mapping[address.row];
    if (!row) {
      return false;
    }
    return !!row[address.col];
  }
  /** @inheritDoc */
  getHeight() {
    return this.height;
  }
  /** @inheritDoc */
  getWidth() {
    return this.width;
  }
  removeCell(address) {
    if (this.mapping[address.row] !== undefined) {
      delete this.mapping[address.row][address.col];
    }
  }
  addRows(row, numberOfRows) {
    const newRows = [];
    for (let i = 0; i < numberOfRows; i++) {
      newRows.push(new Array(this.width));
    }
    this.mapping.splice(row, 0, ...newRows);
    this.height += numberOfRows;
  }
  addColumns(column, numberOfColumns) {
    for (let i = 0; i < this.height; i++) {
      if (this.mapping[i] !== undefined) {
        this.mapping[i].splice(column, 0, ...new Array(numberOfColumns));
      }
    }
    this.width += numberOfColumns;
  }
  removeRows(removedRows) {
    this.mapping.splice(removedRows.rowStart, removedRows.numberOfRows);
    const rightmostRowRemoved = Math.min(this.height - 1, removedRows.rowEnd);
    const numberOfRowsRemoved = Math.max(0, rightmostRowRemoved - removedRows.rowStart + 1);
    this.height = Math.max(0, this.height - numberOfRowsRemoved);
  }
  removeColumns(removedColumns) {
    for (let i = 0; i < this.height; i++) {
      if (this.mapping[i] !== undefined) {
        this.mapping[i].splice(removedColumns.columnStart, removedColumns.numberOfColumns);
      }
    }
    const rightmostColumnRemoved = Math.min(this.width - 1, removedColumns.columnEnd);
    const numberOfColumnsRemoved = Math.max(0, rightmostColumnRemoved - removedColumns.columnStart + 1);
    this.width = Math.max(0, this.width - numberOfColumnsRemoved);
  }
  *getEntries(sheet) {
    for (let y = 0; y < this.height; ++y) {
      for (let x = 0; x < this.width; ++x) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield [(0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, x, y), vertex];
        }
      }
    }
  }
  *verticesFromColumn(column) {
    for (let y = 0; y < this.height; ++y) {
      const vertex = this.getCellVertex(column, y);
      if (vertex) {
        yield vertex;
      }
    }
  }
  *verticesFromRow(row) {
    for (let x = 0; x < this.width; ++x) {
      const vertex = this.getCellVertex(x, row);
      if (vertex) {
        yield vertex;
      }
    }
  }
  *verticesFromColumnsSpan(columnsSpan) {
    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {
      for (let y = 0; y < this.height; ++y) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield vertex;
        }
      }
    }
  }
  *verticesFromRowsSpan(rowsSpan) {
    for (let x = 0; x < this.width; ++x) {
      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield vertex;
        }
      }
    }
  }
  *entriesFromRowsSpan(rowsSpan) {
    for (let x = 0; x < this.width; ++x) {
      for (let y = rowsSpan.rowStart; y <= rowsSpan.rowEnd; ++y) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield [(0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(rowsSpan.sheet, x, y), vertex];
        }
      }
    }
  }
  *entriesFromColumnsSpan(columnsSpan) {
    for (let x = columnsSpan.columnStart; x <= columnsSpan.columnEnd; ++x) {
      for (let y = 0; y < this.height; ++y) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield [(0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(columnsSpan.sheet, x, y), vertex];
        }
      }
    }
  }
  *vertices() {
    for (let y = 0; y < this.height; ++y) {
      for (let x = 0; x < this.width; ++x) {
        const vertex = this.getCellVertex(x, y);
        if (vertex) {
          yield vertex;
        }
      }
    }
  }
  getCellVertex(x, y) {
    var _a;
    return (_a = this.mapping[y]) === null || _a === void 0 ? void 0 : _a[x];
  }
}

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InterpreterState: () => (/* binding */ InterpreterState)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class InterpreterState {
  constructor(formulaAddress, arraysFlag, formulaVertex) {
    this.formulaAddress = formulaAddress;
    this.arraysFlag = arraysFlag;
    this.formulaVertex = formulaVertex;
  }
}

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyValue: () => (/* reexport safe */ _InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.EmptyValue),
/* harmony export */   FunctionArgumentType: () => (/* reexport safe */ _plugin_FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType),
/* harmony export */   FunctionPlugin: () => (/* reexport safe */ _plugin_FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin)
/* harmony export */ });
/* harmony import */ var _plugin_FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FunctionArgumentType: () => (/* binding */ FunctionArgumentType),
/* harmony export */   FunctionPlugin: () => (/* binding */ FunctionPlugin)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(69);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







var FunctionArgumentType;
(function (FunctionArgumentType) {
  /**
   * String type.
   */
  FunctionArgumentType["STRING"] = "STRING";
  /**
   * Floating point type.
   */
  FunctionArgumentType["NUMBER"] = "NUMBER";
  /**
   * Boolean type.
   */
  FunctionArgumentType["BOOLEAN"] = "BOOLEAN";
  /**
   * Any non-range value.
   */
  FunctionArgumentType["SCALAR"] = "SCALAR";
  /**
   * Any non-range, no-error type.
   */
  FunctionArgumentType["NOERROR"] = "NOERROR";
  /**
   * Range type.
   */
  FunctionArgumentType["RANGE"] = "RANGE";
  /**
   * Integer type.
   */
  FunctionArgumentType["INTEGER"] = "INTEGER";
  /**
   * String representing complex number.
   */
  FunctionArgumentType["COMPLEX"] = "COMPLEX";
  /**
   * Range or scalar.
   */
  FunctionArgumentType["ANY"] = "ANY";
})(FunctionArgumentType || (FunctionArgumentType = {}));
/**
 * Abstract class representing interpreter function plugin.
 * Plugin may contain multiple functions. Each function should be of type {@link PluginFunctionType} and needs to be
 * included in {@link implementedFunctions}
 */
class FunctionPlugin {
  constructor(interpreter) {
    this.coerceScalarToNumberOrError = arg => this.arithmeticHelper.coerceScalarToNumberOrError(arg);
    /**
     * A method that should wrap the logic of every built-in function and custom function. It:
     * - Evaluates the function's arguments.
     * - Validates the number of arguments against the [`parameters` array](#function-options).
     * - Coerces the argument values to types set in the [`parameters` array](#argument-validation-options).
     * - Handles optional arguments and default values according to options set in the [`parameters` array](#argument-validation-options).
     * - Validates the function's arguments against the [argument validation options](#argument-validation-options).
     * - Duplicates the arguments according to the [`repeatLastArgs` option](#function-options).
     * - Handles the [array arithmetic mode](arrays.md#array-arithmetic-mode).
     * - Performs [function vectorization](arrays.md#passing-arrays-to-scalar-functions-vectorization).
     * - Performs [argument broadcasting](arrays.md#broadcasting).
     */
    this.runFunction = (args, state, metadata, functionImplementation) => {
      const evaluatedArguments = this.evaluateArguments(args, state, metadata);
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
      const argumentValues = evaluatedArguments.map(([value, _]) => value);
      const argumentIgnorableFlags = evaluatedArguments.map(([_, ignorable]) => ignorable);
      const argumentMetadata = this.buildMetadataForEachArgumentValue(argumentValues.length, metadata);
      const isVectorizationOn = state.arraysFlag && !metadata.vectorizationForbidden;
      if (!this.isNumberOfArgumentValuesValid(argumentMetadata, argumentValues.length)) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongArgNumber);
      }
      const [resultArrayHeight, resultArrayWidth] = isVectorizationOn ? this.calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) : [1, 1];
      if (resultArrayHeight === 1 && resultArrayWidth === 1) {
        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, 0, 0);
        return this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);
      }
      const resultArray = [...Array(resultArrayHeight).keys()].map(row => [...Array(resultArrayWidth).keys()].map(col => {
        const vectorizedArguments = this.vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col);
        const result = this.calculateSingleCellOfResultArray(state, vectorizedArguments, argumentMetadata, argumentIgnorableFlags, functionImplementation, metadata.returnNumberType);
        if (result instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue) {
          throw new Error('Function returning array cannot be vectorized.');
        }
        return result;
      }));
      return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue.onlyValues(resultArray);
    };
    this.runFunctionWithReferenceArgument = (args, state, metadata, noArgCallback, referenceCallback, nonReferenceCallback = () => new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.CellRefExpected)) => {
      if (args.length === 0) {
        return this.returnNumberWrapper(noArgCallback(), metadata.returnNumberType);
      } else if (args.length > 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongArgNumber);
      }
      let arg = args[0];
      while (arg.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PARENTHESIS) {
        arg = arg.expression;
      }
      let cellReference;
      if (arg.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_REFERENCE) {
        cellReference = arg.reference.toSimpleCellAddress(state.formulaAddress);
      } else if (arg.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_RANGE || arg.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.COLUMN_RANGE || arg.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ROW_RANGE) {
        try {
          cellReference = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.fromAst(arg, state.formulaAddress).start;
        } catch (e) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.CellRefExpected);
        }
      }
      if (cellReference !== undefined) {
        return this.returnNumberWrapper(referenceCallback(cellReference), metadata.returnNumberType);
      }
      return this.runFunction(args, state, metadata, nonReferenceCallback);
    };
    this.interpreter = interpreter;
    this.dependencyGraph = interpreter.dependencyGraph;
    this.columnSearch = interpreter.columnSearch;
    this.config = interpreter.config;
    this.serialization = interpreter.serialization;
    this.arraySizePredictor = interpreter.arraySizePredictor;
    this.dateTimeHelper = interpreter.dateTimeHelper;
    this.arithmeticHelper = interpreter.arithmeticHelper;
  }
  evaluateAst(ast, state) {
    return this.interpreter.evaluateAst(ast, state);
  }
  arraySizeForAst(ast, state) {
    return this.arraySizePredictor.checkArraySizeForAst(ast, state);
  }
  listOfScalarValues(asts, state) {
    const ret = [];
    for (const argAst of asts) {
      const value = this.evaluateAst(argAst, state);
      if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue) {
        for (const scalarValue of value.valuesFromTopLeftCorner()) {
          ret.push([scalarValue, true]);
        }
      } else {
        ret.push([value, false]);
      }
    }
    return ret;
  }
  coerceToType(arg, coercedType, state) {
    let ret;
    if (arg instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue) {
      switch (coercedType.argumentType) {
        case FunctionArgumentType.RANGE:
        case FunctionArgumentType.ANY:
          ret = arg;
          break;
        default:
          {
            const coerce = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__.coerceRangeToScalar)(arg, state);
            if (coerce === undefined) {
              return undefined;
            }
            arg = coerce;
          }
      }
    }
    if (!(arg instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue)) {
      switch (coercedType.argumentType) {
        case FunctionArgumentType.INTEGER:
        case FunctionArgumentType.NUMBER:
          // eslint-disable-next-line no-case-declarations
          const coerced = this.coerceScalarToNumberOrError(arg);
          if (!(0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.isExtendedNumber)(coerced)) {
            ret = coerced;
            break;
          }
          // eslint-disable-next-line no-case-declarations
          const value = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.getRawValue)(coerced);
          if (coercedType.maxValue !== undefined && value > coercedType.maxValue) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueLarge);
          }
          if (coercedType.minValue !== undefined && value < coercedType.minValue) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueSmall);
          }
          if (coercedType.lessThan !== undefined && value >= coercedType.lessThan) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueLarge);
          }
          if (coercedType.greaterThan !== undefined && value <= coercedType.greaterThan) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueSmall);
          }
          if (coercedType.argumentType === FunctionArgumentType.INTEGER && !Number.isInteger(value)) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.IntegerExpected);
          }
          ret = coerced;
          break;
        case FunctionArgumentType.STRING:
          ret = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__.coerceScalarToString)(arg);
          break;
        case FunctionArgumentType.BOOLEAN:
          ret = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__.coerceScalarToBoolean)(arg);
          break;
        case FunctionArgumentType.SCALAR:
        case FunctionArgumentType.NOERROR:
        case FunctionArgumentType.ANY:
          ret = arg;
          break;
        case FunctionArgumentType.RANGE:
          if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
            return arg;
          }
          ret = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__.coerceToRange)(arg);
          break;
        case FunctionArgumentType.COMPLEX:
          return this.arithmeticHelper.coerceScalarToComplex((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.getRawValue)(arg));
      }
    }
    if (coercedType.passSubtype || ret === undefined) {
      return ret;
    } else {
      return (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.getRawValue)(ret);
    }
  }
  calculateSingleCellOfResultArray(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags, functionImplementation, returnNumberType) {
    const coercedArguments = this.coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags);
    if (coercedArguments instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return coercedArguments;
    }
    const functionCalculationResult = functionImplementation(...coercedArguments);
    return this.returnNumberWrapper(functionCalculationResult, returnNumberType);
  }
  coerceArgumentsToRequiredTypes(state, vectorizedArguments, argumentsMetadata, argumentIgnorableFlags) {
    const coercedArguments = [];
    for (let i = 0; i < argumentsMetadata.length; i++) {
      const argumentMetadata = argumentsMetadata[i];
      const argumentValue = vectorizedArguments[i] !== undefined ? vectorizedArguments[i] : argumentMetadata === null || argumentMetadata === void 0 ? void 0 : argumentMetadata.defaultValue;
      if (argumentValue === undefined) {
        coercedArguments.push(undefined);
        continue;
      }
      const coercedValue = this.coerceToType(argumentValue, argumentMetadata, state);
      if (coercedValue === undefined && !argumentIgnorableFlags[i]) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongType);
      }
      if (coercedValue instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError && argumentMetadata.argumentType !== FunctionArgumentType.SCALAR) {
        return coercedValue;
      }
      coercedArguments.push(coercedValue);
    }
    return coercedArguments;
  }
  vectorizeAndBroadcastArgumentsIfNecessary(isVectorizationOn, argumentValues, argumentMetadata, row, col) {
    return argumentValues.map((value, i) => isVectorizationOn && this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]) ? this.vectorizeAndBroadcastRangeArgument(value, row, col) : value);
  }
  vectorizeAndBroadcastRangeArgument(argumentValue, rowNum, colNum) {
    var _a;
    const targetRowNum = argumentValue.height() === 1 ? 0 : rowNum;
    const targetColNum = argumentValue.width() === 1 ? 0 : colNum;
    return (_a = argumentValue.data[targetRowNum]) === null || _a === void 0 ? void 0 : _a[targetColNum];
  }
  evaluateArguments(args, state, metadata) {
    return metadata.expandRanges ? this.listOfScalarValues(args, state) : args.map(ast => [this.evaluateAst(ast, state), false]);
  }
  buildMetadataForEachArgumentValue(numberOfArgumentValuesPassed, metadata) {
    const argumentsMetadata = metadata.parameters ? [...metadata.parameters] : [];
    const isRepeatLastArgsValid = metadata.repeatLastArgs !== undefined && Number.isInteger(metadata.repeatLastArgs) && metadata.repeatLastArgs > 0;
    if (isRepeatLastArgsValid) {
      while (numberOfArgumentValuesPassed > argumentsMetadata.length) {
        argumentsMetadata.push(...argumentsMetadata.slice(argumentsMetadata.length - metadata.repeatLastArgs));
      }
    }
    return argumentsMetadata;
  }
  isNumberOfArgumentValuesValid(argumentsMetadata, numberOfArgumentValuesPassed) {
    if (numberOfArgumentValuesPassed > argumentsMetadata.length) {
      return false;
    }
    if (numberOfArgumentValuesPassed < argumentsMetadata.length) {
      const metadataForMissingArguments = argumentsMetadata.slice(numberOfArgumentValuesPassed);
      const areMissingArgumentsOptional = metadataForMissingArguments.every(argMetadata => (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.optionalArg) || (argMetadata === null || argMetadata === void 0 ? void 0 : argMetadata.defaultValue) !== undefined);
      return areMissingArgumentsOptional;
    }
    return true;
  }
  calculateSizeOfVectorizedResultArray(argumentValues, argumentMetadata) {
    const argumentsThatRequireVectorization = argumentValues.filter((value, i) => this.isRangePassedAsAScalarArgument(value, argumentMetadata[i]));
    const height = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.height()));
    const width = Math.max(1, ...argumentsThatRequireVectorization.map(val => val.width()));
    return [height, width];
  }
  isRangePassedAsAScalarArgument(argumentValue, argumentMetadata) {
    if (argumentValue == null || argumentMetadata == null) {
      return false;
    }
    return argumentValue instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue && ![FunctionArgumentType.RANGE, FunctionArgumentType.ANY].includes(argumentMetadata.argumentType);
  }
  metadata(name) {
    const params = this.constructor.implementedFunctions[name];
    if (params !== undefined) {
      return params;
    }
    throw new Error(`No metadata for function ${name}.`);
  }
  returnNumberWrapper(val, type, format) {
    if (type !== undefined && (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.isExtendedNumber)(val)) {
      return this.arithmeticHelper.ExtendedNumberFactory((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.getRawValue)(val), {
        type,
        format
      });
    } else {
      return val;
    }
  }
}

/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArithmeticHelper: () => (/* binding */ ArithmeticHelper),
/* harmony export */   coerceBooleanToNumber: () => (/* binding */ coerceBooleanToNumber),
/* harmony export */   coerceComplexToString: () => (/* binding */ coerceComplexToString),
/* harmony export */   coerceEmptyToValue: () => (/* binding */ coerceEmptyToValue),
/* harmony export */   coerceRangeToScalar: () => (/* binding */ coerceRangeToScalar),
/* harmony export */   coerceScalarToBoolean: () => (/* binding */ coerceScalarToBoolean),
/* harmony export */   coerceScalarToString: () => (/* binding */ coerceScalarToString),
/* harmony export */   coerceToRange: () => (/* binding */ coerceToRange),
/* harmony export */   coerceToRangeNumbersOrError: () => (/* binding */ coerceToRangeNumbersOrError),
/* harmony export */   fixNegativeZero: () => (/* binding */ fixNegativeZero),
/* harmony export */   forceNormalizeString: () => (/* binding */ forceNormalizeString),
/* harmony export */   isNumberOverflow: () => (/* binding */ isNumberOverflow),
/* harmony export */   normalizeString: () => (/* binding */ normalizeString),
/* harmony export */   numberCmp: () => (/* binding */ numberCmp),
/* harmony export */   zeroIfEmpty: () => (/* binding */ zeroIfEmpty)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _StringHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(69);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





const COMPLEX_NUMBER_SYMBOL = 'i';
const complexParsingRegexp = /^\s*([+-]?)\s*(([\d\.,]+(e[+-]?\d+)?)\s*([ij]?)|([ij]))\s*(([+-])\s*([+-]?)\s*(([\d\.,]+(e[+-]?\d+)?)\s*([ij]?)|([ij])))?$/;
class ArithmeticHelper {
  constructor(config, dateTimeHelper, numberLiteralsHelper) {
    this.config = config;
    this.dateTimeHelper = dateTimeHelper;
    this.numberLiteralsHelper = numberLiteralsHelper;
    this.lt = (left, right) => {
      return this.compare(left, right) < 0;
    };
    this.leq = (left, right) => {
      return this.compare(left, right) <= 0;
    };
    this.gt = (left, right) => {
      return this.compare(left, right) > 0;
    };
    this.geq = (left, right) => {
      return this.compare(left, right) >= 0;
    };
    this.eq = (left, right) => {
      return this.compare(left, right) === 0;
    };
    this.neq = (left, right) => {
      return this.compare(left, right) !== 0;
    };
    this.pow = (left, right) => {
      return Math.pow((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(left), (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(right));
    };
    this.addWithEpsilonRaw = (left, right) => {
      const ret = left + right;
      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {
        return 0;
      } else {
        return ret;
      }
    };
    this.addWithEpsilon = (left, right) => {
      const typeOfResult = inferExtendedNumberTypeAdditive(left, right);
      return this.ExtendedNumberFactory(this.addWithEpsilonRaw((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(left), (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(right)), typeOfResult);
    };
    this.unaryMinus = arg => {
      return (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.cloneNumber)(arg, -(0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg));
    };
    this.unaryPlus = arg => arg;
    this.unaryPercent = arg => {
      return new _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.PercentNumber((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg) / 100);
    };
    this.concat = (left, right) => {
      return left.concat(right);
    };
    this.nonstrictadd = (left, right) => {
      if (left instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return left;
      } else if (right instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return right;
      } else if (typeof left === 'number') {
        if (typeof right === 'number') {
          return this.addWithEpsilonRaw(left, right);
        } else {
          return left;
        }
      } else if (typeof right === 'number') {
        return right;
      } else {
        return 0;
      }
    };
    /**
     * Subtracts two numbers
     *
     * Implementation of subtracting which is used in interpreter.
     *
     * @param left - left operand of subtraction
     * @param right - right operand of subtraction
     * @param eps - precision of comparison
     */
    this.subtract = (leftArg, rightArg) => {
      const typeOfResult = inferExtendedNumberTypeAdditive(leftArg, rightArg);
      const left = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(leftArg);
      const right = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(rightArg);
      let ret = left - right;
      if (Math.abs(ret) < this.actualEps * Math.abs(left)) {
        ret = 0;
      }
      return this.ExtendedNumberFactory(ret, typeOfResult);
    };
    this.divide = (leftArg, rightArg) => {
      const left = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(leftArg);
      const right = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(rightArg);
      if (right === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      } else {
        const typeOfResult = inferExtendedNumberTypeMultiplicative(leftArg, rightArg);
        return this.ExtendedNumberFactory(left / right, typeOfResult);
      }
    };
    this.multiply = (left, right) => {
      const typeOfResult = inferExtendedNumberTypeMultiplicative(left, right);
      return this.ExtendedNumberFactory((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(left) * (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(right), typeOfResult);
    };
    this.manyToExactComplex = args => {
      const ret = [];
      for (const arg of args) {
        if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return arg;
        } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg) || typeof arg === 'string') {
          const coerced = this.coerceScalarToComplex(arg);
          if (!(coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError)) {
            ret.push(coerced);
          }
        }
      }
      return ret;
    };
    this.coerceNumbersExactRanges = args => this.manyToNumbers(args, this.manyToExactNumbers);
    this.coerceNumbersCoerceRangesDropNulls = args => this.manyToNumbers(args, this.manyToCoercedNumbersDropNulls);
    this.manyToExactNumbers = args => {
      const ret = [];
      for (const arg of args) {
        if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return arg;
        } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
          ret.push((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg));
        }
      }
      return ret;
    };
    this.manyToOnlyNumbersDropNulls = args => {
      const ret = [];
      for (const arg of args) {
        if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return arg;
        } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
          ret.push((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg));
        } else if (arg !== _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NumberExpected);
        }
      }
      return ret;
    };
    this.manyToCoercedNumbersDropNulls = args => {
      const ret = [];
      for (const arg of args) {
        if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return arg;
        }
        if (arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
          continue;
        }
        const coerced = this.coerceScalarToNumberOrError(arg);
        if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(coerced)) {
          ret.push((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(coerced));
        }
      }
      return ret;
    };
    this.collator = (0,_StringHelper__WEBPACK_IMPORTED_MODULE_2__.collatorFromConfig)(config);
    this.actualEps = config.smartRounding ? config.precisionEpsilon : 0;
  }
  eqMatcherFunction(pattern) {
    const regexp = this.buildRegex(pattern);
    return cellValue => typeof cellValue === 'string' && regexp.test(this.normalizeString(cellValue));
  }
  neqMatcherFunction(pattern) {
    const regexp = this.buildRegex(pattern);
    return cellValue => {
      return !(typeof cellValue === 'string') || !regexp.test(this.normalizeString(cellValue));
    };
  }
  searchString(pattern, text) {
    var _a;
    const regexp = this.buildRegex(pattern, false);
    const result = regexp.exec(text);
    return (_a = result === null || result === void 0 ? void 0 : result.index) !== null && _a !== void 0 ? _a : -1;
  }
  requiresRegex(pattern) {
    if (!this.config.useRegularExpressions && !this.config.useWildcards) {
      return !this.config.matchWholeCell;
    }
    for (let i = 0; i < pattern.length; i++) {
      const c = pattern.charAt(i);
      if (isWildcard(c) || this.config.useRegularExpressions && needsEscape(c)) {
        return true;
      }
    }
    return false;
  }
  floatCmp(leftArg, rightArg) {
    const left = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(leftArg);
    const right = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(rightArg);
    const mod = 1 + this.actualEps;
    if (right >= 0 && left * mod >= right && left <= right * mod) {
      return 0;
    } else if (right <= 0 && left * mod <= right && left >= right * mod) {
      return 0;
    } else if (left > right) {
      return 1;
    } else {
      return -1;
    }
  }
  coerceScalarToNumberOrError(arg) {
    var _a;
    if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return arg;
    }
    return (_a = this.coerceToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NumberCoercion);
  }
  coerceToMaybeNumber(arg) {
    var _a;
    return (_a = this.coerceNonDateScalarToMaybeNumber(arg)) !== null && _a !== void 0 ? _a : typeof arg === 'string' ? this.dateTimeHelper.dateStringToDateNumber(arg) : undefined;
  }
  coerceNonDateScalarToMaybeNumber(arg) {
    if (arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
      return 0;
    } else if (typeof arg === 'string') {
      if (arg === '') {
        return 0;
      }
      const maybePercentNumber = this.coerceStringToMaybePercentNumber(arg);
      if (maybePercentNumber !== undefined) {
        return maybePercentNumber;
      }
      const maybeCurrencyNumber = this.coerceStringToMaybeCurrencyNumber(arg);
      if (maybeCurrencyNumber !== undefined) {
        return maybeCurrencyNumber;
      }
      return this.numberLiteralsHelper.numericStringToMaybeNumber(arg.trim());
    } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
      return arg;
    } else if (typeof arg === 'boolean') {
      return Number(arg);
    } else {
      return undefined;
    }
  }
  coerceStringToMaybePercentNumber(input) {
    const trimmedInput = input.trim();
    if (trimmedInput.endsWith('%')) {
      const numOfPercents = trimmedInput.slice(0, trimmedInput.length - 1).trim();
      const parsedNumOfPercents = this.numberLiteralsHelper.numericStringToMaybeNumber(numOfPercents);
      if (parsedNumOfPercents !== undefined) {
        return new _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.PercentNumber(parsedNumOfPercents / 100);
      }
    }
    return undefined;
  }
  coerceStringToMaybeCurrencyNumber(input) {
    const matchedCurrency = this.currencyMatcher(input.trim());
    if (matchedCurrency !== undefined) {
      const [currencySymbol, currencyValue] = matchedCurrency;
      const parsedCurrencyValue = this.numberLiteralsHelper.numericStringToMaybeNumber(currencyValue);
      if (parsedCurrencyValue !== undefined) {
        return new _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.CurrencyNumber(parsedCurrencyValue, currencySymbol);
      }
    }
    return undefined;
  }
  currencyMatcher(token) {
    for (const currency of this.config.currencySymbol) {
      if (token.startsWith(currency)) {
        return [currency, token.slice(currency.length).trim()];
      }
      if (token.endsWith(currency)) {
        return [currency, token.slice(0, token.length - currency.length).trim()];
      }
    }
    return undefined;
  }
  coerceComplexExactRanges(args) {
    const vals = [];
    for (const arg of args) {
      if (arg instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue) {
        vals.push(arg);
      } else if (arg !== _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
        const coerced = this.coerceScalarToComplex(arg);
        if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return coerced;
        } else {
          vals.push(coerced);
        }
      }
    }
    const expandedVals = [];
    for (const val of vals) {
      if (val instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue) {
        const arr = this.manyToExactComplex(val.valuesFromTopLeftCorner());
        if (arr instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return arr;
        } else {
          expandedVals.push(...arr);
        }
      } else {
        expandedVals.push(val);
      }
    }
    return expandedVals;
  }
  coerceScalarToComplex(arg) {
    if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return arg;
    } else if (arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
      return [0, 0];
    } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
      return [(0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg), 0];
    } else if (typeof arg === 'string') {
      return this.coerceStringToComplex(arg);
    } else {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ComplexNumberExpected);
    }
  }
  ExtendedNumberFactory(value, typeFormat) {
    const {
      type,
      format
    } = typeFormat;
    switch (type) {
      case _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW:
        return value;
      case _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_CURRENCY:
        {
          return new _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.CurrencyNumber(value, format !== null && format !== void 0 ? format : this.config.currencySymbol[0]);
        }
      case _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATE:
        return new _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.DateNumber(value, format);
      case _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME:
        return new _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.DateTimeNumber(value, format);
      case _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_TIME:
        return new _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.TimeNumber(value, format);
      case _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_PERCENT:
        return new _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.PercentNumber(value, format);
    }
  }
  buildRegex(pattern, matchWholeCell = true) {
    pattern = this.normalizeString(pattern);
    let regexpStr;
    let useWildcards = this.config.useWildcards;
    let useRegularExpressions = this.config.useRegularExpressions;
    if (useRegularExpressions) {
      try {
        RegExp(pattern);
      } catch (e) {
        useRegularExpressions = false;
        useWildcards = false;
      }
    }
    if (useRegularExpressions) {
      regexpStr = escapeNoCharacters(pattern, this.config.caseSensitive);
    } else if (useWildcards) {
      regexpStr = escapeNonWildcards(pattern, this.config.caseSensitive);
    } else {
      regexpStr = escapeAllCharacters(pattern, this.config.caseSensitive);
    }
    if (this.config.matchWholeCell && matchWholeCell) {
      return RegExp('^(' + regexpStr + ')$');
    } else {
      return RegExp(regexpStr);
    }
  }
  normalizeString(str) {
    if (!this.config.caseSensitive) {
      str = str.toLowerCase();
    }
    if (!this.config.accentSensitive) {
      str = normalizeString(str, 'nfd').replace(/[\u0300-\u036f]/g, '');
    }
    return str;
  }
  compare(left, right) {
    if (typeof left === 'string' || typeof right === 'string') {
      const leftTmp = typeof left === 'string' ? this.dateTimeHelper.dateStringToDateNumber(left) : left;
      const rightTmp = typeof right === 'string' ? this.dateTimeHelper.dateStringToDateNumber(right) : right;
      if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(leftTmp) && (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(rightTmp)) {
        return this.floatCmp(leftTmp, rightTmp);
      }
    }
    if (left === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
      left = coerceEmptyToValue(right);
    } else if (right === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
      right = coerceEmptyToValue(left);
    }
    if (typeof left === 'string' && typeof right === 'string') {
      return this.stringCmp(left, right);
    } else if (typeof left === 'boolean' && typeof right === 'boolean') {
      return numberCmp(coerceBooleanToNumber(left), coerceBooleanToNumber(right));
    } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(left) && (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(right)) {
      return this.floatCmp(left, right);
    } else if (left === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue && right === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
      return 0;
    } else {
      return numberCmp((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.CellValueTypeOrd)((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.getCellValueType)(left)), (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.CellValueTypeOrd)((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.getCellValueType)(right)));
    }
  }
  stringCmp(left, right) {
    return this.collator.compare(left, right);
  }
  manyToNumbers(args, rangeFn) {
    const vals = [];
    for (const arg of args) {
      if (arg instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue) {
        vals.push(arg);
      } else {
        const coerced = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(this.coerceScalarToNumberOrError(arg));
        if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return coerced;
        } else {
          vals.push(coerced);
        }
      }
    }
    const expandedVals = [];
    for (const val of vals) {
      if (val instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue) {
        const arr = rangeFn(val.valuesFromTopLeftCorner());
        if (arr instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return arr;
        } else {
          expandedVals.push(...arr);
        }
      } else {
        expandedVals.push(val);
      }
    }
    return expandedVals;
  }
  coerceStringToComplex(arg) {
    const match = complexParsingRegexp.exec(arg);
    if (match === null) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ComplexNumberExpected);
    }
    let val1;
    if (match[6] !== undefined) {
      val1 = match[1] === '-' ? [0, -1] : [0, 1];
    } else {
      val1 = this.parseComplexToken(match[1] + match[3], match[5]);
    }
    if (val1 instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return val1;
    }
    if (match[8] === undefined) {
      return val1;
    }
    let val2;
    if (match[14] !== undefined) {
      val2 = match[9] === '-' ? [0, -1] : [0, 1];
    } else {
      val2 = this.parseComplexToken(match[9] + match[11], match[13]);
    }
    if (val2 instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return val2;
    }
    if (match[5] !== '' || match[13] === '') {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ComplexNumberExpected);
    }
    if (match[8] === '+') {
      return [val1[0] + val2[0], val1[1] + val2[1]];
    } else {
      return [val1[0] - val2[0], val1[1] - val2[1]];
    }
  }
  parseComplexToken(arg, mod) {
    const val = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(this.coerceNonDateScalarToMaybeNumber(arg));
    if (val === undefined) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ComplexNumberExpected);
    }
    if (mod === '') {
      return [val, 0];
    } else {
      return [0, val];
    }
  }
}
function coerceComplexToString([re, im], symb) {
  if (!isFinite(re) || !isFinite(im)) {
    return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NaN);
  }
  symb = symb !== null && symb !== void 0 ? symb : COMPLEX_NUMBER_SYMBOL;
  if (im === 0) {
    return `${re}`;
  }
  const imStr = `${im === -1 || im === 1 ? '' : Math.abs(im)}${symb}`;
  if (re === 0) {
    return `${im < 0 ? '-' : ''}${imStr}`;
  }
  return `${re}${im < 0 ? '-' : '+'}${imStr}`;
}
function coerceToRange(arg) {
  if (arg instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue) {
    return arg;
  } else {
    return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue.fromScalar(arg);
  }
}
function coerceToRangeNumbersOrError(arg) {
  if (arg instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue && arg.hasOnlyNumbers() || arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
    return arg;
  } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
    return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue.fromScalar(arg);
  } else {
    return null;
  }
}
function coerceBooleanToNumber(arg) {
  return Number(arg);
}
function coerceEmptyToValue(arg) {
  if (typeof arg === 'string') {
    return '';
  } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
    return 0;
  } else if (typeof arg === 'boolean') {
    return false;
  } else {
    return _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue;
  }
}
/**
 * Coerce scalar value to boolean if possible, or error if value is an error
 *
 * @param arg
 */
function coerceScalarToBoolean(arg) {
  if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError || typeof arg === 'boolean') {
    return arg;
  } else if (arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
    return false;
  } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
    return (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg) !== 0;
  } else {
    const argUppered = arg.toUpperCase();
    if (argUppered === 'TRUE') {
      return true;
    } else if (argUppered === 'FALSE') {
      return false;
    } else if (argUppered === '') {
      return false;
    } else {
      return undefined;
    }
  }
}
function coerceScalarToString(arg) {
  if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError || typeof arg === 'string') {
    return arg;
  } else if (arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
    return '';
  } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
    return (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg).toString();
  } else {
    return arg ? 'TRUE' : 'FALSE';
  }
}
function zeroIfEmpty(arg) {
  return arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue ? 0 : arg;
}
function numberCmp(leftArg, rightArg) {
  const left = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(leftArg);
  const right = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(rightArg);
  if (left > right) {
    return 1;
  } else if (left < right) {
    return -1;
  } else {
    return 0;
  }
}
function isNumberOverflow(arg) {
  return isNaN(arg) || arg === Infinity || arg === -Infinity;
}
function fixNegativeZero(arg) {
  if (arg === 0) {
    return 0;
  } else {
    return arg;
  }
}
function isWildcard(c) {
  return ['*', '?'].includes(c);
}
const escapedCharacters = ['{', '}', '[', ']', '(', ')', '<', '>', '=', '.', '+', '-', ',', '\\', '$', '^', '!'];
function needsEscape(c) {
  return escapedCharacters.includes(c);
}
function escapeNonWildcards(pattern, caseSensitive) {
  let str = '';
  for (let i = 0; i < pattern.length; i++) {
    const c = pattern.charAt(i);
    if (c === '~') {
      if (i == pattern.length - 1) {
        str += '~';
        continue;
      }
      const d = pattern.charAt(i + 1);
      if (isWildcard(d) || needsEscape(d)) {
        str += '\\' + d;
        i++;
      } else {
        str += d;
        i++;
      }
    } else if (isWildcard(c)) {
      str += '.' + c;
    } else if (needsEscape(c)) {
      str += '\\' + c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }
  return str;
}
function escapeAllCharacters(pattern, caseSensitive) {
  let str = '';
  for (let i = 0; i < pattern.length; i++) {
    const c = pattern.charAt(i);
    if (isWildcard(c) || needsEscape(c)) {
      str += '\\' + c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }
  return str;
}
function escapeNoCharacters(pattern, caseSensitive) {
  let str = '';
  for (let i = 0; i < pattern.length; i++) {
    const c = pattern.charAt(i);
    if (isWildcard(c) || needsEscape(c)) {
      str += c;
    } else if (caseSensitive) {
      str += c;
    } else {
      str += c.toLowerCase();
    }
  }
  return str;
}
function inferExtendedNumberTypeAdditive(leftArg, rightArg) {
  const {
    type: leftType,
    format: leftFormat
  } = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getTypeFormatOfExtendedNumber)(leftArg);
  const {
    type: rightType,
    format: rightFormat
  } = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getTypeFormatOfExtendedNumber)(rightArg);
  if (leftType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW) {
    return {
      type: rightType,
      format: rightFormat
    };
  }
  if (rightType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW) {
    return {
      type: leftType,
      format: leftFormat
    };
  }
  if ((leftType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME || leftType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATE) && (rightType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME || rightType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATE)) {
    return {
      type: _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW
    };
  }
  if (leftType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_TIME) {
    if (rightType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATE) {
      return {
        type: _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME,
        format: `${rightFormat} ${leftFormat}`
      };
    }
    if (rightType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME) {
      return {
        type: _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME,
        format: rightFormat
      };
    }
  }
  if (rightType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_TIME) {
    if (leftType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATE) {
      return {
        type: _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME,
        format: `${leftFormat} ${rightFormat}`
      };
    }
    if (leftType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME) {
      return {
        type: _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_DATETIME,
        format: leftFormat
      };
    }
  }
  return {
    type: leftType,
    format: leftFormat
  };
}
function inferExtendedNumberTypeMultiplicative(leftArg, rightArg) {
  let {
    type: leftType,
    format: leftFormat
  } = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getTypeFormatOfExtendedNumber)(leftArg);
  let {
    type: rightType,
    format: rightFormat
  } = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getTypeFormatOfExtendedNumber)(rightArg);
  if (leftType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_PERCENT) {
    leftType = _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW;
    leftFormat = undefined;
  }
  if (rightType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_PERCENT) {
    rightType = _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW;
    rightFormat = undefined;
  }
  if (leftType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW) {
    return {
      type: rightType,
      format: rightFormat
    };
  }
  if (rightType === _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW) {
    return {
      type: leftType,
      format: leftFormat
    };
  }
  return {
    type: _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.NumberType.NUMBER_RAW
  };
}
function forceNormalizeString(str) {
  return normalizeString(str.toLowerCase(), 'nfd').replace(/[\u0300-\u036f]/g, '');
}
function coerceRangeToScalar(arg, state) {
  var _a;
  if (arg.isAdHoc()) {
    return (_a = arg.data[0]) === null || _a === void 0 ? void 0 : _a[0];
  }
  const range = arg.range;
  if (state.formulaAddress.sheet === range.sheet) {
    if (range.width() === 1) {
      const offset = state.formulaAddress.row - range.start.row;
      if (offset >= 0 && offset < range.height()) {
        return arg.data[offset][0];
      }
    } else if (range.height() === 1) {
      const offset = state.formulaAddress.col - range.start.col;
      if (offset >= 0 && offset < range.width()) {
        return arg.data[0][offset];
      }
    }
  }
  return undefined;
}
function normalizeString(str, form) {
  return str.normalize(form.toUpperCase());
}

/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   collatorFromConfig: () => (/* binding */ collatorFromConfig)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
function collatorFromConfig(config) {
  const sensitivity = config.caseSensitive ? config.accentSensitive ? 'variant' : 'case' : config.accentSensitive ? 'accent' : 'base';
  const caseFirst = config.caseFirst;
  const ignorePunctuation = config.ignorePunctuation;
  return new Intl.Collator(config.localeLang, {
    sensitivity,
    caseFirst,
    ignorePunctuation
  });
}

/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DetailedCellError: () => (/* binding */ DetailedCellError)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class DetailedCellError {
  constructor(error, value, address) {
    var _a;
    this.value = value;
    this.address = address;
    this.type = error.type;
    this.message = (_a = error.message) !== null && _a !== void 0 ? _a : '';
  }
  toString() {
    return this.value;
  }
  valueOf() {
    return this.value;
  }
}

/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Config: () => (/* binding */ Config),
/* harmony export */   getDefaultConfig: () => (/* binding */ getDefaultConfig)
/* harmony export */ });
/* harmony import */ var _ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(102);
/* harmony import */ var _DateTimeDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(103);
/* harmony import */ var _DateTimeHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(104);
/* harmony import */ var _DependencyGraph_AddressMapping_ChooseAddressMappingPolicy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(105);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(77);
/* harmony import */ var _format_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(106);
/* harmony import */ var _helpers_licenseKeyValidator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(108);
/* harmony import */ var _HyperFormula__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(110);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */








const privatePool = new WeakMap();
class Config {
  constructor(options = {}, showDeprecatedWarns = true) {
    const {
      accentSensitive,
      binarySearchThreshold,
      caseSensitive,
      caseFirst,
      chooseAddressMappingPolicy,
      context,
      currencySymbol,
      dateFormats,
      decimalSeparator,
      evaluateNullToZero,
      functionArgSeparator,
      functionPlugins,
      ignorePunctuation,
      leapYear1900,
      localeLang,
      language,
      ignoreWhiteSpace,
      licenseKey,
      matchWholeCell,
      arrayColumnSeparator,
      arrayRowSeparator,
      maxRows,
      maxColumns,
      nullYear,
      nullDate,
      parseDateTime,
      precisionEpsilon,
      precisionRounding,
      stringifyDateTime,
      stringifyDuration,
      smartRounding,
      timeFormats,
      thousandSeparator,
      useArrayArithmetic,
      useStats,
      undoLimit,
      useColumnIndex,
      useRegularExpressions,
      useWildcards
    } = options;
    if (showDeprecatedWarns) {
      Config.warnDeprecatedOptions(options);
    }
    this.useArrayArithmetic = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(useArrayArithmetic, 'boolean', 'useArrayArithmetic');
    this.accentSensitive = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(accentSensitive, 'boolean', 'accentSensitive');
    this.caseSensitive = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(caseSensitive, 'boolean', 'caseSensitive');
    this.caseFirst = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(caseFirst, ['upper', 'lower', 'false'], 'caseFirst');
    this.ignorePunctuation = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(ignorePunctuation, 'boolean', 'ignorePunctuation');
    this.chooseAddressMappingPolicy = chooseAddressMappingPolicy !== null && chooseAddressMappingPolicy !== void 0 ? chooseAddressMappingPolicy : Config.defaultConfig.chooseAddressMappingPolicy;
    this.dateFormats = [...(0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParamCheck)(dateFormats, Array.isArray, 'array', 'dateFormats')];
    this.timeFormats = [...(0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParamCheck)(timeFormats, Array.isArray, 'array', 'timeFormats')];
    this.functionArgSeparator = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(functionArgSeparator, 'string', 'functionArgSeparator');
    this.decimalSeparator = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(decimalSeparator, ['.', ','], 'decimalSeparator');
    this.language = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(language, 'string', 'language');
    this.ignoreWhiteSpace = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(ignoreWhiteSpace, ['standard', 'any'], 'ignoreWhiteSpace');
    this.licenseKey = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(licenseKey, 'string', 'licenseKey');
    this.thousandSeparator = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(thousandSeparator, ['', ',', ' ', '.'], 'thousandSeparator');
    this.arrayColumnSeparator = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(arrayColumnSeparator, [',', ';'], 'arrayColumnSeparator');
    this.arrayRowSeparator = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(arrayRowSeparator, [';', '|'], 'arrayRowSeparator');
    this.localeLang = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(localeLang, 'string', 'localeLang');
    this.functionPlugins = [...(functionPlugins !== null && functionPlugins !== void 0 ? functionPlugins : Config.defaultConfig.functionPlugins)];
    this.smartRounding = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(smartRounding, 'boolean', 'smartRounding');
    this.evaluateNullToZero = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(evaluateNullToZero, 'boolean', 'evaluateNullToZero');
    this.nullYear = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(nullYear, 'number', 'nullYear');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.validateNumberToBeAtLeast)(this.nullYear, 'nullYear', 0);
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.validateNumberToBeAtMost)(this.nullYear, 'nullYear', 100);
    this.precisionRounding = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(precisionRounding, 'number', 'precisionRounding');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.validateNumberToBeAtLeast)(this.precisionRounding, 'precisionRounding', 0);
    this.precisionEpsilon = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(precisionEpsilon, 'number', 'precisionEpsilon');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.validateNumberToBeAtLeast)(this.precisionEpsilon, 'precisionEpsilon', 0);
    this.useColumnIndex = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(useColumnIndex, 'boolean', 'useColumnIndex');
    this.useStats = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(useStats, 'boolean', 'useStats');
    this.binarySearchThreshold = binarySearchThreshold !== null && binarySearchThreshold !== void 0 ? binarySearchThreshold : Config.defaultConfig.binarySearchThreshold;
    this.parseDateTime = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(parseDateTime, 'function', 'parseDateTime');
    this.stringifyDateTime = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(stringifyDateTime, 'function', 'stringifyDateTime');
    this.stringifyDuration = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(stringifyDuration, 'function', 'stringifyDuration');
    this.translationPackage = _HyperFormula__WEBPACK_IMPORTED_MODULE_7__.HyperFormula.getLanguage(this.language);
    this.errorMapping = this.translationPackage.buildErrorMapping();
    this.nullDate = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParamCheck)(nullDate, _DateTimeHelper__WEBPACK_IMPORTED_MODULE_2__.instanceOfSimpleDate, 'IDate', 'nullDate');
    this.leapYear1900 = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(leapYear1900, 'boolean', 'leapYear1900');
    this.undoLimit = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(undoLimit, 'number', 'undoLimit');
    this.useRegularExpressions = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(useRegularExpressions, 'boolean', 'useRegularExpressions');
    this.useWildcards = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(useWildcards, 'boolean', 'useWildcards');
    this.matchWholeCell = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(matchWholeCell, 'boolean', 'matchWholeCell');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.validateNumberToBeAtLeast)(this.undoLimit, 'undoLimit', 0);
    this.maxRows = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(maxRows, 'number', 'maxRows');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.validateNumberToBeAtLeast)(this.maxRows, 'maxRows', 1);
    this.maxColumns = (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParam)(maxColumns, 'number', 'maxColumns');
    this.currencySymbol = this.setupCurrencySymbol(currencySymbol);
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.validateNumberToBeAtLeast)(this.maxColumns, 'maxColumns', 1);
    this.context = context;
    privatePool.set(this, {
      licenseKeyValidityState: (0,_helpers_licenseKeyValidator__WEBPACK_IMPORTED_MODULE_6__.checkLicenseKeyValidity)(this.licenseKey)
    });
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configCheckIfParametersNotInConflict)({
      value: this.decimalSeparator,
      name: 'decimalSeparator'
    }, {
      value: this.functionArgSeparator,
      name: 'functionArgSeparator'
    }, {
      value: this.thousandSeparator,
      name: 'thousandSeparator'
    });
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configCheckIfParametersNotInConflict)({
      value: this.arrayRowSeparator,
      name: 'arrayRowSeparator'
    }, {
      value: this.arrayColumnSeparator,
      name: 'arrayColumnSeparator'
    });
  }
  setupCurrencySymbol(currencySymbol) {
    const valueAfterCheck = [...(0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_0__.configValueFromParamCheck)(currencySymbol, Array.isArray, 'array', 'currencySymbol')];
    valueAfterCheck.forEach(val => {
      if (typeof val !== 'string') {
        throw new _errors__WEBPACK_IMPORTED_MODULE_4__.ExpectedValueOfTypeError('string[]', 'currencySymbol');
      }
      if (val === '') {
        throw new _errors__WEBPACK_IMPORTED_MODULE_4__.ConfigValueEmpty('currencySymbol');
      }
    });
    return valueAfterCheck;
  }
  /**
   * Proxied property to its private counterpart. This makes the property
   * as accessible as the other Config options but without ability to change the value.
   *
   * @internal
   */
  get licenseKeyValidityState() {
    return privatePool.get(this).licenseKeyValidityState;
  }
  getConfig() {
    return getFullConfigFromPartial(this);
  }
  mergeConfig(init) {
    const mergedConfig = Object.assign({}, this.getConfig(), init);
    Config.warnDeprecatedOptions(init);
    return new Config(mergedConfig, false);
  }
  static warnDeprecatedOptions(options) {
    Config.warnDeprecatedIfUsed(options.binarySearchThreshold, 'binarySearchThreshold', '1.1');
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static warnDeprecatedIfUsed(inputValue, paramName, fromVersion, replacementName) {
    if (inputValue !== undefined) {
      if (replacementName === undefined) {
        console.warn(`${paramName} option is deprecated since ${fromVersion}`);
      } else {
        console.warn(`${paramName} option is deprecated since ${fromVersion}, please use ${replacementName}`);
      }
    }
  }
}
Config.defaultConfig = {
  accentSensitive: false,
  binarySearchThreshold: 20,
  currencySymbol: ['$'],
  caseSensitive: false,
  caseFirst: 'lower',
  context: undefined,
  chooseAddressMappingPolicy: new _DependencyGraph_AddressMapping_ChooseAddressMappingPolicy__WEBPACK_IMPORTED_MODULE_3__.AlwaysDense(),
  dateFormats: ['DD/MM/YYYY', 'DD/MM/YY'],
  decimalSeparator: '.',
  evaluateNullToZero: false,
  functionArgSeparator: ',',
  functionPlugins: [],
  ignorePunctuation: false,
  language: 'enGB',
  ignoreWhiteSpace: 'standard',
  licenseKey: '',
  leapYear1900: false,
  localeLang: 'en',
  matchWholeCell: true,
  arrayColumnSeparator: ',',
  arrayRowSeparator: ';',
  maxRows: 40000,
  maxColumns: 18278,
  nullYear: 30,
  nullDate: {
    year: 1899,
    month: 12,
    day: 30
  },
  parseDateTime: _DateTimeDefault__WEBPACK_IMPORTED_MODULE_1__.defaultParseToDateTime,
  precisionEpsilon: 1e-13,
  precisionRounding: 14,
  smartRounding: true,
  stringifyDateTime: _format_format__WEBPACK_IMPORTED_MODULE_5__.defaultStringifyDateTime,
  stringifyDuration: _format_format__WEBPACK_IMPORTED_MODULE_5__.defaultStringifyDuration,
  timeFormats: ['hh:mm', 'hh:mm:ss.sss'],
  thousandSeparator: '',
  undoLimit: 20,
  useRegularExpressions: false,
  useWildcards: true,
  useColumnIndex: false,
  useStats: false,
  useArrayArithmetic: false
};
function getFullConfigFromPartial(partialConfig) {
  var _a;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const ret = {};
  for (const key in Config.defaultConfig) {
    const val = (_a = partialConfig[key]) !== null && _a !== void 0 ? _a : Config.defaultConfig[key];
    if (Array.isArray(val)) {
      ret[key] = [...val];
    } else {
      ret[key] = val;
    }
  }
  return ret;
}
function getDefaultConfig() {
  return getFullConfigFromPartial({});
}

/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   configCheckIfParametersNotInConflict: () => (/* binding */ configCheckIfParametersNotInConflict),
/* harmony export */   configValueFromParam: () => (/* binding */ configValueFromParam),
/* harmony export */   configValueFromParamCheck: () => (/* binding */ configValueFromParamCheck),
/* harmony export */   validateArgToType: () => (/* binding */ validateArgToType),
/* harmony export */   validateNumberToBeAtLeast: () => (/* binding */ validateNumberToBeAtLeast),
/* harmony export */   validateNumberToBeAtMost: () => (/* binding */ validateNumberToBeAtMost)
/* harmony export */ });
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(77);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


// eslint-disable-next-line @typescript-eslint/no-explicit-any
function configValueFromParam(inputValue, expectedType, paramName) {
  if (typeof inputValue === 'undefined') {
    return _Config__WEBPACK_IMPORTED_MODULE_0__.Config.defaultConfig[paramName];
  } else if (typeof expectedType === 'string') {
    if (typeof inputValue === expectedType) {
      return inputValue;
    } else {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ExpectedValueOfTypeError(expectedType, paramName);
    }
  } else {
    if (expectedType.includes(inputValue)) {
      return inputValue;
    } else {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ExpectedOneOfValuesError(expectedType.map(val => `'${val}'`).join(' '), paramName);
    }
  }
}
function validateNumberToBeAtLeast(value, paramName, minimum) {
  if (value < minimum) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ConfigValueTooSmallError(paramName, minimum);
  }
}
function validateNumberToBeAtMost(value, paramName, maximum) {
  if (value > maximum) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ConfigValueTooBigError(paramName, maximum);
  }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function configValueFromParamCheck(inputValue, typeCheck, expectedType, paramName) {
  if (typeCheck(inputValue)) {
    return inputValue;
  } else if (typeof inputValue === 'undefined') {
    return _Config__WEBPACK_IMPORTED_MODULE_0__.Config.defaultConfig[paramName];
  } else {
    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ExpectedValueOfTypeError(expectedType, paramName);
  }
}
function configCheckIfParametersNotInConflict(...params) {
  const valuesMap = new Map();
  params.forEach(param => {
    const names = valuesMap.get(param.value) || [];
    names.push(param.name);
    valuesMap.set(param.value, names);
  });
  const duplicates = [];
  for (const entry of valuesMap.values()) {
    if (entry.length > 1) {
      duplicates.push(entry);
    }
  }
  if (duplicates.length > 0) {
    duplicates.forEach(entry => entry.sort());
    const paramNames = duplicates.map(entry => `[${entry}]`).join('; ');
    throw new Error(`Config initialization failed. Parameters in conflict: ${paramNames}`);
  }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function validateArgToType(inputValue, expectedType, paramName) {
  if (typeof inputValue !== expectedType) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.ExpectedValueOfTypeError(expectedType, paramName);
  }
}

/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TIME_FORMAT_SECONDS_ITEM_REGEXP: () => (/* binding */ TIME_FORMAT_SECONDS_ITEM_REGEXP),
/* harmony export */   defaultParseToDateTime: () => (/* binding */ defaultParseToDateTime)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
const TIME_FORMAT_SECONDS_ITEM_REGEXP = new RegExp('^ss(\\.(s+|0+))?$');
const QUICK_CHECK_REGEXP = new RegExp('^[0-9/.\\-: ]+[ap]?m?$');
const WHITESPACE_REGEXP = new RegExp('\\s+');
const DATE_SEPARATOR_REGEXP = new RegExp('[ /.-]');
const TIME_SEPARATOR = ':';
const SECONDS_PRECISION = 1000;
const memoizedParseTimeFormat = memoize(parseTimeFormat);
const memoizedParseDateFormat = memoize(parseDateFormat);
/**
 * Parses a DateTime value from a string if the string matches the given date format and time format.
 *
 * Idea for more readable implementation:
 *   - divide string into parts by a regexp [date_regexp]? [time_regexp]? [ampm_regexp]?
 *   - start by finding the time part, because it is unambiguous '([0-9]+:[0-9:.]+ ?[ap]?m?)$', before it is the date part
 *   - OR split by spaces - last segment is ampm token, second to last is time (with or without ampm), rest is date
 * If applied:
 *   - date parsing might work differently after these changes but still according to the docs
 *   - make sure to test edge cases like timeFormats: ['hh', 'ss.ss'] etc, string: '01-01-2019 AM', 'PM'
 */
function defaultParseToDateTime(text, dateFormat, timeFormat) {
  if (dateFormat === undefined && timeFormat === undefined) {
    return undefined;
  }
  let dateTimeString = text.replace(WHITESPACE_REGEXP, ' ').trim().toLowerCase();
  if (!doesItLookLikeADateTimeQuickCheck(dateTimeString)) {
    return undefined;
  }
  let ampmToken = dateTimeString.substring(dateTimeString.length - 2);
  if (ampmToken === 'am' || ampmToken === 'pm') {
    dateTimeString = dateTimeString.substring(0, dateTimeString.length - 2).trim();
  } else {
    ampmToken = dateTimeString.substring(dateTimeString.length - 1);
    if (ampmToken === 'a' || ampmToken === 'p') {
      dateTimeString = dateTimeString.substring(0, dateTimeString.length - 1).trim();
    } else {
      ampmToken = undefined;
    }
  }
  const dateItems = dateTimeString.split(DATE_SEPARATOR_REGEXP);
  if (dateItems.length >= 2 && dateItems[dateItems.length - 2].includes(TIME_SEPARATOR)) {
    dateItems[dateItems.length - 2] = dateItems[dateItems.length - 2] + '.' + dateItems[dateItems.length - 1];
    dateItems.pop();
  }
  const timeItems = dateItems[dateItems.length - 1].split(TIME_SEPARATOR);
  if (ampmToken !== undefined) {
    timeItems.push(ampmToken);
  }
  if (dateItems.length === 1) {
    return defaultParseToTime(timeItems, timeFormat);
  }
  if (timeItems.length === 1) {
    return defaultParseToDate(dateItems, dateFormat);
  }
  const parsedDate = defaultParseToDate(dateItems.slice(0, dateItems.length - 1), dateFormat);
  const parsedTime = defaultParseToTime(timeItems, timeFormat);
  if (parsedDate === undefined) {
    return undefined;
  } else if (parsedTime === undefined) {
    return undefined;
  } else {
    return Object.assign(Object.assign({}, parsedDate), parsedTime);
  }
}
/**
 * Parses a time value from a string if the string matches the given time format.
 */
function defaultParseToTime(timeItems, timeFormat) {
  var _a, _b, _c;
  if (timeFormat === undefined) {
    return undefined;
  }
  const {
    itemsCount,
    hourItem,
    minuteItem,
    secondItem
  } = memoizedParseTimeFormat(timeFormat);
  let ampm = undefined;
  if (timeItems[timeItems.length - 1] === 'am' || timeItems[timeItems.length - 1] === 'a') {
    ampm = false;
    timeItems.pop();
  } else if (timeItems[timeItems.length - 1] === 'pm' || timeItems[timeItems.length - 1] === 'p') {
    ampm = true;
    timeItems.pop();
  }
  if (timeItems.length !== itemsCount) {
    return undefined;
  }
  const secondsParsed = Number((_a = timeItems[secondItem]) !== null && _a !== void 0 ? _a : '0');
  if (!Number.isFinite(secondsParsed)) {
    return undefined;
  }
  const seconds = Math.round(secondsParsed * SECONDS_PRECISION) / SECONDS_PRECISION;
  const minutes = Number((_b = timeItems[minuteItem]) !== null && _b !== void 0 ? _b : '0');
  if (!(Number.isFinite(minutes) && Number.isInteger(minutes))) {
    return undefined;
  }
  const hoursParsed = Number((_c = timeItems[hourItem]) !== null && _c !== void 0 ? _c : '0');
  if (!(Number.isFinite(hoursParsed) && Number.isInteger(hoursParsed))) {
    return undefined;
  }
  if (ampm !== undefined && (hoursParsed < 0 || hoursParsed > 12)) {
    return undefined;
  }
  const hours = ampm !== undefined ? hoursParsed % 12 + (ampm ? 12 : 0) : hoursParsed;
  return {
    hours,
    minutes,
    seconds
  };
}
/**
 * Parses a date value from a string if the string matches the given date format.
 */
function defaultParseToDate(dateItems, dateFormat) {
  var _a;
  if (dateFormat === undefined) {
    return undefined;
  }
  const {
    itemsCount,
    dayItem,
    monthItem,
    shortYearItem,
    longYearItem
  } = memoizedParseDateFormat(dateFormat);
  if (dateItems.length !== itemsCount) {
    return undefined;
  }
  const day = Number(dateItems[dayItem]);
  if (!(Number.isFinite(day) && Number.isInteger(day))) {
    return undefined;
  }
  const month = Number(dateItems[monthItem]);
  if (!(Number.isFinite(month) && Number.isInteger(month))) {
    return undefined;
  }
  if (dateItems[longYearItem] && dateItems[shortYearItem]) {
    return undefined;
  }
  const year = Number((_a = dateItems[longYearItem]) !== null && _a !== void 0 ? _a : dateItems[shortYearItem]);
  if (!(Number.isFinite(year) && Number.isInteger(year))) {
    return undefined;
  }
  if (dateItems[longYearItem] && (year < 1000 || year > 9999)) {
    return undefined;
  }
  if (dateItems[shortYearItem] && (year < 0 || year > 99)) {
    return undefined;
  }
  return {
    year,
    month,
    day
  };
}
/**
 * Parses a time format string into a format object.
 */
function parseTimeFormat(timeFormat) {
  const formatLowercase = timeFormat.toLowerCase().trim();
  const formatWithoutAmPmItem = formatLowercase.endsWith('am/pm') ? formatLowercase.substring(0, formatLowercase.length - 5) : formatLowercase.endsWith('a/p') ? formatLowercase.substring(0, timeFormat.length - 3) : formatLowercase;
  const items = formatWithoutAmPmItem.trim().split(TIME_SEPARATOR);
  return {
    itemsCount: items.length,
    hourItem: items.indexOf('hh'),
    minuteItem: items.indexOf('mm'),
    secondItem: items.findIndex(item => TIME_FORMAT_SECONDS_ITEM_REGEXP.test(item))
  };
}
/**
 * Parses a date format string into a format object.
 */
function parseDateFormat(dateFormat) {
  const items = dateFormat.toLowerCase().trim().split(DATE_SEPARATOR_REGEXP);
  return {
    itemsCount: items.length,
    dayItem: items.indexOf('dd'),
    monthItem: items.indexOf('mm'),
    shortYearItem: items.indexOf('yy'),
    longYearItem: items.indexOf('yyyy')
  };
}
/**
 * If this function returns false, the string is not parsable as a date time. Otherwise, it might be.
 * This is a quick check that is used to avoid running the more expensive parsing operations.
 */
function doesItLookLikeADateTimeQuickCheck(text) {
  return QUICK_CHECK_REGEXP.test(text);
}
/**
 * Function memoization for improved performance.
 */
function memoize(fn) {
  const memoizedResults = {};
  return arg => {
    const memoizedResult = memoizedResults[arg];
    if (memoizedResult !== undefined) {
      return memoizedResult;
    }
    const result = fn(arg);
    memoizedResults[arg] = result;
    return result;
  };
}

/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateTimeHelper: () => (/* binding */ DateTimeHelper),
/* harmony export */   instanceOfSimpleDate: () => (/* binding */ instanceOfSimpleDate),
/* harmony export */   instanceOfSimpleTime: () => (/* binding */ instanceOfSimpleTime),
/* harmony export */   maxDate: () => (/* binding */ maxDate),
/* harmony export */   numberToSimpleTime: () => (/* binding */ numberToSimpleTime),
/* harmony export */   offsetMonth: () => (/* binding */ offsetMonth),
/* harmony export */   roundToNearestSecond: () => (/* binding */ roundToNearestSecond),
/* harmony export */   timeToNumber: () => (/* binding */ timeToNumber),
/* harmony export */   toBasisEU: () => (/* binding */ toBasisEU),
/* harmony export */   truncateDayInMonth: () => (/* binding */ truncateDayInMonth)
/* harmony export */ });
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const numDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const prefSumDays = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
const SECONDS_PER_MINUTE = 60;
const MINUTES_PER_HOUR = 60;
const HOURS_PER_DAY = 24;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function instanceOfSimpleDate(obj) {
  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {
    return 'year' in obj && typeof obj.year === 'number' && 'month' in obj && typeof obj.month === 'number' && 'day' in obj && typeof obj.day === 'number';
  } else {
    return false;
  }
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function instanceOfSimpleTime(obj) {
  if (obj && (typeof obj === 'object' || typeof obj === 'function')) {
    return 'hours' in obj && typeof obj.hours === 'number' && 'minutes' in obj && typeof obj.minutes === 'number' && 'seconds' in obj && typeof obj.seconds === 'number';
  } else {
    return false;
  }
}
const maxDate = {
  year: 9999,
  month: 12,
  day: 31
};
class DateTimeHelper {
  constructor(config) {
    this.config = config;
    this.minDateAbsoluteValue = this.dateToNumberFromZero(config.nullDate);
    this.maxDateValue = this.dateToNumber(maxDate);
    this.leapYear1900 = config.leapYear1900;
    // code below fixes epochYearStart while being leapYear1900 sensitive
    // if nullDate is earlier than fateful 28 Feb 1900 and 1900 is not supposed to be leap year, then we should
    // add two days (this is the config default)
    // otherwise only one day
    if (!this.leapYear1900 && 0 <= this.dateToNumber({
      year: 1900,
      month: 2,
      day: 28
    })) {
      this.epochYearZero = this.numberToSimpleDate(2).year;
    } else {
      this.epochYearZero = this.numberToSimpleDate(1).year;
    }
    this.parseDateTime = config.parseDateTime;
  }
  getWithinBounds(dayNumber) {
    return dayNumber <= this.maxDateValue && dayNumber >= 0 ? dayNumber : undefined;
  }
  dateStringToDateNumber(dateTimeString) {
    const {
      dateTime,
      dateFormat = '',
      timeFormat = ''
    } = this.parseDateTimeFromConfigFormats(dateTimeString);
    if (dateTime === undefined) {
      return undefined;
    }
    if (instanceOfSimpleTime(dateTime)) {
      if (instanceOfSimpleDate(dateTime)) {
        return new _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.DateTimeNumber(timeToNumber(dateTime) + this.dateToNumber(dateTime), dateFormat + ' ' + timeFormat);
      } else {
        return new _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.TimeNumber(timeToNumber(dateTime), timeFormat);
      }
    } else {
      if (instanceOfSimpleDate(dateTime)) {
        return new _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.DateNumber(this.dateToNumber(dateTime), dateFormat);
      } else {
        return 0;
      }
    }
  }
  parseDateTimeFromConfigFormats(dateTimeString) {
    return this.parseDateTimeFromFormats(dateTimeString, this.config.dateFormats, this.config.timeFormats);
  }
  getNullYear() {
    return this.config.nullYear;
  }
  getEpochYearZero() {
    return this.epochYearZero;
  }
  isValidDate(date) {
    if (isNaN(date.year) || isNaN(date.month) || isNaN(date.day)) {
      return false;
    } else if (date.day !== Math.round(date.day) || date.month !== Math.round(date.month) || date.year !== Math.round(date.year)) {
      return false;
    } else if (date.year < 1582) {
      // Gregorian calendar start
      return false;
    } else if (date.month < 1 || date.month > 12) {
      return false;
    } else if (date.day < 1) {
      return false;
    } else if (this.isLeapYear(date.year) && date.month === 2) {
      return date.day <= 29;
    } else {
      return date.day <= numDays[date.month - 1];
    }
  }
  dateToNumber(date) {
    return this.dateToNumberFromZero(date) - this.minDateAbsoluteValue;
  }
  relativeNumberToAbsoluteNumber(arg) {
    return arg + this.minDateAbsoluteValue - (this.leapYear1900 ? 1 : 0);
  }
  numberToSimpleDate(arg) {
    const dateNumber = Math.floor(arg) + this.minDateAbsoluteValue;
    let year = Math.floor(dateNumber / 365.2425);
    if (this.dateToNumberFromZero({
      year: year + 1,
      month: 1,
      day: 1
    }) <= dateNumber) {
      year++;
    } else if (this.dateToNumberFromZero({
      year: year - 1,
      month: 1,
      day: 1
    }) > dateNumber) {
      year--;
    }
    const dayOfYear = dateNumber - this.dateToNumberFromZero({
      year,
      month: 1,
      day: 1
    });
    const month = dayToMonth(dayOfYear - (this.isLeapYear(year) && dayOfYear >= 59 ? 1 : 0));
    const day = dayOfYear - prefSumDays[month] - (this.isLeapYear(year) && month > 1 ? 1 : 0);
    return {
      year,
      month: month + 1,
      day: day + 1
    };
  }
  numberToSimpleDateTime(arg) {
    const time = numberToSimpleTime(arg % 1);
    const carryDays = Math.floor(time.hours / HOURS_PER_DAY);
    time.hours = time.hours % HOURS_PER_DAY;
    const date = this.numberToSimpleDate(Math.floor(arg) + carryDays);
    return Object.assign(Object.assign({}, date), time);
  }
  leapYearsCount(year) {
    return Math.floor(year / 4) - Math.floor(year / 100) + Math.floor(year / 400) + (this.config.leapYear1900 && year >= 1900 ? 1 : 0);
  }
  daysInMonth(year, month) {
    if (this.isLeapYear(year) && month === 2) {
      return 29;
    } else {
      return numDays[month - 1];
    }
  }
  endOfMonth(date) {
    return {
      year: date.year,
      month: date.month,
      day: this.daysInMonth(date.year, date.month)
    };
  }
  toBasisUS(start, end) {
    if (start.day === 31) {
      start.day = 30;
    }
    if (start.day === 30 && end.day === 31) {
      end.day = 30;
    }
    if (start.month === 2 && start.day === this.daysInMonth(start.year, start.month)) {
      start.day = 30;
      if (end.month === 2 && end.day === this.daysInMonth(end.year, end.month)) {
        end.day = 30;
      }
    }
    return [start, end];
  }
  yearLengthForBasis(start, end) {
    if (start.year !== end.year) {
      if (start.year + 1 !== end.year || start.month < end.month || start.month === end.month && start.day < end.day) {
        // this is true IFF at least one year of gap between dates
        return (this.leapYearsCount(end.year) - this.leapYearsCount(start.year - 1)) / (end.year - start.year + 1) + 365;
      }
      if (this.countLeapDays(end) !== this.countLeapDays({
        year: start.year,
        month: start.month,
        day: start.day - 1
      })) {
        return 366;
      } else {
        return 365;
      }
    }
    if (this.isLeapYear(start.year)) {
      return 366;
    } else {
      return 365;
    }
  }
  parseSingleFormat(dateString, dateFormat, timeFormat) {
    const dateTime = this.parseDateTime(dateString, dateFormat, timeFormat);
    if (instanceOfSimpleDate(dateTime)) {
      if (dateTime.year >= 0 && dateTime.year < 100) {
        if (dateTime.year < this.getNullYear()) {
          dateTime.year += 2000;
        } else {
          dateTime.year += 1900;
        }
      }
      if (!this.isValidDate(dateTime)) {
        return undefined;
      }
    }
    return dateTime;
  }
  parseDateTimeFromFormats(dateTimeString, dateFormats, timeFormats) {
    const dateFormatsArray = dateFormats.length === 0 ? [undefined] : dateFormats;
    const timeFormatsArray = timeFormats.length === 0 ? [undefined] : timeFormats;
    for (const dateFormat of dateFormatsArray) {
      for (const timeFormat of timeFormatsArray) {
        const dateTime = this.parseSingleFormat(dateTimeString, dateFormat, timeFormat);
        if (dateTime !== undefined) {
          return {
            dateTime,
            timeFormat,
            dateFormat
          };
        }
      }
    }
    return {};
  }
  countLeapDays(date) {
    if (date.month > 2 || date.month === 2 && date.day >= 29) {
      return this.leapYearsCount(date.year);
    } else {
      return this.leapYearsCount(date.year - 1);
    }
  }
  dateToNumberFromZero(date) {
    return 365 * date.year + prefSumDays[date.month - 1] + date.day - 1 + (date.month <= 2 ? this.leapYearsCount(date.year - 1) : this.leapYearsCount(date.year));
  }
  isLeapYear(year) {
    if (year % 4) {
      return false;
    } else if (year % 100) {
      return true;
    } else if (year % 400) {
      return year === 1900 && this.config.leapYear1900;
    } else {
      return true;
    }
  }
}
function dayToMonth(dayOfYear) {
  let month = 0;
  if (prefSumDays[month + 6] <= dayOfYear) {
    month += 6;
  }
  if (prefSumDays[month + 3] <= dayOfYear) {
    month += 3;
  }
  if (prefSumDays[month + 2] <= dayOfYear) {
    month += 2;
  } else if (prefSumDays[month + 1] <= dayOfYear) {
    month += 1;
  }
  return month;
}
function offsetMonth(date, offset) {
  const totalM = 12 * date.year + date.month - 1 + offset;
  return {
    year: Math.floor(totalM / 12),
    month: totalM % 12 + 1,
    day: date.day
  };
}
function truncateDayInMonth(date) {
  return {
    year: date.year,
    month: date.month,
    day: Math.min(date.day, numDays[date.month - 1])
  };
}
function roundToNearestSecond(arg) {
  return Math.round(arg * 3600 * 24) / (3600 * 24);
}
function roundToEpsilon(arg, epsilon = 1) {
  return Math.round(arg * epsilon) / epsilon;
}
// Note: The result of this function might be { hours = 24, minutes = 0, seconds = 0 } if arg < 1 but arg ≈ 1
function numberToSimpleTime(arg) {
  const argAsSeconds = arg * HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDS_PER_MINUTE;
  const seconds = roundToEpsilon(argAsSeconds % SECONDS_PER_MINUTE, 100000) % SECONDS_PER_MINUTE;
  const argAsMinutes = (argAsSeconds - seconds) / SECONDS_PER_MINUTE;
  const minutes = Math.round(argAsMinutes % MINUTES_PER_HOUR) % MINUTES_PER_HOUR;
  const argAsHours = (argAsMinutes - minutes) / MINUTES_PER_HOUR;
  const hours = Math.round(argAsHours);
  return {
    hours,
    minutes,
    seconds
  };
}
function timeToNumber(time) {
  return ((time.seconds / 60 + time.minutes) / 60 + time.hours) / 24;
}
function toBasisEU(date) {
  return {
    year: date.year,
    month: date.month,
    day: Math.min(30, date.day)
  };
}

/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AlwaysDense: () => (/* binding */ AlwaysDense),
/* harmony export */   AlwaysSparse: () => (/* binding */ AlwaysSparse),
/* harmony export */   DenseSparseChooseBasedOnThreshold: () => (/* binding */ DenseSparseChooseBasedOnThreshold)
/* harmony export */ });
/* harmony import */ var _DenseStrategy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);
/* harmony import */ var _SparseStrategy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class DenseSparseChooseBasedOnThreshold {
  constructor(threshold) {
    this.threshold = threshold;
  }
  call(fill) {
    if (fill > this.threshold) {
      return _DenseStrategy__WEBPACK_IMPORTED_MODULE_0__.DenseStrategy;
    } else {
      return _SparseStrategy__WEBPACK_IMPORTED_MODULE_1__.SparseStrategy;
    }
  }
}
class AlwaysSparse {
  call() {
    return _SparseStrategy__WEBPACK_IMPORTED_MODULE_1__.SparseStrategy;
  }
}
class AlwaysDense {
  call() {
    return _DenseStrategy__WEBPACK_IMPORTED_MODULE_0__.DenseStrategy;
  }
}

/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultStringifyDateTime: () => (/* binding */ defaultStringifyDateTime),
/* harmony export */   defaultStringifyDuration: () => (/* binding */ defaultStringifyDuration),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   padLeft: () => (/* binding */ padLeft),
/* harmony export */   padRight: () => (/* binding */ padRight)
/* harmony export */ });
/* harmony import */ var _DateTimeDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(103);
/* harmony import */ var _DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(104);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(107);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



function format(value, formatArg, config, dateHelper) {
  const tryDateTime = config.stringifyDateTime(dateHelper.numberToSimpleDateTime(value), formatArg); // default points to defaultStringifyDateTime()
  if (tryDateTime !== undefined) {
    return tryDateTime;
  }
  const tryDuration = config.stringifyDuration((0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.numberToSimpleTime)(value), formatArg);
  if (tryDuration !== undefined) {
    return tryDuration;
  }
  const expression = (0,_parser__WEBPACK_IMPORTED_MODULE_2__.parseForNumberFormat)(formatArg);
  if (expression !== undefined) {
    return numberFormat(expression.tokens, value);
  }
  return formatArg;
}
function padLeft(number, size) {
  let result = `${number}`;
  while (result.length < size) {
    result = '0' + result;
  }
  return result;
}
function padRight(number, size) {
  let result = `${number}`;
  while (result.length < size) {
    result = result + '0';
  }
  return result;
}
function countChars(text, char) {
  return text.split(char).length - 1;
}
function numberFormat(tokens, value) {
  let result = '';
  for (let i = 0; i < tokens.length; ++i) {
    const token = tokens[i];
    if (token.type === _parser__WEBPACK_IMPORTED_MODULE_2__.TokenType.FREE_TEXT) {
      result += token.value;
      continue;
    }
    const tokenParts = token.value.split('.');
    const integerFormat = tokenParts[0];
    const decimalFormat = tokenParts[1] || '';
    const separator = tokenParts[1] ? '.' : '';
    /* get fixed-point number without trailing zeros */
    const valueParts = Number(value.toFixed(decimalFormat.length)).toString().split('.');
    let integerPart = valueParts[0] || '';
    let decimalPart = valueParts[1] || '';
    if (integerFormat.length > integerPart.length) {
      const padSizeInteger = countChars(integerFormat.substr(0, integerFormat.length - integerPart.length), '0');
      integerPart = padLeft(integerPart, padSizeInteger + integerPart.length);
    }
    const padSizeDecimal = countChars(decimalFormat.substr(decimalPart.length, decimalFormat.length - decimalPart.length), '0');
    decimalPart = padRight(decimalPart, padSizeDecimal + decimalPart.length);
    result += integerPart + separator + decimalPart;
  }
  return result;
}
function defaultStringifyDuration(time, formatArg) {
  const expression = (0,_parser__WEBPACK_IMPORTED_MODULE_2__.parseForDateTimeFormat)(formatArg);
  if (expression === undefined) {
    return undefined;
  }
  const tokens = expression.tokens;
  let result = '';
  for (const token of tokens) {
    if (token.type === _parser__WEBPACK_IMPORTED_MODULE_2__.TokenType.FREE_TEXT) {
      result += token.value;
      continue;
    }
    switch (token.value.toLowerCase()) {
      case 'h':
      case 'hh':
        {
          result += padLeft(time.hours, token.value.length);
          time.hours = 0;
          break;
        }
      case '[hh]':
        {
          result += padLeft(time.hours, token.value.length - 2);
          time.hours = 0;
          break;
        }
      case 'm':
      case 'mm':
        {
          result += padLeft(time.minutes, token.value.length);
          time.minutes = 0;
          break;
        }
      case '[mm]':
        {
          result += padLeft(time.minutes + 60 * time.hours, token.value.length - 2);
          time.minutes = 0;
          time.hours = 0;
          break;
        }
      /* seconds */
      case 's':
      case 'ss':
        {
          result += padLeft(Math.floor(time.seconds), token.value.length);
          break;
        }
      default:
        {
          if (_DateTimeDefault__WEBPACK_IMPORTED_MODULE_0__.TIME_FORMAT_SECONDS_ITEM_REGEXP.test(token.value)) {
            const fractionOfSecondPrecision = Math.max(token.value.length - 3, 0);
            result += `${time.seconds < 10 ? '0' : ''}${Math.floor(time.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision)}`;
            continue;
          }
          return undefined;
        }
    }
  }
  return result;
}
function defaultStringifyDateTime(dateTime, formatArg) {
  const expression = (0,_parser__WEBPACK_IMPORTED_MODULE_2__.parseForDateTimeFormat)(formatArg);
  if (expression === undefined) {
    return undefined;
  }
  const tokens = expression.tokens;
  let result = '';
  let minutes = false;
  const ampm = tokens.some(token => token.type === _parser__WEBPACK_IMPORTED_MODULE_2__.TokenType.FORMAT && (token.value === 'a/p' || token.value === 'A/P' || token.value === 'am/pm' || token.value === 'AM/PM'));
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.type === _parser__WEBPACK_IMPORTED_MODULE_2__.TokenType.FREE_TEXT) {
      result += token.value;
      continue;
    }
    switch (token.value.toLowerCase()) {
      /* hours*/
      case 'h':
      case 'hh':
        {
          minutes = true;
          result += padLeft(ampm ? (dateTime.hours + 11) % 12 + 1 : dateTime.hours, token.value.length);
          break;
        }
      /* days */
      case 'd':
      case 'dd':
        {
          result += padLeft(dateTime.day, token.value.length);
          break;
        }
      /* seconds */
      case 's':
      case 'ss':
        {
          result += padLeft(Math.floor(dateTime.seconds), token.value.length);
          break;
        }
      /* minutes / months */
      case 'm':
      case 'mm':
        {
          if (i + 1 < tokens.length && tokens[i + 1].value.startsWith(':')) {
            minutes = true;
          }
          if (minutes) {
            result += padLeft(dateTime.minutes, token.value.length);
          } else {
            result += padLeft(dateTime.month, token.value.length);
          }
          minutes = true;
          break;
        }
      /* years */
      case 'yy':
        {
          result += padLeft(dateTime.year % 100, token.value.length);
          break;
        }
      case 'yyyy':
        {
          result += dateTime.year;
          break;
        }
      /* AM / PM */
      case 'am/pm':
      case 'a/p':
        {
          const [am, pm] = token.value.split('/');
          result += dateTime.hours < 12 ? am : pm;
          break;
        }
      default:
        {
          if (_DateTimeDefault__WEBPACK_IMPORTED_MODULE_0__.TIME_FORMAT_SECONDS_ITEM_REGEXP.test(token.value)) {
            const fractionOfSecondPrecision = token.value.length - 3;
            result += `${dateTime.seconds < 10 ? '0' : ''}${Math.floor(dateTime.seconds * Math.pow(10, fractionOfSecondPrecision)) / Math.pow(10, fractionOfSecondPrecision)}`;
            continue;
          }
          return undefined;
        }
    }
  }
  return result;
}

/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormatExpressionType: () => (/* binding */ FormatExpressionType),
/* harmony export */   TokenType: () => (/* binding */ TokenType),
/* harmony export */   formatToken: () => (/* binding */ formatToken),
/* harmony export */   isEscapeToken: () => (/* binding */ isEscapeToken),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   parseForDateTimeFormat: () => (/* binding */ parseForDateTimeFormat),
/* harmony export */   parseForNumberFormat: () => (/* binding */ parseForNumberFormat)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
const dateFormatRegex = /(\\.|dd|DD|d|D|mm|MM|m|M|YYYY|YY|yyyy|yy|HH|hh|H|h|ss(\.(0+|s+))?|s|AM\/PM|am\/pm|A\/P|a\/p|\[mm]|\[MM]|\[hh]|\[HH])/g;
const numberFormatRegex = /(\\.|[#0]+(\.[#0]*)?)/g;
var TokenType;
(function (TokenType) {
  TokenType["FORMAT"] = "FORMAT";
  TokenType["FREE_TEXT"] = "FREE_TEXT";
})(TokenType || (TokenType = {}));
function formatToken(type, value) {
  return {
    type,
    value
  };
}
var FormatExpressionType;
(function (FormatExpressionType) {
  FormatExpressionType["DATE"] = "DATE";
  FormatExpressionType["NUMBER"] = "NUMBER";
  FormatExpressionType["STRING"] = "STRING";
})(FormatExpressionType || (FormatExpressionType = {}));
function matchDateFormat(str) {
  dateFormatRegex.lastIndex = 0;
  const tokens = [];
  let m;
  do {
    m = dateFormatRegex.exec(str);
    if (m !== null) {
      tokens.push(m);
    }
  } while (m);
  return tokens;
}
function matchNumberFormat(str) {
  numberFormatRegex.lastIndex = 0;
  const numberFormatToken = numberFormatRegex.exec(str);
  if (numberFormatToken !== null) {
    return [numberFormatToken];
  } else {
    return [];
  }
}
function createTokens(regexTokens, str) {
  const tokens = [];
  let start = 0;
  for (let i = 0; i < regexTokens.length; ++i) {
    const token = regexTokens[i];
    if (token.index !== start) {
      const beforeToken = str.substr(start, token.index - start);
      tokens.push(formatToken(TokenType.FREE_TEXT, beforeToken));
    }
    if (token[0].startsWith('\\')) {
      tokens.push(formatToken(TokenType.FREE_TEXT, token[0]));
    } else {
      tokens.push(formatToken(TokenType.FORMAT, token[0]));
    }
    start = token.index + token[0].length;
  }
  const lastToken = regexTokens[regexTokens.length - 1];
  if (lastToken.index + lastToken[0].length < str.length) {
    const afterLastToken = str.substr(lastToken.index + lastToken[0].length, str.length);
    tokens.push(formatToken(TokenType.FREE_TEXT, afterLastToken));
  }
  return tokens;
}
function parseForDateTimeFormat(str) {
  const dateFormatTokens = matchDateFormat(str);
  if (dateFormatTokens.every(elem => isEscapeToken(elem))) {
    return undefined;
  } else {
    return {
      type: FormatExpressionType.DATE,
      tokens: createTokens(dateFormatTokens, str)
    };
  }
}
function parseForNumberFormat(str) {
  const numberFormatTokens = matchNumberFormat(str);
  if (numberFormatTokens.every(elem => isEscapeToken(elem))) {
    return undefined;
  } else {
    return {
      type: FormatExpressionType.NUMBER,
      tokens: createTokens(numberFormatTokens, str)
    };
  }
}
function parse(str) {
  var _a, _b;
  return (_b = (_a = parseForDateTimeFormat(str)) !== null && _a !== void 0 ? _a : parseForNumberFormat(str)) !== null && _b !== void 0 ? _b : {
    type: FormatExpressionType.STRING,
    tokens: [{
      type: TokenType.FREE_TEXT,
      value: str
    }]
  };
}
function isEscapeToken(token) {
  return token[0].startsWith('\\');
}

/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkLicenseKeyValidity: () => (/* binding */ checkLicenseKeyValidity)
/* harmony export */ });
/* harmony import */ var _licenseKeyHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(109);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

/**
 * List of all not valid messages which may occur.
 */
const consoleMessages = {
  invalid: () => 'The license key for HyperFormula is invalid.',
  expired: ({
    keyValidityDate
  }) => 'The license key for HyperFormula expired' + ` on ${keyValidityDate}, and is not valid for the installed version.`,
  missing: () => 'The license key for HyperFormula is missing.'
};
let _notified = false;
/**
 * Checks if the provided license key is grammatically valid or not expired.
 *
 * @param {string} licenseKey The license key to check.
 * @returns {LicenseKeyValidityState} Returns the checking state.
 */
function checkLicenseKeyValidity(licenseKey) {
  const messageDescriptor = {
    template: "missing" /* MISSING */,
    vars: {}
  };
  if (licenseKey === 'gpl-v3' || licenseKey === 'internal-use-in-handsontable') {
    messageDescriptor.template = "valid" /* VALID */;
  } else if (typeof licenseKey === 'string' && (0,_licenseKeyHelper__WEBPACK_IMPORTED_MODULE_0__.checkKeySchema)(licenseKey)) {
    const [day, month, year] = ("18/07/2024" || 0).split('/');
    const releaseDays = Math.floor(new Date(`${month}/${day}/${year}`).getTime() / 8.64e7);
    const keyValidityDays = (0,_licenseKeyHelper__WEBPACK_IMPORTED_MODULE_0__.extractTime)(licenseKey);
    messageDescriptor.vars.keyValidityDate = formatDate(new Date((keyValidityDays + 1) * 8.64e7));
    if (releaseDays > keyValidityDays) {
      messageDescriptor.template = "expired" /* EXPIRED */;
    } else {
      messageDescriptor.template = "valid" /* VALID */;
    }
  } else if (licenseKey !== '') {
    messageDescriptor.template = "invalid" /* INVALID */;
  }
  if (!_notified && messageDescriptor.template !== "valid" /* VALID */) {
    console.warn(consoleMessages[messageDescriptor.template](messageDescriptor.vars));
    _notified = true;
  }
  return messageDescriptor.template;
}
/**
 * Formats a Date instance to hard-coded format MMMM DD, YYYY.
 *
 * @param {Date} date The date to format.
 * @returns {string}
 */
function formatDate(date) {
  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  const month = monthNames[date.getMonth()];
  const day = date.getDate();
  const year = date.getFullYear();
  return `${month} ${day}, ${year}`;
}

/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkKeySchema: () => (/* binding */ checkKeySchema),
/* harmony export */   extractTime: () => (/* binding */ extractTime)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
/* eslint-disable */
const _rl = '\x6C\x65\x6E\x67\x74\x68';
const _hd = v => parseInt(v, 16);
const _pi = v => parseInt(v, 10);
const _nm = v => (v + '').replace(/\-/g, '');
const _ss = (v, s, l) => v['\x73\x75\x62\x73\x74\x72'](s, l);
const _cp = v => v['\x63\x6F\x64\x65\x50\x6F\x69\x6E\x74\x41\x74'](0) - 65;
function extractTime(v) {
  return _nm(v)[_rl] === 50 >> 1 ? _hd(_ss(_nm(v), _hd('12'), _cp('\x46'))) / (_hd(_ss(_nm(v), _cp('C'), _cp('\x59') >> 4)) || (~~![][_rl] << 3) + 1) : 0;
}
function checkKeySchema(v) {
  v = (v + '').replace(/\-/g, '');
  if (v[_rl] !== _cp('\x5A')) {
    return false;
  }
  let sp = 0;
  return [[0, _cp('\x47') + 1], [_cp('\x48'), _cp('\x48') - 1], [_cp('G') + _cp('H'), _cp('\x47')]].reduce((e, [a, b], c) => {
    e |= (_pi(`${_pi(_hd(_ss(v, ...[sp + a - (c === 3 >> 2 ? 0 : 2), b + (!c ? 0 : 2)])) + (_hd(_ss(v, ...[sp + a + b, 2])) + []).padStart(2, '0'))}`) % 97 || 2) >> 1;
    sp += 2;
    return e;
  }, _cp('A')) === [] + 1 >> 1;
}
/* eslint-enable */

/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HyperFormula: () => (/* binding */ HyperFormula)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(102);
/* harmony import */ var _BuildEngineFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(111);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _CellContentParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(101);
/* harmony import */ var _DateTimeHelper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(104);
/* harmony import */ var _Destroy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(143);
/* harmony import */ var _Emitter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(144);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(77);
/* harmony import */ var _i18n__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(88);
/* harmony import */ var _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(130);
/* harmony import */ var _Operations__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(116);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(7);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */














/**
 * This is a class for creating HyperFormula instance, all the following public methods
 * are related to this class.
 *
 * The instance can be created only by calling one of the static methods
 * `buildFromArray`, `buildFromSheets` or `buildEmpty` and should be disposed of with the
 * `destroy` method when it's no longer needed to free the resources.
 *
 * The instance can be seen as a workbook where worksheets can be created and
 * manipulated. They are organized within a widely known structure of columns and rows
 * which can be manipulated as well. The smallest possible data unit are the cells, which
 * may contain simple values or formulas to be calculated.
 *
 * All CRUD methods are called directly on HyperFormula instance and will trigger
 * corresponding lifecycle events. The events are marked accordingly, as well as thrown
 * errors, so they can be correctly handled.
 */
class HyperFormula {
  /**
   * Constructor
   *
   * @internal
   */
  constructor(_config, _stats, _dependencyGraph, _columnSearch, _parser, _unparser, _cellContentParser, _evaluator, _lazilyTransformingAstService, _crudOperations, _exporter, _namedExpressions, _serialization, _functionRegistry) {
    this._config = _config;
    this._stats = _stats;
    this._dependencyGraph = _dependencyGraph;
    this._columnSearch = _columnSearch;
    this._parser = _parser;
    this._unparser = _unparser;
    this._cellContentParser = _cellContentParser;
    this._evaluator = _evaluator;
    this._lazilyTransformingAstService = _lazilyTransformingAstService;
    this._crudOperations = _crudOperations;
    this._exporter = _exporter;
    this._namedExpressions = _namedExpressions;
    this._serialization = _serialization;
    this._functionRegistry = _functionRegistry;
    this._emitter = new _Emitter__WEBPACK_IMPORTED_MODULE_8__.Emitter();
    this._evaluationSuspended = false;
  }
  /**
   * Returns all of HyperFormula's default [configuration options](../../guide/configuration-options.md).
   *
   * @example
   * ```js
   * // returns all default configuration options
   * const defaultConfig = HyperFormula.defaultConfig;
   * ```
   *
   * @category Static Accessors
   */
  static get defaultConfig() {
    return (0,_Config__WEBPACK_IMPORTED_MODULE_5__.getDefaultConfig)();
  }
  /**
   * Calls the `graph` method on the dependency graph.
   * Allows for executing `graph` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get graph() {
    return this.dependencyGraph.graph;
  }
  /**
   * Calls the `rangeMapping` method on the dependency graph.
   * Allows for executing `rangeMapping` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get rangeMapping() {
    return this.dependencyGraph.rangeMapping;
  }
  /**
   * Calls the `arrayMapping` method on the dependency graph.
   * Allows for executing `arrayMapping` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get arrayMapping() {
    return this.dependencyGraph.arrayMapping;
  }
  /**
   * Calls the `sheetMapping` method on the dependency graph.
   * Allows for executing `sheetMapping` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get sheetMapping() {
    return this.dependencyGraph.sheetMapping;
  }
  /**
   * Calls the `addressMapping` method on the dependency graph.
   * Allows for executing `addressMapping` directly, without a need to refer to `dependencyGraph`.
   *
   * @internal
   */
  get addressMapping() {
    return this.dependencyGraph.addressMapping;
  }
  /** @internal */
  get dependencyGraph() {
    return this._dependencyGraph;
  }
  /** @internal */
  get evaluator() {
    return this._evaluator;
  }
  /** @internal */
  get columnSearch() {
    return this._columnSearch;
  }
  /** @internal */
  get lazilyTransformingAstService() {
    return this._lazilyTransformingAstService;
  }
  /**
   * Returns state of the validity of the license key.
   *
   * @internal
   */
  get licenseKeyValidityState() {
    return this._config.licenseKeyValidityState;
  }
  /**
   * Builds the engine for a sheet from a two-dimensional array representation.
   * The engine is created with a single sheet.
   * Can be configured with the optional second parameter that represents a [[ConfigParams]].
   * If not specified, the engine will be built with the default configuration.
   *
   * @param {Sheet} sheet - two-dimensional array representation of sheet
   * @param {Partial<ConfigParams>} configInput - engine configuration
   * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions
   *
   * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits
   * @throws [[InvalidArgumentsError]] when sheet is not an array of arrays
   * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata
   *
   * @example
   * ```js
   * // data represented as an array
   * const sheetData = [
   *  ['0', '=SUM(1, 2, 3)', '52'],
   *  ['=SUM(A1:C1)', '', '=A1'],
   *  ['2', '=SUM(A1:C1)', '91'],
   * ];
   *
   * // method with optional config parameter maxColumns
   * const hfInstance = HyperFormula.buildFromArray(sheetData, { maxColumns: 1000 });
   * ```
   *
   * @category Factories
   */
  static buildFromArray(sheet, configInput = {}, namedExpressions = []) {
    return this.buildFromEngineState(_BuildEngineFactory__WEBPACK_IMPORTED_MODULE_2__.BuildEngineFactory.buildFromSheet(sheet, configInput, namedExpressions));
  }
  /**
   * Builds the engine from an object containing multiple sheets with names.
   * The engine is created with one or more sheets.
   * Can be configured with the optional second parameter that represents a [[ConfigParams]].
   * If not specified the engine will be built with the default configuration.
   *
   * @param {Sheet} sheets - object with sheets definition
   * @param {Partial<ConfigParams>} configInput - engine configuration
   * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions
   *
   * @throws [[SheetSizeLimitExceededError]] when sheet size exceeds the limits
   * @throws [[InvalidArgumentsError]] when any sheet is not an array of arrays
   * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata
   *
   * @example
   * ```js
   * // data represented as an object with sheets: Sheet1 and Sheet2
   * const sheetData = {
   *  'Sheet1': [
   *    ['1', '', '=Sheet2!$A1'],
   *    ['', '2', '=SUM(1, 2, 3)'],
   *    ['=Sheet2!$A2', '2', ''],
   *   ],
   *  'Sheet2': [
   *    ['', '4', '=Sheet1!$B1'],
   *    ['', '8', '=SUM(9, 3, 3)'],
   *    ['=Sheet1!$B1', '2', ''],
   *   ],
   * };
   *
   * // method with optional config parameter useColumnIndex
   * const hfInstance = HyperFormula.buildFromSheets(sheetData, { useColumnIndex: true });
   * ```
   *
   * @category Factories
   */
  static buildFromSheets(sheets, configInput = {}, namedExpressions = []) {
    return this.buildFromEngineState(_BuildEngineFactory__WEBPACK_IMPORTED_MODULE_2__.BuildEngineFactory.buildFromSheets(sheets, configInput, namedExpressions));
  }
  /**
   * Builds an empty engine instance.
   * Can be configured with the optional parameter that represents a [[ConfigParams]].
   * If not specified the engine will be built with the default configuration.
   *
   * @param {Partial<ConfigParams>} configInput - engine configuration
   * @param {SerializedNamedExpression[]} namedExpressions - starting named expressions
   *
   * @example
   * ```js
   * // build with no initial data and with optional config parameter maxColumns
   * const hfInstance = HyperFormula.buildEmpty({ maxColumns: 1000 });
   * ```
   *
   * @category Factories
   */
  static buildEmpty(configInput = {}, namedExpressions = []) {
    return this.buildFromEngineState(_BuildEngineFactory__WEBPACK_IMPORTED_MODULE_2__.BuildEngineFactory.buildEmpty(configInput, namedExpressions));
  }
  /**
   * Returns registered language from its code string.
   *
   * @param {string} languageCode - code string of the translation package
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[LanguageNotRegisteredError]] when trying to retrieve not registered language
   *
   * @example
   * ```js
   * // return registered language
   * const language = HyperFormula.getLanguage('enGB');
   * ```
   *
   * @category Static Methods
   */
  static getLanguage(languageCode) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(languageCode, 'string', 'languageCode');
    const val = this.registeredLanguages.get(languageCode);
    if (val === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.LanguageNotRegisteredError();
    } else {
      return val;
    }
  }
  /**
   * Registers language under given code string.
   *
   * For more information, see the [Localizing functions guide](/guide/localizing-functions.md).
   *
   * @param {string} languageCode - code string of the translation package
   * @param {RawTranslationPackage} languagePackage - translation package to be registered
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function
   * @throws [[LanguageAlreadyRegisteredError]] when given language is already registered
   *
   * @example
   * ```js
   * // return registered language
   * HyperFormula.registerLanguage('enUS', enUS);
   * const engine = HyperFormula.buildEmpty({language: 'enUS'});
   * ```
   *
   * @category Static Methods
   */
  static registerLanguage(languageCode, languagePackage) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(languageCode, 'string', 'languageCode');
    if (this.registeredLanguages.has(languageCode)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.LanguageAlreadyRegisteredError();
    } else {
      this.registeredLanguages.set(languageCode, (0,_i18n__WEBPACK_IMPORTED_MODULE_10__.buildTranslationPackage)(languagePackage));
    }
  }
  /**
   * Unregisters language that is registered under given code string.
   *
   * @param {string} languageCode - code string of the translation package
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[LanguageNotRegisteredError]] when given language is not registered
   *
   * @example
   * ```js
   * // register the language for the instance
   * HyperFormula.registerLanguage('plPL', plPL);
   *
   * // unregister plPL
   * HyperFormula.unregisterLanguage('plPL');
   * ```
   *
   * @category Static Methods
   */
  static unregisterLanguage(languageCode) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(languageCode, 'string', 'languageCode');
    if (this.registeredLanguages.has(languageCode)) {
      this.registeredLanguages.delete(languageCode);
    } else {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.LanguageNotRegisteredError();
    }
  }
  /**
   * Returns all registered languages codes.
   *
   * @example
   * ```js
   * // should return all registered language codes: ['enGB', 'plPL']
   * const registeredLanguages = HyperFormula.getRegisteredLanguagesCodes();
   * ```
   *
   * @category Static Methods
   */
  static getRegisteredLanguagesCodes() {
    return Array.from(this.registeredLanguages.keys());
  }
  /**
   * Registers all functions in a given plugin with optional translations.
   *
   * Note: FunctionPlugins must be registered prior to the creation of HyperFormula instances in which they are used.
   * HyperFormula instances created prior to the registration of a FunctionPlugin are unable to access the FunctionPlugin.
   * Registering a FunctionPlugin with [[custom-functions]] requires the translations parameter.
   *
   * @param {FunctionPluginDefinition} plugin - plugin class
   * @param {FunctionTranslationsPackage} translations - optional package of function names translations
   *
   * @throws [[FunctionPluginValidationError]] when plugin class definition is not consistent with metadata
   * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * // register the plugin
   * HyperFormula.registerFunctionPlugin(MyExamplePlugin);
   * ```
   *
   * @category Static Methods
   */
  static registerFunctionPlugin(plugin, translations) {
    _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__.FunctionRegistry.registerFunctionPlugin(plugin, translations);
  }
  /**
   * Unregisters all functions defined in given plugin.
   *
   * Note: This method does not affect the existing HyperFormula instances.
   *
   * @param {FunctionPluginDefinition} plugin - plugin class
   *
   * @example
   * ```js
   * // get the class of a plugin
   * const registeredPluginClass = HyperFormula.getFunctionPlugin('EXAMPLE');
   *
   * // unregister all functions defined in a plugin of ID 'EXAMPLE'
   * HyperFormula.unregisterFunctionPlugin(registeredPluginClass);
   * ```
   *
   * @category Static Methods
   */
  static unregisterFunctionPlugin(plugin) {
    _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__.FunctionRegistry.unregisterFunctionPlugin(plugin);
  }
  /**
   * Registers a function with a given id if such exists in a plugin.
   *
   * Note: This method does not affect the existing HyperFormula instances.
   *
   * @param {string} functionId - function id, e.g., 'SUMIF'
   * @param {FunctionPluginDefinition} plugin - plugin class
   * @param {FunctionTranslationsPackage} translations - translations for the function name
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[FunctionPluginValidationError]] when function with a given id does not exist in plugin or plugin class definition is not consistent with metadata
   * @throws [[ProtectedFunctionTranslationError]] when trying to register translation for protected function
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * // register a function
   * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);
   * ```
   *
   * @category Static Methods
   */
  static registerFunction(functionId, plugin, translations) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(functionId, 'string', 'functionId');
    _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__.FunctionRegistry.registerFunction(functionId, plugin, translations);
  }
  /**
   * Unregisters a function with a given id.
   *
   * Note: This method does not affect the existing HyperFormula instances.
   *
   * @param {string} functionId - function id, e.g., 'SUMIF'
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * // register a function
   * HyperFormula.registerFunction('EXAMPLE', MyExamplePlugin);
   *
   * // unregister a function
   * HyperFormula.unregisterFunction('EXAMPLE');
   * ```
   *
   * @category Static Methods
   */
  static unregisterFunction(functionId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(functionId, 'string', 'functionId');
    _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__.FunctionRegistry.unregisterFunction(functionId);
  }
  /**
   * Clears function registry.
   *
   * Note: This method does not affect the existing HyperFormula instances.
   *
   * @example
   * ```js
   * HyperFormula.unregisterAllFunctions();
   * ```
   *
   * @category Static Methods
   */
  static unregisterAllFunctions() {
    _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__.FunctionRegistry.unregisterAll();
  }
  /**
   * Returns translated names of all registered functions for a given language
   *
   * @param {string} code - language code
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // return a list of function names registered for enGB
   * const allNames = HyperFormula.getRegisteredFunctionNames('enGB');
   * ```
   *
   * @category Static Methods
   */
  static getRegisteredFunctionNames(code) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(code, 'string', 'code');
    const functionIds = _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__.FunctionRegistry.getRegisteredFunctionIds();
    const language = this.getLanguage(code);
    return language.getFunctionTranslations(functionIds);
  }
  /**
   * Returns class of a plugin used by function with given id
   *
   * @param {string} functionId - id of a function, e.g., 'SUMIF'
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * // register a plugin
   * HyperFormula.registerFunctionPlugin(MyExamplePlugin);
   *
   * // return the class of a given plugin
   * const myFunctionClass = HyperFormula.getFunctionPlugin('EXAMPLE');
   * ```
   *
   * @category Static Methods
   */
  static getFunctionPlugin(functionId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(functionId, 'string', 'functionId');
    return _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__.FunctionRegistry.getFunctionPlugin(functionId);
  }
  /**
   * Returns classes of all plugins registered in HyperFormula.
   *
   * @example
   * ```js
   * // return classes of all plugins
   * const allClasses = HyperFormula.getAllFunctionPlugins();
   * ```
   *
   * @category Static Methods
   */
  static getAllFunctionPlugins() {
    return _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_11__.FunctionRegistry.getPlugins();
  }
  static buildFromEngineState(engine) {
    return new HyperFormula(engine.config, engine.stats, engine.dependencyGraph, engine.columnSearch, engine.parser, engine.unparser, engine.cellContentParser, engine.evaluator, engine.lazilyTransformingAstService, engine.crudOperations, engine.exporter, engine.namedExpressions, engine.serialization, engine.functionRegistry);
  }
  /**
   * Returns the cell value of a given address.
   * Applies rounding and post-processing.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2, 3)', '2'],
   * ]);
   *
   * // get value of A1 cell, should be '6'
   * const A1Value = hfInstance.getCellValue({ sheet: 0, col: 0, row: 0 });
   *
   * // get value of B1 cell, should be '2'
   * const B1Value = hfInstance.getCellValue({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellValue(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getCellValue(cellAddress);
  }
  /**
   * Returns a normalized formula string from the cell of a given address or `undefined` for an address that does not exist and empty values.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2, 3)', '0'],
   * ]);
   *
   * // should return a normalized A1 cell formula: '=SUM(1, 2, 3)'
   * const A1Formula = hfInstance.getCellFormula({ sheet: 0, col: 0, row: 0 });
   *
   * // should return a normalized B1 cell formula: 'undefined'
   * const B1Formula = hfInstance.getCellFormula({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellFormula(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    return this._serialization.getCellFormula(cellAddress);
  }
  /**
   * Returns the `HYPERLINK` url for a cell of a given address or `undefined` for an address that does not exist or a cell that is not `HYPERLINK`
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=HYPERLINK("https://hyperformula.handsontable.com/", "HyperFormula")', '0'],
   * ]);
   *
   * // should return url of 'HYPERLINK': https://hyperformula.handsontable.com/
   * const A1Hyperlink = hfInstance.getCellHyperlink({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'undefined' for a cell that is not 'HYPERLINK'
   * const B1Hyperlink = hfInstance.getCellHyperlink({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellHyperlink(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getCellHyperlink(cellAddress);
  }
  /**
   * Returns [[RawCellContent]] with a serialized content of the cell of a given address: either a cell formula, an explicit value, or an error.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] when cellAddress is of incorrect type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2, 3)', '0'],
   * ]);
   *
   * // should return serialized content of A1 cell: '=SUM(1, 2, 3)'
   * const cellA1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 0, row: 0 });
   *
   * // should return serialized content of B1 cell: '0'
   * const cellB1Serialized = hfInstance.getCellSerialized({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellSerialized(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getCellSerialized(cellAddress);
  }
  /**
   * Returns an array of arrays of [[CellValue]] with values of all cells from [[Sheet]].
   * Applies rounding and post-processing.
   *
   * @param {number} sheetId - sheet ID number
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['0', '=SUM(1, 2, 3)', '=A1'],
   *  ['1', '=TEXT(A2, "0.0%")', '=C1'],
   *  ['2', '=SUM(A1:C1)', '=C1'],
   * ]);
   *
   * // should return all values of a sheet: [[0, 6, 0], [1, '1.0%', 0], [2, 6, 0]]
   * const sheetValues = hfInstance.getSheetValues(0);
   * ```
   *
   * @category Sheets
   */
  getSheetValues(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getSheetValues(sheetId);
  }
  /**
   * Returns an array with normalized formula strings from [[Sheet]] or `undefined` for a cells that have no value.
   *
   * @param {SimpleCellAddress} sheetId - sheet ID number
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['0', '=SUM(1, 2, 3)', '=A1'],
   *  ['1', '=TEXT(A2, "0.0%")', '=C1'],
   *  ['2', '=SUM(A1:C1)', '=C1'],
   * ]);
   *
   * // should return all formulas of a sheet:
   * // [
   * //  [undefined, '=SUM(1, 2, 3)', '=A1'],
   * //  [undefined, '=TEXT(A2, "0.0%")', '=C1'],
   * //  [undefined, '=SUM(A1:C1)', '=C1'],
   * // ];
   * const sheetFormulas = hfInstance.getSheetFormulas(0);
   * ```
   *
   * @category Sheets
   */
  getSheetFormulas(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    return this._serialization.getSheetFormulas(sheetId);
  }
  /**
   * Returns an array of arrays of [[RawCellContent]] with serialized content of cells from [[Sheet]], either a cell formula or an explicit value.
   *
   * @param {SimpleCellAddress} sheetId - sheet ID number
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['0', '=SUM(1, 2, 3)', '=A1'],
   *  ['1', '=TEXT(A2, "0.0%")', '=C1'],
   *  ['2', '=SUM(A1:C1)', '=C1'],
   * ]);
   *
   * // should return:
   * // [
   * //  ['0', '=SUM(1, 2, 3)', '=A1'],
   * //  ['1', '=TEXT(A2, "0.0%")', '=C1'],
   * //  ['2', '=SUM(A1:C1)', '=C1'],
   * // ];
   * const serializedContent = hfInstance.getSheetSerialized(0);
   * ```
   *
   * @category Sheets
   */
  getSheetSerialized(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getSheetSerialized(sheetId);
  }
  /**
   * Returns a map containing dimensions of all sheets for the engine instance represented as a key-value pairs where keys are sheet IDs and dimensions are returned as numbers, width and height respectively.
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   Sheet1: [
   *    ['1', '2', '=Sheet2!$A1'],
   *   ],
   *   Sheet2: [
   *    ['3'],
   *    ['4'],
   *   ],
   * });
   *
   * // should return the dimensions of all sheets:
   * // { Sheet1: { width: 3, height: 1 }, Sheet2: { width: 1, height: 2 } }
   * const allSheetsDimensions = hfInstance.getAllSheetsDimensions();
   * ```
   *
   * @category Sheets
   */
  getAllSheetsDimensions() {
    return this._serialization.genericAllSheetsGetter(arg => this.getSheetDimensions(arg));
  }
  /**
   * Returns dimensions of a specified sheet.
   * The sheet dimensions is represented with numbers: width and height.
   *
   * @param {number} sheetId - sheet ID number
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *    ['1', '2', '=Sheet2!$A1'],
   * ]);
   *
   * // should return provided sheet's dimensions: { width: 3, height: 1 }
   * const sheetDimensions = hfInstance.getSheetDimensions(0);
   * ```
   *
   * @category Sheets
   */
  getSheetDimensions(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    return {
      width: this.dependencyGraph.getSheetWidth(sheetId),
      height: this.dependencyGraph.getSheetHeight(sheetId)
    };
  }
  /**
   * Returns values of all sheets in a form of an object which property keys are strings and values are 2D arrays of [[CellValue]].
   *
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '=A1+10', '3'],
   * ]);
   *
   * // should return all sheets values: { Sheet1: [ [ 1, 11, 3 ] ] }
   * const allSheetsValues = hfInstance.getAllSheetsValues();
   * ```
   *
   * @category Sheets
   */
  getAllSheetsValues() {
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getAllSheetsValues();
  }
  /**
   * Returns formulas of all sheets in a form of an object which property keys are strings and values are 2D arrays of strings or possibly `undefined` when the call does not contain a formula.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '=A1+10'],
   * ]);
   *
   * // should return only formulas: { Sheet1: [ [ undefined, undefined, '=A1+10' ] ] }
   * const allSheetsFormulas = hfInstance.getAllSheetsFormulas();
   * ```
   * @category Sheets
   */
  getAllSheetsFormulas() {
    return this._serialization.getAllSheetsFormulas();
  }
  /**
   * Returns formulas or values of all sheets in a form of an object which property keys are strings and values are 2D arrays of [[RawCellContent]].
   *
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '=A1+10'],
   * ]);
   *
   * // should return all sheets serialized content: { Sheet1: [ [ 1, 2, '=A1+10' ] ] }
   * const allSheetsSerialized = hfInstance.getAllSheetsSerialized();
   * ```
   *
   * @category Sheets
   */
  getAllSheetsSerialized() {
    this.ensureEvaluationIsNotSuspended();
    return this._serialization.getAllSheetsSerialized();
  }
  /**
   * Updates the config with given new metadata. It is an expensive operation, as it might trigger rebuilding the engine and recalculation of all formulas.
   *
   * @param {Partial<ConfigParams>} newParams configuration options to be updated or added
   *
   * @throws [[ExpectedValueOfTypeError]] when some parameters of config are of wrong type (e.g., currencySymbol)
   * @throws [[ConfigValueEmpty]] when some parameters of config are of invalid value (e.g., currencySymbol)
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // add a config param, for example maxColumns,
   * // you can check the configuration with getConfig method
   * hfInstance.updateConfig({ maxColumns: 1000 });
   * ```
   *
   * @category Instance
   */
  updateConfig(newParams) {
    const isNewConfigTheSame = Object.entries(newParams).every(([key, value]) => this._config[key] === value);
    if (isNewConfigTheSame) {
      return;
    }
    this.rebuildWithConfig(newParams);
  }
  /**
   * Returns current configuration of the engine instance.
   *
   * @example
   * ```js
   * // should return all config metadata including default and those which were added
   * const hfConfig = hfInstance.getConfig();
   * ```
   *
   * @category Instance
   */
  getConfig() {
    return this._config.getConfig();
  }
  /**
   * Rebuilds the HyperFormula instance preserving the current sheets data.
   *
   * @example
   * ```js
   * hfInstance.rebuildAndRecalculate();
   * ```
   *
   * @category Instance
   */
  rebuildAndRecalculate() {
    this.rebuildWithConfig({});
  }
  /**
   * Returns a snapshot of computation time statistics.
   * It returns a map with key-value pairs where keys are enums for stat type and time (number).
   *
   * @internal
   *
   * @category Instance
   */
  getStats() {
    return this._stats.snapshot();
  }
  /**
   * Undo the previous operation.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoOperationToUndoError]] when there is no operation running that can be undone
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   *  ['3', ''],
   * ]);
   *
   * // perform CRUD operation, for example remove the second row
   * hfInstance.removeRows(0, [1, 1]);
   *
   * // undo the operation, it should return the changes
   * const changes = hfInstance.undo();
   * ```
   *
   * @category Undo and Redo
   */
  undo() {
    this._crudOperations.undo();
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Re-do recently undone operation.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoOperationToRedoError]] when there is no operation running that can be re-done
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   *  ['3'],
   * ]);
   *
   * // perform CRUD operation, for example remove the second row
   * hfInstance.removeRows(0, [1, 1]);
   *
   * // undo the operation, it should return previous values: [['1'], ['2'], ['3']]
   * hfInstance.undo();
   *
   * // do a redo, it should return the values after removing the second row: [['1'], ['3']]
   * const changes = hfInstance.redo();
   * ```
   *
   * @category Undo and Redo
   */
  redo() {
    this._crudOperations.redo();
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Checks if there is at least one operation that can be undone.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   *  ['3'],
   * ]);
   *
   * // perform CRUD operation, for example remove the second row
   * hfInstance.removeRows(0, [1, 1]);
   *
   * // should return 'true', it is possible to undo last operation
   * // which is removing rows in this example
   * const isSomethingToUndo = hfInstance.isThereSomethingToUndo();
   * ```
   *
   * @category Undo and Redo
   */
  isThereSomethingToUndo() {
    return this._crudOperations.isThereSomethingToUndo();
  }
  /**
   * Checks if there is at least one operation that can be re-done.
   *
   * @example
   * ```js
   * hfInstance.undo();
   *
   * // when there is an action to redo, this returns 'true'
   * const isSomethingToRedo = hfInstance.isThereSomethingToRedo();
   * ```
   *
   * @category Undo and Redo
   */
  isThereSomethingToRedo() {
    return this._crudOperations.isThereSomethingToRedo();
  }
  /**
   * Returns information whether it is possible to change the content in a rectangular area bounded by the box.
   * If returns `true`, doing [[setCellContents]] operation won't throw any errors.
   * Returns `false` if the address is invalid or the sheet does not exist.
   *
   * @param {SimpleCellAddress | SimpleCellRange} address - single cell or block of cells to check
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // top left corner
   * const address1 = { col: 0, row: 0, sheet: 0 };
   * // bottom right corner
   * const address2 = { col: 1, row: 0, sheet: 0 };
   *
   * // should return 'true' for this example, it is possible to set content of
   * // width 2, height 1 in the first row and column of sheet 0
   * const isSettable = hfInstance.isItPossibleToSetCellContents({ start: address1, end: address2 });
   * ```
   *
   * @category Cells
   */
  isItPossibleToSetCellContents(address) {
    let range;
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(address)) {
      range = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(address, address);
    } else if ((0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(address)) {
      range = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(address.start, address.end);
    } else {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', 'address');
    }
    try {
      this._crudOperations.ensureRangeInSizeLimits(range);
      for (const it of range.addresses(this._dependencyGraph)) {
        this._crudOperations.ensureItIsPossibleToChangeContent(it);
      }
    } catch (e) {
      return false;
    }
    return true;
  }
  /**
   * Sets the content for a block of cells of a given coordinates.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {SimpleCellAddress} topLeftCornerAddress - top left corner of block of cells
   * @param {(RawCellContent[][]|RawCellContent)} cellContents - array with content
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when the value is not an array of arrays or a raw cell value
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   * @throws [[ExpectedValueOfTypeError]] if topLeftCornerAddress argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '=A1'],
   * ]);
   *
   * // should set the content, returns:
   * // [{
   * //   address: { sheet: 0, col: 3, row: 0 },
   * //   newValue: 2,
   * // }]
   * const changes = hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);
   * ```
   *
   * @category Cells
   */
  setCellContents(topLeftCornerAddress, cellContents) {
    this._crudOperations.setCellContents(topLeftCornerAddress, cellContents);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Reorders rows of a sheet according to a source-target mapping.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet
   * @throws [[SourceLocationHasArrayError]] when the selected position has array inside
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1],
   *  [2],
   *  [4, 5],
   * ]);
   *
   * // should set swap rows 0 and 2 in place, returns:
   * // [{
   * //   address: { sheet: 0, col: 0, row: 2 },
   * //   newValue: 1,
   * // },
   * // {
   * //   address: { sheet: 0, col: 1, row: 2 },
   * //   newValue: null,
   * // },
   * // {
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: 4,
   * // },
   * // {
   * //   address: { sheet: 0, col: 1, row: 0 },
   * //   newValue: 5,
   * // }]
   * const changes = hfInstance.swapRowIndexes(0, [[0, 2], [2, 0]]);
   * ```
   *
   * @category Rows
   */
  swapRowIndexes(sheetId, rowMapping) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.setRowOrder(sheetId, rowMapping);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Checks if it is possible to reorder rows of a sheet according to a source-target mapping.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {[number, number][]} rowMapping - array mapping original positions to final positions of rows
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1],
   *  [2],
   *  [4, 5],
   * ]);
   *
   * // returns true
   * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0, 2], [2, 0]]);
   *
   * // returns false
   * const isSwappable = hfInstance.isItPossibleToSwapRowIndexes(0, [[0, 1]]);
   * ```
   *
   * @category Rows
   */
  isItPossibleToSwapRowIndexes(sheetId, rowMapping) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);
      this._crudOperations.testRowOrderForArrays(sheetId, rowMapping);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Reorders rows of a sheet according to a permutation of 0-based indexes.
   * Parameter `newRowOrder` should have a form `[ newPositionForRow0, newPositionForRow1, newPositionForRow2, ... ]`.
   * This method might be used to [sort the rows of a sheet](../../guide/sorting-data.md).
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note: This method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {number[]} newRowOrder - permutation of rows
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when rowMapping does not define correct row permutation for some subset of rows of the given sheet
   * @throws [[SourceLocationHasArrayError]] when the selected position has array inside
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['A'],
   *  ['B'],
   *  ['C'],
   *  ['D']
   * ]);
   *
   * const newRowOrder = [0, 3, 2, 1]; // [ newPosForA, newPosForB, newPosForC, newPosForD ]
   *
   * const changes = hfInstance.setRowOrder(0, newRowOrder);
   *
   * // Sheet after this operation: [['A'], ['D'], ['C'], ['B']]
   * ```
   *
   * @category Rows
   */
  setRowOrder(sheetId, newRowOrder) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    const mapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');
    return this.swapRowIndexes(sheetId, mapping);
  }
  /**
   * Checks if it is possible to reorder rows of a sheet according to a permutation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {number[]} newRowOrder - permutation of rows
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1],
   *  [2],
   *  [4, 5],
   * ]);
   *
   * // returns true
   * hfInstance.isItPossibleToSetRowOrder(0, [2, 1, 0]);
   *
   * // returns false
   * hfInstance.isItPossibleToSetRowOrder(0, [2]);
   * ```
   *
   * @category Rows
   */
  isItPossibleToSetRowOrder(sheetId, newRowOrder) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    try {
      const rowMapping = this._crudOperations.mappingFromOrder(sheetId, newRowOrder, 'row');
      this._crudOperations.validateSwapRowIndexes(sheetId, rowMapping);
      this._crudOperations.testRowOrderForArrays(sheetId, rowMapping);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Reorders columns of a sheet according to a source-target mapping.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {[number, number][]} columnMapping - array mapping original positions to final positions of columns
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet
   * @throws [[SourceLocationHasArrayError]] when the selected position has array inside
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1, 2, 4],
   *  [5]
   * ]);
   *
   * // should set swap columns 0 and 2 in place, returns:
   * // [{
   * //   address: { sheet: 0, col: 2, row: 0 },
   * //   newValue: 1,
   * // },
   * // {
   * //   address: { sheet: 0, col: 2, row: 1 },
   * //   newValue: 5,
   * // },
   * // {
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: 4,
   * // },
   * // {
   * //   address: { sheet: 0, col: 0, row: 1 },
   * //   newValue: null,
   * // }]
   * const changes = hfInstance.swapColumnIndexes(0, [[0, 2], [2, 0]]);
   * ```
   *
   * @category Columns
   */
  swapColumnIndexes(sheetId, columnMapping) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.setColumnOrder(sheetId, columnMapping);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Checks if it is possible to reorder columns of a sheet according to a source-target mapping.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1, 2, 4],
   *  [5]
   * ]);
   *
   * // returns true
   * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0, 2], [2, 0]]);
   *
   * // returns false
   * hfInstance.isItPossibleToSwapColumnIndexes(0, [[0, 1]]);
   * ```
   *
   * @category Columns
   */
  isItPossibleToSwapColumnIndexes(sheetId, columnMapping) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);
      this._crudOperations.testColumnOrderForArrays(sheetId, columnMapping);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Reorders columns of a sheet according to a permutation of 0-based indexes.
   * Parameter `newColumnOrder` should have a form `[ newPositionForColumn0, newPositionForColumn1, newPositionForColumn2, ... ]`.
   * This method might be used to [sort the columns of a sheet](../../guide/sorting-data.md).
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note: This method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {number[]} newColumnOrder - permutation of columns
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when columnMapping does not define correct column permutation for some subset of columns of the given sheet
   * @throws [[SourceLocationHasArrayError]] when the selected position has array inside
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['A', 'B', 'C', 'D']
   * ]);
   *
   * const newColumnOrder = [0, 3, 2, 1]; // [ newPosForA, newPosForB, newPosForC, newPosForD ]
   *
   * const changes = hfInstance.setColumnOrder(0, newColumnOrder);
   *
   * // Sheet after this operation: [['A', 'D', 'C', 'B']]
   * ```
   *
   * @category Columns
   */
  setColumnOrder(sheetId, newColumnOrder) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    const mapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');
    return this.swapColumnIndexes(sheetId, mapping);
  }
  /**
   * Checks if it is possible to reorder columns of a sheet according to a permutation.
   *
   * @param {number} sheetId - ID of a sheet to operate on
   * @param {number[]} newColumnOrder - permutation of columns
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  [1, 2, 4],
   *  [5]
   * ]);
   *
   * // returns true
   * hfInstance.isItPossibleToSetColumnOrder(0, [2, 1, 0]);
   *
   * // returns false
   * hfInstance.isItPossibleToSetColumnOrder(0, [1]);
   * ```
   *
   * @category Columns
   */
  isItPossibleToSetColumnOrder(sheetId, newColumnOrder) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    try {
      const columnMapping = this._crudOperations.mappingFromOrder(sheetId, newColumnOrder, 'column');
      this._crudOperations.validateSwapColumnIndexes(sheetId, columnMapping);
      this._crudOperations.testColumnOrderForArrays(sheetId, columnMapping);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Returns information whether it is possible to add rows into a specified position in a given sheet.
   * Checks against particular rules to ascertain that addRows can be called.
   * If returns `true`, doing [[addRows]] operation won't throw any errors.
   * Returns `false` if adding rows would exceed the sheet size limit or given arguments are invalid.
   *
   * @param {number} sheetId - sheet ID in which rows will be added
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '3'],
   * ]);
   *
   * // should return 'true' for this example,
   * // it is possible to add one row in the second row of sheet 0
   * const isAddable = hfInstance.isItPossibleToAddRows(0, [1, 1]);
   * ```
   *
   * @category Rows
   */
  isItPossibleToAddRows(sheetId, ...indexes) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    const normalizedIndexes = (0,_Operations__WEBPACK_IMPORTED_MODULE_12__.normalizeAddedIndexes)(indexes);
    try {
      this._crudOperations.ensureItIsPossibleToAddRows(sheetId, ...normalizedIndexes);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Adds multiple rows into a specified position in a given sheet.
   * Does nothing if rows are outside effective sheet size.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID in which rows will be added
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [row, amount], where row is a row number above which the rows will be added
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values
   * const changes = hfInstance.addRows(0, [0, 1]);
   * ```
   *
   * @category Rows
   */
  addRows(sheetId, ...indexes) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.addRows(sheetId, ...indexes);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to remove rows from a specified position in a given sheet.
   * Checks against particular rules to ascertain that removeRows can be called.
   * If returns `true`, doing [[removeRows]] operation won't throw any errors.
   * Returns `false` if given arguments are invalid.
   *
   * @param {number} sheetId - sheet ID from which rows will be removed
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return 'true' for this example
   * // it is possible to remove one row from row 1 of sheet 0
   * const isRemovable = hfInstance.isItPossibleToRemoveRows(0, [1, 1]);
   * ```
   *
   * @category Rows
   */
  isItPossibleToRemoveRows(sheetId, ...indexes) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    const normalizedIndexes = (0,_Operations__WEBPACK_IMPORTED_MODULE_12__.normalizeRemovedIndexes)(indexes);
    try {
      this._crudOperations.ensureItIsPossibleToRemoveRows(sheetId, ...normalizedIndexes);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Removes multiple rows from a specified position in a given sheet.
   * Does nothing if rows are outside the effective sheet size.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID from which rows will be removed
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [row, amount]
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return: [{ sheet: 0, col: 1, row: 2, value: null }] for this example
   * const changes = hfInstance.removeRows(0, [1, 1]);
   * ```
   *
   * @category Rows
   */
  removeRows(sheetId, ...indexes) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.removeRows(sheetId, ...indexes);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to add columns into a specified position in a given sheet.
   * Checks against particular rules to ascertain that addColumns can be called.
   * If returns `true`, doing [[addColumns]] operation won't throw any errors.
   * Returns `false` if adding columns would exceed the sheet size limit or given arguments are invalid.
   *
   * @param {number} sheetId - sheet ID in which columns will be added
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // should return 'true' for this example,
   * // it is possible to add 1 column in sheet 0, at column 1
   * const isAddable = hfInstance.isItPossibleToAddColumns(0, [1, 1]);
   * ```
   *
   * @category Columns
   */
  isItPossibleToAddColumns(sheetId, ...indexes) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    const normalizedIndexes = (0,_Operations__WEBPACK_IMPORTED_MODULE_12__.normalizeAddedIndexes)(indexes);
    try {
      this._crudOperations.ensureItIsPossibleToAddColumns(sheetId, ...normalizedIndexes);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Adds multiple columns into a specified position in a given sheet.
   * Does nothing if the columns are outside the effective sheet size.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID in which columns will be added
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount], where column is a column number from which new columns will be added
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=RAND()', '42'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, for this example:
   * // [{
   * //   address: { sheet: 0, col: 1, row: 0 },
   * //   newValue: 0.92754862796338,
   * // }]
   * const changes = hfInstance.addColumns(0, [0, 1]);
   * ```
   *
   * @category Columns
   */
  addColumns(sheetId, ...indexes) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.addColumns(sheetId, ...indexes);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to remove columns from a specified position in a given sheet.
   * Checks against particular rules to ascertain that removeColumns can be called.
   * If returns `true`, doing [[removeColumns]] operation won't throw any errors.
   * Returns `false` if given arguments are invalid.
   *
   * @param {number} sheetId - sheet ID from which columns will be removed
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format [column, amount]
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // should return 'true' for this example
   * // it is possible to remove one column, in place of the second column of sheet 0
   * const isRemovable = hfInstance.isItPossibleToRemoveColumns(0, [1, 1]);
   * ```
   *
   * @category Columns
   */
  isItPossibleToRemoveColumns(sheetId, ...indexes) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    const normalizedIndexes = (0,_Operations__WEBPACK_IMPORTED_MODULE_12__.normalizeRemovedIndexes)(indexes);
    try {
      this._crudOperations.ensureItIsPossibleToRemoveColumns(sheetId, ...normalizedIndexes);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Removes multiple columns from a specified position in a given sheet.
   * Does nothing if columns are outside the effective sheet size.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID from which columns will be removed
   * @param {ColumnRowIndex[]} indexes - non-contiguous indexes with format: [column, amount]
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['0', '=SUM(1, 2, 3)', '=A1'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, in this example it will return:
   * // [{
   * //   address: { sheet: 0, col: 1, row: 0 },
   * //   newValue: { error: [CellError], value: '#REF!' },
   * // }]
   * const changes = hfInstance.removeColumns(0, [0, 1]);
   * ```
   *
   * @category Columns
   */
  removeColumns(sheetId, ...indexes) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.removeColumns(sheetId, ...indexes);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to move cells to a specified position in a given sheet.
   * Checks against particular rules to ascertain that moveCells can be called.
   * If returns `true`, doing [[moveCells]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted and causes side effects by the fact that there is an array inside the selected columns, the target location includes an array or the provided address is invalid.
   *
   * @param {SimpleCellRange} source - range for a moved block
   * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block
   *
   * @throws [[ExpectedValueOfTypeError]] if destinationLeftCorner, source, or any of basic type arguments are of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // choose the coordinates and assign them to variables
   * const source = { sheet: 0, col: 1, row: 0 };
   * const destination = { sheet: 0, col: 3, row: 0 };
   *
   * // should return 'true' for this example
   * // it is possible to move a block of width 1 and height 1
   * // from the corner: column 1 and row 0 of sheet 0
   * // into destination corner: column 3, row 0 of sheet 0
   * const isMovable = hfInstance.isItPossibleToMoveCells({ start: source, end: source }, destination);
   * ```
   * @category Cells
   */
  isItPossibleToMoveCells(source, destinationLeftCorner) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(destinationLeftCorner)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'destinationLeftCorner');
    }
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(source)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    try {
      const range = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(source.start, source.end);
      this._crudOperations.operations.ensureItIsPossibleToMoveCells(range.start, range.width(), range.height(), destinationLeftCorner);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Moves the content of a cell block from source to the target location.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {SimpleCellRange} source - range for a moved block
   * @param {SimpleCellAddress} destinationLeftCorner - upper left address of the target cell block
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if destinationLeftCorner or source are of wrong type
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved
   * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=RAND()', '42'],
   * ]);
   *
   * // choose the coordinates and assign them to variables
   * const source = { sheet: 0, col: 1, row: 0 };
   * const destination = { sheet: 0, col: 3, row: 0 };
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, for this example:
   * // [{
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: 0.93524248002062,
   * // }]
   * const changes = hfInstance.moveCells({ start: source, end: source }, destination);
   * ```
   *
   * @category Cells
   */
  moveCells(source, destinationLeftCorner) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(destinationLeftCorner)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'destinationLeftCorner');
    }
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(source)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const range = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(source.start, source.end);
    this._crudOperations.moveCells(range.start, range.width(), range.height(), destinationLeftCorner);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to move a particular number of rows to a specified position in a given sheet.
   * Checks against particular rules to ascertain that moveRows can be called.
   * If returns `true`, doing [[moveRows]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted and causes side effects by the fact that there is an array inside the selected rows, the target location includes an array or the provided address is invalid.
   *
   * @param {number} sheetId - a sheet number in which the operation will be performed
   * @param {number} startRow - number of the first row to move
   * @param {number} numberOfRows - number of rows to move
   * @param {number} targetRow - row number before which rows will be moved
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return 'true' for this example
   * // it is possible to move one row from row 0 into row 2
   * const isMovable = hfInstance.isItPossibleToMoveRows(0, 0, 1, 2);
   * ```
   *
   * @category Rows
   */
  isItPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(startRow, 'number', 'startRow');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(numberOfRows, 'number', 'numberOfRows');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(targetRow, 'number', 'targetRow');
    try {
      this._crudOperations.ensureItIsPossibleToMoveRows(sheetId, startRow, numberOfRows, targetRow);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Moves a particular number of rows to a specified position in a given sheet.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - a sheet number in which the operation will be performed
   * @param {number} startRow - number of the first row to move
   * @param {number} numberOfRows - number of rows to move
   * @param {number} targetRow - row number before which rows will be moved
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved
   * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1'],
   *  ['2'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values
   * const changes = hfInstance.moveRows(0, 0, 1, 2);
   * ```
   *
   * @category Rows
   */
  moveRows(sheetId, startRow, numberOfRows, targetRow) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(startRow, 'number', 'startRow');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(numberOfRows, 'number', 'numberOfRows');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(targetRow, 'number', 'targetRow');
    this._crudOperations.moveRows(sheetId, startRow, numberOfRows, targetRow);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to move a particular number of columns to a specified position in a given sheet.
   * Checks against particular rules to ascertain that moveColumns can be called.
   * If returns `true`, doing [[moveColumns]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted and causes side effects by the fact that there is an array inside the selected columns, the target location includes an array or the provided address is invalid.
   *
   * @param {number} sheetId - a sheet number in which the operation will be performed
   * @param {number} startColumn - number of the first column to move
   * @param {number} numberOfColumns - number of columns to move
   * @param {number} targetColumn - column number before which columns will be moved
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // should return 'true' for this example
   * // it is possible to move one column from column 1 into column 2 of sheet 0
   * const isMovable = hfInstance.isItPossibleToMoveColumns(0, 1, 1, 2);
   * ```
   *
   * @category Columns
   */
  isItPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(startColumn, 'number', 'startColumn');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(numberOfColumns, 'number', 'numberOfColumns');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(targetColumn, 'number', 'targetColumn');
    try {
      this._crudOperations.ensureItIsPossibleToMoveColumns(sheetId, startColumn, numberOfColumns, targetColumn);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Moves a particular number of columns to a specified position in a given sheet.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - a sheet number in which the operation will be performed
   * @param {number} startColumn - number of the first column to move
   * @param {number} numberOfColumns - number of columns to move
   * @param {number} targetColumn - column number before which columns will be moved
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[InvalidArgumentsError]] when the given arguments are invalid
   * @throws [[SourceLocationHasArrayError]] when the source location has array inside - array cannot be moved
   * @throws [[TargetLocationHasArrayError]] when the target location has array inside - cells cannot be replaced by the array
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2', '3', '=RAND()', '=SUM(A1:C1)'],
   * ]);
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, for this example:
   * // [{
   * //   address: { sheet: 0, col: 1, row: 0 },
   * //   newValue: 0.16210054671639,
   * //  }, {
   * //   address: { sheet: 0, col: 4, row: 0 },
   * //   newValue: 6.16210054671639,
   * // }]
   * const changes = hfInstance.moveColumns(0, 1, 1, 2);
   * ```
   *
   * @category Columns
   */
  moveColumns(sheetId, startColumn, numberOfColumns, targetColumn) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(startColumn, 'number', 'startColumn');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(numberOfColumns, 'number', 'numberOfColumns');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(targetColumn, 'number', 'targetColumn');
    this._crudOperations.moveColumns(sheetId, startColumn, numberOfColumns, targetColumn);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Stores a copy of the cell block in internal clipboard for the further paste.
   * Returns the copied values for use in external clipboard.
   *
   * @param {SimpleCellRange} source - rectangle range to copy
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2'],
   * ]);
   *
   * // it copies [ [ 2 ] ]
   * const clipboardContent = hfInstance.copy({
   *   start: { sheet: 0, col: 1, row: 0 },
   *   end: { sheet: 0, col: 1, row: 0 },
   * });
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  copy(source) {
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(source)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const range = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(source.start, source.end);
    this._crudOperations.copy(range.start, range.width(), range.height());
    return this.getRangeValues(source);
  }
  /**
   * Stores information of the cell block in internal clipboard for further paste.
   * Calling [[paste]] right after this method is equivalent to call [[moveCells]].
   * Almost any CRUD operation called after this method will abort the cut operation.
   * Returns the cut values for use in external clipboard.
   *
   * @param {SimpleCellRange} source - rectangle range to cut
   *
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2'],
   * ]);
   *
   * // returns the values that were cut: [ [ 1 ] ]
   * const clipboardContent = hfInstance.cut({
   *   start: { sheet: 0, col: 0, row: 0 },
   *   end: { sheet: 0, col: 0, row: 0 },
   * });
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  cut(source) {
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(source)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const range = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(source.start, source.end);
    this._crudOperations.cut(range.start, range.width(), range.height());
    return this.getRangeValues(source);
  }
  /**
   * When called after [[copy]] it pastes copied values and formulas into a cell block.
   * When called after [[cut]] it performs [[moveCells]] operation into the cell block.
   * Does nothing if the clipboard is empty.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {SimpleCellAddress} targetLeftCorner - upper left address of the target cell block
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[SheetSizeLimitExceededError]] when performing this operation would result in sheet size limits exceeding
   * @throws [[NothingToPasteError]] when clipboard is empty
   * @throws [[TargetLocationHasArrayError]] when the selected target area has array inside
   * @throws [[ExpectedValueOfTypeError]] if targetLeftCorner is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2'],
   * ]);
   *
   * // [ [ 2 ] ] was copied
   * const clipboardContent = hfInstance.copy({
   *   start: { sheet: 0, col: 1, row: 0 },
   *   end: { sheet: 0, col: 1, row: 0 },
   * });
   *
   * // returns a list of modified cells: their absolute addresses and new values
   * const changes = hfInstance.paste({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  paste(targetLeftCorner) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(targetLeftCorner)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'targetLeftCorner');
    }
    this.ensureEvaluationIsNotSuspended();
    this._crudOperations.paste(targetLeftCorner);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether there is something in the clipboard.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // copy desired content
   * const clipboardContent = hfInstance.copy({
   *   start: { sheet: 0, col: 1, row: 0 },
   *   end: { sheet: 0, col: 1, row: 0 },
   * });
   *
   * // returns 'false', there is content in the clipboard
   * const isClipboardEmpty = hfInstance.isClipboardEmpty();
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  isClipboardEmpty() {
    return this._crudOperations.isClipboardEmpty();
  }
  /**
   * Clears the clipboard content.
   *
   * @example
   * ```js
   * // clears the clipboard, isClipboardEmpty() should return true if called afterwards
   * hfInstance.clearClipboard();
   * ```
   *
   * The usage of the internal clipboard is described thoroughly in the [Clipboard Operations guide](../../guide/clipboard-operations.md).
   *
   * @category Clipboard
   */
  clearClipboard() {
    this._crudOperations.clearClipboard();
  }
  /**
   * Clears the redo stack in undoRedo history.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2', '3'],
   * ]);
   *
   * // do an operation, for example remove columns
   * hfInstance.removeColumns(0, [0, 1]);
   *
   * // undo the operation
   * hfInstance.undo();
   *
   * // redo the operation
   * hfInstance.redo();
   *
   * // clear the redo stack
   * hfInstance.clearRedoStack();
   * ```
   *
   * @category Undo and Redo
   */
  clearRedoStack() {
    this._crudOperations.undoRedo.clearRedoStack();
  }
  /**
   * Clears the undo stack in undoRedo history.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   ['1', '2', '3'],
   * ]);
   *
   * // do an operation, for example remove columns
   * hfInstance.removeColumns(0, [0, 1]);
   *
   * // undo the operation
   * hfInstance.undo();
   *
   * // clear the undo stack
   * hfInstance.clearUndoStack();
   * ```
   *
   * @category Undo and Redo
   */
  clearUndoStack() {
    this._crudOperations.undoRedo.clearUndoStack();
  }
  /**
   * Returns the cell content of a given range in a [[CellValue]][][] format.
   *
   * @param {SimpleCellRange} source - rectangular range
   *
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2)', '2', '10'],
   *  ['5', '6', '7'],
   *  ['40', '30', '20'],
   * ]);
   *
   *
   * // returns calculated cells content: [ [ 3, 2 ], [ 5, 6 ] ]
   * const rangeValues = hfInstance.getRangeValues({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });
   * ```
   *
   * @category Ranges
   */
  getRangeValues(source) {
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(source)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const cellRange = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(source.start, source.end);
    return cellRange.arrayOfAddressesInRange().map(subarray => subarray.map(address => this.getCellValue(address)));
  }
  /**
   * Returns cell formulas in given range.
   *
   * @param {SimpleCellRange} source - rectangular range
   *
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2)', '2', '10'],
   *  ['5', '6', '7'],
   *  ['40', '30', '20'],
   * ]);
   *
   * // returns cell formulas of a given range only:
   * // [ [ '=SUM(1, 2)', undefined ], [ undefined, undefined ] ]
   * const rangeFormulas = hfInstance.getRangeFormulas({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });
   * ```
   *
   * @category Ranges
   */
  getRangeFormulas(source) {
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(source)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const cellRange = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(source.start, source.end);
    return cellRange.arrayOfAddressesInRange().map(subarray => subarray.map(address => this.getCellFormula(address)));
  }
  /**
   * Returns serialized cells in given range.
   *
   * @param {SimpleCellRange} source - rectangular range
   *
   * @throws [[ExpectedValueOfTypeError]] if source is of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2)', '2', '10'],
   *  ['5', '6', '7'],
   *  ['40', '30', '20'],
   * ]);
   *
   * // should return serialized cell content for the given range:
   * // [ [ '=SUM(1, 2)', 2 ], [ 5, 6 ] ]
   * const rangeSerialized = hfInstance.getRangeSerialized({ start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 1 } });
   * ```
   *
   * @category Ranges
   */
  getRangeSerialized(source) {
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(source)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    const cellRange = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(source.start, source.end);
    return cellRange.arrayOfAddressesInRange().map(subarray => subarray.map(address => this.getCellSerialized(address)));
  }
  /**
   * Returns values to fill target range using source range, with properly extending the range using wrap-around heuristic.
   *
   * @param {SimpleCellRange} source of data
   * @param {SimpleCellRange} target range where data is intended to be put
   * @param {boolean} offsetsFromTarget if true, offsets are computed from target corner, otherwise from source corner
   *
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] if source or target are of wrong type
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([[1, '=A1'], ['=$A$1', '2']]);
   *
   * // should return [['2', '=$A$1', '2'], ['=A3', 1, '=C3'], ['2', '=$A$1', '2']]
   * hfInstance.getFillRangeData( {start: {sheet: 0, row: 0, col: 0}, end: {sheet: 0, row: 1, col: 1}},
   * {start: {sheet: 0, row: 1, col: 1}, end: {sheet: 0, row: 3, col: 3}});
   * ```
   *
   * @category Ranges
   */
  getFillRangeData(source, target, offsetsFromTarget = false) {
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(source)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'source');
    }
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(target)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'target');
    }
    const sourceRange = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(source.start, source.end);
    const targetRange = new _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange(target.start, target.end);
    this.ensureEvaluationIsNotSuspended();
    return targetRange.arrayOfAddressesInRange().map(subarray => subarray.map(address => {
      const row = ((address.row - (offsetsFromTarget ? target : source).start.row) % sourceRange.height() + sourceRange.height()) % sourceRange.height() + source.start.row;
      const col = ((address.col - (offsetsFromTarget ? target : source).start.col) % sourceRange.width() + sourceRange.width()) % sourceRange.width() + source.start.col;
      return this._serialization.getCellSerialized({
        row,
        col,
        sheet: sourceRange.sheet
      }, address);
    }));
  }
  /**
   * Returns information whether it is possible to add a sheet to the engine.
   * Checks against particular rules to ascertain that addSheet can be called.
   * If returns `true`, doing [[addSheet]] operation won't throw any errors, and it is possible to add sheet with provided name.
   * Returns `false` if the chosen name is already used.
   *
   * @param {string} sheetName - sheet name, case-insensitive
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'false' because 'MySheet2' already exists
   * const isAddable = hfInstance.isItPossibleToAddSheet('MySheet2');
   * ```
   *
   * @category Sheets
   */
  isItPossibleToAddSheet(sheetName) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetName, 'string', 'sheetName');
    try {
      this._crudOperations.ensureItIsPossibleToAddSheet(sheetName);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Adds a new sheet to the HyperFormula instance. Returns given or autogenerated name of a new sheet.
   *
   * @param {string} [sheetName] - if not specified, name is autogenerated
   *
   * @fires [[sheetAdded]] after the sheet was added
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[SheetNameAlreadyTakenError]] when sheet with a given name already exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'MySheet3'
   * const nameProvided = hfInstance.addSheet('MySheet3');
   *
   * // should return autogenerated 'Sheet4'
   * // because no name was provided and 3 other ones already exist
   * const generatedName = hfInstance.addSheet();
   * ```
   *
   * @category Sheets
   */
  addSheet(sheetName) {
    if (sheetName !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetName, 'string', 'sheetName');
    }
    const addedSheetName = this._crudOperations.addSheet(sheetName);
    this._emitter.emit(_Emitter__WEBPACK_IMPORTED_MODULE_8__.Events.SheetAdded, addedSheetName);
    return addedSheetName;
  }
  /**
   * Returns information whether it is possible to remove sheet for the engine.
   * Returns `true` if the provided sheet exists, and therefore it can be removed, doing [[removeSheet]] operation won't throw any errors.
   * Returns `false` otherwise
   *
   * @param {number} sheetId - sheet ID.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'true' because sheet with ID 1 exists and is removable
   * const isRemovable = hfInstance.isItPossibleToRemoveSheet(1);
   * ```
   *
   * @category Sheets
   */
  isItPossibleToRemoveSheet(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.ensureScopeIdIsValid(sheetId);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Removes a sheet
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID.
   *
   * @fires [[sheetRemoved]] after the sheet was removed
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, in this example it will return:
   * // [{
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: { error: [CellError], value: '#REF!' },
   * // }]
   * const changes = hfInstance.removeSheet(1);
   * ```
   *
   * @category Sheets
   */
  removeSheet(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    const displayName = this.sheetMapping.getDisplayName(sheetId);
    this._crudOperations.removeSheet(sheetId);
    const changes = this.recomputeIfDependencyGraphNeedsIt();
    this._emitter.emit(_Emitter__WEBPACK_IMPORTED_MODULE_8__.Events.SheetRemoved, displayName, changes);
    return changes;
  }
  /**
   * Returns information whether it is possible to clear a specified sheet.
   * If returns `true`, doing [[clearSheet]] operation won't throw any errors, provided sheet exists and its content can be cleared.
   * Returns `false` otherwise
   *
   * @param {number} sheetId - sheet ID.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'true' because 'MySheet2' exists and can be cleared
   * const isClearable = hfInstance.isItPossibleToClearSheet(1);
   * ```
   *
   * @category Sheets
   */
  isItPossibleToClearSheet(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.ensureScopeIdIsValid(sheetId);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Clears the sheet content. Double-checks if the sheet exists.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {number} sheetId - sheet ID.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['=SUM(MySheet2!A1:A2)'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values, in this example it will return:
   * // [{
   * //   address: { sheet: 0, col: 0, row: 0 },
   * //   newValue: 0,
   * // }]
   * const changes = hfInstance.clearSheet(0);
   * ```
   *
   * @category Sheets
   */
  clearSheet(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.clearSheet(sheetId);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to replace the sheet content.
   * If returns `true`, doing [[setSheetContent]] operation won't throw any errors, the provided sheet exists and then its content can be replaced.
   * Returns `false` otherwise
   *
   * @param {number} sheetId - sheet ID.
   * @param {RawCellContent[][]} values - array of new values
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'true' because sheet of ID 0 exists
   * // and the provided content can be placed in this sheet
   * const isReplaceable = hfInstance.isItPossibleToReplaceSheetContent(0, [['50'], ['60']]);
   * ```
   *
   * @category Sheets
   */
  isItPossibleToReplaceSheetContent(sheetId, values) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    try {
      this._crudOperations.ensureScopeIdIsValid(sheetId);
      this._crudOperations.ensureItIsPossibleToChangeSheetContents(sheetId, values);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Replaces the sheet content with new values.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * @param {number} sheetId - sheet ID.
   * @param {RawCellContent[][]} values - array of new values
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[InvalidArgumentsError]] when values argument is not an array of arrays
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return a list of cells which values changed after the operation,
   * // their absolute addresses and new values
   * const changes = hfInstance.setSheetContent(0, [['50'], ['60']]);
   * ```
   *
   * @category Sheets
   */
  setSheetContent(sheetId, values) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.setSheetContent(sheetId, values);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Computes the simple (absolute) address of a cell address, based on its string representation.
   * - If a sheet name is present in the string representation but is not present in the engine, returns `undefined`.
   * - If no sheet name is present in the string representation, returns `contextSheetId` as sheet number.
   *
   * @param {string} cellAddress - string representation of cell address in A1 notation
   * @param {number} contextSheetId - context used in case of missing sheet in the first argument
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   * hfInstance.addSheet('Sheet0'); //sheetId = 0
   *
   * // returns { sheet: 0, col: 0, row: 0 }
   * const simpleCellAddress = hfInstance.simpleCellAddressFromString('A1', 0);
   *
   * // returns { sheet: 0, col: 0, row: 5 }
   * const simpleCellAddress = hfInstance.simpleCellAddressFromString('Sheet1!A6');
   *
   * // returns { sheet: 0, col: 0, row: 5 }
   * const simpleCellAddress = hfInstance.simpleCellAddressFromString('Sheet1!$A$6');
   *
   * // returns 'undefined', as there's no 'Sheet 2' in the HyperFormula instance
   * const simpleCellAddress = hfInstance.simpleCellAddressFromString('Sheet2!A6');
   * ```
   *
   * @category Helpers
   */
  simpleCellAddressFromString(cellAddress, contextSheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(cellAddress, 'string', 'cellAddress');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(contextSheetId, 'number', 'sheetId');
    return (0,_parser__WEBPACK_IMPORTED_MODULE_13__.simpleCellAddressFromString)(this.sheetMapping.get, cellAddress, contextSheetId);
  }
  /**
   * Computes simple (absolute) address of a cell range based on its string representation.
   * If sheet name is present in string representation but not present in the engine, returns `undefined`.
   *
   * @param {string} cellRange - string representation of cell range in A1 notation
   * @param {number} sheetId - context used in case of missing sheet in the first argument
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   * hfInstance.addSheet('Sheet0'); //sheetId = 0
   *
   * // should return { start: { sheet: 0, col: 0, row: 0 }, end: { sheet: 0, col: 1, row: 0 } }
   * const simpleCellAddress = hfInstance.simpleCellRangeFromString('A1:A2', 0);
   * ```
   *
   * @category Helpers
   */
  simpleCellRangeFromString(cellRange, sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(cellRange, 'string', 'cellRange');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    return (0,_parser__WEBPACK_IMPORTED_MODULE_13__.simpleCellRangeFromString)(this.sheetMapping.get, cellRange, sheetId);
  }
  /**
   * Returns string representation of an absolute address in A1 notation or `undefined` if the sheet index is not present in the engine.
   *
   * @param {SimpleCellAddress} cellAddress - object representation of an absolute address
   * @param {number} sheetId - context used in case of missing sheet in the first argument
   *
   * @throws [[ExpectedValueOfTypeError]] if its arguments are of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   * hfInstance.addSheet('Sheet0'); //sheetId = 0
   *
   * // should return 'B2'
   * const A1Notation = hfInstance.simpleCellAddressToString({ sheet: 0, col: 1, row: 1 }, 0);
   * ```
   *
   * @category Helpers
   */
  simpleCellAddressToString(cellAddress, sheetId) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    return (0,_parser__WEBPACK_IMPORTED_MODULE_13__.simpleCellAddressToString)(this.sheetMapping.fetchDisplayName, cellAddress, sheetId);
  }
  /**
   * Returns string representation of an absolute range in A1 notation or `undefined` if the sheet index is not present in the engine.
   *
   * Note: This method is useful only for cell ranges; does not work with column ranges and row ranges.
   *
   * @param {SimpleCellRange} cellRange - object representation of an absolute range
   * @param {number} sheetId - context used in case of missing sheet in the first argument
   *
   * @throws [[ExpectedValueOfTypeError]] if its arguments are of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   * hfInstance.addSheet('Sheet0'); //sheetId = 0
   * hfInstance.addSheet('Sheet1'); //sheetId = 1
   *
   * // should return 'B2:C2'
   * const A1Notation = hfInstance.simpleCellRangeToString({ start: { sheet: 0, col: 1, row: 1 }, end: { sheet: 0, col: 2, row: 1 } }, 0);
   *
   *  // should return 'Sheet1!B2:C2'
   * const another = hfInstance.simpleCellRangeToString({ start: { sheet: 1, col: 1, row: 1 }, end: { sheet: 1, col: 2, row: 1 } }, 0);
   * ```
   *
   * @category Helpers
   */
  simpleCellRangeToString(cellRange, sheetId) {
    if (!(0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(cellRange)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellRange', 'cellRange');
    }
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    return (0,_parser__WEBPACK_IMPORTED_MODULE_13__.simpleCellRangeToString)(this.sheetMapping.fetchDisplayName, cellRange, sheetId);
  }
  /**
   * Returns all the out-neighbors in the [dependency graph](../../guide/dependency-graph.md) for a given cell address or range. Including:
   * - All cells with formulas that contain the given cell address or range
   * - Some of the ranges that contain the given cell address or range
   *
   * The exact result depends on the optimizations applied by the HyperFormula to the dependency graph, some of which are described in the section ["Optimizations for large ranges"](../../guide/dependency-graph.md#optimizations-for-large-ranges).
   *
   * The returned array includes also named expression dependents. They are represented as cell references with sheet ID `-1`.
   *
   * @param {SimpleCellAddress | SimpleCellRange} address - object representation of an absolute address or range of addresses
   *
   * @throws [[ExpectedValueOfTypeError]] if address is not [[SimpleCellAddress]] or [[SimpleCellRange]]
   * @throws [[SheetsNotEqual]] if range provided has distinct sheet numbers for start and end
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );
   *
   * hfInstance.getCellDependents({ sheet: 0, col: 0, row: 0});
   * // returns [{ sheet: 0, col: 1, row: 0}, { sheet: 0, col: 2, row: 0}]
   * ```
   *
   * @category Helpers
   */
  getCellDependents(address) {
    let vertex;
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(address)) {
      vertex = this._dependencyGraph.addressMapping.getCell(address);
    } else if ((0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(address)) {
      vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);
    } else {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', address);
    }
    if (vertex === undefined) {
      return [];
    }
    return this._dependencyGraph.getAdjacentNodesAddresses(vertex);
  }
  /**
   * Returns all the in-neighbors in the [dependency graph](../../guide/dependency-graph.md) for a given cell address or range. In particular:
   * - If the argument is a single cell, `getCellPrecedents()` returns all cells and ranges contained in that cell's formula.
   * - If the argument is a range of cells, `getCellPrecedents()` returns some of the cell addresses and smaller ranges contained in that range (but not all of them). The exact result depends on the optimizations applied by the HyperFormula to the dependency graph, some of which are described in the section ["Optimizations for large ranges"](../../guide/dependency-graph.md#optimizations-for-large-ranges).
   *
   * The returned array includes also named expression precedents. They are represented as cell references with sheet ID `-1`.
   *
   * @param {SimpleCellAddress | SimpleCellRange} address - object representation of an absolute address or range of addresses
   *
   * @throws [[ExpectedValueOfTypeError]] if address is of wrong type
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray( [ ['1', '=A1', '=A1+B1'] ] );
   *
   * hfInstance.getCellPrecedents({ sheet: 0, col: 2, row: 0});
   * // returns [{ sheet: 0, col: 0, row: 0}, { sheet: 0, col: 1, row: 0}]
   * ```
   *
   * @category Helpers
   */
  getCellPrecedents(address) {
    let vertex;
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(address)) {
      vertex = this._dependencyGraph.addressMapping.getCell(address);
    } else if ((0,_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.isSimpleCellRange)(address)) {
      vertex = this._dependencyGraph.rangeMapping.getRange(address.start, address.end);
    } else {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress | SimpleCellRange', address);
    }
    if (vertex === undefined) {
      return [];
    }
    return this._dependencyGraph.dependencyQueryAddresses(vertex);
  }
  /**
   * Returns a unique sheet name assigned to the sheet of a given ID or `undefined` if the there is no sheet with a given ID.
   *
   * @param {number} sheetId - ID of the sheet, for which we want to retrieve name
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'MySheet2' as this sheet is the second one
   * const sheetName = hfInstance.getSheetName(1);
   * ```
   *
   * @category Sheets
   */
  getSheetName(sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    return this.sheetMapping.getDisplayName(sheetId);
  }
  /**
   * List all sheet names.
   * Returns an array of sheet names as strings.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // should return all sheets names: ['MySheet1', 'MySheet2']
   * const sheetNames = hfInstance.getSheetNames();
   * ```
   *
   * @category Sheets
   */
  getSheetNames() {
    return this.sheetMapping.sheetNames();
  }
  /**
   * Returns a unique sheet ID assigned to the sheet with a given name or `undefined` if the sheet does not exist.
   *
   * @param {string} sheetName - name of the sheet, for which we want to retrieve ID, case-insensitive.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // should return '0' because 'MySheet1' is of ID '0'
   * const sheetID = hfInstance.getSheetId('MySheet1');
   * ```
   *
   * @category Sheets
   */
  getSheetId(sheetName) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetName, 'string', 'sheetName');
    return this.sheetMapping.get(sheetName);
  }
  /**
   * Returns `true` whether sheet with a given name exists. The method accepts sheet name to be checked.
   *
   * @param {string} sheetName - name of the sheet, case-insensitive.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // should return 'true' since 'MySheet1' exists
   * const sheetExist = hfInstance.doesSheetExist('MySheet1');
   * ```
   *
   * @category Sheets
   */
  doesSheetExist(sheetName) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetName, 'string', 'sheetName');
    return this.sheetMapping.hasSheetWithName(sheetName);
  }
  /**
   * Returns the type of a cell at a given address.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(A2:A3)', '2'],
   * ]);
   *
   * // should return 'FORMULA', the cell of given coordinates is of this type
   * const cellA1Type = hfInstance.getCellType({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'VALUE', the cell of given coordinates is of this type
   * const cellB1Type = hfInstance.getCellType({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellType(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    const vertex = this.dependencyGraph.getCell(cellAddress);
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.getCellType)(vertex, cellAddress);
  }
  /**
   * Returns `true` if the specified cell contains a simple value.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(A2:A3)', '2'],
   * ]);
   *
   * // should return 'true' since the selected cell contains a simple value
   * const isA1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'false' since the selected cell does not contain a simple value
   * const isB1Simple = hfInstance.doesCellHaveSimpleValue({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  doesCellHaveSimpleValue(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    return this.getCellType(cellAddress) === _Cell__WEBPACK_IMPORTED_MODULE_3__.CellType.VALUE;
  }
  /**
   * Returns `true` if the specified cell contains a formula.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(A2:A3)', '2'],
   * ]);
   *
   * // should return 'true' since the A1 cell contains a formula
   * const A1Formula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'false' since the B1 cell does not contain a formula
   * const B1NoFormula = hfInstance.doesCellHaveFormula({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  doesCellHaveFormula(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    const cellType = this.getCellType(cellAddress);
    return cellType === _Cell__WEBPACK_IMPORTED_MODULE_3__.CellType.FORMULA || cellType === _Cell__WEBPACK_IMPORTED_MODULE_3__.CellType.ARRAYFORMULA;
  }
  /**
   * Returns`true` if the specified cell is empty.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *   [null, '1'],
   * ]);
   *
   * // should return 'true', cell of provided coordinates is empty
   * const isEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'false', cell of provided coordinates is not empty
   * const isNotEmpty = hfInstance.isCellEmpty({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  isCellEmpty(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    return this.getCellType(cellAddress) === _Cell__WEBPACK_IMPORTED_MODULE_3__.CellType.EMPTY;
  }
  /**
   * Returns `true` if a given cell is a part of an array.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *    ['{=TRANSPOSE(B1:B1)}'],
   * ]);
   *
   * // should return 'true', cell of provided coordinates is a part of an array
   * const isPartOfArray = hfInstance.isCellPartOfArray({ sheet: 0, col: 0, row: 0 });
   * ```
   *
   * @category Cells
   */
  isCellPartOfArray(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    const cellType = this.getCellType(cellAddress);
    return cellType === _Cell__WEBPACK_IMPORTED_MODULE_3__.CellType.ARRAY || cellType === _Cell__WEBPACK_IMPORTED_MODULE_3__.CellType.ARRAYFORMULA;
  }
  /**
   * Returns type of the cell value of a given address.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['=SUM(1, 2, 3)', '2'],
   * ]);
   *
   * // should return 'NUMBER', cell value type of provided coordinates is a number
   * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 1, row: 0 });
   *
   * // should return 'NUMBER', cell value type of provided coordinates is a number
   * const cellValue = hfInstance.getCellValueType({ sheet: 0, col: 0, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellValueType(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    const value = this.dependencyGraph.getCellValue(cellAddress);
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.getCellValueType)(value);
  }
  /**
   * Returns detailed type of the cell value of a given address.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1%', '1$'],
   * ]);
   *
   * // should return 'NUMBER_PERCENT', cell value type of provided coordinates is a number with a format inference percent.
   * const cellType = hfInstance.getCellValueDetailedType({ sheet: 0, col: 0, row: 0 });
   *
   * // should return 'NUMBER_CURRENCY', cell value type of provided coordinates is a number with a format inference currency.
   * const cellType = hfInstance.getCellValueDetailedType({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellValueDetailedType(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    const value = this.dependencyGraph.getCellValue(cellAddress);
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.getCellValueDetailedType)(value);
  }
  /**
   * Returns auxiliary format information of the cell value of a given address.
   * The method accepts cell coordinates as object with column, row and sheet numbers.
   *
   * @param {SimpleCellAddress} cellAddress - cell coordinates
   *
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[EvaluationSuspendedError]] when the evaluation is suspended
   * @throws [[ExpectedValueOfTypeError]] if cellAddress is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1$', '1'],
   * ]);
   *
   * // should return '$', cell value type of provided coordinates is a number with a format inference currency, parsed as using '$' as currency.
   * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 0, row: 0 });
   *
   * // should return undefined, cell value type of provided coordinates is a number with no format information.
   * const cellFormat = hfInstance.getCellValueFormat({ sheet: 0, col: 1, row: 0 });
   * ```
   *
   * @category Cells
   */
  getCellValueFormat(cellAddress) {
    if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.isSimpleCellAddress)(cellAddress)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.ExpectedValueOfTypeError('SimpleCellAddress', 'cellAddress');
    }
    this.ensureEvaluationIsNotSuspended();
    const value = this.dependencyGraph.getCellValue(cellAddress);
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.getCellValueFormat)(value);
  }
  /**
   * Returns the number of existing sheets.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['1', '2'],
   * ]);
   *
   * // should return the number of sheets which is '1'
   * const sheetsCount = hfInstance.countSheets();
   * ```
   *
   * @category Sheets
   */
  countSheets() {
    return this.sheetMapping.numberOfSheets();
  }
  /**
   * Returns information whether it is possible to rename sheet.
   * Returns `true` if the sheet with provided id exists and new name is available
   * Returns `false` if sheet cannot be renamed
   *
   * @param {number} sheetId - a sheet number
   * @param {string} newName - a name of the sheet to be given
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // returns true
   * hfInstance.isItPossibleToRenameSheet(0, 'MySheet0');
   * ```
   *
   * @category Sheets
   */
  isItPossibleToRenameSheet(sheetId, newName) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(newName, 'string', 'newName');
    try {
      this._crudOperations.ensureItIsPossibleToRenameSheet(sheetId, newName);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Renames a specified sheet.
   *
   * @param {number} sheetId - a sheet ID
   * @param {string} newName - a name of the sheet to be given, if is the same as the old one the method does nothing
   *
   * @fires [[sheetRenamed]] after the sheet was renamed
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] when the given sheet ID does not exist
   * @throws [[SheetNameAlreadyTakenError]] when the provided sheet name already exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *   MySheet1: [ ['1'] ],
   *   MySheet2: [ ['10'] ],
   * });
   *
   * // renames the sheet 'MySheet1'
   * hfInstance.renameSheet(0, 'MySheet0');
   * ```
   *
   * @category Sheets
   */
  renameSheet(sheetId, newName) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(newName, 'string', 'newName');
    const oldName = this._crudOperations.renameSheet(sheetId, newName);
    if (oldName !== undefined) {
      this._emitter.emit(_Emitter__WEBPACK_IMPORTED_MODULE_8__.Events.SheetRenamed, oldName, newName);
    }
  }
  /**
   * Runs the provided callback as a single [batch operation](../../guide/batch-operations.md) and returns the changed cells.
   *
   * Returns [an array of cells whose values changed as a result of all batched operations](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {() => void} batchOperations - a function with operations to be performed
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   * @fires [[evaluationSuspended]] always
   * @fires [[evaluationResumed]] after the recomputation of necessary values
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // multiple operations in a single callback will trigger evaluation only once
   * // and only one set of changes is returned as a combined result of all
   * // the operations that were triggered within the callback
   * const changes = hfInstance.batch(() => {
   *  hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);
   *  hfInstance.setCellContents({ col: 4, row: 0, sheet: 0 }, [['=A1']]);
   * });
   * ```
   *
   * @category Batch
   */
  batch(batchOperations) {
    this.suspendEvaluation();
    this._crudOperations.beginUndoRedoBatchMode();
    try {
      batchOperations();
    } catch (e) {
      this._crudOperations.commitUndoRedoBatchMode();
      this.resumeEvaluation();
      throw e;
    }
    this._crudOperations.commitUndoRedoBatchMode();
    return this.resumeEvaluation();
  }
  /**
   * Suspends the dependency graph recalculation to start a [batch operation](../../guide/batch-operations.md).
   * It allows optimizing the performance.
   * With this method, multiple CRUD operations can be done without triggering recalculation after every operation.
   * Suspending evaluation should result in an overall faster calculation compared to recalculating after each operation separately.
   * To resume the evaluation use [[resumeEvaluation]].
   *
   * @fires [[evaluationSuspended]] always
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // similar to batch() but operations are not within a callback,
   * // one method suspends the recalculation
   * // the second will resume calculations and return the changes
   *
   * // suspend the evaluation with this method
   * hfInstance.suspendEvaluation();
   *
   * // perform operations
   * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);
   * hfInstance.setSheetContent(1, [['50'], ['60']]);
   *
   * // use resumeEvaluation to resume
   * const changes = hfInstance.resumeEvaluation();
   * ```
   *
   * @category Batch
   */
  suspendEvaluation() {
    this._evaluationSuspended = true;
    this._emitter.emit(_Emitter__WEBPACK_IMPORTED_MODULE_8__.Events.EvaluationSuspended);
  }
  /**
   * Resumes the dependency graph recalculation that was [suspended](../../guide/batch-operations.md) with [[suspendEvaluation]].
   * It also triggers the recalculation and returns [an array of cells whose values changed as a result of all batched operations](/guide/basic-operations.md#changes-array).
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   * @fires [[evaluationResumed]] after the recomputation of necessary values
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  MySheet1: [ ['1'] ],
   *  MySheet2: [ ['10'] ],
   * });
   *
   * // similar to batch() but operations are not within a callback,
   * // one method suspends the recalculation
   * // the second will resume calculations and return the changes
   *
   * // first, suspend the evaluation
   * hfInstance.suspendEvaluation();
   *
   * // perform operations
   * hfInstance.setCellContents({ col: 3, row: 0, sheet: 0 }, [['=B1']]);
   * hfInstance.setSheetContent(1, [['50'], ['60']]);
   *
   * // resume the evaluation
   * const changes = hfInstance.resumeEvaluation();
   * ```
   *
   * @category Batch
   */
  resumeEvaluation() {
    this._evaluationSuspended = false;
    const changes = this.recomputeIfDependencyGraphNeedsIt();
    this._emitter.emit(_Emitter__WEBPACK_IMPORTED_MODULE_8__.Events.EvaluationResumed, changes);
    return changes;
  }
  /**
   * Checks if the dependency graph recalculation process is [suspended](../../guide/batch-operations.md) or not.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // suspend the evaluation
   * hfInstance.suspendEvaluation();
   *
   * // between suspendEvaluation() and resumeEvaluation()
   * // or inside batch() callback it will return 'true', otherwise 'false'
   * const isEvaluationSuspended = hfInstance.isEvaluationSuspended();
   *
   * const changes = hfInstance.resumeEvaluation();
   * ```
   *
   * @category Batch
   */
  isEvaluationSuspended() {
    return this._evaluationSuspended;
  }
  /**
   * Returns information whether it is possible to add named expression into a specific scope.
   * Checks against particular rules to ascertain that addNamedExpression can be called.
   * If returns `true`, doing [[addNamedExpression]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted.
   *
   * @param {string} expressionName - a name of the expression to be added
   * @param {RawCellContent} expression - the expression
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // should return 'true' for this example,
   * // it is possible to add named expression to global scope
   * const isAddable = hfInstance.isItPossibleToAddNamedExpression('prettyName', '=Sheet1!$A$1+100');
   * ```
   *
   * @category Named Expressions
   */
  isItPossibleToAddNamedExpression(expressionName, expression, scope) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    try {
      this._crudOperations.ensureItIsPossibleToAddNamedExpression(expressionName, expression, scope);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Adds a specified named expression.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {string} expressionName - a name of the expression to be added
   * @param {RawCellContent} expression - the expression
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   * @param {NamedExpressionOptions?} options - additional metadata related to named expression
   *
   * @fires [[namedExpressionAdded]] always, unless [[batch]] mode is used
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NamedExpressionNameIsAlreadyTakenError]] when the named-expression name is not available.
   * @throws [[NamedExpressionNameIsInvalidError]] when the named-expression name is not valid
   * @throws [[NoRelativeAddressesAllowedError]] when the named-expression formula contains relative references
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add own expression, scope limited to 'Sheet1' (sheetId=0), the method should return a list of cells which values
   * // changed after the operation, their absolute addresses and new values
   * // for this example:
   * // [{
   * //   name: 'prettyName',
   * //   newValue: 142,
   * // }]
   * const changes = hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   * ```
   *
   * @category Named Expressions
   */
  addNamedExpression(expressionName, expression, scope, options) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    this._crudOperations.addNamedExpression(expressionName, expression, scope, options);
    const changes = this.recomputeIfDependencyGraphNeedsIt();
    this._emitter.emit(_Emitter__WEBPACK_IMPORTED_MODULE_8__.Events.NamedExpressionAdded, expressionName, changes);
    return changes;
  }
  /**
   * Gets specified named expression value.
   * Returns a [[CellValue]] or undefined if the given named expression does not exist.
   *
   * @param {string} expressionName - expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression, only 'Sheet1' (sheetId=0) considered as it is the scope
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 'Sheet1');
   *
   * // returns the calculated value of a passed named expression, '142' for this example
   * const myFormula = hfInstance.getNamedExpressionValue('prettyName', 'Sheet1');
   * ```
   *
   * @category Named Expressions
   */
  getNamedExpressionValue(expressionName, scope) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    this.ensureEvaluationIsNotSuspended();
    this._crudOperations.ensureScopeIdIsValid(scope);
    const namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);
    if (namedExpression) {
      return this._serialization.getCellValue(namedExpression.address);
    } else {
      return undefined;
    }
  }
  /**
   * Returns a normalized formula string for given named expression, or `undefined` for a named expression that does not exist or does not hold a formula.
   *
   * @param {string} expressionName - expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression in 'Sheet1' (sheetId=0)
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   *
   * // returns a normalized formula string corresponding to the passed name from 'Sheet1' (sheetId=0),
   * // '=Sheet1!A1+100' for this example
   * const myFormula = hfInstance.getNamedExpressionFormula('prettyName', 0);
   * ```
   *
   * @category Named Expressions
   */
  getNamedExpressionFormula(expressionName, scope) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    this._crudOperations.ensureScopeIdIsValid(scope);
    const namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);
    if (namedExpression === undefined) {
      return undefined;
    } else {
      return this._serialization.getCellFormula(namedExpression.address);
    }
  }
  /**
   * Returns a named expression, or `undefined` for a named expression that does not exist or does not hold a formula.
   *
   * @param {string} expressionName - expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression in 'Sheet1' (sheetId=0)
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   *
   * // returns a named expression that corresponds to the passed name from 'Sheet1' (sheetId=0)
   * // for this example, returns:
   * // {name: 'prettyName', expression: '=Sheet1!$A$1+100', options: undefined, scope: 0}
   * const myFormula = hfInstance.getNamedExpression('prettyName', 0);
   *
   * // for a named expression that doesn't exist, returns 'undefined':
   * const myFormulaTwo = hfInstance.getNamedExpression('uglyName', 0);
   * ```
   *
   * @category Named Expressions
   */
  getNamedExpression(expressionName, scope) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    const namedExpression = this._namedExpressions.namedExpressionForScope(expressionName, scope);
    if (namedExpression === undefined) {
      return undefined;
    }
    const expression = this._serialization.getCellFormula(namedExpression.address);
    return {
      name: expressionName,
      scope: scope,
      expression: expression,
      options: namedExpression.options
    };
  }
  /**
   * Returns information whether it is possible to change named expression in a specific scope.
   * Checks against particular rules to ascertain that changeNamedExpression can be called.
   * If returns `true`, doing [[changeNamedExpression]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted.
   *
   * @param {string} expressionName - an expression name, case-insensitive.
   * @param {RawCellContent} newExpression - a new expression
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');
   *
   * // should return 'true' for this example,
   * // it is possible to change named expression
   * const isAddable = hfInstance.isItPossibleToChangeNamedExpression('prettyName', '=Sheet1!$A$1+100');
   * ```
   *
   * @category Named Expressions
   */
  isItPossibleToChangeNamedExpression(expressionName, newExpression, scope) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    try {
      this._crudOperations.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, scope);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Changes a given named expression to a specified formula.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {string} expressionName - an expression name, case-insensitive.
   * @param {RawCellContent} newExpression - a new expression
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   * @param {NamedExpressionOptions?} options - additional metadata related to named expression
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   * @throws [[ArrayFormulasNotSupportedError]] when the named expression formula is an array formula
   * @throws [[NoRelativeAddressesAllowedError]] when the named expression formula contains relative references
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression, scope limited to 'Sheet1' (sheetId=0)
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   *
   * // change the named expression
   * const changes = hfInstance.changeNamedExpression('prettyName', '=Sheet1!$A$1+200');
   * ```
   *
   * @category Named Expressions
   */
  changeNamedExpression(expressionName, newExpression, scope, options) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    this._crudOperations.changeNamedExpressionExpression(expressionName, scope, newExpression, options);
    return this.recomputeIfDependencyGraphNeedsIt();
  }
  /**
   * Returns information whether it is possible to remove named expression from a specific scope.
   * Checks against particular rules to ascertain that removeNamedExpression can be called.
   * If returns `true`, doing [[removeNamedExpression]] operation won't throw any errors.
   * Returns `false` if the operation might be disrupted.
   *
   * @param {string} expressionName - an expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');
   *
   * // should return 'true' for this example,
   * // it is possible to change named expression
   * const isAddable = hfInstance.isItPossibleToRemoveNamedExpression('prettyName');
   * ```
   *
   * @category Named Expressions
   */
  isItPossibleToRemoveNamedExpression(expressionName, scope) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    try {
      this._crudOperations.isItPossibleToRemoveNamedExpression(expressionName, scope);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Removes a named expression.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @param {string} expressionName - expression name, case-insensitive.
   * @param {number?} scope - scope definition, `sheetId` for local scope or `undefined` for global scope
   *
   * @fires [[namedExpressionRemoved]] after the expression was removed
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NamedExpressionDoesNotExistError]] when the given expression does not exist.
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   * ]);
   *
   * // add a named expression
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100', 0);
   *
   * // remove the named expression
   * const changes = hfInstance.removeNamedExpression('prettyName', 0);
   * ```
   *
   * @category Named Expressions
   */
  removeNamedExpression(expressionName, scope) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(expressionName, 'string', 'expressionName');
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    const removedNamedExpression = this._crudOperations.removeNamedExpression(expressionName, scope);
    if (removedNamedExpression) {
      const changes = this.recomputeIfDependencyGraphNeedsIt();
      this._emitter.emit(_Emitter__WEBPACK_IMPORTED_MODULE_8__.Events.NamedExpressionRemoved, removedNamedExpression.displayName, changes);
      return changes;
    } else {
      return []; // codecov note: this does not look possible - removeNamedExpression() will throw if the named expression cannot be found
    }
  }
  /**
   * Lists named expressions.
   * - If scope parameter is provided, returns an array of expression names defined for this scope.
   * - If scope parameter is undefined, returns an array of global expression names.
   *
   * @param {number?} scope - scope of the named expressions, `sheetId` for local scope or `undefined` for global scope
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NoSheetWithIdError]] if no sheet with given sheetId exists
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   *  ['50'],
   *  ['60'],
   * ]);
   *
   * // add two named expressions and one scoped
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');
   * hfInstance.addNamedExpression('anotherPrettyName', '=Sheet1!$A$2+100');
   * hfInstance.addNamedExpression('alsoPrettyName', '=Sheet1!$A$3+100', 0);
   *
   * // list the expressions, should return: ['prettyName', 'anotherPrettyName'] for this example
   * const listOfExpressions = hfInstance.listNamedExpressions();
   *
   *  // list the expressions, should return: ['alsoPrettyName'] for this example
   * const listOfExpressions = hfInstance.listNamedExpressions(0);
   * ```
   *
   * @category Named Expressions
   */
  listNamedExpressions(scope) {
    if (scope !== undefined) {
      (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(scope, 'number', 'scope');
    }
    this._crudOperations.ensureScopeIdIsValid(scope);
    return this._namedExpressions.getAllNamedExpressionsNamesInScope(scope);
  }
  /**
   * Returns all named expressions serialized.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   *  ['50'],
   *  ['60'],
   * ]);
   *
   * // add two named expressions and one scoped
   * hfInstance.addNamedExpression('prettyName', '=Sheet1!$A$1+100');
   * hfInstance.addNamedExpression('anotherPrettyName', '=Sheet1!$A$2+100');
   * hfInstance.addNamedExpression('prettyName3', '=Sheet1!$A$3+100', 0);
   *
   * // get all expressions serialized
   * // should return:
   * // [
   * // {name: 'prettyName', expression: '=Sheet1!$A$1+100', options: undefined, scope: undefined},
   * // {name: 'anotherPrettyName', expression: '=Sheet1!$A$2+100', options: undefined, scope: undefined},
   * // {name: 'alsoPrettyName', expression: '=Sheet1!$A$3+100', options: undefined, scope: 0}
   * // ]
   * const allExpressions = hfInstance.getAllNamedExpressionsSerialized();
   * ```
   *
   * @category Named Expressions
   */
  getAllNamedExpressionsSerialized() {
    return this._serialization.getAllNamedExpressionsSerialized();
  }
  /**
   * Parses and then unparses a formula.
   * Returns a normalized formula (e.g., restores the original capitalization of sheet names, function names, cell addresses, and named expressions).
   *
   * @param {string} formulaString - a formula in a proper format - it must start with "="
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   * @throws [[NotAFormulaError]] when the provided string is not a valid formula, i.e., does not start with "="
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromArray([
   *  ['42'],
   *  ['50'],
   * ]);
   *
   * // returns '=Sheet1!$A$1+10'
   * const normalizedFormula = hfInstance.normalizeFormula('=SHEET1!$A$1+10');
   *
   * // returns '=3*$A$1'
   * const normalizedFormula = hfInstance.normalizeFormula('=3*$a$1');
   * ```
   *
   * @category Helpers
   */
  normalizeFormula(formulaString) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(formulaString, 'string', 'formulaString');
    const {
      ast,
      address
    } = this.extractTemporaryFormula(formulaString);
    if (ast === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.NotAFormulaError();
    }
    return this._unparser.unparse(ast, address);
  }
  /**
   * Calculates fire-and-forget formula, returns the calculated value.
   *
   * @param {string} formulaString - A formula in a proper format, starting with `=`.
   * @param {number} sheetId - The ID of a sheet in context of which the formula gets evaluated.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type arguments is of wrong type.
   * @throws [[NotAFormulaError]] when the provided string is not a valid formula (i.e., doesn't start with `=`).
   * @throws [[NoSheetWithIdError]] when the provided `sheetID` doesn't exist.
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildFromSheets({
   *  Sheet1: [['58']],
   *  Sheet2: [['1', '2', '3'], ['4', '5', '6']]
   * });
   *
   * // returns the calculated formula's value
   * // for this example, returns `68`
   * const calculatedFormula = hfInstance.calculateFormula('=A1+10', 0);
   *
   * // for this example, returns [['11', '12', '13'], ['14', '15', '16']]
   * const calculatedFormula = hfInstance.calculateFormula('=A1:B3+10', 1);
   * ```
   *
   * @category Helpers
   */
  calculateFormula(formulaString, sheetId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(formulaString, 'string', 'formulaString');
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(sheetId, 'number', 'sheetId');
    this._crudOperations.ensureScopeIdIsValid(sheetId);
    const {
      ast,
      address,
      dependencies
    } = this.extractTemporaryFormula(formulaString, sheetId);
    if (ast === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.NotAFormulaError();
    }
    const internalCellValue = this.evaluator.runAndForget(ast, address, dependencies);
    return this._exporter.exportScalarOrRange(internalCellValue);
  }
  /**
   * Return a list of named expressions used by a formula.
   *
   * @param {string} formulaString - A formula in a proper format, starting with `=`.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type arguments is of wrong type.
   * @throws [[NotAFormulaError]] when the provided string is not a valid formula (i.e., doesn't start with `=`).
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // returns a list of named expressions used by a formula
   * // for this example, returns ['foo', 'bar']
   * const namedExpressions = hfInstance.getNamedExpressionsFromFormula('=foo+bar*2');
   * ```
   *
   * @category Helpers
   */
  getNamedExpressionsFromFormula(formulaString) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(formulaString, 'string', 'formulaString');
    const {
      ast,
      dependencies
    } = this.extractTemporaryFormula(formulaString);
    if (ast === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.NotAFormulaError();
    }
    const namedExpressionDependencies = dependencies.filter(dep => dep instanceof _parser__WEBPACK_IMPORTED_MODULE_13__.NamedExpressionDependency).map(namedExpr => namedExpr.name);
    const uniqueNamedExpressionDependencies = [...new Set(namedExpressionDependencies)];
    return uniqueNamedExpressionDependencies;
  }
  /**
   * Validates the formula.
   * If the provided string starts with "=" and is a parsable formula, the method returns `true`.
   * The validation is purely grammatical: the method doesn't verify if the formula can be calculated or not.
   *
   * @param {string} formulaString -  a formula in a proper format - it must start with "="
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // checks if the given string is a valid formula, should return 'true' for this example
   * const isFormula = hfInstance.validateFormula('=SUM(1, 2)');
   * ```
   *
   * @category Helpers
   */
  validateFormula(formulaString) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(formulaString, 'string', 'formulaString');
    const {
      ast
    } = this.extractTemporaryFormula(formulaString);
    return ast !== undefined;
  }
  /**
   * Returns translated names of all functions registered in this instance of HyperFormula
   * according to the language set in the configuration
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // return translated names of all functions, assign to a variable
   * const allNames = hfInstance.getRegisteredFunctionNames();
   * ```
   *
   * @category Custom Functions
   */
  getRegisteredFunctionNames() {
    const language = HyperFormula.getLanguage(this._config.language);
    return language.getFunctionTranslations(this._functionRegistry.getRegisteredFunctionIds());
  }
  /**
   * Returns class of a plugin used by function with given id
   *
   * @param {string} functionId - id of a function, e.g., 'SUMIF'
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * // import your own plugin
   * import { MyExamplePlugin } from './file_with_your_plugin';
   *
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // register a plugin
   * HyperFormula.registerFunctionPlugin(MyExamplePlugin);
   *
   * // get the plugin
   * const myPlugin = hfInstance.getFunctionPlugin('EXAMPLE');
   * ```
   *
   * @category Custom Functions
   */
  getFunctionPlugin(functionId) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(functionId, 'string', 'functionId');
    return this._functionRegistry.getFunctionPlugin(functionId);
  }
  /**
   * Returns classes of all plugins registered in this instance of HyperFormula
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // return classes of all plugins registered, assign to a variable
   * const allNames = hfInstance.getAllFunctionPlugins();
   * ```
   *
   * @category Custom Functions
   */
  getAllFunctionPlugins() {
    return this._functionRegistry.getPlugins();
  }
  /**
   * Interprets number as a date + time.
   *
   * @param {number} inputNumber - number of days since nullDate, should be non-negative, fractions are interpreted as hours/minutes/seconds.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // pass the number of days since nullDate
   * // the method should return formatted date and time, for this example:
   * // {year: 2020, month: 1, day: 15, hours: 2, minutes: 24, seconds: 0}
   * const dateTimeFromNumber = hfInstance.numberToDateTime(43845.1);
   *
   * ```
   *
   * @category Helpers
   */
  numberToDateTime(inputNumber) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(inputNumber, 'number', 'val');
    return this._evaluator.interpreter.dateTimeHelper.numberToSimpleDateTime(inputNumber);
  }
  /**
   * Interprets number as a date.
   *
   * @param {number} inputNumber - number of days since nullDate, should be non-negative, fractions are ignored.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // pass the number of days since nullDate
   * // the method should return formatted date, for this example:
   * // {year: 2020, month: 1, day: 15}
   * const dateFromNumber = hfInstance.numberToDate(43845);
   * ```
   *
   * @category Helpers
   */
  numberToDate(inputNumber) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(inputNumber, 'number', 'val');
    return this._evaluator.interpreter.dateTimeHelper.numberToSimpleDate(inputNumber);
  }
  /**
   * Interprets number as a time (hours/minutes/seconds).
   *
   * @param {number} inputNumber - time in 24h units.
   *
   * @throws [[ExpectedValueOfTypeError]] if any of its basic type argument is of wrong type
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // pass a number to be interpreted as a time
   * // should return {hours: 26, minutes: 24} for this example
   * const timeFromNumber = hfInstance.numberToTime(1.1);
   * ```
   *
   * @category Helpers
   */
  numberToTime(inputNumber) {
    (0,_ArgumentSanitization__WEBPACK_IMPORTED_MODULE_1__.validateArgToType)(inputNumber, 'number', 'val');
    return (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_6__.numberToSimpleTime)(inputNumber);
  }
  /**
   * Subscribes to an event.
   * For the list of all available events, see [[Listeners]].
   *
   * @param {Event} event the name of the event to subscribe to
   * @param {Listener} listener to be called when event is emitted
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // subscribe to a 'sheetAdded', pass a simple handler
   * hfInstance.on('sheetAdded', ( ) => { console.log('foo') });
   *
   * // add a sheet to trigger an event,
   * // console should print 'foo' after each time sheet is added in this example
   * hfInstance.addSheet('FooBar');
   * ```
   *
   * @category Events
   */
  on(event, listener) {
    this._emitter.on(event, listener);
  }
  /**
   * Subscribes to an event once.
   * For the list of all available events, see [[Listeners]].
   *
   * @param {Event} event the name of the event to subscribe to
   * @param {Listener} listener to be called when event is emitted
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // subscribe to a 'sheetAdded', pass a simple handler
   * hfInstance.once('sheetAdded', ( ) => { console.log('foo') });
   *
   * // call addSheet twice,
   * // console should print 'foo' only once when the sheet is added in this example
   * hfInstance.addSheet('FooBar');
   * hfInstance.addSheet('FooBaz');
   * ```
   *
   * @category Events
   */
  once(event, listener) {
    this._emitter.once(event, listener);
  }
  /**
   * Unsubscribes from an event or from all events.
   * For the list of all available events, see [[Listeners]].
   *
   * @param {Event} event the name of the event to subscribe to
   * @param {Listener} listener to be called when event is emitted
   *
   * @example
   * ```js
   * const hfInstance = HyperFormula.buildEmpty();
   *
   * // define a simple function to be called upon emitting an event
   * const handler = ( ) => { console.log('baz') }
   *
   * // subscribe to a 'sheetAdded', pass the handler
   * hfInstance.on('sheetAdded', handler);
   *
   * // add a sheet to trigger an event,
   * // console should print 'baz' each time a sheet is added
   * hfInstance.addSheet('FooBar');
   *
   * // unsubscribe from a 'sheetAdded'
   * hfInstance.off('sheetAdded', handler);
   *
   * // add a sheet, the console should not print anything
   * hfInstance.addSheet('FooBaz');
   * ```
   *
   * @category Events
   */
  off(event, listener) {
    this._emitter.off(event, listener);
  }
  /**
   * Destroys instance of HyperFormula.
   *
   * @example
   * ```js
   * // destroys the instance
   * hfInstance.destroy();
   * ```
   *
   * @category Instance
   */
  destroy() {
    (0,_Destroy__WEBPACK_IMPORTED_MODULE_7__.objectDestroy)(this);
  }
  ensureEvaluationIsNotSuspended() {
    if (this._evaluationSuspended) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_9__.EvaluationSuspendedError();
    }
  }
  extractTemporaryFormula(formulaString, sheetId = 1) {
    const parsedCellContent = this._cellContentParser.parse(formulaString);
    const address = {
      sheet: sheetId,
      col: 0,
      row: 0
    };
    if (!(parsedCellContent instanceof _CellContentParser__WEBPACK_IMPORTED_MODULE_4__.CellContent.Formula)) {
      return {
        address,
        dependencies: []
      };
    }
    const {
      ast,
      errors,
      dependencies
    } = this._parser.parse(parsedCellContent.formula, address);
    if (errors.length > 0) {
      return {
        address,
        dependencies: []
      };
    }
    return {
      ast,
      address,
      dependencies
    };
  }
  /**
   * Rebuilds the engine with new configuration.
   */
  rebuildWithConfig(newParams) {
    const newConfig = this._config.mergeConfig(newParams);
    const configNewLanguage = this._config.mergeConfig({
      language: newParams.language
    });
    const serializedSheets = this._serialization.withNewConfig(configNewLanguage, this._namedExpressions).getAllSheetsSerialized();
    const serializedNamedExpressions = this._serialization.getAllNamedExpressionsSerialized();
    const newEngine = _BuildEngineFactory__WEBPACK_IMPORTED_MODULE_2__.BuildEngineFactory.rebuildWithConfig(newConfig, serializedSheets, serializedNamedExpressions, this._stats);
    this._config = newEngine.config;
    this._stats = newEngine.stats;
    this._dependencyGraph = newEngine.dependencyGraph;
    this._columnSearch = newEngine.columnSearch;
    this._parser = newEngine.parser;
    this._unparser = newEngine.unparser;
    this._cellContentParser = newEngine.cellContentParser;
    this._evaluator = newEngine.evaluator;
    this._lazilyTransformingAstService = newEngine.lazilyTransformingAstService;
    this._crudOperations = newEngine.crudOperations;
    this._exporter = newEngine.exporter;
    this._namedExpressions = newEngine.namedExpressions;
    this._serialization = newEngine.serialization;
    this._functionRegistry = newEngine.functionRegistry;
  }
  /**
   * Runs a recomputation starting from recently changed vertices.
   *
   * Returns [an array of cells whose values changed as a result of this operation](/guide/basic-operations.md#changes-array).
   *
   * Note that this method may trigger dependency graph recalculation.
   *
   * @fires [[valuesUpdated]] if recalculation was triggered by this change
   */
  recomputeIfDependencyGraphNeedsIt() {
    if (!this._evaluationSuspended) {
      const changes = this._crudOperations.getAndClearContentChanges();
      const verticesToRecomputeFrom = this.dependencyGraph.verticesToRecompute();
      this.dependencyGraph.clearDirtyVertices();
      if (verticesToRecomputeFrom.length > 0) {
        changes.addAll(this.evaluator.partialRun(verticesToRecomputeFrom));
      }
      const exportedChanges = changes.exportChanges(this._exporter);
      if (!changes.isEmpty()) {
        this._emitter.emit(_Emitter__WEBPACK_IMPORTED_MODULE_8__.Events.ValuesUpdated, exportedChanges);
      }
      return exportedChanges;
    } else {
      return [];
    }
  }
}
/**
 * Version of the HyperFormula.
 *
 * @category Static Properties
 */
HyperFormula.version = "2.7.1";
/**
 * Latest build date.
 *
 * @category Static Properties
 */
HyperFormula.buildDate = "18/07/2024 11:23:17";
/**
 * A release date.
 *
 * @category Static Properties
 */
HyperFormula.releaseDate = "18/07/2024";
/**
 * When using the UMD build, this property contains all available languages to use with the [registerLanguage](#registerlanguage) method.
 *
 * For more information, see the [Localizing functions](/guide/localizing-functions.md) guide.
 *
 * @category Static Properties
 */
HyperFormula.languages = {};
HyperFormula.registeredLanguages = new Map();

/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BuildEngineFactory: () => (/* binding */ BuildEngineFactory)
/* harmony export */ });
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _CellContentParser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(112);
/* harmony import */ var _ClipboardOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(113);
/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(101);
/* harmony import */ var _CrudOperations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(114);
/* harmony import */ var _DateTimeHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(104);
/* harmony import */ var _DependencyGraph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(77);
/* harmony import */ var _Evaluator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(127);
/* harmony import */ var _Exporter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(128);
/* harmony import */ var _GraphBuilder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(129);
/* harmony import */ var _i18n__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(88);
/* harmony import */ var _interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(98);
/* harmony import */ var _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(130);
/* harmony import */ var _interpreter_Interpreter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(132);
/* harmony import */ var _LazilyTransformingAstService__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(134);
/* harmony import */ var _Lookup_SearchStrategy__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(136);
/* harmony import */ var _NamedExpressions__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(115);
/* harmony import */ var _NumberLiteralHelper__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(141);
/* harmony import */ var _Operations__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(116);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(7);
/* harmony import */ var _Serialization__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(142);
/* harmony import */ var _Sheet__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(125);
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(72);
/* harmony import */ var _UndoRedo__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(126);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

























class BuildEngineFactory {
  static buildFromSheets(sheets, configInput = {}, namedExpressions = []) {
    const config = new _Config__WEBPACK_IMPORTED_MODULE_3__.Config(configInput);
    return this.buildEngine(config, sheets, namedExpressions);
  }
  static buildFromSheet(sheet, configInput = {}, namedExpressions = []) {
    const config = new _Config__WEBPACK_IMPORTED_MODULE_3__.Config(configInput);
    const newsheetprefix = config.translationPackage.getUITranslation(_i18n__WEBPACK_IMPORTED_MODULE_11__.UIElement.NEW_SHEET_PREFIX) + '1';
    return this.buildEngine(config, {
      [newsheetprefix]: sheet
    }, namedExpressions);
  }
  static buildEmpty(configInput = {}, namedExpressions = []) {
    return this.buildEngine(new _Config__WEBPACK_IMPORTED_MODULE_3__.Config(configInput), {}, namedExpressions);
  }
  static rebuildWithConfig(config, sheets, namedExpressions, stats) {
    return this.buildEngine(config, sheets, namedExpressions, stats);
  }
  static buildEngine(config, sheets = {}, inputNamedExpressions = [], stats = config.useStats ? new _statistics__WEBPACK_IMPORTED_MODULE_23__.Statistics() : new _statistics__WEBPACK_IMPORTED_MODULE_23__.EmptyStatistics()) {
    stats.start(_statistics__WEBPACK_IMPORTED_MODULE_23__.StatType.BUILD_ENGINE_TOTAL);
    const namedExpressions = new _NamedExpressions__WEBPACK_IMPORTED_MODULE_17__.NamedExpressions();
    const functionRegistry = new _interpreter_FunctionRegistry__WEBPACK_IMPORTED_MODULE_13__.FunctionRegistry(config);
    const lazilyTransformingAstService = new _LazilyTransformingAstService__WEBPACK_IMPORTED_MODULE_15__.LazilyTransformingAstService(stats);
    const dependencyGraph = _DependencyGraph__WEBPACK_IMPORTED_MODULE_6__.DependencyGraph.buildEmpty(lazilyTransformingAstService, config, functionRegistry, namedExpressions, stats);
    const columnSearch = (0,_Lookup_SearchStrategy__WEBPACK_IMPORTED_MODULE_16__.buildColumnSearchStrategy)(dependencyGraph, config, stats);
    const sheetMapping = dependencyGraph.sheetMapping;
    const addressMapping = dependencyGraph.addressMapping;
    for (const sheetName in sheets) {
      if (Object.prototype.hasOwnProperty.call(sheets, sheetName)) {
        const sheet = sheets[sheetName];
        (0,_Sheet__WEBPACK_IMPORTED_MODULE_22__.validateAsSheet)(sheet);
        const boundaries = (0,_Sheet__WEBPACK_IMPORTED_MODULE_22__.findBoundaries)(sheet);
        if (boundaries.height > config.maxRows || boundaries.width > config.maxColumns) {
          throw new _errors__WEBPACK_IMPORTED_MODULE_7__.SheetSizeLimitExceededError();
        }
        const sheetId = sheetMapping.addSheet(sheetName);
        addressMapping.autoAddSheet(sheetId, boundaries);
      }
    }
    const parser = new _parser__WEBPACK_IMPORTED_MODULE_20__.ParserWithCaching(config, functionRegistry, sheetMapping.get);
    lazilyTransformingAstService.parser = parser;
    const unparser = new _parser__WEBPACK_IMPORTED_MODULE_20__.Unparser(config, (0,_parser__WEBPACK_IMPORTED_MODULE_20__.buildLexerConfig)(config), sheetMapping.fetchDisplayName, namedExpressions);
    const dateTimeHelper = new _DateTimeHelper__WEBPACK_IMPORTED_MODULE_5__.DateTimeHelper(config);
    const numberLiteralHelper = new _NumberLiteralHelper__WEBPACK_IMPORTED_MODULE_18__.NumberLiteralHelper(config);
    const arithmeticHelper = new _interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_12__.ArithmeticHelper(config, dateTimeHelper, numberLiteralHelper);
    const cellContentParser = new _CellContentParser__WEBPACK_IMPORTED_MODULE_1__.CellContentParser(config, dateTimeHelper, numberLiteralHelper);
    const arraySizePredictor = new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySizePredictor(config, functionRegistry);
    const operations = new _Operations__WEBPACK_IMPORTED_MODULE_19__.Operations(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor);
    const undoRedo = new _UndoRedo__WEBPACK_IMPORTED_MODULE_24__.UndoRedo(config, operations);
    lazilyTransformingAstService.undoRedo = undoRedo;
    const clipboardOperations = new _ClipboardOperations__WEBPACK_IMPORTED_MODULE_2__.ClipboardOperations(config, dependencyGraph, operations);
    const crudOperations = new _CrudOperations__WEBPACK_IMPORTED_MODULE_4__.CrudOperations(config, operations, undoRedo, clipboardOperations, dependencyGraph, columnSearch, parser, cellContentParser, lazilyTransformingAstService, namedExpressions);
    inputNamedExpressions.forEach(entry => {
      crudOperations.ensureItIsPossibleToAddNamedExpression(entry.name, entry.expression, entry.scope);
      crudOperations.operations.addNamedExpression(entry.name, entry.expression, entry.scope, entry.options);
    });
    const exporter = new _Exporter__WEBPACK_IMPORTED_MODULE_9__.Exporter(config, namedExpressions, sheetMapping.fetchDisplayName, lazilyTransformingAstService);
    const serialization = new _Serialization__WEBPACK_IMPORTED_MODULE_21__.Serialization(dependencyGraph, unparser, exporter);
    const interpreter = new _interpreter_Interpreter__WEBPACK_IMPORTED_MODULE_14__.Interpreter(config, dependencyGraph, columnSearch, stats, arithmeticHelper, functionRegistry, namedExpressions, serialization, arraySizePredictor, dateTimeHelper);
    stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_23__.StatType.GRAPH_BUILD, () => {
      const graphBuilder = new _GraphBuilder__WEBPACK_IMPORTED_MODULE_10__.GraphBuilder(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor);
      graphBuilder.buildGraph(sheets, stats);
    });
    const evaluator = new _Evaluator__WEBPACK_IMPORTED_MODULE_8__.Evaluator(config, stats, interpreter, lazilyTransformingAstService, dependencyGraph, columnSearch);
    evaluator.run();
    stats.end(_statistics__WEBPACK_IMPORTED_MODULE_23__.StatType.BUILD_ENGINE_TOTAL);
    return {
      config,
      stats,
      dependencyGraph,
      columnSearch,
      parser,
      unparser,
      cellContentParser,
      evaluator,
      lazilyTransformingAstService,
      crudOperations,
      exporter,
      namedExpressions,
      serialization,
      functionRegistry
    };
  }
}

/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CellContent: () => (/* binding */ CellContent),
/* harmony export */   CellContentParser: () => (/* binding */ CellContentParser),
/* harmony export */   isBoolean: () => (/* binding */ isBoolean),
/* harmony export */   isError: () => (/* binding */ isError),
/* harmony export */   isFormula: () => (/* binding */ isFormula)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(104);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77);
/* harmony import */ var _interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */






var CellContent;
(function (CellContent) {
  class Number {
    constructor(value) {
      this.value = value;
      this.value = (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.cloneNumber)(this.value, (0,_interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__.fixNegativeZero)((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.getRawValue)(this.value)));
    }
  }
  CellContent.Number = Number;
  class String {
    constructor(value) {
      this.value = value;
    }
  }
  CellContent.String = String;
  class Boolean {
    constructor(value) {
      this.value = value;
    }
  }
  CellContent.Boolean = Boolean;
  class Empty {
    static getSingletonInstance() {
      if (!Empty.instance) {
        Empty.instance = new Empty();
      }
      return Empty.instance;
    }
  }
  CellContent.Empty = Empty;
  class Formula {
    constructor(formula) {
      this.formula = formula;
    }
  }
  CellContent.Formula = Formula;
  class Error {
    constructor(errorType, message) {
      this.value = new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(errorType, message);
    }
  }
  CellContent.Error = Error;
})(CellContent || (CellContent = {}));
/**
 * Checks whether string looks like formula or not.
 *
 * @param text - formula
 */
function isFormula(text) {
  return text.startsWith('=');
}
function isBoolean(text) {
  const tl = text.toLowerCase();
  return tl === 'true' || tl === 'false';
}
function isError(text, errorMapping) {
  const upperCased = text.toUpperCase();
  const errorRegex = /#[A-Za-z0-9\/]+[?!]?/;
  return errorRegex.test(upperCased) && Object.prototype.hasOwnProperty.call(errorMapping, upperCased);
}
class CellContentParser {
  constructor(config, dateHelper, numberLiteralsHelper) {
    this.config = config;
    this.dateHelper = dateHelper;
    this.numberLiteralsHelper = numberLiteralsHelper;
  }
  parse(content) {
    if (content === undefined || content === null) {
      return CellContent.Empty.getSingletonInstance();
    } else if (typeof content === 'number') {
      if ((0,_interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__.isNumberOverflow)(content)) {
        return new CellContent.Error(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueLarge);
      } else {
        return new CellContent.Number(content);
      }
    } else if (typeof content === 'boolean') {
      return new CellContent.Boolean(content);
    } else if (content instanceof Date) {
      const dateVal = this.dateHelper.dateToNumber({
        day: content.getDate(),
        month: content.getMonth() + 1,
        year: content.getFullYear()
      });
      const timeVal = (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.timeToNumber)({
        hours: content.getHours(),
        minutes: content.getMinutes(),
        seconds: content.getSeconds() + content.getMilliseconds() / 1000
      });
      const val = dateVal + timeVal;
      if (val < 0) {
        return new CellContent.Error(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.DateBounds);
      }
      if (val % 1 === 0) {
        return new CellContent.Number(new _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.DateNumber(val, 'Date()'));
      } else if (val < 1) {
        return new CellContent.Number(new _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.TimeNumber(val, 'Date()'));
      } else {
        return new CellContent.Number(new _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.DateTimeNumber(val, 'Date()'));
      }
    } else if (typeof content === 'string') {
      if (isBoolean(content)) {
        return new CellContent.Boolean(content.toLowerCase() === 'true');
      } else if (isFormula(content)) {
        return new CellContent.Formula(content);
      } else if (isError(content, this.config.errorMapping)) {
        return new CellContent.Error(this.config.errorMapping[content.toUpperCase()]);
      } else {
        let trimmedContent = content.trim();
        let mode = 0;
        let currency;
        if (trimmedContent.endsWith('%')) {
          mode = 1;
          trimmedContent = trimmedContent.slice(0, trimmedContent.length - 1);
        } else {
          const res = this.currencyMatcher(trimmedContent);
          if (res !== undefined) {
            mode = 2;
            [currency, trimmedContent] = res;
          }
        }
        const val = this.numberLiteralsHelper.numericStringToMaybeNumber(trimmedContent);
        if (val !== undefined) {
          let parseAsNum;
          if (mode === 1) {
            parseAsNum = new _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.PercentNumber(val / 100);
          } else if (mode === 2) {
            parseAsNum = new _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.CurrencyNumber(val, currency);
          } else {
            parseAsNum = val;
          }
          return new CellContent.Number(parseAsNum);
        }
        const parsedDateNumber = this.dateHelper.dateStringToDateNumber(trimmedContent);
        if (parsedDateNumber !== undefined) {
          return new CellContent.Number(parsedDateNumber);
        } else {
          return new CellContent.String(content.startsWith('\'') ? content.slice(1) : content);
        }
      }
    } else {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.UnableToParseError(content);
    }
  }
  currencyMatcher(token) {
    for (const currency of this.config.currencySymbol) {
      if (token.startsWith(currency)) {
        return [currency, token.slice(currency.length)];
      }
      if (token.endsWith(currency)) {
        return [currency, token.slice(0, token.length - currency.length)];
      }
    }
    return undefined;
  }
}

/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ClipboardCellType: () => (/* binding */ ClipboardCellType),
/* harmony export */   ClipboardOperations: () => (/* binding */ ClipboardOperations)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(77);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



var ClipboardOperationType;
(function (ClipboardOperationType) {
  ClipboardOperationType[ClipboardOperationType["COPY"] = 0] = "COPY";
  ClipboardOperationType[ClipboardOperationType["CUT"] = 1] = "CUT";
})(ClipboardOperationType || (ClipboardOperationType = {}));
var ClipboardCellType;
(function (ClipboardCellType) {
  ClipboardCellType[ClipboardCellType["VALUE"] = 0] = "VALUE";
  ClipboardCellType[ClipboardCellType["EMPTY"] = 1] = "EMPTY";
  ClipboardCellType[ClipboardCellType["FORMULA"] = 2] = "FORMULA";
  ClipboardCellType[ClipboardCellType["PARSING_ERROR"] = 3] = "PARSING_ERROR";
})(ClipboardCellType || (ClipboardCellType = {}));
class Clipboard {
  constructor(sourceLeftCorner, width, height, type, content) {
    this.sourceLeftCorner = sourceLeftCorner;
    this.width = width;
    this.height = height;
    this.type = type;
    this.content = content;
  }
  *getContent(leftCorner) {
    if (this.content === undefined) {
      return;
    } else {
      for (let y = 0; y < this.height; ++y) {
        for (let x = 0; x < this.width; ++x) {
          yield [(0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(leftCorner.sheet, leftCorner.col + x, leftCorner.row + y), this.content[y][x]];
        }
      }
    }
  }
}
class ClipboardOperations {
  constructor(config, dependencyGraph, operations) {
    this.dependencyGraph = dependencyGraph;
    this.operations = operations;
    this.maxRows = config.maxRows;
    this.maxColumns = config.maxColumns;
  }
  cut(leftCorner, width, height) {
    this.clipboard = new Clipboard(leftCorner, width, height, ClipboardOperationType.CUT);
  }
  copy(leftCorner, width, height) {
    const content = [];
    for (let y = 0; y < height; ++y) {
      content[y] = [];
      for (let x = 0; x < width; ++x) {
        const clipboardCell = this.operations.getClipboardCell((0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(leftCorner.sheet, leftCorner.col + x, leftCorner.row + y));
        content[y].push(clipboardCell);
      }
    }
    this.clipboard = new Clipboard(leftCorner, width, height, ClipboardOperationType.COPY, content);
  }
  abortCut() {
    if (this.clipboard && this.clipboard.type === ClipboardOperationType.CUT) {
      this.clear();
    }
  }
  clear() {
    this.clipboard = undefined;
  }
  ensureItIsPossibleToCopyPaste(destinationLeftCorner) {
    if (this.clipboard === undefined) {
      return;
    }
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(destinationLeftCorner) || !this.dependencyGraph.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_2__.InvalidArgumentsError('a valid target address.');
    }
    const targetRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(destinationLeftCorner, this.clipboard.width, this.clipboard.height);
    if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_2__.SheetSizeLimitExceededError();
    }
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {
      throw new Error('It is not possible to paste onto an array');
    }
  }
  isCutClipboard() {
    return this.clipboard !== undefined && this.clipboard.type === ClipboardOperationType.CUT;
  }
  isCopyClipboard() {
    return this.clipboard !== undefined && this.clipboard.type === ClipboardOperationType.COPY;
  }
}

/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CrudOperations: () => (/* binding */ CrudOperations)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _CellContentParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77);
/* harmony import */ var _NamedExpressions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(115);
/* harmony import */ var _Operations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(116);
/* harmony import */ var _Sheet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(125);
/* harmony import */ var _Span__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(71);
/* harmony import */ var _UndoRedo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(126);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */









class CrudOperations {
  constructor(config, operations, undoRedo, clipboardOperations, dependencyGraph, columnSearch, parser, cellContentParser, lazilyTransformingAstService, namedExpressions) {
    this.operations = operations;
    this.undoRedo = undoRedo;
    this.clipboardOperations = clipboardOperations;
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.parser = parser;
    this.cellContentParser = cellContentParser;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.namedExpressions = namedExpressions;
    this.maxRows = config.maxRows;
    this.maxColumns = config.maxColumns;
  }
  get sheetMapping() {
    return this.dependencyGraph.sheetMapping;
  }
  addRows(sheet, ...indexes) {
    const addRowsCommand = new _Operations__WEBPACK_IMPORTED_MODULE_5__.AddRowsCommand(sheet, indexes);
    this.ensureItIsPossibleToAddRows(sheet, ...indexes);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.operations.addRows(addRowsCommand);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.AddRowsUndoEntry(addRowsCommand));
  }
  removeRows(sheet, ...indexes) {
    const removeRowsCommand = new _Operations__WEBPACK_IMPORTED_MODULE_5__.RemoveRowsCommand(sheet, indexes);
    this.ensureItIsPossibleToRemoveRows(sheet, ...indexes);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const rowsRemovals = this.operations.removeRows(removeRowsCommand);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.RemoveRowsUndoEntry(removeRowsCommand, rowsRemovals));
  }
  addColumns(sheet, ...indexes) {
    const addColumnsCommand = new _Operations__WEBPACK_IMPORTED_MODULE_5__.AddColumnsCommand(sheet, indexes);
    this.ensureItIsPossibleToAddColumns(sheet, ...indexes);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.operations.addColumns(addColumnsCommand);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.AddColumnsUndoEntry(addColumnsCommand));
  }
  removeColumns(sheet, ...indexes) {
    const removeColumnsCommand = new _Operations__WEBPACK_IMPORTED_MODULE_5__.RemoveColumnsCommand(sheet, indexes);
    this.ensureItIsPossibleToRemoveColumns(sheet, ...indexes);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const columnsRemovals = this.operations.removeColumns(removeColumnsCommand);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.RemoveColumnsUndoEntry(removeColumnsCommand, columnsRemovals));
  }
  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const {
      version,
      overwrittenCellsData,
      addedGlobalNamedExpressions
    } = this.operations.moveCells(sourceLeftCorner, width, height, destinationLeftCorner);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.MoveCellsUndoEntry(sourceLeftCorner, width, height, destinationLeftCorner, overwrittenCellsData, addedGlobalNamedExpressions, version));
  }
  moveRows(sheet, startRow, numberOfRows, targetRow) {
    this.ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const version = this.operations.moveRows(sheet, startRow, numberOfRows, targetRow);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.MoveRowsUndoEntry(sheet, startRow, numberOfRows, targetRow, version));
  }
  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {
    this.ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn);
    this.undoRedo.clearRedoStack();
    const version = this.operations.moveColumns(sheet, startColumn, numberOfColumns, targetColumn);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.MoveColumnsUndoEntry(sheet, startColumn, numberOfColumns, targetColumn, version));
  }
  cut(sourceLeftCorner, width, height) {
    this.clipboardOperations.cut(sourceLeftCorner, width, height);
  }
  ensureItIsPossibleToCopy(sourceLeftCorner, width, height) {
    if (!isPositiveInteger(width)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('width to be positive integer.');
    }
    if (!isPositiveInteger(height)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('height to be positive integer.');
    }
  }
  copy(sourceLeftCorner, width, height) {
    this.ensureItIsPossibleToCopy(sourceLeftCorner, width, height);
    this.clipboardOperations.copy(sourceLeftCorner, width, height);
  }
  paste(targetLeftCorner) {
    const clipboard = this.clipboardOperations.clipboard;
    if (clipboard === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NothingToPasteError();
    } else if (this.clipboardOperations.isCutClipboard()) {
      this.moveCells(clipboard.sourceLeftCorner, clipboard.width, clipboard.height, targetLeftCorner);
    } else if (this.clipboardOperations.isCopyClipboard()) {
      this.clipboardOperations.ensureItIsPossibleToCopyPaste(targetLeftCorner);
      const targetRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(targetLeftCorner, clipboard.width, clipboard.height);
      const oldContent = this.operations.getRangeClipboardCells(targetRange);
      this.undoRedo.clearRedoStack();
      const addedGlobalNamedExpressions = this.operations.restoreClipboardCells(clipboard.sourceLeftCorner.sheet, clipboard.getContent(targetLeftCorner));
      this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.PasteUndoEntry(targetLeftCorner, oldContent, clipboard.content, addedGlobalNamedExpressions));
    }
  }
  beginUndoRedoBatchMode() {
    this.undoRedo.beginBatchMode();
  }
  commitUndoRedoBatchMode() {
    this.undoRedo.commitBatchMode();
  }
  isClipboardEmpty() {
    return this.clipboardOperations.clipboard === undefined;
  }
  clearClipboard() {
    this.clipboardOperations.clear();
  }
  addSheet(name) {
    if (name !== undefined) {
      this.ensureItIsPossibleToAddSheet(name);
    }
    this.undoRedo.clearRedoStack();
    const addedSheetName = this.operations.addSheet(name);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.AddSheetUndoEntry(addedSheetName));
    return addedSheetName;
  }
  removeSheet(sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const originalName = this.sheetMapping.fetchDisplayName(sheetId);
    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);
    const {
      version,
      scopedNamedExpressions
    } = this.operations.removeSheet(sheetId);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.RemoveSheetUndoEntry(originalName, sheetId, oldSheetContent, scopedNamedExpressions, version));
  }
  renameSheet(sheetId, newName) {
    this.ensureItIsPossibleToRenameSheet(sheetId, newName);
    const oldName = this.operations.renameSheet(sheetId, newName);
    if (oldName !== undefined) {
      this.undoRedo.clearRedoStack();
      this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.RenameSheetUndoEntry(sheetId, oldName, newName));
    }
    return oldName;
  }
  clearSheet(sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);
    this.operations.clearSheet(sheetId);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.ClearSheetUndoEntry(sheetId, oldSheetContent));
  }
  setCellContents(topLeftCornerAddress, cellContents) {
    if (!(cellContents instanceof Array)) {
      cellContents = [[cellContents]];
    } else {
      for (let i = 0; i < cellContents.length; i++) {
        if (!(cellContents[i] instanceof Array)) {
          throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('an array of arrays or a raw cell value.');
        }
      }
    }
    this.ensureItIsPossibleToChangeCellContents(topLeftCornerAddress, cellContents);
    this.undoRedo.clearRedoStack();
    const oldContents = [];
    for (let i = 0; i < cellContents.length; i++) {
      for (let j = 0; j < cellContents[i].length; j++) {
        const address = {
          sheet: topLeftCornerAddress.sheet,
          row: topLeftCornerAddress.row + i,
          col: topLeftCornerAddress.col + j
        };
        const newContent = cellContents[i][j];
        this.clipboardOperations.abortCut();
        const oldContent = this.operations.setCellContent(address, newContent);
        oldContents.push({
          address,
          newContent,
          oldContent
        });
      }
    }
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.SetCellContentsUndoEntry(oldContents));
  }
  setSheetContent(sheetId, values) {
    this.ensureScopeIdIsValid(sheetId);
    this.ensureItIsPossibleToChangeSheetContents(sheetId, values);
    (0,_Sheet__WEBPACK_IMPORTED_MODULE_6__.validateAsSheet)(values);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const oldSheetContent = this.operations.getSheetClipboardCells(sheetId);
    this.operations.setSheetContent(sheetId, values);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.SetSheetContentUndoEntry(sheetId, oldSheetContent, values));
  }
  setRowOrder(sheetId, rowMapping) {
    this.validateSwapRowIndexes(sheetId, rowMapping);
    this.testRowOrderForArrays(sheetId, rowMapping);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const oldContent = this.operations.setRowOrder(sheetId, rowMapping);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.SetRowOrderUndoEntry(sheetId, rowMapping, oldContent));
  }
  validateSwapRowIndexes(sheetId, rowMapping) {
    if (!this.sheetMapping.hasSheetWithId(sheetId)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(sheetId);
    }
    this.validateRowOrColumnMapping(sheetId, rowMapping, 'row');
  }
  testColumnOrderForArrays(sheetId, columnMapping) {
    for (const [source, target] of columnMapping) {
      if (source !== target) {
        const rowRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom({
          sheet: sheetId,
          col: source,
          row: 0
        }, 1, Infinity);
        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {
          throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SourceLocationHasArrayError();
        }
      }
    }
  }
  setColumnOrder(sheetId, columnMapping) {
    this.validateSwapColumnIndexes(sheetId, columnMapping);
    this.testColumnOrderForArrays(sheetId, columnMapping);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    const oldContent = this.operations.setColumnOrder(sheetId, columnMapping);
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.SetColumnOrderUndoEntry(sheetId, columnMapping, oldContent));
  }
  validateSwapColumnIndexes(sheetId, columnMapping) {
    if (!this.sheetMapping.hasSheetWithId(sheetId)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(sheetId);
    }
    this.validateRowOrColumnMapping(sheetId, columnMapping, 'column');
  }
  testRowOrderForArrays(sheetId, rowMapping) {
    for (const [source, target] of rowMapping) {
      if (source !== target) {
        const rowRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom({
          sheet: sheetId,
          col: 0,
          row: source
        }, Infinity, 1);
        if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(rowRange)) {
          throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SourceLocationHasArrayError();
        }
      }
    }
  }
  mappingFromOrder(sheetId, newOrder, rowOrColumn) {
    if (!this.sheetMapping.hasSheetWithId(sheetId)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(sheetId);
    }
    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);
    if (newOrder.length !== limit) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError(`number of ${rowOrColumn}s provided to be sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);
    }
    const ret = [];
    for (let i = 0; i < limit; i++) {
      if (newOrder[i] !== i) {
        ret.push([i, newOrder[i]]);
      }
    }
    return ret;
  }
  undo() {
    if (this.undoRedo.isUndoStackEmpty()) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoOperationToUndoError();
    }
    this.clipboardOperations.abortCut();
    this.undoRedo.undo();
  }
  redo() {
    if (this.undoRedo.isRedoStackEmpty()) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoOperationToRedoError();
    }
    this.clipboardOperations.abortCut();
    this.undoRedo.redo();
  }
  addNamedExpression(expressionName, expression, sheetId, options) {
    this.ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId);
    this.operations.addNamedExpression(expressionName, expression, sheetId, options);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.AddNamedExpressionUndoEntry(expressionName, expression, sheetId, options));
  }
  changeNamedExpressionExpression(expressionName, sheetId, newExpression, options) {
    this.ensureItIsPossibleToChangeNamedExpression(expressionName, newExpression, sheetId);
    const [oldNamedExpression, content] = this.operations.changeNamedExpressionExpression(expressionName, newExpression, sheetId, options);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.ChangeNamedExpressionUndoEntry(oldNamedExpression, newExpression, content, sheetId, options));
  }
  removeNamedExpression(expressionName, sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    const [namedExpression, content] = this.operations.removeNamedExpression(expressionName, sheetId);
    this.undoRedo.clearRedoStack();
    this.clipboardOperations.abortCut();
    this.undoRedo.saveOperation(new _UndoRedo__WEBPACK_IMPORTED_MODULE_8__.RemoveNamedExpressionUndoEntry(namedExpression, content, sheetId));
    return namedExpression;
  }
  ensureItIsPossibleToAddNamedExpression(expressionName, expression, sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    this.ensureNamedExpressionNameIsValid(expressionName, sheetId);
    this.ensureNamedExpressionIsValid(expression);
  }
  ensureItIsPossibleToChangeNamedExpression(expressionName, expression, sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NamedExpressionDoesNotExistError(expressionName);
    }
    this.ensureNamedExpressionIsValid(expression);
  }
  isItPossibleToRemoveNamedExpression(expressionName, sheetId) {
    this.ensureScopeIdIsValid(sheetId);
    if (this.namedExpressions.namedExpressionForScope(expressionName, sheetId) === undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NamedExpressionDoesNotExistError(expressionName);
    }
  }
  ensureItIsPossibleToAddRows(sheet, ...indexes) {
    if (!this.sheetMapping.hasSheetWithId(sheet)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(sheet);
    }
    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
    const newRowsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);
    if (sheetHeight + newRowsCount > this.maxRows) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SheetSizeLimitExceededError();
    }
    for (const [row, numberOfRowsToAdd] of indexes) {
      if (!isNonnegativeInteger(row) || !isPositiveInteger(numberOfRowsToAdd)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('row number to be nonnegative and number of rows to add to be positive.');
      }
    }
  }
  ensureItIsPossibleToRemoveRows(sheet, ...indexes) {
    for (const [rowStart, numberOfRows] of indexes) {
      const rowEnd = rowStart + numberOfRows - 1;
      if (!isNonnegativeInteger(rowStart) || !isNonnegativeInteger(rowEnd)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('starting and ending row to be nonnegative.');
      }
      if (rowEnd < rowStart) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('starting row to be smaller than the ending row.');
      }
      if (!this.sheetMapping.hasSheetWithId(sheet)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(sheet);
      }
    }
  }
  ensureItIsPossibleToAddColumns(sheet, ...indexes) {
    if (!this.sheetMapping.hasSheetWithId(sheet)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(sheet);
    }
    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);
    const newColumnsCount = indexes.map(index => index[1]).reduce((a, b) => a + b, 0);
    if (sheetWidth + newColumnsCount > this.maxColumns) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SheetSizeLimitExceededError();
    }
    for (const [column, numberOfColumnsToAdd] of indexes) {
      if (!isNonnegativeInteger(column) || !isPositiveInteger(numberOfColumnsToAdd)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('column number to be nonnegative and number of columns to add to be positive.');
      }
    }
  }
  ensureItIsPossibleToRemoveColumns(sheet, ...indexes) {
    for (const [columnStart, numberOfColumns] of indexes) {
      const columnEnd = columnStart + numberOfColumns - 1;
      if (!isNonnegativeInteger(columnStart) || !isNonnegativeInteger(columnEnd)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('starting and ending column to be nonnegative.');
      }
      if (columnEnd < columnStart) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('starting column to be smaller than the ending column.');
      }
      if (!this.sheetMapping.hasSheetWithId(sheet)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(sheet);
      }
    }
  }
  ensureItIsPossibleToMoveRows(sheet, startRow, numberOfRows, targetRow) {
    this.ensureItIsPossibleToAddRows(sheet, [targetRow, numberOfRows]);
    const sourceStart = (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(sheet, 0, startRow);
    const targetStart = (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(sheet, 0, targetRow);
    if (!this.sheetMapping.hasSheetWithId(sheet) || (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(sourceStart) || (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(targetStart) || !isPositiveInteger(numberOfRows) || targetRow <= startRow + numberOfRows && targetRow >= startRow) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('a valid range of rows to move.');
    }
    const width = this.dependencyGraph.getSheetWidth(sheet);
    const sourceRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(sourceStart, width, numberOfRows);
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SourceLocationHasArrayError();
    }
    if (targetRow > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllRows(_Span__WEBPACK_IMPORTED_MODULE_7__.RowsSpan.fromNumberOfRows(sheet, targetRow - 1, 2))) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.TargetLocationHasArrayError();
    }
  }
  ensureItIsPossibleToMoveColumns(sheet, startColumn, numberOfColumns, targetColumn) {
    this.ensureItIsPossibleToAddColumns(sheet, [targetColumn, numberOfColumns]);
    const sourceStart = (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(sheet, startColumn, 0);
    const targetStart = (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(sheet, targetColumn, 0);
    if (!this.sheetMapping.hasSheetWithId(sheet) || (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(sourceStart) || (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(targetStart) || !isPositiveInteger(numberOfColumns) || targetColumn <= startColumn + numberOfColumns && targetColumn >= startColumn) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError('a valid range of columns to move.');
    }
    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
    const sourceRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(sourceStart, numberOfColumns, sheetHeight);
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SourceLocationHasArrayError();
    }
    if (targetColumn > 0 && this.dependencyGraph.arrayMapping.isFormulaArrayInAllColumns(_Span__WEBPACK_IMPORTED_MODULE_7__.ColumnsSpan.fromNumberOfColumns(sheet, targetColumn - 1, 2))) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.TargetLocationHasArrayError();
    }
  }
  ensureItIsPossibleToAddSheet(name) {
    if (this.sheetMapping.hasSheetWithName(name)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SheetNameAlreadyTakenError(name);
    }
  }
  ensureItIsPossibleToRenameSheet(sheetId, name) {
    if (!this.sheetMapping.hasSheetWithId(sheetId)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(sheetId);
    }
    const existingSheetId = this.sheetMapping.get(name);
    if (existingSheetId !== undefined && existingSheetId !== sheetId) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SheetNameAlreadyTakenError(name);
    }
  }
  ensureItIsPossibleToChangeContent(address) {
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_1__.invalidSimpleCellAddress)(address)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidAddressError(address);
    }
    if (!this.sheetMapping.hasSheetWithId(address.sheet)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(address.sheet);
    }
  }
  ensureItIsPossibleToChangeCellContents(inputAddress, content) {
    const boundaries = (0,_Sheet__WEBPACK_IMPORTED_MODULE_6__.findBoundaries)(content);
    const targetRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(inputAddress, boundaries.width, boundaries.height);
    this.ensureRangeInSizeLimits(targetRange);
    for (const address of targetRange.addresses(this.dependencyGraph)) {
      this.ensureItIsPossibleToChangeContent(address);
    }
  }
  ensureItIsPossibleToChangeSheetContents(sheetId, content) {
    const boundaries = (0,_Sheet__WEBPACK_IMPORTED_MODULE_6__.findBoundaries)(content);
    const targetRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom((0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(sheetId, 0, 0), boundaries.width, boundaries.height);
    this.ensureRangeInSizeLimits(targetRange);
  }
  ensureRangeInSizeLimits(range) {
    if (range.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.SheetSizeLimitExceededError();
    }
  }
  isThereSomethingToUndo() {
    return !this.undoRedo.isUndoStackEmpty();
  }
  isThereSomethingToRedo() {
    return !this.undoRedo.isRedoStackEmpty();
  }
  getAndClearContentChanges() {
    return this.operations.getAndClearContentChanges();
  }
  ensureScopeIdIsValid(scopeId) {
    if (scopeId !== undefined && !this.sheetMapping.hasSheetWithId(scopeId)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoSheetWithIdError(scopeId);
    }
  }
  validateRowOrColumnMapping(sheetId, rowMapping, rowOrColumn) {
    const limit = rowOrColumn === 'row' ? this.dependencyGraph.getSheetHeight(sheetId) : this.dependencyGraph.getSheetWidth(sheetId);
    const sources = rowMapping.map(([a, _]) => a).sort((a, b) => a - b);
    const targets = rowMapping.map(([_, b]) => b).sort((a, b) => a - b);
    for (let i = 0; i < sources.length; i++) {
      if (!isNonnegativeInteger(sources[i]) || sources[i] >= limit) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError(`${rowOrColumn} numbers to be nonnegative integers and less than sheet ${rowOrColumn === 'row' ? 'height' : 'width'}.`);
      }
      if (sources[i] === sources[i + 1]) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError(`source ${rowOrColumn} numbers to be unique.`);
      }
      if (sources[i] !== targets[i]) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.InvalidArgumentsError(`target ${rowOrColumn} numbers to be permutation of source ${rowOrColumn} numbers.`);
      }
    }
  }
  ensureNamedExpressionNameIsValid(expressionName, sheetId) {
    if (!this.namedExpressions.isNameValid(expressionName)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NamedExpressionNameIsInvalidError(expressionName);
    }
    if (!this.namedExpressions.isNameAvailable(expressionName, sheetId)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NamedExpressionNameIsAlreadyTakenError(expressionName);
    }
  }
  ensureNamedExpressionIsValid(expression) {
    const parsedExpression = this.cellContentParser.parse(expression);
    if (parsedExpression instanceof _CellContentParser__WEBPACK_IMPORTED_MODULE_2__.CellContent.Formula) {
      const parsingResult = this.parser.parse(parsedExpression.formula, (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(-1, 0, 0));
      if ((0,_NamedExpressions__WEBPACK_IMPORTED_MODULE_4__.doesContainRelativeReferences)(parsingResult.ast)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_3__.NoRelativeAddressesAllowedError();
      }
    }
  }
}
function isPositiveInteger(x) {
  return Number.isInteger(x) && x > 0;
}
function isNonnegativeInteger(x) {
  return Number.isInteger(x) && x >= 0;
}

/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalNamedExpression: () => (/* binding */ InternalNamedExpression),
/* harmony export */   NamedExpressions: () => (/* binding */ NamedExpressions),
/* harmony export */   doesContainRelativeReferences: () => (/* binding */ doesContainRelativeReferences)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _parser_parser_consts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class InternalNamedExpression {
  constructor(displayName, address, added, options) {
    this.displayName = displayName;
    this.address = address;
    this.added = added;
    this.options = options;
  }
  normalizeExpressionName() {
    return this.displayName.toLowerCase();
  }
  copy() {
    return new InternalNamedExpression(this.displayName, this.address, this.added, this.options);
  }
}
class WorkbookStore {
  constructor() {
    this.mapping = new Map();
  }
  has(expressionName) {
    return this.mapping.has(this.normalizeExpressionName(expressionName));
  }
  isNameAvailable(expressionName) {
    const normalizedExpressionName = this.normalizeExpressionName(expressionName);
    const namedExpression = this.mapping.get(normalizedExpressionName);
    return !(namedExpression && namedExpression.added);
  }
  add(namedExpression) {
    this.mapping.set(namedExpression.normalizeExpressionName(), namedExpression);
  }
  get(expressionName) {
    return this.mapping.get(this.normalizeExpressionName(expressionName));
  }
  getExisting(expressionName) {
    const namedExpression = this.mapping.get(this.normalizeExpressionName(expressionName));
    if (namedExpression && namedExpression.added) {
      return namedExpression;
    } else {
      return undefined;
    }
  }
  remove(expressionName) {
    const normalizedExpressionName = this.normalizeExpressionName(expressionName);
    const namedExpression = this.mapping.get(normalizedExpressionName);
    if (namedExpression) {
      namedExpression.added = false;
    }
  }
  getAllNamedExpressions() {
    return Array.from(this.mapping.values()).filter(ne => ne.added);
  }
  normalizeExpressionName(expressionName) {
    return expressionName.toLowerCase();
  }
}
class WorksheetStore {
  constructor() {
    this.mapping = new Map();
  }
  add(namedExpression) {
    this.mapping.set(this.normalizeExpressionName(namedExpression.displayName), namedExpression);
  }
  get(expressionName) {
    return this.mapping.get(this.normalizeExpressionName(expressionName));
  }
  has(expressionName) {
    return this.mapping.has(this.normalizeExpressionName(expressionName));
  }
  getAllNamedExpressions() {
    return Array.from(this.mapping.values()).filter(ne => ne.added);
  }
  isNameAvailable(expressionName) {
    const normalizedExpressionName = this.normalizeExpressionName(expressionName);
    return !this.mapping.has(normalizedExpressionName);
  }
  remove(expressionName) {
    const normalizedExpressionName = this.normalizeExpressionName(expressionName);
    const namedExpression = this.mapping.get(normalizedExpressionName);
    if (namedExpression) {
      this.mapping.delete(normalizedExpressionName);
    }
  }
  normalizeExpressionName(expressionName) {
    return expressionName.toLowerCase();
  }
}
class NamedExpressions {
  constructor() {
    this.nextNamedExpressionRow = 0;
    this.workbookStore = new WorkbookStore();
    this.worksheetStores = new Map();
    this.addressCache = new Map();
  }
  isNameAvailable(expressionName, sheetId) {
    var _a, _b;
    if (sheetId === undefined) {
      return this.workbookStore.isNameAvailable(expressionName);
    } else {
      return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.isNameAvailable(expressionName)) !== null && _b !== void 0 ? _b : true;
    }
  }
  namedExpressionInAddress(row) {
    const namedExpression = this.addressCache.get(row);
    if (namedExpression && namedExpression.added) {
      return namedExpression;
    } else {
      return undefined;
    }
  }
  namedExpressionForScope(expressionName, sheetId) {
    var _a;
    if (sheetId === undefined) {
      return this.workbookStore.getExisting(expressionName);
    } else {
      return (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName);
    }
  }
  nearestNamedExpression(expressionName, sheetId) {
    var _a, _b;
    return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.get(expressionName)) !== null && _b !== void 0 ? _b : this.workbookStore.getExisting(expressionName);
  }
  isExpressionInScope(expressionName, sheetId) {
    var _a, _b;
    return (_b = (_a = this.worksheetStore(sheetId)) === null || _a === void 0 ? void 0 : _a.has(expressionName)) !== null && _b !== void 0 ? _b : false;
  }
  /**
   * Checks the validity of a named-expression's name.
   *
   * The name:
   * - Must start with a Unicode letter or with an underscore (`_`).
   * - Can contain only Unicode letters, numbers, underscores, and periods (`.`).
   * - Can't be the same as any possible reference in the A1 notation (`[A-Za-z]+[0-9]+`).
   * - Can't be the same as any possible reference in the R1C1 notation (`[rR][0-9]*[cC][0-9]*`).
   *
   * The naming rules follow the [OpenDocument](https://docs.oasis-open.org/office/OpenDocument/v1.3/os/part4-formula/OpenDocument-v1.3-os-part4-formula.html#__RefHeading__1017964_715980110) standard.
   */
  isNameValid(expressionName) {
    const a1CellRefRegexp = new RegExp(`^${_parser_parser_consts__WEBPACK_IMPORTED_MODULE_2__.CELL_REFERENCE_PATTERN}$`);
    const r1c1CellRefRegexp = new RegExp(`^${_parser_parser_consts__WEBPACK_IMPORTED_MODULE_2__.R1C1_CELL_REFERENCE_PATTERN}$`);
    const namedExpRegexp = new RegExp(`^${_parser_parser_consts__WEBPACK_IMPORTED_MODULE_2__.NAMED_EXPRESSION_PATTERN}$`);
    if (a1CellRefRegexp.test(expressionName) || r1c1CellRefRegexp.test(expressionName)) {
      return false;
    }
    return namedExpRegexp.test(expressionName);
  }
  addNamedExpression(expressionName, sheetId, options) {
    const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);
    let namedExpression = store.get(expressionName);
    if (namedExpression !== undefined) {
      namedExpression.added = true;
      namedExpression.displayName = expressionName;
      namedExpression.options = options;
    } else {
      namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), true, options);
      store.add(namedExpression);
    }
    this.addressCache.set(namedExpression.address.row, namedExpression);
    return namedExpression;
  }
  restoreNamedExpression(namedExpression, sheetId) {
    const store = sheetId === undefined ? this.workbookStore : this.worksheetStoreOrCreate(sheetId);
    namedExpression.added = true;
    store.add(namedExpression);
    this.addressCache.set(namedExpression.address.row, namedExpression);
    return namedExpression;
  }
  namedExpressionOrPlaceholder(expressionName, sheetId) {
    var _a;
    return (_a = this.worksheetStoreOrCreate(sheetId).get(expressionName)) !== null && _a !== void 0 ? _a : this.workbookNamedExpressionOrPlaceholder(expressionName);
  }
  workbookNamedExpressionOrPlaceholder(expressionName) {
    let namedExpression = this.workbookStore.get(expressionName);
    if (namedExpression === undefined) {
      namedExpression = new InternalNamedExpression(expressionName, this.nextAddress(), false);
      this.workbookStore.add(namedExpression);
    }
    return namedExpression;
  }
  remove(expressionName, sheetId) {
    let store;
    if (sheetId === undefined) {
      store = this.workbookStore;
    } else {
      store = this.worksheetStore(sheetId);
    }
    const namedExpression = store === null || store === void 0 ? void 0 : store.get(expressionName);
    if (store === undefined || namedExpression === undefined || !namedExpression.added) {
      throw Error('Named expression does not exist');
    }
    store.remove(expressionName);
    if (store instanceof WorksheetStore && store.mapping.size === 0) {
      this.worksheetStores.delete(sheetId);
    }
    this.addressCache.delete(namedExpression.address.row);
  }
  getAllNamedExpressionsNamesInScope(sheetId) {
    return this.getAllNamedExpressions().filter(({
      scope
    }) => scope === sheetId).map(ne => ne.expression.displayName);
  }
  getAllNamedExpressionsNames() {
    return this.getAllNamedExpressions().map(ne => ne.expression.displayName);
  }
  getAllNamedExpressions() {
    const storedNamedExpressions = [];
    this.workbookStore.getAllNamedExpressions().forEach(expr => {
      storedNamedExpressions.push({
        expression: expr,
        scope: undefined
      });
    });
    this.worksheetStores.forEach((store, sheetNum) => {
      store.getAllNamedExpressions().forEach(expr => {
        storedNamedExpressions.push({
          expression: expr,
          scope: sheetNum
        });
      });
    });
    return storedNamedExpressions;
  }
  getAllNamedExpressionsForScope(scope) {
    var _a, _b;
    if (scope === undefined) {
      return this.workbookStore.getAllNamedExpressions();
    } else {
      return (_b = (_a = this.worksheetStores.get(scope)) === null || _a === void 0 ? void 0 : _a.getAllNamedExpressions()) !== null && _b !== void 0 ? _b : [];
    }
  }
  worksheetStoreOrCreate(sheetId) {
    let store = this.worksheetStores.get(sheetId);
    if (!store) {
      store = new WorksheetStore();
      this.worksheetStores.set(sheetId, store);
    }
    return store;
  }
  worksheetStore(sheetId) {
    return this.worksheetStores.get(sheetId);
  }
  nextAddress() {
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, 0, this.nextNamedExpressionRow++);
  }
}
NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS = -1;
const doesContainRelativeReferences = ast => {
  switch (ast.type) {
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.EMPTY:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.NUMBER:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.STRING:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.ERROR:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.ERROR_WITH_RAW_INPUT:
      return false;
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.CELL_REFERENCE:
      return !ast.reference.isAbsolute();
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.CELL_RANGE:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.COLUMN_RANGE:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.ROW_RANGE:
      return !ast.start.isAbsolute();
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.NAMED_EXPRESSION:
      return false;
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.PERCENT_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.PLUS_UNARY_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.MINUS_UNARY_OP:
      {
        return doesContainRelativeReferences(ast.value);
      }
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.CONCATENATE_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.EQUALS_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.NOT_EQUAL_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.LESS_THAN_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.GREATER_THAN_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.LESS_THAN_OR_EQUAL_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.GREATER_THAN_OR_EQUAL_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.MINUS_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.PLUS_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.TIMES_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.DIV_OP:
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.POWER_OP:
      return doesContainRelativeReferences(ast.left) || doesContainRelativeReferences(ast.right);
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.PARENTHESIS:
      return doesContainRelativeReferences(ast.expression);
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.FUNCTION_CALL:
      {
        return ast.args.some(arg => doesContainRelativeReferences(arg));
      }
    case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.ARRAY:
      {
        return ast.args.some(row => row.some(arg => doesContainRelativeReferences(arg)));
      }
  }
};

/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddColumnsCommand: () => (/* binding */ AddColumnsCommand),
/* harmony export */   AddRowsCommand: () => (/* binding */ AddRowsCommand),
/* harmony export */   Operations: () => (/* binding */ Operations),
/* harmony export */   RemoveColumnsCommand: () => (/* binding */ RemoveColumnsCommand),
/* harmony export */   RemoveRowsCommand: () => (/* binding */ RemoveRowsCommand),
/* harmony export */   normalizeAddedIndexes: () => (/* binding */ normalizeAddedIndexes),
/* harmony export */   normalizeRemovedIndexes: () => (/* binding */ normalizeRemovedIndexes)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _CellContentParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(113);
/* harmony import */ var _ContentChanges__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(68);
/* harmony import */ var _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4);
/* harmony import */ var _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(80);
/* harmony import */ var _dependencyTransformers_AddColumnsTransformer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(117);
/* harmony import */ var _dependencyTransformers_AddRowsTransformer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(119);
/* harmony import */ var _dependencyTransformers_CleanOutOfScopeDependenciesTransformer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(120);
/* harmony import */ var _dependencyTransformers_MoveCellsTransformer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(121);
/* harmony import */ var _dependencyTransformers_RemoveColumnsTransformer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(122);
/* harmony import */ var _dependencyTransformers_RemoveRowsTransformer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(123);
/* harmony import */ var _dependencyTransformers_RemoveSheetTransformer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(124);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(77);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(70);
/* harmony import */ var _NamedExpressions__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(115);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(7);
/* harmony import */ var _Sheet__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(125);
/* harmony import */ var _Span__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(71);
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(72);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */























class RemoveRowsCommand {
  constructor(sheet, indexes) {
    this.sheet = sheet;
    this.indexes = indexes;
  }
  normalizedIndexes() {
    return normalizeRemovedIndexes(this.indexes);
  }
  rowsSpans() {
    return this.normalizedIndexes().map(normalizedIndex => _Span__WEBPACK_IMPORTED_MODULE_21__.RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));
  }
}
class AddRowsCommand {
  constructor(sheet, indexes) {
    this.sheet = sheet;
    this.indexes = indexes;
  }
  normalizedIndexes() {
    return normalizeAddedIndexes(this.indexes);
  }
  rowsSpans() {
    return this.normalizedIndexes().map(normalizedIndex => _Span__WEBPACK_IMPORTED_MODULE_21__.RowsSpan.fromNumberOfRows(this.sheet, normalizedIndex[0], normalizedIndex[1]));
  }
}
class AddColumnsCommand {
  constructor(sheet, indexes) {
    this.sheet = sheet;
    this.indexes = indexes;
  }
  normalizedIndexes() {
    return normalizeAddedIndexes(this.indexes);
  }
  columnsSpans() {
    return this.normalizedIndexes().map(normalizedIndex => _Span__WEBPACK_IMPORTED_MODULE_21__.ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));
  }
}
class RemoveColumnsCommand {
  constructor(sheet, indexes) {
    this.sheet = sheet;
    this.indexes = indexes;
  }
  normalizedIndexes() {
    return normalizeRemovedIndexes(this.indexes);
  }
  columnsSpans() {
    return this.normalizedIndexes().map(normalizedIndex => _Span__WEBPACK_IMPORTED_MODULE_21__.ColumnsSpan.fromNumberOfColumns(this.sheet, normalizedIndex[0], normalizedIndex[1]));
  }
}
class Operations {
  constructor(config, dependencyGraph, columnSearch, cellContentParser, parser, stats, lazilyTransformingAstService, namedExpressions, arraySizePredictor) {
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.cellContentParser = cellContentParser;
    this.parser = parser;
    this.stats = stats;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.namedExpressions = namedExpressions;
    this.arraySizePredictor = arraySizePredictor;
    this.changes = _ContentChanges__WEBPACK_IMPORTED_MODULE_6__.ContentChanges.empty();
    this.allocateNamedExpressionAddressSpace();
    this.maxColumns = config.maxColumns;
    this.maxRows = config.maxRows;
  }
  get sheetMapping() {
    return this.dependencyGraph.sheetMapping;
  }
  get addressMapping() {
    return this.dependencyGraph.addressMapping;
  }
  removeRows(cmd) {
    const rowsRemovals = [];
    for (const rowsToRemove of cmd.rowsSpans()) {
      const rowsRemoval = this.doRemoveRows(rowsToRemove);
      if (rowsRemoval) {
        rowsRemovals.push(rowsRemoval);
      }
    }
    return rowsRemovals;
  }
  addRows(cmd) {
    for (const addedRows of cmd.rowsSpans()) {
      this.doAddRows(addedRows);
    }
  }
  addColumns(cmd) {
    for (const addedColumns of cmd.columnsSpans()) {
      this.doAddColumns(addedColumns);
    }
  }
  removeColumns(cmd) {
    const columnsRemovals = [];
    for (const columnsToRemove of cmd.columnsSpans()) {
      const columnsRemoval = this.doRemoveColumns(columnsToRemove);
      if (columnsRemoval) {
        columnsRemovals.push(columnsRemoval);
      }
    }
    return columnsRemovals;
  }
  removeSheet(sheetId) {
    this.dependencyGraph.removeSheet(sheetId);
    let version = 0;
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_22__.StatType.TRANSFORM_ASTS, () => {
      const transformation = new _dependencyTransformers_RemoveSheetTransformer__WEBPACK_IMPORTED_MODULE_15__.RemoveSheetTransformer(sheetId);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      version = this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.sheetMapping.removeSheet(sheetId);
    this.columnSearch.removeSheet(sheetId);
    const scopedNamedExpressions = this.namedExpressions.getAllNamedExpressionsForScope(sheetId).map(namedExpression => this.removeNamedExpression(namedExpression.normalizeExpressionName(), sheetId));
    return {
      version: version,
      scopedNamedExpressions
    };
  }
  removeSheetByName(sheetName) {
    const sheetId = this.sheetMapping.fetch(sheetName);
    return this.removeSheet(sheetId);
  }
  clearSheet(sheetId) {
    this.dependencyGraph.clearSheet(sheetId);
    this.columnSearch.removeSheet(sheetId);
  }
  addSheet(name) {
    const sheetId = this.sheetMapping.addSheet(name);
    const sheet = [];
    this.dependencyGraph.addressMapping.autoAddSheet(sheetId, (0,_Sheet__WEBPACK_IMPORTED_MODULE_20__.findBoundaries)(sheet));
    return this.sheetMapping.fetchDisplayName(sheetId);
  }
  renameSheet(sheetId, newName) {
    return this.sheetMapping.renameSheet(sheetId, newName);
  }
  moveRows(sheet, startRow, numberOfRows, targetRow) {
    const rowsToAdd = _Span__WEBPACK_IMPORTED_MODULE_21__.RowsSpan.fromNumberOfRows(sheet, targetRow, numberOfRows);
    this.lazilyTransformingAstService.beginCombinedMode(sheet);
    this.doAddRows(rowsToAdd);
    if (targetRow < startRow) {
      startRow += numberOfRows;
    }
    const startAddress = (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.simpleCellAddress)(sheet, 0, startRow);
    const targetAddress = (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.simpleCellAddress)(sheet, 0, targetRow);
    this.moveCells(startAddress, Number.POSITIVE_INFINITY, numberOfRows, targetAddress);
    const rowsToRemove = _Span__WEBPACK_IMPORTED_MODULE_21__.RowsSpan.fromNumberOfRows(sheet, startRow, numberOfRows);
    this.doRemoveRows(rowsToRemove);
    return this.lazilyTransformingAstService.commitCombinedMode();
  }
  moveColumns(sheet, startColumn, numberOfColumns, targetColumn) {
    const columnsToAdd = _Span__WEBPACK_IMPORTED_MODULE_21__.ColumnsSpan.fromNumberOfColumns(sheet, targetColumn, numberOfColumns);
    this.lazilyTransformingAstService.beginCombinedMode(sheet);
    this.doAddColumns(columnsToAdd);
    if (targetColumn < startColumn) {
      startColumn += numberOfColumns;
    }
    const startAddress = (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.simpleCellAddress)(sheet, startColumn, 0);
    const targetAddress = (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.simpleCellAddress)(sheet, targetColumn, 0);
    this.moveCells(startAddress, numberOfColumns, Number.POSITIVE_INFINITY, targetAddress);
    const columnsToRemove = _Span__WEBPACK_IMPORTED_MODULE_21__.ColumnsSpan.fromNumberOfColumns(sheet, startColumn, numberOfColumns);
    this.doRemoveColumns(columnsToRemove);
    return this.lazilyTransformingAstService.commitCombinedMode();
  }
  moveCells(sourceLeftCorner, width, height, destinationLeftCorner) {
    this.ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner);
    const sourceRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);
    const targetRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);
    const toRight = destinationLeftCorner.col - sourceLeftCorner.col;
    const toBottom = destinationLeftCorner.row - sourceLeftCorner.row;
    const toSheet = destinationLeftCorner.sheet;
    const currentDataAtTarget = this.getRangeClipboardCells(targetRange);
    const valuesToRemove = this.dependencyGraph.rawValuesFromRange(targetRange);
    this.columnSearch.removeValues(valuesToRemove);
    const valuesToMove = this.dependencyGraph.rawValuesFromRange(sourceRange);
    this.columnSearch.moveValues(valuesToMove, toRight, toBottom, toSheet);
    let version = 0;
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_22__.StatType.TRANSFORM_ASTS, () => {
      const transformation = new _dependencyTransformers_MoveCellsTransformer__WEBPACK_IMPORTED_MODULE_12__.MoveCellsTransformer(sourceRange, toRight, toBottom, toSheet);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      version = this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.dependencyGraph.moveCells(sourceRange, toRight, toBottom, toSheet);
    const addedGlobalNamedExpressions = this.updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner);
    return {
      version: version,
      overwrittenCellsData: currentDataAtTarget,
      addedGlobalNamedExpressions: addedGlobalNamedExpressions
    };
  }
  setRowOrder(sheetId, rowMapping) {
    const buffer = [];
    let oldContent = [];
    for (const [source, target] of rowMapping) {
      if (source !== target) {
        const rowRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom({
          sheet: sheetId,
          col: 0,
          row: source
        }, Infinity, 1);
        const row = this.getRangeClipboardCells(rowRange);
        oldContent = oldContent.concat(row);
        buffer.push(row.map(([{
          sheet,
          col
        }, cell]) => [{
          sheet,
          col,
          row: target
        }, cell]));
      }
    }
    buffer.forEach(row => this.restoreClipboardCells(sheetId, row.values()));
    return oldContent;
  }
  setColumnOrder(sheetId, columnMapping) {
    const buffer = [];
    let oldContent = [];
    for (const [source, target] of columnMapping) {
      if (source !== target) {
        const rowRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom({
          sheet: sheetId,
          col: source,
          row: 0
        }, 1, Infinity);
        const column = this.getRangeClipboardCells(rowRange);
        oldContent = oldContent.concat(column);
        buffer.push(column.map(([{
          sheet,
          col: _col,
          row
        }, cell]) => [{
          sheet,
          col: target,
          row
        }, cell]));
      }
    }
    buffer.forEach(column => this.restoreClipboardCells(sheetId, column.values()));
    return oldContent;
  }
  addNamedExpression(expressionName, expression, sheetId, options) {
    const namedExpression = this.namedExpressions.addNamedExpression(expressionName, sheetId, options);
    this.storeNamedExpressionInCell(namedExpression.address, expression);
    this.adjustNamedExpressionEdges(namedExpression, expressionName, sheetId);
  }
  restoreNamedExpression(namedExpression, content, sheetId) {
    const expressionName = namedExpression.displayName;
    this.restoreCell(namedExpression.address, content);
    const restoredNamedExpression = this.namedExpressions.restoreNamedExpression(namedExpression, sheetId);
    this.adjustNamedExpressionEdges(restoredNamedExpression, expressionName, sheetId);
  }
  changeNamedExpressionExpression(expressionName, newExpression, sheetId, options) {
    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);
    if (!namedExpression) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_16__.NamedExpressionDoesNotExistError(expressionName);
    }
    const oldNamedExpression = namedExpression.copy();
    namedExpression.options = options;
    const content = this.getClipboardCell(namedExpression.address);
    this.storeNamedExpressionInCell(namedExpression.address, newExpression);
    return [oldNamedExpression, content];
  }
  removeNamedExpression(expressionName, sheetId) {
    const namedExpression = this.namedExpressions.namedExpressionForScope(expressionName, sheetId);
    if (!namedExpression) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_16__.NamedExpressionDoesNotExistError(expressionName);
    }
    this.namedExpressions.remove(namedExpression.displayName, sheetId);
    const content = this.getClipboardCell(namedExpression.address);
    if (sheetId !== undefined) {
      const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);
      this.dependencyGraph.exchangeNode(namedExpression.address, globalNamedExpression.address);
    } else {
      this.dependencyGraph.setCellEmpty(namedExpression.address);
    }
    return [namedExpression, content];
  }
  ensureItIsPossibleToMoveCells(sourceLeftCorner, width, height, destinationLeftCorner) {
    if ((0,_Cell__WEBPACK_IMPORTED_MODULE_3__.invalidSimpleCellAddress)(sourceLeftCorner) || !(isPositiveInteger(width) && isPositiveInteger(height) || isRowOrColumnRange(sourceLeftCorner, width, height)) || (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.invalidSimpleCellAddress)(destinationLeftCorner) || !this.sheetMapping.hasSheetWithId(sourceLeftCorner.sheet) || !this.sheetMapping.hasSheetWithId(destinationLeftCorner.sheet)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_16__.InvalidArgumentsError('a valid range of cells to move.');
    }
    const sourceRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(sourceLeftCorner, width, height);
    const targetRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);
    if (targetRange.exceedsSheetSizeLimits(this.maxColumns, this.maxRows)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_16__.SheetSizeLimitExceededError();
    }
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(sourceRange)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_16__.SourceLocationHasArrayError();
    }
    if (this.dependencyGraph.arrayMapping.isFormulaArrayInRange(targetRange)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_16__.TargetLocationHasArrayError();
    }
  }
  restoreClipboardCells(sourceSheetId, cells) {
    const addedNamedExpressions = [];
    for (const [address, clipboardCell] of cells) {
      this.restoreCell(address, clipboardCell);
      if (clipboardCell.type === _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.FORMULA) {
        const {
          dependencies
        } = this.parser.fetchCachedResult(clipboardCell.hash);
        addedNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceSheetId, address, dependencies));
      }
    }
    return addedNamedExpressions;
  }
  /**
   * Restores a single cell.
   * @param {SimpleCellAddress} address
   * @param {ClipboardCell} clipboardCell
   */
  restoreCell(address, clipboardCell) {
    switch (clipboardCell.type) {
      case _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.VALUE:
        {
          this.setValueToCell(clipboardCell, address);
          break;
        }
      case _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.FORMULA:
        {
          this.setFormulaToCellFromCache(clipboardCell.hash, address);
          break;
        }
      case _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.EMPTY:
        {
          this.setCellEmpty(address);
          break;
        }
      case _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.PARSING_ERROR:
        {
          this.setParsingErrorToCell(clipboardCell.rawInput, clipboardCell.errors, address);
          break;
        }
    }
  }
  getOldContent(address) {
    const vertex = this.dependencyGraph.getCell(address);
    if (vertex === undefined || vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.EmptyCellVertex) {
      return [address, {
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.EMPTY
      }];
    } else if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.ValueCellVertex) {
      return [address, Object.assign({
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.VALUE
      }, vertex.getValues())];
    } else if (vertex instanceof _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_8__.FormulaVertex) {
      return [vertex.getAddress(this.lazilyTransformingAstService), {
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.FORMULA,
        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))
      }];
    } else if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.ParsingErrorVertex) {
      return [address, {
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.PARSING_ERROR,
        rawInput: vertex.rawInput,
        errors: vertex.errors
      }];
    }
    throw Error('Trying to copy unsupported type');
  }
  getClipboardCell(address) {
    const vertex = this.dependencyGraph.getCell(address);
    if (vertex === undefined || vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.EmptyCellVertex) {
      return {
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.EMPTY
      };
    } else if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.ValueCellVertex) {
      return Object.assign({
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.VALUE
      }, vertex.getValues());
    } else if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.ArrayVertex) {
      const val = vertex.getArrayCellValue(address);
      if (val === _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_17__.EmptyValue) {
        return {
          type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.EMPTY
        };
      }
      return {
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.VALUE,
        parsedValue: val,
        rawValue: vertex.getArrayCellRawValue(address)
      };
    } else if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.FormulaCellVertex) {
      return {
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.FORMULA,
        hash: this.parser.computeHashFromAst(vertex.getFormula(this.lazilyTransformingAstService))
      };
    } else if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.ParsingErrorVertex) {
      return {
        type: _ClipboardOperations__WEBPACK_IMPORTED_MODULE_5__.ClipboardCellType.PARSING_ERROR,
        rawInput: vertex.rawInput,
        errors: vertex.errors
      };
    }
    throw Error('Trying to copy unsupported type');
  }
  getSheetClipboardCells(sheet) {
    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);
    const arr = new Array(sheetHeight);
    for (let i = 0; i < sheetHeight; i++) {
      arr[i] = new Array(sheetWidth);
      for (let j = 0; j < sheetWidth; j++) {
        const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.simpleCellAddress)(sheet, j, i);
        arr[i][j] = this.getClipboardCell(address);
      }
    }
    return arr;
  }
  getRangeClipboardCells(range) {
    const result = [];
    for (const address of range.addresses(this.dependencyGraph)) {
      result.push([address, this.getClipboardCell(address)]);
    }
    return result;
  }
  setCellContent(address, newCellContent) {
    const parsedCellContent = this.cellContentParser.parse(newCellContent);
    const oldContent = this.getOldContent(address);
    if (parsedCellContent instanceof _CellContentParser__WEBPACK_IMPORTED_MODULE_4__.CellContent.Formula) {
      const parserResult = this.parser.parse(parsedCellContent.formula, address);
      const {
        ast,
        errors
      } = parserResult;
      if (errors.length > 0) {
        this.setParsingErrorToCell(parsedCellContent.formula, errors, address);
      } else {
        try {
          const size = this.arraySizePredictor.checkArraySize(ast, address);
          if (size.width <= 0 || size.height <= 0) {
            throw Error('Incorrect array size');
          }
          this.setFormulaToCell(address, size, parserResult);
        } catch (error) {
          if (!error.message) {
            throw error;
          }
          const parsingError = {
            type: _parser__WEBPACK_IMPORTED_MODULE_19__.ParsingErrorType.InvalidRangeSize,
            message: 'Invalid range size.'
          };
          this.setParsingErrorToCell(parsedCellContent.formula, [parsingError], address);
        }
      }
    } else if (parsedCellContent instanceof _CellContentParser__WEBPACK_IMPORTED_MODULE_4__.CellContent.Empty) {
      this.setCellEmpty(address);
    } else {
      this.setValueToCell({
        parsedValue: parsedCellContent.value,
        rawValue: newCellContent
      }, address);
    }
    return oldContent;
  }
  setSheetContent(sheetId, newSheetContent) {
    this.clearSheet(sheetId);
    for (let i = 0; i < newSheetContent.length; i++) {
      for (let j = 0; j < newSheetContent[i].length; j++) {
        const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.simpleCellAddress)(sheetId, j, i);
        this.setCellContent(address, newSheetContent[i][j]);
      }
    }
  }
  setParsingErrorToCell(rawInput, errors, address) {
    const oldValue = this.dependencyGraph.getCellValue(address);
    const vertex = new _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.ParsingErrorVertex(errors, rawInput);
    const arrayChanges = this.dependencyGraph.setParsingErrorToCell(address, vertex);
    this.columnSearch.remove((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_17__.getRawValue)(oldValue), address);
    this.columnSearch.applyChanges(arrayChanges.getChanges());
    this.changes.addAll(arrayChanges);
    this.changes.addChange(vertex.getCellValue(), address);
  }
  setFormulaToCell(address, size, {
    ast,
    hasVolatileFunction,
    hasStructuralChangeFunction,
    dependencies
  }) {
    const oldValue = this.dependencyGraph.getCellValue(address);
    const arrayChanges = this.dependencyGraph.setFormulaToCell(address, ast, (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.absolutizeDependencies)(dependencies, address), size, hasVolatileFunction, hasStructuralChangeFunction);
    this.columnSearch.remove((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_17__.getRawValue)(oldValue), address);
    this.columnSearch.applyChanges(arrayChanges.getChanges());
    this.changes.addAll(arrayChanges);
  }
  setValueToCell(value, address) {
    const oldValue = this.dependencyGraph.getCellValue(address);
    const arrayChanges = this.dependencyGraph.setValueToCell(address, value);
    this.columnSearch.change((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_17__.getRawValue)(oldValue), (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_17__.getRawValue)(value.parsedValue), address);
    this.columnSearch.applyChanges(arrayChanges.getChanges().filter(change => !(0,_Cell__WEBPACK_IMPORTED_MODULE_3__.equalSimpleCellAddress)(change.address, address)));
    this.changes.addAll(arrayChanges);
    this.changes.addChange(value.parsedValue, address);
  }
  setCellEmpty(address) {
    if (this.dependencyGraph.isArrayInternalCell(address)) {
      return;
    }
    const oldValue = this.dependencyGraph.getCellValue(address);
    const arrayChanges = this.dependencyGraph.setCellEmpty(address);
    this.columnSearch.remove((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_17__.getRawValue)(oldValue), address);
    this.columnSearch.applyChanges(arrayChanges.getChanges());
    this.changes.addAll(arrayChanges);
    this.changes.addChange(_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_17__.EmptyValue, address);
  }
  setFormulaToCellFromCache(formulaHash, address) {
    const {
      ast,
      hasVolatileFunction,
      hasStructuralChangeFunction,
      dependencies
    } = this.parser.fetchCachedResult(formulaHash);
    const absoluteDependencies = (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.absolutizeDependencies)(dependencies, address);
    const [cleanedAst] = new _dependencyTransformers_CleanOutOfScopeDependenciesTransformer__WEBPACK_IMPORTED_MODULE_11__.CleanOutOfScopeDependenciesTransformer(address.sheet).transformSingleAst(ast, address);
    this.parser.rememberNewAst(cleanedAst);
    const cleanedDependencies = (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.filterDependenciesOutOfScope)(absoluteDependencies);
    const size = this.arraySizePredictor.checkArraySize(ast, address);
    this.dependencyGraph.setFormulaToCell(address, cleanedAst, cleanedDependencies, size, hasVolatileFunction, hasStructuralChangeFunction);
  }
  /**
   * Returns true if row number is outside of given sheet.
   * @param {number} row - row number
   * @param {number} sheet - sheet ID number
   */
  rowEffectivelyNotInSheet(row, sheet) {
    const height = this.dependencyGraph.addressMapping.getHeight(sheet);
    return row >= height;
  }
  getAndClearContentChanges() {
    const changes = this.changes;
    this.changes = _ContentChanges__WEBPACK_IMPORTED_MODULE_6__.ContentChanges.empty();
    return changes;
  }
  forceApplyPostponedTransformations() {
    this.dependencyGraph.forceApplyPostponedTransformations();
  }
  /**
   * Removes multiple rows from sheet. </br>
   * Does nothing if rows are outside of effective sheet size.
   * @param {RowsSpan} rowsToRemove - rows to remove
   */
  doRemoveRows(rowsToRemove) {
    if (this.rowEffectivelyNotInSheet(rowsToRemove.rowStart, rowsToRemove.sheet)) {
      return;
    }
    const removedCells = [];
    for (const [address] of this.dependencyGraph.entriesFromRowsSpan(rowsToRemove)) {
      removedCells.push({
        address,
        cellType: this.getClipboardCell(address)
      });
    }
    const {
      affectedArrays,
      contentChanges
    } = this.dependencyGraph.removeRows(rowsToRemove);
    this.columnSearch.applyChanges(contentChanges.getChanges());
    let version = 0;
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_22__.StatType.TRANSFORM_ASTS, () => {
      const transformation = new _dependencyTransformers_RemoveRowsTransformer__WEBPACK_IMPORTED_MODULE_14__.RemoveRowsTransformer(rowsToRemove);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      version = this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.rewriteAffectedArrays(affectedArrays);
    return {
      version: version,
      removedCells,
      rowFrom: rowsToRemove.rowStart,
      rowCount: rowsToRemove.numberOfRows
    };
  }
  /**
   * Removes multiple columns from sheet. </br>
   * Does nothing if columns are outside of effective sheet size.
   * @param {ColumnsSpan} columnsToRemove - columns to remove
   */
  doRemoveColumns(columnsToRemove) {
    if (this.columnEffectivelyNotInSheet(columnsToRemove.columnStart, columnsToRemove.sheet)) {
      return;
    }
    const removedCells = [];
    for (const [address] of this.dependencyGraph.entriesFromColumnsSpan(columnsToRemove)) {
      removedCells.push({
        address,
        cellType: this.getClipboardCell(address)
      });
    }
    const {
      affectedArrays,
      contentChanges
    } = this.dependencyGraph.removeColumns(columnsToRemove);
    this.columnSearch.applyChanges(contentChanges.getChanges());
    this.columnSearch.removeColumns(columnsToRemove);
    let version = 0;
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_22__.StatType.TRANSFORM_ASTS, () => {
      const transformation = new _dependencyTransformers_RemoveColumnsTransformer__WEBPACK_IMPORTED_MODULE_13__.RemoveColumnsTransformer(columnsToRemove);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      version = this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.rewriteAffectedArrays(affectedArrays);
    return {
      version: version,
      removedCells,
      columnFrom: columnsToRemove.columnStart,
      columnCount: columnsToRemove.numberOfColumns
    };
  }
  /**
   * Add multiple rows to sheet. </br>
   * Does nothing if rows are outside of effective sheet size.
   * @param {RowsSpan} addedRows - rows to add
   */
  doAddRows(addedRows) {
    if (this.rowEffectivelyNotInSheet(addedRows.rowStart, addedRows.sheet)) {
      return;
    }
    const {
      affectedArrays
    } = this.dependencyGraph.addRows(addedRows);
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_22__.StatType.TRANSFORM_ASTS, () => {
      const transformation = new _dependencyTransformers_AddRowsTransformer__WEBPACK_IMPORTED_MODULE_10__.AddRowsTransformer(addedRows);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.rewriteAffectedArrays(affectedArrays);
  }
  rewriteAffectedArrays(affectedArrays) {
    for (const arrayVertex of affectedArrays.values()) {
      if (arrayVertex.array.size.isRef) {
        continue;
      }
      const ast = arrayVertex.getFormula(this.lazilyTransformingAstService);
      const address = arrayVertex.getAddress(this.lazilyTransformingAstService);
      const hash = this.parser.computeHashFromAst(ast);
      this.setFormulaToCellFromCache(hash, address);
    }
  }
  /**
   * Add multiple columns to sheet </br>
   * Does nothing if columns are outside of effective sheet size
   * @param {ColumnsSpan} addedColumns - object containing information about columns to add
   */
  doAddColumns(addedColumns) {
    if (this.columnEffectivelyNotInSheet(addedColumns.columnStart, addedColumns.sheet)) {
      return;
    }
    const {
      affectedArrays,
      contentChanges
    } = this.dependencyGraph.addColumns(addedColumns);
    this.columnSearch.addColumns(addedColumns);
    this.columnSearch.applyChanges(contentChanges.getChanges());
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_22__.StatType.TRANSFORM_ASTS, () => {
      const transformation = new _dependencyTransformers_AddColumnsTransformer__WEBPACK_IMPORTED_MODULE_9__.AddColumnsTransformer(addedColumns);
      transformation.performEagerTransformations(this.dependencyGraph, this.parser);
      this.lazilyTransformingAstService.addTransformation(transformation);
    });
    this.rewriteAffectedArrays(affectedArrays);
  }
  /**
   * Returns true if row number is outside of given sheet.
   * @param {number} column - row number
   * @param {number} sheet - sheet ID number
   */
  columnEffectivelyNotInSheet(column, sheet) {
    const width = this.dependencyGraph.addressMapping.getWidth(sheet);
    return column >= width;
  }
  adjustNamedExpressionEdges(namedExpression, expressionName, sheetId) {
    if (sheetId === undefined) {
      return;
    }
    const {
      vertex: localVertex,
      id: maybeLocalVertexId
    } = this.dependencyGraph.fetchCellOrCreateEmpty(namedExpression.address);
    const localVertexId = maybeLocalVertexId !== null && maybeLocalVertexId !== void 0 ? maybeLocalVertexId : this.dependencyGraph.graph.getNodeId(localVertex);
    const globalNamedExpression = this.namedExpressions.workbookNamedExpressionOrPlaceholder(expressionName);
    const {
      vertex: globalVertex,
      id: maybeGlobalVertexId
    } = this.dependencyGraph.fetchCellOrCreateEmpty(globalNamedExpression.address);
    const globalVertexId = maybeGlobalVertexId !== null && maybeGlobalVertexId !== void 0 ? maybeGlobalVertexId : this.dependencyGraph.graph.getNodeId(globalVertex);
    for (const adjacentNode of this.dependencyGraph.graph.adjacentNodes(globalVertex)) {
      if (adjacentNode instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.FormulaCellVertex && adjacentNode.getAddress(this.lazilyTransformingAstService).sheet === sheetId) {
        const ast = adjacentNode.getFormula(this.lazilyTransformingAstService);
        const formulaAddress = adjacentNode.getAddress(this.lazilyTransformingAstService);
        const {
          dependencies
        } = this.parser.fetchCachedResultForAst(ast);
        for (const dependency of (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.absolutizeDependencies)(dependencies, formulaAddress)) {
          if (dependency instanceof _parser__WEBPACK_IMPORTED_MODULE_19__.NamedExpressionDependency && dependency.name.toLowerCase() === namedExpression.displayName.toLowerCase()) {
            this.dependencyGraph.graph.removeEdge(globalVertexId, adjacentNode);
            this.dependencyGraph.graph.addEdge(localVertexId, adjacentNode);
          }
        }
      }
    }
  }
  storeNamedExpressionInCell(address, expression) {
    const parsedCellContent = this.cellContentParser.parse(expression);
    if (parsedCellContent instanceof _CellContentParser__WEBPACK_IMPORTED_MODULE_4__.CellContent.Formula) {
      const parsingResult = this.parser.parse(parsedCellContent.formula, (0,_Cell__WEBPACK_IMPORTED_MODULE_3__.simpleCellAddress)(-1, 0, 0));
      if ((0,_NamedExpressions__WEBPACK_IMPORTED_MODULE_18__.doesContainRelativeReferences)(parsingResult.ast)) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_16__.NoRelativeAddressesAllowedError();
      }
      const {
        ast,
        hasVolatileFunction,
        hasStructuralChangeFunction,
        dependencies
      } = parsingResult;
      this.dependencyGraph.setFormulaToCell(address, ast, (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.absolutizeDependencies)(dependencies, address), _ArraySize__WEBPACK_IMPORTED_MODULE_2__.ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);
    } else if (parsedCellContent instanceof _CellContentParser__WEBPACK_IMPORTED_MODULE_4__.CellContent.Empty) {
      this.setCellEmpty(address);
    } else {
      this.setValueToCell({
        parsedValue: parsedCellContent.value,
        rawValue: expression
      }, address);
    }
  }
  updateNamedExpressionsForMovedCells(sourceLeftCorner, width, height, destinationLeftCorner) {
    if (sourceLeftCorner.sheet === destinationLeftCorner.sheet) {
      return [];
    }
    const addedGlobalNamedExpressions = [];
    const targetRange = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(destinationLeftCorner, width, height);
    for (const formulaAddress of targetRange.addresses(this.dependencyGraph)) {
      const vertex = this.addressMapping.fetchCell(formulaAddress);
      if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.FormulaCellVertex && formulaAddress.sheet !== sourceLeftCorner.sheet) {
        const ast = vertex.getFormula(this.lazilyTransformingAstService);
        const {
          dependencies
        } = this.parser.fetchCachedResultForAst(ast);
        addedGlobalNamedExpressions.push(...this.updateNamedExpressionsForTargetAddress(sourceLeftCorner.sheet, formulaAddress, dependencies));
      }
    }
    return addedGlobalNamedExpressions;
  }
  updateNamedExpressionsForTargetAddress(sourceSheet, targetAddress, dependencies) {
    if (sourceSheet === targetAddress.sheet) {
      return [];
    }
    const addedGlobalNamedExpressions = [];
    const vertex = this.addressMapping.fetchCell(targetAddress);
    for (const namedExpressionDependency of (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.absolutizeDependencies)(dependencies, targetAddress)) {
      if (!(namedExpressionDependency instanceof _parser__WEBPACK_IMPORTED_MODULE_19__.NamedExpressionDependency)) {
        continue;
      }
      const expressionName = namedExpressionDependency.name;
      const sourceVertex = this.dependencyGraph.fetchNamedExpressionVertex(expressionName, sourceSheet).vertex;
      const namedExpressionInTargetScope = this.namedExpressions.isExpressionInScope(expressionName, targetAddress.sheet);
      const targetScopeExpressionVertex = namedExpressionInTargetScope ? this.dependencyGraph.fetchNamedExpressionVertex(expressionName, targetAddress.sheet).vertex : this.copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedGlobalNamedExpressions);
      if (targetScopeExpressionVertex !== sourceVertex) {
        this.dependencyGraph.graph.removeEdgeIfExists(sourceVertex, vertex);
        this.dependencyGraph.graph.addEdge(targetScopeExpressionVertex, vertex);
      }
    }
    return addedGlobalNamedExpressions;
  }
  allocateNamedExpressionAddressSpace() {
    this.dependencyGraph.addressMapping.addSheet(_NamedExpressions__WEBPACK_IMPORTED_MODULE_18__.NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS, new _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.SparseStrategy(0, 0));
  }
  copyOrFetchGlobalNamedExpressionVertex(expressionName, sourceVertex, addedNamedExpressions) {
    let expression = this.namedExpressions.namedExpressionForScope(expressionName);
    if (expression === undefined) {
      expression = this.namedExpressions.addNamedExpression(expressionName);
      addedNamedExpressions.push(expression.normalizeExpressionName());
      if (sourceVertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.FormulaCellVertex) {
        const parsingResult = this.parser.fetchCachedResultForAst(sourceVertex.getFormula(this.lazilyTransformingAstService));
        const {
          ast,
          hasVolatileFunction,
          hasStructuralChangeFunction,
          dependencies
        } = parsingResult;
        this.dependencyGraph.setFormulaToCell(expression.address, ast, (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.absolutizeDependencies)(dependencies, expression.address), _ArraySize__WEBPACK_IMPORTED_MODULE_2__.ArraySize.scalar(), hasVolatileFunction, hasStructuralChangeFunction);
      } else if (sourceVertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.EmptyCellVertex) {
        this.setCellEmpty(expression.address);
      } else if (sourceVertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_7__.ValueCellVertex) {
        this.setValueToCell(sourceVertex.getValues(), expression.address);
      }
    }
    return this.dependencyGraph.fetchCellOrCreateEmpty(expression.address).vertex;
  }
}
function normalizeRemovedIndexes(indexes) {
  if (indexes.length <= 1) {
    return indexes;
  }
  const sorted = [...indexes].sort(([a], [b]) => a - b);
  /* merge overlapping and adjacent indexes */
  const merged = sorted.reduce((acc, [startIndex, amount]) => {
    const previous = acc[acc.length - 1];
    const lastIndex = previous[0] + previous[1];
    if (startIndex <= lastIndex) {
      previous[1] += Math.max(0, amount - (lastIndex - startIndex));
    } else {
      acc.push([startIndex, amount]);
    }
    return acc;
  }, [sorted[0]]);
  /* shift further indexes */
  let shift = 0;
  for (let i = 0; i < merged.length; ++i) {
    merged[i][0] -= shift;
    shift += merged[i][1];
  }
  return merged;
}
function normalizeAddedIndexes(indexes) {
  if (indexes.length <= 1) {
    return indexes;
  }
  const sorted = [...indexes].sort(([a], [b]) => a - b);
  /* merge indexes with same start */
  const merged = sorted.reduce((acc, [startIndex, amount]) => {
    const previous = acc[acc.length - 1];
    if (startIndex === previous[0]) {
      previous[1] = Math.max(previous[1], amount);
    } else {
      acc.push([startIndex, amount]);
    }
    return acc;
  }, [sorted[0]]);
  /* shift further indexes */
  let shift = 0;
  for (let i = 0; i < merged.length; ++i) {
    merged[i][0] += shift;
    shift += merged[i][1];
  }
  return merged;
}
function isPositiveInteger(n) {
  return Number.isInteger(n) && n > 0;
}
function isRowOrColumnRange(leftCorner, width, height) {
  return leftCorner.row === 0 && isPositiveInteger(width) && height === Number.POSITIVE_INFINITY || leftCorner.col === 0 && isPositiveInteger(height) && width === Number.POSITIVE_INFINITY;
}

/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddColumnsTransformer: () => (/* binding */ AddColumnsTransformer)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _Transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class AddColumnsTransformer extends _Transformer__WEBPACK_IMPORTED_MODULE_1__.Transformer {
  constructor(columnsSpan) {
    super();
    this.columnsSpan = columnsSpan;
  }
  get sheet() {
    return this.columnsSpan.sheet;
  }
  isIrreversible() {
    return false;
  }
  transformRowRangeAst(ast, _formulaAddress) {
    return ast;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(_start, _end, _formulaAddress) {
    throw Error('Not implemented');
  }
  transformColumnRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    const absoluteDependencySheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(dependencyAddress, formulaAddress);
    // Case 4 and 5
    if (absoluteDependencySheet !== this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {
      return false;
    }
    const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);
    // Case 3
    if (absoluteDependencySheet === this.columnsSpan.sheet && formulaAddress.sheet !== this.columnsSpan.sheet) {
      if (this.columnsSpan.columnStart <= absolutizedDependencyAddress.col) {
        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
      } else {
        return false;
      }
    }
    // Case 2
    if (formulaAddress.sheet === this.columnsSpan.sheet && absoluteDependencySheet !== this.columnsSpan.sheet) {
      if (dependencyAddress.isColumnAbsolute()) {
        return false;
      }
      if (formulaAddress.col < this.columnsSpan.columnStart) {
        return false;
      }
      return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
    }
    // Case 1
    if (dependencyAddress.isColumnAbsolute()) {
      if (dependencyAddress.col < this.columnsSpan.columnStart) {
        // Case Aa
        return false;
      } else {
        // Case Ab
        return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
      }
    } else {
      const absolutizedDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);
      if (absolutizedDependencyAddress.col < this.columnsSpan.columnStart) {
        if (formulaAddress.col < this.columnsSpan.columnStart) {
          // Case Raa
          return false;
        } else {
          // Case Rab
          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
        }
      } else {
        if (formulaAddress.col < this.columnsSpan.columnStart) {
          // Case Rba
          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
        } else {
          // Case Rbb
          return false;
        }
      }
    }
  }
  fixNodeAddress(address) {
    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {
      return Object.assign(Object.assign({}, address), {
        col: address.col + this.columnsSpan.numberOfColumns
      });
    } else {
      return address;
    }
  }
  transformRange(start, end, formulaAddress) {
    const newStart = this.transformCellAddress(start, formulaAddress);
    const newEnd = this.transformCellAddress(end, formulaAddress);
    if (newStart === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF || newEnd === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF) {
      return _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF;
    } else if (newStart || newEnd) {
      return [newStart || start, newEnd || end];
    } else {
      return false;
    }
  }
}

/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Transformer: () => (/* binding */ Transformer)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class Transformer {
  performEagerTransformations(graph, parser) {
    for (const node of graph.arrayFormulaNodes()) {
      const [newAst, newAddress] = this.transformSingleAst(node.getFormula(graph.lazilyTransformingAstService), node.getAddress(graph.lazilyTransformingAstService));
      const cachedAst = parser.rememberNewAst(newAst);
      node.setFormula(cachedAst);
      node.setAddress(newAddress);
    }
  }
  transformSingleAst(ast, address) {
    const newAst = this.transformAst(ast, address);
    const newAddress = this.fixNodeAddress(address);
    return [newAst, newAddress];
  }
  transformAst(ast, address) {
    switch (ast.type) {
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.CELL_REFERENCE:
        {
          return this.transformCellReferenceAst(ast, address);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.CELL_RANGE:
        {
          return this.transformCellRangeAst(ast, address);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.COLUMN_RANGE:
        {
          return this.transformColumnRangeAst(ast, address);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.ROW_RANGE:
        {
          return this.transformRowRangeAst(ast, address);
        }
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.EMPTY:
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.ERROR:
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.NUMBER:
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.NAMED_EXPRESSION:
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.ERROR_WITH_RAW_INPUT:
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.STRING:
        {
          return ast;
        }
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.PERCENT_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.MINUS_UNARY_OP:
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.PLUS_UNARY_OP:
        {
          return Object.assign(Object.assign({}, ast), {
            value: this.transformAst(ast.value, address)
          });
        }
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.FUNCTION_CALL:
        {
          return Object.assign(Object.assign({}, ast), {
            procedureName: ast.procedureName,
            args: ast.args.map(arg => this.transformAst(arg, address))
          });
        }
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.PARENTHESIS:
        {
          return Object.assign(Object.assign({}, ast), {
            expression: this.transformAst(ast.expression, address)
          });
        }
      case _parser__WEBPACK_IMPORTED_MODULE_1__.AstNodeType.ARRAY:
        {
          return Object.assign(Object.assign({}, ast), {
            args: ast.args.map(row => row.map(val => this.transformAst(val, address)))
          });
        }
      default:
        {
          return Object.assign(Object.assign({}, ast), {
            left: this.transformAst(ast.left, address),
            right: this.transformAst(ast.right, address)
          });
        }
    }
  }
  transformCellReferenceAst(ast, formulaAddress) {
    const newCellAddress = this.transformCellAddress(ast.reference, formulaAddress);
    if (newCellAddress instanceof _parser__WEBPACK_IMPORTED_MODULE_1__.CellAddress) {
      return Object.assign(Object.assign({}, ast), {
        reference: newCellAddress
      });
    } else if (newCellAddress === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF) {
      return (0,_parser__WEBPACK_IMPORTED_MODULE_1__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF));
    } else {
      return ast;
    }
  }
  transformCellRangeAst(ast, formulaAddress) {
    const newRange = this.transformCellRange(ast.start, ast.end, formulaAddress);
    if (Array.isArray(newRange)) {
      return Object.assign(Object.assign({}, ast), {
        start: newRange[0],
        end: newRange[1]
      });
    } else if (newRange === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF) {
      return (0,_parser__WEBPACK_IMPORTED_MODULE_1__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF));
    } else {
      return ast;
    }
  }
  transformColumnRangeAst(ast, formulaAddress) {
    const newRange = this.transformColumnRange(ast.start, ast.end, formulaAddress);
    if (Array.isArray(newRange)) {
      return Object.assign(Object.assign({}, ast), {
        start: newRange[0],
        end: newRange[1]
      });
    } else if (newRange === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF) {
      return (0,_parser__WEBPACK_IMPORTED_MODULE_1__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF));
    } else {
      return ast;
    }
  }
  transformRowRangeAst(ast, formulaAddress) {
    const newRange = this.transformRowRange(ast.start, ast.end, formulaAddress);
    if (Array.isArray(newRange)) {
      return Object.assign(Object.assign({}, ast), {
        start: newRange[0],
        end: newRange[1]
      });
    } else if (newRange === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF) {
      return (0,_parser__WEBPACK_IMPORTED_MODULE_1__.buildCellErrorAst)(new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF));
    } else {
      return ast;
    }
  }
}

/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddRowsTransformer: () => (/* binding */ AddRowsTransformer)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _Transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class AddRowsTransformer extends _Transformer__WEBPACK_IMPORTED_MODULE_1__.Transformer {
  constructor(rowsSpan) {
    super();
    this.rowsSpan = rowsSpan;
  }
  get sheet() {
    return this.rowsSpan.sheet;
  }
  isIrreversible() {
    return false;
  }
  transformColumnRangeAst(ast, _formulaAddress) {
    return ast;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformColumnRange(_start, _end, _formulaAddress) {
    throw Error('Not implemented');
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    const absoluteDependencySheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(dependencyAddress, formulaAddress);
    // Case 4 and 5
    if (absoluteDependencySheet !== this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {
      return false;
    }
    const absolutizedDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);
    // Case 3
    if (absoluteDependencySheet === this.rowsSpan.sheet && formulaAddress.sheet !== this.rowsSpan.sheet) {
      if (this.rowsSpan.rowStart <= absolutizedDependencyAddress.row) {
        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
      } else {
        return false;
      }
    }
    // Case 2
    if (formulaAddress.sheet === this.rowsSpan.sheet && absoluteDependencySheet !== this.rowsSpan.sheet) {
      if (dependencyAddress.isRowAbsolute()) {
        return false;
      }
      if (formulaAddress.row < this.rowsSpan.rowStart) {
        return false;
      }
      return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
    }
    // Case 1
    if (dependencyAddress.isRowAbsolute()) {
      if (dependencyAddress.row < this.rowsSpan.rowStart) {
        // Case Aa
        return false;
      } else {
        // Case Ab
        return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
      }
    } else {
      if (absolutizedDependencyAddress.row < this.rowsSpan.rowStart) {
        if (formulaAddress.row < this.rowsSpan.rowStart) {
          // Case Raa
          return false;
        } else {
          // Case Rab
          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
        }
      } else {
        if (formulaAddress.row < this.rowsSpan.rowStart) {
          // Case Rba
          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
        } else {
          // Case Rbb
          return false;
        }
      }
    }
  }
  fixNodeAddress(address) {
    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {
      return Object.assign(Object.assign({}, address), {
        row: address.row + this.rowsSpan.numberOfRows
      });
    } else {
      return address;
    }
  }
  transformRange(start, end, formulaAddress) {
    const newStart = this.transformCellAddress(start, formulaAddress);
    const newEnd = this.transformCellAddress(end, formulaAddress);
    if (newStart === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF || newEnd === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF) {
      return _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF;
    } else if (newStart || newEnd) {
      return [newStart || start, newEnd || end];
    } else {
      return false;
    }
  }
}

/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CleanOutOfScopeDependenciesTransformer: () => (/* binding */ CleanOutOfScopeDependenciesTransformer)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _Transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class CleanOutOfScopeDependenciesTransformer extends _Transformer__WEBPACK_IMPORTED_MODULE_1__.Transformer {
  constructor(sheet) {
    super();
    this.sheet = sheet;
  }
  isIrreversible() {
    return true;
  }
  fixNodeAddress(address) {
    return address;
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    return dependencyAddress.isInvalid(formulaAddress) ? _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF : false;
  }
  transformCellRange(start, end, formulaAddress) {
    return start.isInvalid(formulaAddress) || end.isInvalid(formulaAddress) ? _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF : false;
  }
  transformColumnRange(start, end, formulaAddress) {
    return start.isInvalid(formulaAddress) || end.isInvalid(formulaAddress) ? _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF : false;
  }
  transformRowRange(start, end, formulaAddress) {
    return start.isInvalid(formulaAddress) || end.isInvalid(formulaAddress) ? _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF : false;
  }
}

/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DependentFormulaTransformer: () => (/* binding */ DependentFormulaTransformer),
/* harmony export */   MoveCellsTransformer: () => (/* binding */ MoveCellsTransformer)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _parser_RowAddress__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _Transformer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(118);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class MoveCellsTransformer extends _Transformer__WEBPACK_IMPORTED_MODULE_3__.Transformer {
  constructor(sourceRange, toRight, toBottom, toSheet) {
    super();
    this.sourceRange = sourceRange;
    this.toRight = toRight;
    this.toBottom = toBottom;
    this.toSheet = toSheet;
    this.dependentFormulaTransformer = new DependentFormulaTransformer(sourceRange, toRight, toBottom, toSheet);
  }
  get sheet() {
    return this.sourceRange.sheet;
  }
  isIrreversible() {
    return true;
  }
  transformSingleAst(ast, address) {
    if (this.sourceRange.addressInRange(address)) {
      const newAst = this.transformAst(ast, address);
      return [newAst, this.fixNodeAddress(address)];
    } else {
      return this.dependentFormulaTransformer.transformSingleAst(ast, address);
    }
  }
  fixNodeAddress(address) {
    return (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(this.toSheet, address.col + this.toRight, address.row + this.toBottom);
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    return this.transformAddress(dependencyAddress, formulaAddress);
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformColumnRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformAddress(dependencyAddress, formulaAddress) {
    const sourceRange = this.sourceRange;
    if (dependencyAddress instanceof _parser__WEBPACK_IMPORTED_MODULE_1__.CellAddress) {
      const absoluteDependencyAddress = dependencyAddress.toSimpleCellAddress(formulaAddress);
      if (sourceRange.addressInRange(absoluteDependencyAddress)) {
        // If dependency is internal, move only absolute dimensions
        return dependencyAddress.shiftAbsoluteDimensions(this.toRight, this.toBottom);
      }
    }
    return dependencyAddress.shiftRelativeDimensions(-this.toRight, -this.toBottom);
  }
  transformRange(start, end, formulaAddress) {
    const sourceRange = this.sourceRange;
    if (start instanceof _parser__WEBPACK_IMPORTED_MODULE_1__.CellAddress && end instanceof _parser__WEBPACK_IMPORTED_MODULE_1__.CellAddress) {
      const absoluteStart = start.toSimpleCellAddress(formulaAddress);
      const absoluteEnd = end.toSimpleCellAddress(formulaAddress);
      if (sourceRange.addressInRange(absoluteStart) && sourceRange.addressInRange(absoluteEnd)) {
        return [start.shiftAbsoluteDimensions(this.toRight, this.toBottom), end.shiftAbsoluteDimensions(this.toRight, this.toBottom)];
      }
    }
    return [start.shiftRelativeDimensions(-this.toRight, -this.toBottom), end.shiftRelativeDimensions(-this.toRight, -this.toBottom)];
  }
}
class DependentFormulaTransformer extends _Transformer__WEBPACK_IMPORTED_MODULE_3__.Transformer {
  constructor(sourceRange, toRight, toBottom, toSheet) {
    super();
    this.sourceRange = sourceRange;
    this.toRight = toRight;
    this.toBottom = toBottom;
    this.toSheet = toSheet;
  }
  get sheet() {
    return this.sourceRange.sheet;
  }
  isIrreversible() {
    return true;
  }
  fixNodeAddress(address) {
    return address;
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    if (this.shouldMove(dependencyAddress, formulaAddress)) {
      return dependencyAddress.moved(this.toSheet, this.toRight, this.toBottom);
    }
    return false;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformColumnRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  shouldMove(dependencyAddress, formulaAddress) {
    if (dependencyAddress instanceof _parser__WEBPACK_IMPORTED_MODULE_1__.CellAddress) {
      return this.sourceRange.addressInRange(dependencyAddress.toSimpleCellAddress(formulaAddress));
    } else if (dependencyAddress instanceof _parser_RowAddress__WEBPACK_IMPORTED_MODULE_2__.RowAddress) {
      return this.sourceRange.rowInRange(dependencyAddress.toSimpleRowAddress(formulaAddress)) && !this.sourceRange.isFinite();
    } else {
      return this.sourceRange.columnInRange(dependencyAddress.toSimpleColumnAddress(formulaAddress)) && !this.sourceRange.isFinite();
    }
  }
  transformRange(start, end, formulaAddress) {
    const newStart = this.transformCellAddress(start, formulaAddress);
    const newEnd = this.transformCellAddress(end, formulaAddress);
    if (newStart && newEnd) {
      return [newStart, newEnd];
    }
    return false;
  }
}

/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RemoveColumnsTransformer: () => (/* binding */ RemoveColumnsTransformer)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _Transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class RemoveColumnsTransformer extends _Transformer__WEBPACK_IMPORTED_MODULE_1__.Transformer {
  constructor(columnsSpan) {
    super();
    this.columnsSpan = columnsSpan;
  }
  get sheet() {
    return this.columnsSpan.sheet;
  }
  isIrreversible() {
    return true;
  }
  transformRowRangeAst(ast, _formulaAddress) {
    return ast;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(_start, _end, _formulaAddress) {
    throw Error('Not implemented');
  }
  transformColumnRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    const absoluteDependencySheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(dependencyAddress, formulaAddress);
    // Case 4
    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {
      return false;
    }
    // Case 3 -- removed column in same sheet where dependency is but formula in different
    if (this.columnsSpan.sheet !== formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {
      const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);
      if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {
        // 3.ARa
        return false;
      } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {
        // 3.ARb
        return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
      }
    }
    // Case 2 -- removed column in same sheet where formula but dependency in different sheet
    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet !== absoluteDependencySheet) {
      if (dependencyAddress.isColumnAbsolute()) {
        // 2.A
        return false;
      } else {
        if (formulaAddress.col < this.columnsSpan.columnStart) {
          // 2.Ra
          return false;
        } else if (formulaAddress.col > this.columnsSpan.columnEnd) {
          // 2.Rb
          return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
        }
      }
    }
    // Case 1 -- same sheet
    if (this.columnsSpan.sheet === formulaAddress.sheet && this.columnsSpan.sheet === absoluteDependencySheet) {
      if (dependencyAddress.isColumnAbsolute()) {
        if (dependencyAddress.col < this.columnsSpan.columnStart) {
          // 1.Aa
          return false;
        } else if (dependencyAddress.col > this.columnsSpan.columnEnd) {
          // 1.Ab
          return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
        }
      } else {
        const absoluteDependencyAddress = dependencyAddress.toSimpleColumnAddress(formulaAddress);
        if (absoluteDependencyAddress.col < this.columnsSpan.columnStart) {
          if (formulaAddress.col < this.columnsSpan.columnStart) {
            // 1.Raa
            return false;
          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {
            // 1.Rab
            return dependencyAddress.shiftedByColumns(this.columnsSpan.numberOfColumns);
          }
        } else if (absoluteDependencyAddress.col > this.columnsSpan.columnEnd) {
          if (formulaAddress.col < this.columnsSpan.columnStart) {
            // 1.Rba
            return dependencyAddress.shiftedByColumns(-this.columnsSpan.numberOfColumns);
          } else if (formulaAddress.col > this.columnsSpan.columnEnd) {
            // 1.Rbb
            return false;
          }
        }
      }
    }
    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb
    return _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF;
  }
  fixNodeAddress(address) {
    if (this.columnsSpan.sheet === address.sheet && this.columnsSpan.columnStart <= address.col) {
      return Object.assign(Object.assign({}, address), {
        col: address.col - this.columnsSpan.numberOfColumns
      });
    } else {
      return address;
    }
  }
  transformRange(start, end, formulaAddress) {
    const startSheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(start, formulaAddress);
    let actualStart = start;
    let actualEnd = end;
    if (this.columnsSpan.sheet === startSheet) {
      const startSCA = start.toSimpleColumnAddress(formulaAddress);
      const endSCA = end.toSimpleColumnAddress(formulaAddress);
      if (this.columnsSpan.columnStart <= startSCA.col && this.columnsSpan.columnEnd >= endSCA.col) {
        return _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF;
      }
      if (startSCA.col >= this.columnsSpan.columnStart && startSCA.col <= this.columnsSpan.columnEnd) {
        actualStart = start.shiftedByColumns(this.columnsSpan.columnEnd - startSCA.col + 1);
      }
      if (endSCA.col >= this.columnsSpan.columnStart && endSCA.col <= this.columnsSpan.columnEnd) {
        actualEnd = end.shiftedByColumns(-(endSCA.col - this.columnsSpan.columnStart + 1));
      }
    }
    const newStart = this.transformCellAddress(actualStart, formulaAddress);
    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);
    if (newStart === false && newEnd === false) {
      return [actualStart, actualEnd];
    } else if (newStart === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF || newEnd === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF) {
      throw Error('Cannot happen');
    } else {
      return [newStart || actualStart, newEnd || actualEnd];
    }
  }
}

/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RemoveRowsTransformer: () => (/* binding */ RemoveRowsTransformer)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _Transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class RemoveRowsTransformer extends _Transformer__WEBPACK_IMPORTED_MODULE_1__.Transformer {
  constructor(rowsSpan) {
    super();
    this.rowsSpan = rowsSpan;
  }
  get sheet() {
    return this.rowsSpan.sheet;
  }
  isIrreversible() {
    return true;
  }
  transformColumnRangeAst(ast, _formulaAddress) {
    return ast;
  }
  transformCellAddress(dependencyAddress, formulaAddress) {
    const absoluteDependencySheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(dependencyAddress, formulaAddress);
    // Case 4
    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {
      return false;
    }
    // Case 3 -- removed row in same sheet where dependency is but formula in different
    if (this.rowsSpan.sheet !== formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {
      const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);
      if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {
        // 3.ARa
        return false;
      } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {
        // 3.ARb
        return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
      }
    }
    // Case 2 -- removed row in same sheet where formula but dependency in different sheet
    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet !== absoluteDependencySheet) {
      if (dependencyAddress.isRowAbsolute()) {
        // 2.A
        return false;
      } else {
        if (formulaAddress.row < this.rowsSpan.rowStart) {
          // 2.Ra
          return false;
        } else if (formulaAddress.row > this.rowsSpan.rowEnd) {
          // 2.Rb
          return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
        }
      }
    }
    // Case 1 -- same sheet
    if (this.rowsSpan.sheet === formulaAddress.sheet && this.rowsSpan.sheet === absoluteDependencySheet) {
      if (dependencyAddress.isRowAbsolute()) {
        if (dependencyAddress.row < this.rowsSpan.rowStart) {
          // 1.Aa
          return false;
        } else if (dependencyAddress.row > this.rowsSpan.rowEnd) {
          // 1.Ab
          return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
        }
      } else {
        const absoluteDependencyAddress = dependencyAddress.toSimpleRowAddress(formulaAddress);
        if (absoluteDependencyAddress.row < this.rowsSpan.rowStart) {
          if (formulaAddress.row < this.rowsSpan.rowStart) {
            // 1.Raa
            return false;
          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {
            // 1.Rab
            return dependencyAddress.shiftedByRows(this.rowsSpan.numberOfRows);
          }
        } else if (absoluteDependencyAddress.row > this.rowsSpan.rowEnd) {
          if (formulaAddress.row < this.rowsSpan.rowStart) {
            // 1.Rba
            return dependencyAddress.shiftedByRows(-this.rowsSpan.numberOfRows);
          } else if (formulaAddress.row > this.rowsSpan.rowEnd) {
            // 1.Rbb
            return false;
          }
        }
      }
    }
    // 1.Ac, 1.Rca, 1.Rcb, 3.Ac, 3.Rca, 3.Rcb
    return _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF;
  }
  transformCellRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformRowRange(start, end, formulaAddress) {
    return this.transformRange(start, end, formulaAddress);
  }
  transformColumnRange(_start, _end, _formulaAddress) {
    throw Error('Not implemented');
  }
  fixNodeAddress(address) {
    if (this.rowsSpan.sheet === address.sheet && this.rowsSpan.rowStart <= address.row) {
      return Object.assign(Object.assign({}, address), {
        row: address.row - this.rowsSpan.numberOfRows
      });
    } else {
      return address;
    }
  }
  transformRange(start, end, formulaAddress) {
    const startSheet = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.absoluteSheetReference)(start, formulaAddress);
    let actualStart = start;
    let actualEnd = end;
    if (this.rowsSpan.sheet === startSheet) {
      const startSCA = start.toSimpleRowAddress(formulaAddress);
      const endSCA = end.toSimpleRowAddress(formulaAddress);
      if (this.rowsSpan.rowStart <= startSCA.row && this.rowsSpan.rowEnd >= endSCA.row) {
        return _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF;
      }
      if (startSCA.row >= this.rowsSpan.rowStart && startSCA.row <= this.rowsSpan.rowEnd) {
        actualStart = start.shiftedByRows(this.rowsSpan.rowEnd - startSCA.row + 1);
      }
      if (endSCA.row >= this.rowsSpan.rowStart && endSCA.row <= this.rowsSpan.rowEnd) {
        actualEnd = end.shiftedByRows(-(endSCA.row - this.rowsSpan.rowStart + 1));
      }
    }
    const newStart = this.transformCellAddress(actualStart, formulaAddress);
    const newEnd = this.transformCellAddress(actualEnd, formulaAddress);
    if (newStart === false && newEnd === false) {
      return [actualStart, actualEnd];
    } else if (newStart === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF || newEnd === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF) {
      return _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF;
    } else {
      return [newStart || actualStart, newEnd || actualEnd];
    }
  }
}

/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RemoveSheetTransformer: () => (/* binding */ RemoveSheetTransformer)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _Transformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(118);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class RemoveSheetTransformer extends _Transformer__WEBPACK_IMPORTED_MODULE_1__.Transformer {
  constructor(sheet) {
    super();
    this.sheet = sheet;
  }
  isIrreversible() {
    return true;
  }
  performEagerTransformations(graph, _parser) {
    for (const node of graph.arrayFormulaNodes()) {
      const [newAst] = this.transformSingleAst(node.getFormula(graph.lazilyTransformingAstService), node.getAddress(graph.lazilyTransformingAstService));
      node.setFormula(newAst);
    }
  }
  fixNodeAddress(address) {
    return address;
  }
  transformCellAddress(dependencyAddress, _formulaAddress) {
    return this.transformAddress(dependencyAddress);
  }
  transformCellRange(start, _end, _formulaAddress) {
    return this.transformAddress(start);
  }
  transformColumnRange(start, _end, _formulaAddress) {
    return this.transformAddress(start);
  }
  transformRowRange(start, _end, _formulaAddress) {
    return this.transformAddress(start);
  }
  transformAddress(address) {
    if (address.sheet === this.sheet) {
      return _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF;
    }
    return false;
  }
}

/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findBoundaries: () => (/* binding */ findBoundaries),
/* harmony export */   validateAsSheet: () => (/* binding */ validateAsSheet)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

function validateAsSheet(sheet) {
  if (!Array.isArray(sheet)) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentsError('an array of arrays.');
  }
  for (let i = 0; i < sheet.length; i++) {
    if (!Array.isArray(sheet[i])) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentsError('an array of arrays.');
    }
  }
}
/**
 * Returns actual width, height and fill ratio of a sheet
 *
 * @param sheet - two-dimmensional array sheet representation
 */
function findBoundaries(sheet) {
  let width = 0;
  let height = 0;
  let cellsCount = 0;
  for (let currentRow = 0; currentRow < sheet.length; currentRow++) {
    let currentRowWidth = 0;
    for (let currentCol = 0; currentCol < sheet[currentRow].length; currentCol++) {
      const currentValue = sheet[currentRow][currentCol];
      if (currentValue === undefined || currentValue === null) {
        continue;
      }
      currentRowWidth = currentCol + 1;
      ++cellsCount;
    }
    width = Math.max(width, currentRowWidth);
    if (currentRowWidth > 0) {
      height = currentRow + 1;
    }
  }
  const sheetSize = width * height;
  return {
    height: height,
    width: width,
    fill: sheetSize === 0 ? 0 : cellsCount / sheetSize
  };
}

/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddColumnsUndoEntry: () => (/* binding */ AddColumnsUndoEntry),
/* harmony export */   AddNamedExpressionUndoEntry: () => (/* binding */ AddNamedExpressionUndoEntry),
/* harmony export */   AddRowsUndoEntry: () => (/* binding */ AddRowsUndoEntry),
/* harmony export */   AddSheetUndoEntry: () => (/* binding */ AddSheetUndoEntry),
/* harmony export */   BaseUndoEntry: () => (/* binding */ BaseUndoEntry),
/* harmony export */   BatchUndoEntry: () => (/* binding */ BatchUndoEntry),
/* harmony export */   ChangeNamedExpressionUndoEntry: () => (/* binding */ ChangeNamedExpressionUndoEntry),
/* harmony export */   ClearSheetUndoEntry: () => (/* binding */ ClearSheetUndoEntry),
/* harmony export */   MoveCellsUndoEntry: () => (/* binding */ MoveCellsUndoEntry),
/* harmony export */   MoveColumnsUndoEntry: () => (/* binding */ MoveColumnsUndoEntry),
/* harmony export */   MoveRowsUndoEntry: () => (/* binding */ MoveRowsUndoEntry),
/* harmony export */   PasteUndoEntry: () => (/* binding */ PasteUndoEntry),
/* harmony export */   RemoveColumnsUndoEntry: () => (/* binding */ RemoveColumnsUndoEntry),
/* harmony export */   RemoveNamedExpressionUndoEntry: () => (/* binding */ RemoveNamedExpressionUndoEntry),
/* harmony export */   RemoveRowsUndoEntry: () => (/* binding */ RemoveRowsUndoEntry),
/* harmony export */   RemoveSheetUndoEntry: () => (/* binding */ RemoveSheetUndoEntry),
/* harmony export */   RenameSheetUndoEntry: () => (/* binding */ RenameSheetUndoEntry),
/* harmony export */   SetCellContentsUndoEntry: () => (/* binding */ SetCellContentsUndoEntry),
/* harmony export */   SetColumnOrderUndoEntry: () => (/* binding */ SetColumnOrderUndoEntry),
/* harmony export */   SetRowOrderUndoEntry: () => (/* binding */ SetRowOrderUndoEntry),
/* harmony export */   SetSheetContentUndoEntry: () => (/* binding */ SetSheetContentUndoEntry),
/* harmony export */   UndoRedo: () => (/* binding */ UndoRedo)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _Operations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(116);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class BaseUndoEntry {}
class RemoveRowsUndoEntry extends BaseUndoEntry {
  constructor(command, rowsRemovals) {
    super();
    this.command = command;
    this.rowsRemovals = rowsRemovals;
  }
  doUndo(undoRedo) {
    undoRedo.undoRemoveRows(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRemoveRows(this);
  }
}
class MoveCellsUndoEntry extends BaseUndoEntry {
  constructor(sourceLeftCorner, width, height, destinationLeftCorner, overwrittenCellsData, addedGlobalNamedExpressions, version) {
    super();
    this.sourceLeftCorner = sourceLeftCorner;
    this.width = width;
    this.height = height;
    this.destinationLeftCorner = destinationLeftCorner;
    this.overwrittenCellsData = overwrittenCellsData;
    this.addedGlobalNamedExpressions = addedGlobalNamedExpressions;
    this.version = version;
  }
  doUndo(undoRedo) {
    undoRedo.undoMoveCells(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoMoveCells(this);
  }
}
class AddRowsUndoEntry extends BaseUndoEntry {
  constructor(command) {
    super();
    this.command = command;
  }
  doUndo(undoRedo) {
    undoRedo.undoAddRows(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoAddRows(this);
  }
}
class SetRowOrderUndoEntry extends BaseUndoEntry {
  constructor(sheetId, rowMapping, oldContent) {
    super();
    this.sheetId = sheetId;
    this.rowMapping = rowMapping;
    this.oldContent = oldContent;
  }
  doUndo(undoRedo) {
    undoRedo.undoSetRowOrder(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoSetRowOrder(this);
  }
}
class SetColumnOrderUndoEntry extends BaseUndoEntry {
  constructor(sheetId, columnMapping, oldContent) {
    super();
    this.sheetId = sheetId;
    this.columnMapping = columnMapping;
    this.oldContent = oldContent;
  }
  doUndo(undoRedo) {
    undoRedo.undoSetColumnOrder(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoSetColumnOrder(this);
  }
}
class SetSheetContentUndoEntry extends BaseUndoEntry {
  constructor(sheetId, oldSheetContent, newSheetContent) {
    super();
    this.sheetId = sheetId;
    this.oldSheetContent = oldSheetContent;
    this.newSheetContent = newSheetContent;
  }
  doUndo(undoRedo) {
    undoRedo.undoSetSheetContent(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoSetSheetContent(this);
  }
}
class MoveRowsUndoEntry extends BaseUndoEntry {
  constructor(sheet, startRow, numberOfRows, targetRow, version) {
    super();
    this.sheet = sheet;
    this.startRow = startRow;
    this.numberOfRows = numberOfRows;
    this.targetRow = targetRow;
    this.version = version;
    this.undoStart = this.startRow < this.targetRow ? this.targetRow - this.numberOfRows : this.targetRow;
    this.undoEnd = this.startRow > this.targetRow ? this.startRow + this.numberOfRows : this.startRow;
  }
  doUndo(undoRedo) {
    undoRedo.undoMoveRows(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoMoveRows(this);
  }
}
class MoveColumnsUndoEntry extends BaseUndoEntry {
  constructor(sheet, startColumn, numberOfColumns, targetColumn, version) {
    super();
    this.sheet = sheet;
    this.startColumn = startColumn;
    this.numberOfColumns = numberOfColumns;
    this.targetColumn = targetColumn;
    this.version = version;
    this.undoStart = this.startColumn < this.targetColumn ? this.targetColumn - this.numberOfColumns : this.targetColumn;
    this.undoEnd = this.startColumn > this.targetColumn ? this.startColumn + this.numberOfColumns : this.startColumn;
  }
  doUndo(undoRedo) {
    undoRedo.undoMoveColumns(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoMoveColumns(this);
  }
}
class AddColumnsUndoEntry extends BaseUndoEntry {
  constructor(command) {
    super();
    this.command = command;
  }
  doUndo(undoRedo) {
    undoRedo.undoAddColumns(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoAddColumns(this);
  }
}
class RemoveColumnsUndoEntry extends BaseUndoEntry {
  constructor(command, columnsRemovals) {
    super();
    this.command = command;
    this.columnsRemovals = columnsRemovals;
  }
  doUndo(undoRedo) {
    undoRedo.undoRemoveColumns(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRemoveColumns(this);
  }
}
class AddSheetUndoEntry extends BaseUndoEntry {
  constructor(sheetName) {
    super();
    this.sheetName = sheetName;
  }
  doUndo(undoRedo) {
    undoRedo.undoAddSheet(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoAddSheet(this);
  }
}
class RemoveSheetUndoEntry extends BaseUndoEntry {
  constructor(sheetName, sheetId, oldSheetContent, scopedNamedExpressions, version) {
    super();
    this.sheetName = sheetName;
    this.sheetId = sheetId;
    this.oldSheetContent = oldSheetContent;
    this.scopedNamedExpressions = scopedNamedExpressions;
    this.version = version;
  }
  doUndo(undoRedo) {
    undoRedo.undoRemoveSheet(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRemoveSheet(this);
  }
}
class RenameSheetUndoEntry extends BaseUndoEntry {
  constructor(sheetId, oldName, newName) {
    super();
    this.sheetId = sheetId;
    this.oldName = oldName;
    this.newName = newName;
  }
  doUndo(undoRedo) {
    undoRedo.undoRenameSheet(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRenameSheet(this);
  }
}
class ClearSheetUndoEntry extends BaseUndoEntry {
  constructor(sheetId, oldSheetContent) {
    super();
    this.sheetId = sheetId;
    this.oldSheetContent = oldSheetContent;
  }
  doUndo(undoRedo) {
    undoRedo.undoClearSheet(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoClearSheet(this);
  }
}
class SetCellContentsUndoEntry extends BaseUndoEntry {
  constructor(cellContents) {
    super();
    this.cellContents = cellContents;
  }
  doUndo(undoRedo) {
    undoRedo.undoSetCellContents(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoSetCellContents(this);
  }
}
class PasteUndoEntry extends BaseUndoEntry {
  constructor(targetLeftCorner, oldContent, newContent, addedGlobalNamedExpressions) {
    super();
    this.targetLeftCorner = targetLeftCorner;
    this.oldContent = oldContent;
    this.newContent = newContent;
    this.addedGlobalNamedExpressions = addedGlobalNamedExpressions;
  }
  doUndo(undoRedo) {
    undoRedo.undoPaste(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoPaste(this);
  }
}
class AddNamedExpressionUndoEntry extends BaseUndoEntry {
  constructor(name, newContent, scope, options) {
    super();
    this.name = name;
    this.newContent = newContent;
    this.scope = scope;
    this.options = options;
  }
  doUndo(undoRedo) {
    undoRedo.undoAddNamedExpression(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoAddNamedExpression(this);
  }
}
class RemoveNamedExpressionUndoEntry extends BaseUndoEntry {
  constructor(namedExpression, content, scope) {
    super();
    this.namedExpression = namedExpression;
    this.content = content;
    this.scope = scope;
  }
  doUndo(undoRedo) {
    undoRedo.undoRemoveNamedExpression(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoRemoveNamedExpression(this);
  }
}
class ChangeNamedExpressionUndoEntry extends BaseUndoEntry {
  constructor(namedExpression, newContent, oldContent, scope, options) {
    super();
    this.namedExpression = namedExpression;
    this.newContent = newContent;
    this.oldContent = oldContent;
    this.scope = scope;
    this.options = options;
  }
  doUndo(undoRedo) {
    undoRedo.undoChangeNamedExpression(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoChangeNamedExpression(this);
  }
}
class BatchUndoEntry extends BaseUndoEntry {
  constructor() {
    super(...arguments);
    this.operations = [];
  }
  add(operation) {
    this.operations.push(operation);
  }
  *reversedOperations() {
    for (let i = this.operations.length - 1; i >= 0; i--) {
      yield this.operations[i];
    }
  }
  doUndo(undoRedo) {
    undoRedo.undoBatch(this);
  }
  doRedo(undoRedo) {
    undoRedo.redoBatch(this);
  }
}
class UndoRedo {
  constructor(config, operations) {
    this.operations = operations;
    this.oldData = new Map();
    this.undoStack = [];
    this.redoStack = [];
    this.undoLimit = config.undoLimit;
  }
  saveOperation(operation) {
    if (this.batchUndoEntry !== undefined) {
      this.batchUndoEntry.add(operation);
    } else {
      this.addUndoEntry(operation);
    }
  }
  beginBatchMode() {
    this.batchUndoEntry = new BatchUndoEntry();
  }
  commitBatchMode() {
    if (this.batchUndoEntry === undefined) {
      throw Error('Batch mode wasn\'t started');
    }
    this.addUndoEntry(this.batchUndoEntry);
    this.batchUndoEntry = undefined;
  }
  storeDataForVersion(version, address, astHash) {
    if (!this.oldData.has(version)) {
      this.oldData.set(version, []);
    }
    const currentOldData = this.oldData.get(version);
    currentOldData.push([address, astHash]);
  }
  clearRedoStack() {
    this.redoStack = [];
  }
  clearUndoStack() {
    this.undoStack = [];
  }
  isUndoStackEmpty() {
    return this.undoStack.length === 0;
  }
  isRedoStackEmpty() {
    return this.redoStack.length === 0;
  }
  undo() {
    const operation = this.undoStack.pop();
    if (!operation) {
      throw Error('Attempted to undo without operation on stack');
    }
    this.undoEntry(operation);
    this.redoStack.push(operation);
  }
  undoBatch(batchOperation) {
    for (const operation of batchOperation.reversedOperations()) {
      this.undoEntry(operation);
    }
  }
  undoRemoveRows(operation) {
    this.operations.forceApplyPostponedTransformations();
    const {
      command: {
        sheet
      },
      rowsRemovals
    } = operation;
    for (let i = rowsRemovals.length - 1; i >= 0; --i) {
      const rowsRemoval = rowsRemovals[i];
      this.operations.addRows(new _Operations__WEBPACK_IMPORTED_MODULE_1__.AddRowsCommand(sheet, [[rowsRemoval.rowFrom, rowsRemoval.rowCount]]));
      for (const {
        address,
        cellType
      } of rowsRemoval.removedCells) {
        this.operations.restoreCell(address, cellType);
      }
      this.restoreOldDataFromVersion(rowsRemoval.version - 1);
    }
  }
  undoRemoveColumns(operation) {
    this.operations.forceApplyPostponedTransformations();
    const {
      command: {
        sheet
      },
      columnsRemovals
    } = operation;
    for (let i = columnsRemovals.length - 1; i >= 0; --i) {
      const columnsRemoval = columnsRemovals[i];
      this.operations.addColumns(new _Operations__WEBPACK_IMPORTED_MODULE_1__.AddColumnsCommand(sheet, [[columnsRemoval.columnFrom, columnsRemoval.columnCount]]));
      for (const {
        address,
        cellType
      } of columnsRemoval.removedCells) {
        this.operations.restoreCell(address, cellType);
      }
      this.restoreOldDataFromVersion(columnsRemoval.version - 1);
    }
  }
  undoAddRows(operation) {
    const addedRowsSpans = operation.command.rowsSpans();
    for (let i = addedRowsSpans.length - 1; i >= 0; --i) {
      const addedRows = addedRowsSpans[i];
      this.operations.removeRows(new _Operations__WEBPACK_IMPORTED_MODULE_1__.RemoveRowsCommand(operation.command.sheet, [[addedRows.rowStart, addedRows.numberOfRows]]));
    }
  }
  undoAddColumns(operation) {
    const addedColumnsSpans = operation.command.columnsSpans();
    for (let i = addedColumnsSpans.length - 1; i >= 0; --i) {
      const addedColumns = addedColumnsSpans[i];
      this.operations.removeColumns(new _Operations__WEBPACK_IMPORTED_MODULE_1__.RemoveColumnsCommand(operation.command.sheet, [[addedColumns.columnStart, addedColumns.numberOfColumns]]));
    }
  }
  undoSetCellContents(operation) {
    for (const cellContentData of operation.cellContents) {
      const address = cellContentData.address;
      const [oldContentAddress, oldContent] = cellContentData.oldContent;
      if (!(0,_Cell__WEBPACK_IMPORTED_MODULE_0__.equalSimpleCellAddress)(address, oldContentAddress)) {
        this.operations.setCellEmpty(address);
      }
      this.operations.restoreCell(oldContentAddress, oldContent);
    }
  }
  undoPaste(operation) {
    this.restoreOperationOldContent(operation.oldContent);
    for (const namedExpression of operation.addedGlobalNamedExpressions) {
      this.operations.removeNamedExpression(namedExpression);
    }
  }
  undoMoveRows(operation) {
    const {
      sheet
    } = operation;
    this.operations.moveRows(sheet, operation.undoStart, operation.numberOfRows, operation.undoEnd);
    this.restoreOldDataFromVersion(operation.version - 1);
  }
  undoMoveColumns(operation) {
    const {
      sheet
    } = operation;
    this.operations.moveColumns(sheet, operation.undoStart, operation.numberOfColumns, operation.undoEnd);
    this.restoreOldDataFromVersion(operation.version - 1);
  }
  undoMoveCells(operation) {
    this.operations.forceApplyPostponedTransformations();
    this.operations.moveCells(operation.destinationLeftCorner, operation.width, operation.height, operation.sourceLeftCorner);
    this.restoreOperationOldContent(operation.overwrittenCellsData);
    this.restoreOldDataFromVersion(operation.version - 1);
    for (const namedExpression of operation.addedGlobalNamedExpressions) {
      this.operations.removeNamedExpression(namedExpression);
    }
  }
  undoAddSheet(operation) {
    const {
      sheetName
    } = operation;
    this.operations.removeSheetByName(sheetName);
  }
  undoRemoveSheet(operation) {
    this.operations.forceApplyPostponedTransformations();
    const {
      oldSheetContent,
      sheetId
    } = operation;
    this.operations.addSheet(operation.sheetName);
    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {
      const row = oldSheetContent[rowIndex];
      for (let col = 0; col < row.length; col++) {
        const cellType = row[col];
        const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheetId, col, rowIndex);
        this.operations.restoreCell(address, cellType);
      }
    }
    for (const [namedexpression, content] of operation.scopedNamedExpressions) {
      this.operations.restoreNamedExpression(namedexpression, content, sheetId);
    }
    this.restoreOldDataFromVersion(operation.version - 1);
  }
  undoRenameSheet(operation) {
    this.operations.renameSheet(operation.sheetId, operation.oldName);
  }
  undoClearSheet(operation) {
    const {
      oldSheetContent,
      sheetId
    } = operation;
    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {
      const row = oldSheetContent[rowIndex];
      for (let col = 0; col < row.length; col++) {
        const cellType = row[col];
        const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheetId, col, rowIndex);
        this.operations.restoreCell(address, cellType);
      }
    }
  }
  undoSetSheetContent(operation) {
    const {
      oldSheetContent,
      sheetId
    } = operation;
    this.operations.clearSheet(sheetId);
    for (let rowIndex = 0; rowIndex < oldSheetContent.length; rowIndex++) {
      const row = oldSheetContent[rowIndex];
      for (let col = 0; col < row.length; col++) {
        const cellType = row[col];
        const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheetId, col, rowIndex);
        this.operations.restoreCell(address, cellType);
      }
    }
  }
  undoAddNamedExpression(operation) {
    this.operations.removeNamedExpression(operation.name, operation.scope);
  }
  undoRemoveNamedExpression(operation) {
    this.operations.restoreNamedExpression(operation.namedExpression, operation.content, operation.scope);
  }
  undoChangeNamedExpression(operation) {
    this.operations.restoreNamedExpression(operation.namedExpression, operation.oldContent, operation.scope);
  }
  undoSetRowOrder(operation) {
    this.restoreOperationOldContent(operation.oldContent);
  }
  undoSetColumnOrder(operation) {
    this.restoreOperationOldContent(operation.oldContent);
  }
  redo() {
    const operation = this.redoStack.pop();
    if (!operation) {
      throw Error('Attempted to redo without operation on stack');
    }
    this.redoEntry(operation);
    this.undoStack.push(operation);
  }
  redoBatch(batchOperation) {
    for (const operation of batchOperation.operations) {
      this.redoEntry(operation);
    }
  }
  redoRemoveRows(operation) {
    this.operations.removeRows(operation.command);
  }
  redoMoveCells(operation) {
    this.operations.moveCells(operation.sourceLeftCorner, operation.width, operation.height, operation.destinationLeftCorner);
  }
  redoRemoveColumns(operation) {
    this.operations.removeColumns(operation.command);
  }
  redoPaste(operation) {
    const {
      targetLeftCorner,
      newContent
    } = operation;
    const height = newContent.length;
    const width = newContent[0].length;
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(targetLeftCorner.sheet, targetLeftCorner.col + x, targetLeftCorner.row + y);
        this.operations.restoreCell(address, newContent[y][x]);
      }
    }
  }
  redoSetCellContents(operation) {
    for (const cellContentData of operation.cellContents) {
      this.operations.setCellContent(cellContentData.address, cellContentData.newContent);
    }
  }
  redoAddRows(operation) {
    this.operations.addRows(operation.command);
  }
  redoAddColumns(operation) {
    this.operations.addColumns(operation.command);
  }
  redoRemoveSheet(operation) {
    this.operations.removeSheetByName(operation.sheetName);
  }
  redoAddSheet(operation) {
    this.operations.addSheet(operation.sheetName);
  }
  redoRenameSheet(operation) {
    this.operations.renameSheet(operation.sheetId, operation.newName);
  }
  redoMoveRows(operation) {
    this.operations.moveRows(operation.sheet, operation.startRow, operation.numberOfRows, operation.targetRow);
  }
  redoMoveColumns(operation) {
    this.operations.moveColumns(operation.sheet, operation.startColumn, operation.numberOfColumns, operation.targetColumn);
  }
  redoClearSheet(operation) {
    this.operations.clearSheet(operation.sheetId);
  }
  redoSetSheetContent(operation) {
    const {
      sheetId,
      newSheetContent
    } = operation;
    this.operations.setSheetContent(sheetId, newSheetContent);
  }
  redoAddNamedExpression(operation) {
    this.operations.addNamedExpression(operation.name, operation.newContent, operation.scope, operation.options);
  }
  redoRemoveNamedExpression(operation) {
    this.operations.removeNamedExpression(operation.namedExpression.displayName, operation.scope);
  }
  redoChangeNamedExpression(operation) {
    this.operations.changeNamedExpressionExpression(operation.namedExpression.displayName, operation.newContent, operation.scope, operation.options);
  }
  redoSetRowOrder(operation) {
    this.operations.setRowOrder(operation.sheetId, operation.rowMapping);
  }
  redoSetColumnOrder(operation) {
    this.operations.setColumnOrder(operation.sheetId, operation.columnMapping);
  }
  addUndoEntry(operation) {
    this.undoStack.push(operation);
    this.undoStack.splice(0, Math.max(0, this.undoStack.length - this.undoLimit));
  }
  undoEntry(operation) {
    operation.doUndo(this);
  }
  restoreOperationOldContent(oldContent) {
    for (const [address, clipboardCell] of oldContent) {
      this.operations.restoreCell(address, clipboardCell);
    }
  }
  redoEntry(operation) {
    operation.doRedo(this);
  }
  restoreOldDataFromVersion(version) {
    const oldDataToRestore = this.oldData.get(version) || [];
    for (const entryToRestore of oldDataToRestore) {
      const [address, hash] = entryToRestore;
      this.operations.setFormulaToCellFromCache(hash, address);
    }
  }
}

/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Evaluator: () => (/* binding */ Evaluator)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _ContentChanges__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(68);
/* harmony import */ var _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
/* harmony import */ var _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(80);
/* harmony import */ var _interpreter_InterpreterState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(95);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(69);
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(72);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */










class Evaluator {
  constructor(config, stats, interpreter, lazilyTransformingAstService, dependencyGraph, columnSearch) {
    this.config = config;
    this.stats = stats;
    this.interpreter = interpreter;
    this.lazilyTransformingAstService = lazilyTransformingAstService;
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
  }
  run() {
    this.stats.start(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.TOP_SORT);
    const {
      sorted,
      cycled
    } = this.dependencyGraph.topSortWithScc();
    this.stats.end(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.TOP_SORT);
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.EVALUATION, () => {
      this.recomputeFormulas(cycled, sorted);
    });
  }
  partialRun(vertices) {
    const changes = _ContentChanges__WEBPACK_IMPORTED_MODULE_3__.ContentChanges.empty();
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_9__.StatType.EVALUATION, () => {
      this.dependencyGraph.graph.getTopSortedWithSccSubgraphFrom(vertices, vertex => {
        if (vertex instanceof _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_5__.FormulaVertex) {
          const currentValue = vertex.isComputed() ? vertex.getCellValue() : undefined;
          const newCellValue = this.recomputeFormulaVertexValue(vertex);
          if (newCellValue !== currentValue) {
            const address = vertex.getAddress(this.lazilyTransformingAstService);
            changes.addChange(newCellValue, address);
            this.columnSearch.change((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_7__.getRawValue)(currentValue), (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_7__.getRawValue)(newCellValue), address);
            return true;
          }
          return false;
        } else if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.RangeVertex) {
          vertex.clearCache();
          return true;
        } else {
          return true;
        }
      }, vertex => {
        if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.RangeVertex) {
          vertex.clearCache();
        } else if (vertex instanceof _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_5__.FormulaVertex) {
          const address = vertex.getAddress(this.lazilyTransformingAstService);
          this.columnSearch.remove((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_7__.getRawValue)(vertex.valueOrUndef()), address);
          const error = new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.CYCLE, undefined, vertex);
          vertex.setCellValue(error);
          changes.addChange(error, address);
        }
      });
    });
    return changes;
  }
  runAndForget(ast, address, dependencies) {
    const tmpRanges = [];
    for (const dep of (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_1__.absolutizeDependencies)(dependencies, address)) {
      if (dep instanceof _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange) {
        const range = dep;
        if (this.dependencyGraph.getRange(range.start, range.end) === undefined) {
          const rangeVertex = new _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.RangeVertex(range);
          this.dependencyGraph.rangeMapping.setRange(rangeVertex);
          tmpRanges.push(rangeVertex);
        }
      }
    }
    const ret = this.evaluateAstToCellValue(ast, new _interpreter_InterpreterState__WEBPACK_IMPORTED_MODULE_6__.InterpreterState(address, this.config.useArrayArithmetic));
    tmpRanges.forEach(rangeVertex => {
      this.dependencyGraph.rangeMapping.removeRange(rangeVertex);
    });
    return ret;
  }
  /**
   * Recalculates formulas in the topological sort order
   */
  recomputeFormulas(cycled, sorted) {
    cycled.forEach(vertex => {
      if (vertex instanceof _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_5__.FormulaVertex) {
        vertex.setCellValue(new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.CYCLE, undefined, vertex));
      }
    });
    sorted.forEach(vertex => {
      if (vertex instanceof _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_5__.FormulaVertex) {
        const newCellValue = this.recomputeFormulaVertexValue(vertex);
        const address = vertex.getAddress(this.lazilyTransformingAstService);
        this.columnSearch.add((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_7__.getRawValue)(newCellValue), address);
      } else if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.RangeVertex) {
        vertex.clearCache();
      }
    });
  }
  recomputeFormulaVertexValue(vertex) {
    const address = vertex.getAddress(this.lazilyTransformingAstService);
    if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.ArrayVertex && (vertex.array.size.isRef || !this.dependencyGraph.isThereSpaceForArray(vertex))) {
      return vertex.setNoSpace();
    } else {
      const formula = vertex.getFormula(this.lazilyTransformingAstService);
      const newCellValue = this.evaluateAstToCellValue(formula, new _interpreter_InterpreterState__WEBPACK_IMPORTED_MODULE_6__.InterpreterState(address, this.config.useArrayArithmetic, vertex));
      return vertex.setCellValue(newCellValue);
    }
  }
  evaluateAstToCellValue(ast, state) {
    const interpreterValue = this.interpreter.evaluateAst(ast, state);
    if (interpreterValue instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_8__.SimpleRangeValue) {
      return interpreterValue;
    } else if (interpreterValue === _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_7__.EmptyValue && this.config.evaluateNullToZero) {
      return 0;
    } else {
      return interpreterValue;
    }
  }
}

/***/ }),
/* 128 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExportedCellChange: () => (/* binding */ ExportedCellChange),
/* harmony export */   ExportedNamedExpressionChange: () => (/* binding */ ExportedNamedExpressionChange),
/* harmony export */   Exporter: () => (/* binding */ Exporter)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _CellValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(100);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(69);
/* harmony import */ var _NamedExpressions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(115);
/* harmony import */ var _parser_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







/**
 * A list of cells which values changed after the operation, their absolute addresses and new values.
 */
class ExportedCellChange {
  constructor(address, newValue) {
    this.address = address;
    this.newValue = newValue;
  }
  get col() {
    return this.address.col;
  }
  get row() {
    return this.address.row;
  }
  get sheet() {
    return this.address.sheet;
  }
  get value() {
    return this.newValue;
  }
}
class ExportedNamedExpressionChange {
  constructor(name, newValue) {
    this.name = name;
    this.newValue = newValue;
  }
}
class Exporter {
  constructor(config, namedExpressions, sheetIndexMapping, lazilyTransformingService) {
    this.config = config;
    this.namedExpressions = namedExpressions;
    this.sheetIndexMapping = sheetIndexMapping;
    this.lazilyTransformingService = lazilyTransformingService;
  }
  exportChange(change) {
    const value = change.value;
    const address = change.address;
    if (address.sheet === _NamedExpressions__WEBPACK_IMPORTED_MODULE_5__.NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {
      const namedExpression = this.namedExpressions.namedExpressionInAddress(address.row);
      if (!namedExpression) {
        throw new Error('Missing named expression');
      }
      return new ExportedNamedExpressionChange(namedExpression.displayName, this.exportScalarOrRange(value));
    } else if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue) {
      const result = [];
      for (const [cellValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {
        result.push(new ExportedCellChange(cellAddress, this.exportValue(cellValue)));
      }
      return result;
    } else {
      return new ExportedCellChange(address, this.exportValue(value));
    }
  }
  exportValue(value) {
    if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue) {
      return this.detailedError(new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ScalarExpected));
    } else if (this.config.smartRounding && (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(value)) {
      return this.cellValueRounding((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(value));
    } else if (value instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return this.detailedError(value);
    } else if (value === _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.EmptyValue) {
      return null;
    } else {
      return (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(value);
    }
  }
  exportScalarOrRange(value) {
    if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_4__.SimpleRangeValue) {
      return value.rawData().map(row => row.map(v => this.exportValue(v)));
    } else {
      return this.exportValue(value);
    }
  }
  detailedError(error) {
    var _a, _b;
    let address = undefined;
    const originAddress = (_a = error.root) === null || _a === void 0 ? void 0 : _a.getAddress(this.lazilyTransformingService);
    if (originAddress !== undefined) {
      if (originAddress.sheet === _NamedExpressions__WEBPACK_IMPORTED_MODULE_5__.NamedExpressions.SHEET_FOR_WORKBOOK_EXPRESSIONS) {
        address = (_b = this.namedExpressions.namedExpressionInAddress(originAddress.row)) === null || _b === void 0 ? void 0 : _b.displayName;
      } else {
        address = (0,_parser_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_6__.simpleCellAddressToString)(this.sheetIndexMapping, originAddress, -1);
      }
    }
    return new _CellValue__WEBPACK_IMPORTED_MODULE_1__.DetailedCellError(error, this.config.translationPackage.getErrorTranslation(error.type), address);
  }
  cellValueRounding(value) {
    if (value === 0) {
      return value;
    }
    const magnitudeMultiplierExponent = Math.floor(Math.log10(Math.abs(value)));
    const placesMultiplier = Math.pow(10, this.config.precisionRounding - magnitudeMultiplierExponent);
    if (value < 0) {
      return -Math.round(-value * placesMultiplier) / placesMultiplier;
    } else {
      return Math.round(value * placesMultiplier) / placesMultiplier;
    }
  }
}

/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphBuilder: () => (/* binding */ GraphBuilder),
/* harmony export */   SimpleStrategy: () => (/* binding */ SimpleStrategy)
/* harmony export */ });
/* harmony import */ var _absolutizeDependencies__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _CellContentParser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70);
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(72);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







/**
 * Service building the graph and mappings.
 */
class GraphBuilder {
  /**
   * Configures the building service.
   */
  constructor(dependencyGraph, columnSearch, parser, cellContentParser, stats, arraySizePredictor) {
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.parser = parser;
    this.cellContentParser = cellContentParser;
    this.stats = stats;
    this.arraySizePredictor = arraySizePredictor;
    this.buildStrategy = new SimpleStrategy(dependencyGraph, columnSearch, parser, stats, cellContentParser, arraySizePredictor);
  }
  /**
   * Builds graph.
   */
  buildGraph(sheets, stats) {
    const dependencies = stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_6__.StatType.COLLECT_DEPENDENCIES, () => this.buildStrategy.run(sheets));
    this.dependencyGraph.getAndClearContentChanges();
    stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_6__.StatType.PROCESS_DEPENDENCIES, () => this.processDependencies(dependencies));
  }
  processDependencies(dependencies) {
    dependencies.forEach((cellDependencies, endVertex) => {
      this.dependencyGraph.processCellDependencies(cellDependencies, endVertex);
    });
  }
}
class SimpleStrategy {
  constructor(dependencyGraph, columnIndex, parser, stats, cellContentParser, arraySizePredictor) {
    this.dependencyGraph = dependencyGraph;
    this.columnIndex = columnIndex;
    this.parser = parser;
    this.stats = stats;
    this.cellContentParser = cellContentParser;
    this.arraySizePredictor = arraySizePredictor;
  }
  run(sheets) {
    const dependencies = new Map();
    for (const sheetName in sheets) {
      const sheetId = this.dependencyGraph.getSheetId(sheetName);
      const sheet = sheets[sheetName];
      for (let i = 0; i < sheet.length; ++i) {
        const row = sheet[i];
        for (let j = 0; j < row.length; ++j) {
          const cellContent = row[j];
          const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_2__.simpleCellAddress)(sheetId, j, i);
          const parsedCellContent = this.cellContentParser.parse(cellContent);
          if (parsedCellContent instanceof _CellContentParser__WEBPACK_IMPORTED_MODULE_3__.CellContent.Formula) {
            const parseResult = this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_6__.StatType.PARSER, () => this.parser.parse(parsedCellContent.formula, address));
            if (parseResult.errors.length > 0) {
              this.shrinkArrayIfNeeded(address);
              const vertex = new _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.ParsingErrorVertex(parseResult.errors, parsedCellContent.formula);
              this.dependencyGraph.addVertex(address, vertex);
            } else {
              this.shrinkArrayIfNeeded(address);
              const size = this.arraySizePredictor.checkArraySize(parseResult.ast, address);
              if (size.isScalar()) {
                const vertex = new _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.FormulaCellVertex(parseResult.ast, address, 0);
                dependencies.set(vertex, (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_0__.absolutizeDependencies)(parseResult.dependencies, address));
                this.dependencyGraph.addVertex(address, vertex);
                if (parseResult.hasVolatileFunction) {
                  this.dependencyGraph.markAsVolatile(vertex);
                }
                if (parseResult.hasStructuralChangeFunction) {
                  this.dependencyGraph.markAsDependentOnStructureChange(vertex);
                }
              } else {
                const vertex = new _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.ArrayVertex(parseResult.ast, address, new _ArraySize__WEBPACK_IMPORTED_MODULE_1__.ArraySize(size.width, size.height));
                dependencies.set(vertex, (0,_absolutizeDependencies__WEBPACK_IMPORTED_MODULE_0__.absolutizeDependencies)(parseResult.dependencies, address));
                this.dependencyGraph.addArrayVertex(address, vertex);
              }
            }
          } else if (parsedCellContent instanceof _CellContentParser__WEBPACK_IMPORTED_MODULE_3__.CellContent.Empty) {
            /* we don't care about empty cells here */
          } else {
            this.shrinkArrayIfNeeded(address);
            const vertex = new _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.ValueCellVertex(parsedCellContent.value, cellContent);
            this.columnIndex.add((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_5__.getRawValue)(parsedCellContent.value), address);
            this.dependencyGraph.addVertex(address, vertex);
          }
        }
      }
    }
    return dependencies;
  }
  shrinkArrayIfNeeded(address) {
    const vertex = this.dependencyGraph.getCell(address);
    if (vertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_4__.ArrayVertex) {
      this.dependencyGraph.shrinkArrayToCorner(vertex);
    }
  }
}

/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FunctionRegistry: () => (/* binding */ FunctionRegistry)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/* harmony import */ var _HyperFormula__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);
/* harmony import */ var _plugin_VersionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(131);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



function validateAndReturnMetadataFromName(functionId, plugin) {
  var _a;
  let entry = plugin.implementedFunctions[functionId];
  const key = (_a = plugin.aliases) === null || _a === void 0 ? void 0 : _a[functionId];
  if (key !== undefined) {
    if (entry !== undefined) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__.AliasAlreadyExisting(functionId, plugin.name);
    }
    entry = plugin.implementedFunctions[key];
  }
  if (entry === undefined) {
    throw _errors__WEBPACK_IMPORTED_MODULE_0__.FunctionPluginValidationError.functionNotDeclaredInPlugin(functionId, plugin.name);
  }
  return entry;
}
class FunctionRegistry {
  constructor(config) {
    this.config = config;
    this.functions = new Map();
    this.arraySizeFunctions = new Map();
    this.volatileFunctions = new Set();
    this.arrayFunctions = new Set();
    this.structuralChangeFunctions = new Set();
    this.functionsWhichDoesNotNeedArgumentsToBeComputed = new Set();
    this.functionsMetadata = new Map();
    this.doesFunctionNeedArgumentToBeComputed = functionId => this.functionsWhichDoesNotNeedArgumentsToBeComputed.has(functionId);
    this.isFunctionVolatile = functionId => this.volatileFunctions.has(functionId);
    this.isArrayFunction = functionId => this.arrayFunctions.has(functionId);
    this.isFunctionDependentOnSheetStructureChange = functionId => this.structuralChangeFunctions.has(functionId);
    if (config.functionPlugins.length > 0) {
      this.instancePlugins = new Map();
      for (const plugin of config.functionPlugins) {
        FunctionRegistry.loadPluginFunctions(plugin, this.instancePlugins);
      }
    } else {
      this.instancePlugins = new Map(FunctionRegistry.plugins);
    }
    for (const [functionId, plugin] of FunctionRegistry.protectedFunctions()) {
      FunctionRegistry.loadFunctionUnprotected(plugin, functionId, this.instancePlugins);
    }
    for (const [functionId, plugin] of this.instancePlugins.entries()) {
      this.categorizeFunction(functionId, validateAndReturnMetadataFromName(functionId, plugin));
    }
  }
  static registerFunctionPlugin(plugin, translations) {
    this.loadPluginFunctions(plugin, this.plugins);
    if (translations !== undefined) {
      this.loadTranslations(translations);
    }
  }
  static registerFunction(functionId, plugin, translations) {
    this.loadPluginFunction(plugin, functionId, this.plugins);
    if (translations !== undefined) {
      this.loadTranslations(translations);
    }
  }
  static unregisterFunction(functionId) {
    if (this.functionIsProtected(functionId)) {
      throw _errors__WEBPACK_IMPORTED_MODULE_0__.ProtectedFunctionError.cannotUnregisterFunctionWithId(functionId);
    }
    this.plugins.delete(functionId);
  }
  static unregisterFunctionPlugin(plugin) {
    for (const protectedPlugin of this.protectedPlugins()) {
      if (protectedPlugin === plugin) {
        throw _errors__WEBPACK_IMPORTED_MODULE_0__.ProtectedFunctionError.cannotUnregisterProtectedPlugin();
      }
    }
    for (const [functionId, registeredPlugin] of this.plugins.entries()) {
      if (registeredPlugin === plugin) {
        this.plugins.delete(functionId);
      }
    }
  }
  static unregisterAll() {
    this.plugins.clear();
  }
  static getRegisteredFunctionIds() {
    return [...Array.from(this.plugins.keys()), ...Array.from(this._protectedPlugins.keys())];
  }
  static getPlugins() {
    return Array.from(new Set(this.plugins.values()).values());
  }
  static getFunctionPlugin(functionId) {
    if (this.functionIsProtected(functionId)) {
      return undefined;
    } else {
      return this.plugins.get(functionId);
    }
  }
  static functionIsProtected(functionId) {
    return this._protectedPlugins.has(functionId);
  }
  static loadTranslations(translations) {
    const registeredLanguages = new Set(_HyperFormula__WEBPACK_IMPORTED_MODULE_1__.HyperFormula.getRegisteredLanguagesCodes());
    Object.keys(translations).forEach(code => {
      if (registeredLanguages.has(code)) {
        _HyperFormula__WEBPACK_IMPORTED_MODULE_1__.HyperFormula.getLanguage(code).extendFunctions(translations[code]);
      }
    });
  }
  static loadPluginFunctions(plugin, registry) {
    Object.keys(plugin.implementedFunctions).forEach(functionName => {
      this.loadPluginFunction(plugin, functionName, registry);
    });
    if (plugin.aliases !== undefined) {
      Object.keys(plugin.aliases).forEach(functionName => {
        this.loadPluginFunction(plugin, functionName, registry);
      });
    }
  }
  static loadPluginFunction(plugin, functionId, registry) {
    if (this.functionIsProtected(functionId)) {
      throw _errors__WEBPACK_IMPORTED_MODULE_0__.ProtectedFunctionError.cannotRegisterFunctionWithId(functionId);
    } else {
      this.loadFunctionUnprotected(plugin, functionId, registry);
    }
  }
  static loadFunctionUnprotected(plugin, functionId, registry) {
    const methodName = validateAndReturnMetadataFromName(functionId, plugin).method;
    if (Object.prototype.hasOwnProperty.call(plugin.prototype, methodName)) {
      registry.set(functionId, plugin);
    } else {
      throw _errors__WEBPACK_IMPORTED_MODULE_0__.FunctionPluginValidationError.functionMethodNotFound(methodName, plugin.name);
    }
  }
  static *protectedFunctions() {
    for (const [functionId, plugin] of this._protectedPlugins) {
      if (plugin !== undefined) {
        yield [functionId, plugin];
      }
    }
  }
  static *protectedPlugins() {
    for (const [, plugin] of this._protectedPlugins) {
      if (plugin !== undefined) {
        yield plugin;
      }
    }
  }
  initializePlugins(interpreter) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const instances = [];
    for (const [functionId, plugin] of this.instancePlugins.entries()) {
      let foundPluginInstance = instances.find(pluginInstance => pluginInstance instanceof plugin);
      if (foundPluginInstance === undefined) {
        foundPluginInstance = new plugin(interpreter);
        instances.push(foundPluginInstance);
      }
      const metadata = validateAndReturnMetadataFromName(functionId, plugin);
      const methodName = metadata.method;
      this.functions.set(functionId, [methodName, foundPluginInstance]);
      const arraySizeMethodName = metadata.arraySizeMethod;
      if (arraySizeMethodName !== undefined) {
        this.arraySizeFunctions.set(functionId, [arraySizeMethodName, foundPluginInstance]);
      }
    }
  }
  getFunctionPlugin(functionId) {
    if (FunctionRegistry.functionIsProtected(functionId)) {
      return undefined;
    }
    return this.instancePlugins.get(functionId);
  }
  getFunction(functionId) {
    const pluginEntry = this.functions.get(functionId);
    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {
      const [pluginFunction, pluginInstance] = pluginEntry;
      return (ast, state) => pluginInstance[pluginFunction](ast, state);
    } else {
      return undefined;
    }
  }
  getArraySizeFunction(functionId) {
    const pluginEntry = this.arraySizeFunctions.get(functionId);
    if (pluginEntry !== undefined && this.config.translationPackage.isFunctionTranslated(functionId)) {
      const [pluginArraySizeFunction, pluginInstance] = pluginEntry;
      return (ast, state) => pluginInstance[pluginArraySizeFunction](ast, state);
    } else {
      return undefined;
    }
  }
  getMetadata(functionId) {
    return this.functionsMetadata.get(functionId);
  }
  getPlugins() {
    const plugins = new Set();
    for (const [functionId, plugin] of this.instancePlugins) {
      if (!FunctionRegistry.functionIsProtected(functionId)) {
        plugins.add(plugin);
      }
    }
    return Array.from(plugins);
  }
  getRegisteredFunctionIds() {
    return Array.from(this.functions.keys());
  }
  categorizeFunction(functionId, functionMetadata) {
    if (functionMetadata.isVolatile) {
      this.volatileFunctions.add(functionId);
    }
    if (functionMetadata.arrayFunction) {
      this.arrayFunctions.add(functionId);
    }
    if (functionMetadata.doesNotNeedArgumentsToBeComputed) {
      this.functionsWhichDoesNotNeedArgumentsToBeComputed.add(functionId);
    }
    if (functionMetadata.isDependentOnSheetStructureChange) {
      this.structuralChangeFunctions.add(functionId);
    }
    this.functionsMetadata.set(functionId, functionMetadata);
  }
}
FunctionRegistry.plugins = new Map();
FunctionRegistry._protectedPlugins = new Map([['VERSION', _plugin_VersionPlugin__WEBPACK_IMPORTED_MODULE_2__.VersionPlugin], ['OFFSET', undefined]]);

/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VersionPlugin: () => (/* binding */ VersionPlugin)
/* harmony export */ });
/* harmony import */ var _HyperFormula__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(110);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


const LICENSE_STATUS_MAP = new Map([['gpl-v3', 1], ["missing" /* MISSING */, 2], ["invalid" /* INVALID */, 3], ["expired" /* EXPIRED */, 4]]);
class VersionPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionPlugin {
  version(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('VERSION'), () => {
      const {
        licenseKeyValidityState: validityState,
        licenseKey
      } = this.config;
      let status;
      if (LICENSE_STATUS_MAP.has(licenseKey)) {
        status = LICENSE_STATUS_MAP.get(licenseKey);
      } else if (LICENSE_STATUS_MAP.has(validityState)) {
        status = LICENSE_STATUS_MAP.get(validityState);
      } else if (validityState === "valid" /* VALID */) {
        status = licenseKey.slice(-5);
      }
      return `HyperFormula v${_HyperFormula__WEBPACK_IMPORTED_MODULE_0__.HyperFormula.version}, ${status}`;
    });
  }
}
VersionPlugin.implementedFunctions = {
  'VERSION': {
    method: 'version',
    parameters: []
  }
};

/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Interpreter: () => (/* binding */ Interpreter)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _ArrayValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(61);
/* harmony import */ var _parser_Ast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/* harmony import */ var _ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98);
/* harmony import */ var _Criterion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(133);
/* harmony import */ var _FunctionRegistry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(130);
/* harmony import */ var _InterpreterState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(95);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(69);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




// noinspection TypeScriptPreferShortImport







class Interpreter {
  constructor(config, dependencyGraph, columnSearch, stats, arithmeticHelper, functionRegistry, namedExpressions, serialization, arraySizePredictor, dateTimeHelper) {
    this.config = config;
    this.dependencyGraph = dependencyGraph;
    this.columnSearch = columnSearch;
    this.stats = stats;
    this.arithmeticHelper = arithmeticHelper;
    this.functionRegistry = functionRegistry;
    this.namedExpressions = namedExpressions;
    this.serialization = serialization;
    this.arraySizePredictor = arraySizePredictor;
    this.dateTimeHelper = dateTimeHelper;
    this.equalOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.eq, arg1, arg2);
    this.notEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.neq, arg1, arg2);
    this.greaterThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.gt, arg1, arg2);
    this.lessThanOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.lt, arg1, arg2);
    this.greaterThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.geq, arg1, arg2);
    this.lessThanOrEqualOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.leq, arg1, arg2);
    this.concatOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.concat, (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.coerceScalarToString)(arg1), (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.coerceScalarToString)(arg2));
    this.plusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.addWithEpsilon, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.minusOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.subtract, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.timesOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.multiply, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.powerOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.pow, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.divOp = (arg1, arg2) => binaryErrorWrapper(this.arithmeticHelper.divide, this.arithmeticHelper.coerceScalarToNumberOrError(arg1), this.arithmeticHelper.coerceScalarToNumberOrError(arg2));
    this.unaryMinusOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryMinus, this.arithmeticHelper.coerceScalarToNumberOrError(arg));
    this.percentOp = arg => unaryErrorWrapper(this.arithmeticHelper.unaryPercent, this.arithmeticHelper.coerceScalarToNumberOrError(arg));
    this.unaryPlusOp = arg => this.arithmeticHelper.unaryPlus(arg);
    this.functionRegistry.initializePlugins(this);
    this.criterionBuilder = new _Criterion__WEBPACK_IMPORTED_MODULE_6__.CriterionBuilder(config);
  }
  evaluateAst(ast, state) {
    let val = this.evaluateAstWithoutPostprocessing(ast, state);
    if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_9__.isExtendedNumber)(val)) {
      if ((0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.isNumberOverflow)((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_9__.getRawValue)(val))) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.NaN);
      } else {
        val = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_9__.cloneNumber)(val, (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.fixNegativeZero)((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_9__.getRawValue)(val)));
      }
    }
    if (val instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue && val.height() === 1 && val.width() === 1) {
      [[val]] = val.data;
    }
    return wrapperForRootVertex(val, state.formulaVertex);
  }
  /**
   * Calculates cell value from formula abstract syntax tree
   *
   * @param formula - abstract syntax tree of formula
   * @param formulaAddress - address of the cell in which formula is located
   */
  evaluateAstWithoutPostprocessing(ast, state) {
    switch (ast.type) {
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.EMPTY:
        {
          return _InterpreterValue__WEBPACK_IMPORTED_MODULE_9__.EmptyValue;
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CELL_REFERENCE:
        {
          const address = ast.reference.toSimpleCellAddress(state.formulaAddress);
          if ((0,_Cell__WEBPACK_IMPORTED_MODULE_2__.invalidSimpleCellAddress)(address)) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.BadRef);
          }
          return this.dependencyGraph.getCellValue(address);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NUMBER:
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.STRING:
        {
          return ast.value;
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CONCATENATE_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.concatOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.EQUALS_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.equalOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NOT_EQUAL_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.notEqualOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.GREATER_THAN_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.greaterThanOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.LESS_THAN_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.lessThanOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.GREATER_THAN_OR_EQUAL_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.greaterThanOrEqualOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.LESS_THAN_OR_EQUAL_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.lessThanOrEqualOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.PLUS_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.plusOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.MINUS_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.minusOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.TIMES_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.timesOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.POWER_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.powerOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.DIV_OP:
        {
          const leftResult = this.evaluateAst(ast.left, state);
          const rightResult = this.evaluateAst(ast.right, state);
          return this.binaryRangeWrapper(this.divOp, leftResult, rightResult, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.PLUS_UNARY_OP:
        {
          const result = this.evaluateAst(ast.value, state);
          return this.unaryRangeWrapper(this.unaryPlusOp, result, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.MINUS_UNARY_OP:
        {
          const result = this.evaluateAst(ast.value, state);
          return this.unaryRangeWrapper(this.unaryMinusOp, result, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.PERCENT_OP:
        {
          const result = this.evaluateAst(ast.value, state);
          return this.unaryRangeWrapper(this.percentOp, result, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.FUNCTION_CALL:
        {
          if (this.config.licenseKeyValidityState !== "valid" /* VALID */ && !_FunctionRegistry__WEBPACK_IMPORTED_MODULE_7__.FunctionRegistry.functionIsProtected(ast.procedureName)) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.LIC, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.LicenseKey(this.config.licenseKeyValidityState));
          }
          const pluginFunction = this.functionRegistry.getFunction(ast.procedureName);
          if (pluginFunction !== undefined) {
            return pluginFunction(ast, new _InterpreterState__WEBPACK_IMPORTED_MODULE_8__.InterpreterState(state.formulaAddress, state.arraysFlag || this.functionRegistry.isArrayFunction(ast.procedureName), state.formulaVertex));
          } else {
            return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.NAME, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.FunctionName(ast.procedureName));
          }
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.NAMED_EXPRESSION:
        {
          const namedExpression = this.namedExpressions.nearestNamedExpression(ast.expressionName, state.formulaAddress.sheet);
          if (namedExpression) {
            return this.dependencyGraph.getCellValue(namedExpression.address);
          } else {
            return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.NAME, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.NamedExpressionName(ast.expressionName));
          }
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CELL_RANGE:
        {
          if (!this.rangeSpansOneSheet(ast)) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.RangeManySheets);
          }
          const range = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.fromCellRange(ast, state.formulaAddress);
          const arrayVertex = this.dependencyGraph.getArray(range);
          if (arrayVertex) {
            const array = arrayVertex.array;
            if (array instanceof _ArrayValue__WEBPACK_IMPORTED_MODULE_1__.NotComputedArray) {
              throw new Error('Array should be already computed');
            } else if (array instanceof _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError) {
              return array;
            } else if (array instanceof _ArrayValue__WEBPACK_IMPORTED_MODULE_1__.ArrayValue) {
              return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.fromRange(array.raw(), range, this.dependencyGraph);
            } else {
              throw new Error('Unknown array');
            }
          } else {
            return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyRange(range, this.dependencyGraph);
          }
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.COLUMN_RANGE:
        {
          if (!this.rangeSpansOneSheet(ast)) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.RangeManySheets);
          }
          const range = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteColumnRange.fromColumnRange(ast, state.formulaAddress);
          return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyRange(range, this.dependencyGraph);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.ROW_RANGE:
        {
          if (!this.rangeSpansOneSheet(ast)) {
            return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.RangeManySheets);
          }
          const range = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteRowRange.fromRowRangeAst(ast, state.formulaAddress);
          return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyRange(range, this.dependencyGraph);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.PARENTHESIS:
        {
          return this.evaluateAst(ast.expression, state);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.ARRAY:
        {
          let totalWidth = undefined;
          const ret = [];
          for (const astRow of ast.args) {
            let rowHeight = undefined;
            const rowRet = [];
            for (const astIt of astRow) {
              const arr = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.coerceToRange)(this.evaluateAst(astIt, state));
              const height = arr.height();
              if (rowHeight === undefined) {
                rowHeight = height;
                rowRet.push(...arr.data);
              } else if (rowHeight === height) {
                for (let i = 0; i < height; i++) {
                  rowRet[i].push(...arr.data[i]);
                }
              } else {
                return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.SizeMismatch);
              }
            }
            const width = rowRet[0].length;
            if (totalWidth === undefined) {
              totalWidth = width;
              ret.push(...rowRet);
            } else if (totalWidth === width) {
              ret.push(...rowRet);
            } else {
              return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.SizeMismatch);
            }
          }
          return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyValues(ret);
        }
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.ERROR_WITH_RAW_INPUT:
      case _parser_Ast__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.ERROR:
        {
          return ast.error;
        }
    }
  }
  rangeSpansOneSheet(ast) {
    return ast.start.sheet === ast.end.sheet;
  }
  unaryRangeWrapper(op, arg, state) {
    var _a;
    if (arg instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue && !state.arraysFlag) {
      arg = (_a = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.coerceRangeToScalar)(arg, state)) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.ScalarExpected);
    }
    if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError) {
      return arg;
    }
    if (arg instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue) {
      const newRaw = arg.data.map(row => row.map(op));
      return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyValues(newRaw);
    }
    return op(arg);
  }
  binaryRangeWrapper(op, arg1, arg2, state) {
    var _a, _b;
    if (arg1 instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue && !state.arraysFlag) {
      arg1 = (_a = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.coerceRangeToScalar)(arg1, state)) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.ScalarExpected);
    }
    if (arg1 instanceof _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError) {
      return arg1;
    }
    if (arg2 instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue && !state.arraysFlag) {
      arg2 = (_b = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.coerceRangeToScalar)(arg2, state)) !== null && _b !== void 0 ? _b : new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.ScalarExpected);
    }
    if (arg2 instanceof _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError) {
      return arg2;
    }
    if (arg1 instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue || arg2 instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue) {
      if (!(arg1 instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue)) {
        if (arg2.isAdHoc()) {
          const raw2 = arg2.data;
          for (let i = 0; i < raw2.length; i++) {
            for (let j = 0; j < raw2[0].length; j++) {
              raw2[i][j] = op(arg1, raw2[i][j]);
            }
          }
          return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyValues(raw2);
        } else {
          arg1 = _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.fromScalar(arg1);
        }
      }
      if (!(arg2 instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue)) {
        if (arg1.isAdHoc()) {
          const raw1 = arg1.data;
          for (let i = 0; i < raw1.length; i++) {
            for (let j = 0; j < raw1[0].length; j++) {
              raw1[i][j] = op(raw1[i][j], arg2);
            }
          }
          return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyValues(raw1);
        } else {
          arg2 = _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.fromScalar(arg2);
        }
      }
      if (arg1.width() === arg2.width() && arg1.height() === arg2.height()) {
        if (arg1.isAdHoc()) {
          const raw1 = arg1.data;
          const raw2 = arg2.data;
          for (let i = 0; i < raw1.length; i++) {
            for (let j = 0; j < raw1[0].length; j++) {
              raw1[i][j] = op(raw1[i][j], raw2[i][j]);
            }
          }
          return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyValues(raw1);
        }
        if (arg2.isAdHoc()) {
          const raw1 = arg1.data;
          const raw2 = arg2.data;
          for (let i = 0; i < raw1.length; i++) {
            for (let j = 0; j < raw1[0].length; j++) {
              raw2[i][j] = op(raw1[i][j], raw2[i][j]);
            }
          }
          return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyValues(raw2);
        }
      }
      const width = Math.max(arg1.width(), arg2.width());
      const height = Math.max(arg1.height(), arg2.height());
      const ret = Array(height);
      for (let i = 0; i < height; i++) {
        ret[i] = Array(width);
      }
      for (let i = 0; i < height; i++) {
        const i1 = arg1.height() !== 1 ? i : 0;
        const i2 = arg2.height() !== 1 ? i : 0;
        for (let j = 0; j < width; j++) {
          const j1 = arg1.width() !== 1 ? j : 0;
          const j2 = arg2.width() !== 1 ? j : 0;
          if (i1 < arg1.height() && i2 < arg2.height() && j1 < arg1.width() && j2 < arg2.width()) {
            ret[i][j] = op(arg1.data[i1][j1], arg2.data[i2][j2]);
          } else {
            ret[i][j] = new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.NA);
          }
        }
      }
      return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_10__.SimpleRangeValue.onlyValues(ret);
    }
    return op(arg1, arg2);
  }
}
function unaryErrorWrapper(op, arg) {
  if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError) {
    return arg;
  } else {
    return op(arg);
  }
}
function binaryErrorWrapper(op, arg1, arg2) {
  if (arg1 instanceof _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError) {
    return arg1;
  } else if (arg2 instanceof _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError) {
    return arg2;
  } else {
    return op(arg1, arg2);
  }
}
function wrapperForRootVertex(val, vertex) {
  if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError && vertex !== undefined) {
    return val.attachRootVertex(vertex);
  }
  return val;
}

/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CriterionBuilder: () => (/* binding */ CriterionBuilder),
/* harmony export */   CriterionType: () => (/* binding */ CriterionType),
/* harmony export */   buildCriterion: () => (/* binding */ buildCriterion),
/* harmony export */   buildCriterionLambda: () => (/* binding */ buildCriterionLambda)
/* harmony export */ });
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

var CriterionType;
(function (CriterionType) {
  CriterionType["GREATER_THAN"] = "GREATER_THAN";
  CriterionType["GREATER_THAN_OR_EQUAL"] = "GREATER_THAN_OR_EQUAL";
  CriterionType["LESS_THAN"] = "LESS_THAN";
  CriterionType["LESS_THAN_OR_EQUAL"] = "LESS_THAN_OR_EQUAL";
  CriterionType["NOT_EQUAL"] = "NOT_EQUAL";
  CriterionType["EQUAL"] = "EQUAL";
})(CriterionType || (CriterionType = {}));
const buildCriterion = (operator, value) => ({
  operator,
  value
});
class CriterionBuilder {
  constructor(config) {
    var _a, _b, _c, _d;
    this.trueString = (_b = (_a = config.translationPackage.getMaybeFunctionTranslation('TRUE')) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'true';
    this.falseString = (_d = (_c = config.translationPackage.getMaybeFunctionTranslation('FALSE')) === null || _c === void 0 ? void 0 : _c.toLowerCase()) !== null && _d !== void 0 ? _d : 'false';
  }
  fromCellValue(raw, arithmeticHelper) {
    if (typeof raw !== 'string' && typeof raw !== 'boolean' && typeof raw !== 'number') {
      return undefined;
    }
    const criterion = this.parseCriterion(raw, arithmeticHelper);
    if (criterion === undefined) {
      return undefined;
    }
    return {
      raw,
      lambda: buildCriterionLambda(criterion, arithmeticHelper)
    };
  }
  parseCriterion(criterion, arithmeticHelper) {
    if (typeof criterion === 'number' || typeof criterion === 'boolean') {
      return buildCriterion(CriterionType.EQUAL, criterion);
    } else if (typeof criterion === 'string') {
      const regexResult = ANY_CRITERION_REGEX.exec(criterion);
      let criterionValue;
      let criterionType;
      if (regexResult) {
        criterionType = StrToCriterionType(regexResult[1]);
        criterionValue = regexResult[2];
      } else {
        criterionType = CriterionType.EQUAL;
        criterionValue = criterion;
      }
      const value = arithmeticHelper.coerceToMaybeNumber(criterionValue);
      const boolvalue = criterionValue.toLowerCase() === this.trueString ? true : criterionValue.toLowerCase() === this.falseString ? false : undefined;
      if (criterionType === undefined) {
        return undefined;
      }
      if (criterionValue === '') {
        return buildCriterion(criterionType, null);
      } else if (value === undefined) {
        if (criterionType === CriterionType.EQUAL || criterionType === CriterionType.NOT_EQUAL) {
          return buildCriterion(criterionType, boolvalue !== null && boolvalue !== void 0 ? boolvalue : criterionValue);
        }
      } else {
        return buildCriterion(criterionType, (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.getRawValue)(value));
      }
    }
    return undefined;
  }
}
const ANY_CRITERION_REGEX = /([<>=]+)(.*)/;
function StrToCriterionType(str) {
  switch (str) {
    case '>':
      return CriterionType.GREATER_THAN;
    case '>=':
      return CriterionType.GREATER_THAN_OR_EQUAL;
    case '<':
      return CriterionType.LESS_THAN;
    case '<=':
      return CriterionType.LESS_THAN_OR_EQUAL;
    case '<>':
      return CriterionType.NOT_EQUAL;
    case '=':
      return CriterionType.EQUAL;
    default:
      return undefined;
  }
}
const buildCriterionLambda = (criterion, arithmeticHelper) => {
  switch (criterion.operator) {
    case CriterionType.GREATER_THAN:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) > 0;
        } else {
          return _cellValue => false;
        }
      }
    case CriterionType.GREATER_THAN_OR_EQUAL:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) >= 0;
        } else {
          return _cellValue => false;
        }
      }
    case CriterionType.LESS_THAN:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) < 0;
        } else {
          return _cellValue => false;
        }
      }
    case CriterionType.LESS_THAN_OR_EQUAL:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => typeof cellValue === 'number' && arithmeticHelper.floatCmp(cellValue, criterion.value) <= 0;
        } else {
          return _cellValue => false;
        }
      }
    case CriterionType.EQUAL:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => {
            if (typeof cellValue === 'number') {
              return arithmeticHelper.floatCmp(cellValue, criterion.value) === 0;
            } else if (typeof cellValue === 'string') {
              if (cellValue === '') {
                return false;
              }
              const val = arithmeticHelper.coerceToMaybeNumber(cellValue);
              if (val === undefined) {
                return false;
              }
              return arithmeticHelper.floatCmp(val, criterion.value) === 0;
            } else {
              return false;
            }
          };
        } else if (typeof criterion.value === 'string') {
          return arithmeticHelper.eqMatcherFunction(criterion.value);
        } else if (typeof criterion.value === 'boolean') {
          return cellValue => typeof cellValue === 'boolean' && cellValue === criterion.value;
        } else {
          return cellValue => cellValue === _InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.EmptyValue;
        }
      }
    case CriterionType.NOT_EQUAL:
      {
        if (typeof criterion.value === 'number') {
          return cellValue => {
            if (typeof cellValue === 'number') {
              return arithmeticHelper.floatCmp(cellValue, criterion.value) !== 0;
            } else if (typeof cellValue === 'string') {
              if (cellValue === '') {
                return true;
              }
              const val = arithmeticHelper.coerceToMaybeNumber(cellValue);
              if (val === undefined) {
                return true;
              }
              return arithmeticHelper.floatCmp(val, criterion.value) !== 0;
            } else {
              return true;
            }
          };
        } else if (typeof criterion.value === 'string') {
          return arithmeticHelper.neqMatcherFunction(criterion.value);
        } else if (typeof criterion.value === 'boolean') {
          return cellValue => typeof cellValue !== 'boolean' || cellValue !== criterion.value;
        } else {
          return cellValue => cellValue !== _InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.EmptyValue;
        }
      }
  }
};

/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LazilyTransformingAstService: () => (/* binding */ LazilyTransformingAstService)
/* harmony export */ });
/* harmony import */ var _dependencyTransformers_CombinedTransformer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class LazilyTransformingAstService {
  constructor(stats) {
    this.stats = stats;
    this.transformations = [];
  }
  version() {
    return this.transformations.length;
  }
  addTransformation(transformation) {
    if (this.combinedTransformer !== undefined) {
      this.combinedTransformer.add(transformation);
    } else {
      this.transformations.push(transformation);
    }
    return this.version();
  }
  beginCombinedMode(sheet) {
    this.combinedTransformer = new _dependencyTransformers_CombinedTransformer__WEBPACK_IMPORTED_MODULE_0__.CombinedTransformer(sheet);
  }
  commitCombinedMode() {
    if (this.combinedTransformer === undefined) {
      throw Error('Combined mode wasn\'t started');
    }
    this.transformations.push(this.combinedTransformer);
    this.combinedTransformer = undefined;
    return this.version();
  }
  applyTransformations(ast, address, version) {
    this.stats.start(_statistics__WEBPACK_IMPORTED_MODULE_1__.StatType.TRANSFORM_ASTS_POSTPONED);
    for (let v = version; v < this.transformations.length; v++) {
      const transformation = this.transformations[v];
      if (transformation.isIrreversible()) {
        this.undoRedo.storeDataForVersion(v, address, this.parser.computeHashFromAst(ast));
        this.parser.rememberNewAst(ast);
      }
      const [newAst, newAddress] = transformation.transformSingleAst(ast, address);
      ast = newAst;
      address = newAddress;
    }
    const cachedAst = this.parser.rememberNewAst(ast);
    this.stats.end(_statistics__WEBPACK_IMPORTED_MODULE_1__.StatType.TRANSFORM_ASTS_POSTPONED);
    return [cachedAst, address, this.transformations.length];
  }
  *getTransformationsFrom(version, filter) {
    for (let v = version; v < this.transformations.length; v++) {
      const transformation = this.transformations[v];
      if (!filter || filter(transformation)) {
        yield transformation;
      }
    }
  }
}

/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CombinedTransformer: () => (/* binding */ CombinedTransformer)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class CombinedTransformer {
  constructor(sheet) {
    this.sheet = sheet;
    this.transformations = [];
  }
  add(transformation) {
    this.transformations.push(transformation);
  }
  performEagerTransformations(graph, parser) {
    this.transformations.forEach(transformation => transformation.performEagerTransformations(graph, parser));
  }
  transformSingleAst(ast, address) {
    let [transformedAst, transformedAddress] = [ast, address];
    this.transformations.forEach(transformation => {
      [transformedAst, transformedAddress] = transformation.transformSingleAst(transformedAst, transformedAddress);
    });
    return [transformedAst, transformedAddress];
  }
  isIrreversible() {
    return true;
  }
}

/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildColumnSearchStrategy: () => (/* binding */ buildColumnSearchStrategy)
/* harmony export */ });
/* harmony import */ var _ColumnBinarySearch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(137);
/* harmony import */ var _ColumnIndex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(140);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


function buildColumnSearchStrategy(dependencyGraph, config, statistics) {
  if (config.useColumnIndex) {
    return new _ColumnIndex__WEBPACK_IMPORTED_MODULE_1__.ColumnIndex(dependencyGraph, config, statistics);
  } else {
    return new _ColumnBinarySearch__WEBPACK_IMPORTED_MODULE_0__.ColumnBinarySearch(dependencyGraph);
  }
}

/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColumnBinarySearch: () => (/* binding */ ColumnBinarySearch)
/* harmony export */ });
/* harmony import */ var _AdvancedFind__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(138);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class ColumnBinarySearch extends _AdvancedFind__WEBPACK_IMPORTED_MODULE_0__.AdvancedFind {
  constructor(dependencyGraph) {
    super(dependencyGraph);
    this.dependencyGraph = dependencyGraph;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  add(value, address) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  remove(value, address) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  change(oldValue, newValue, address) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  applyChanges(contentChanges) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addColumns(columnsSpan) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeColumns(columnsSpan) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeSheet(sheetId) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  moveValues(sourceRange, toRight, toBottom, toSheet) {}
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeValues(range) {}
  /*
   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true
   */
  find(searchKey, rangeValue, searchOptions) {
    return this.basicFind(searchKey, rangeValue, 'row', searchOptions);
  }
}

/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AdvancedFind: () => (/* binding */ AdvancedFind)
/* harmony export */ });
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
/* harmony import */ var _interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98);
/* harmony import */ var _interpreter_binarySearch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class AdvancedFind {
  constructor(dependencyGraph) {
    this.dependencyGraph = dependencyGraph;
  }
  advancedFind(keyMatcher, rangeValue) {
    let values;
    const range = rangeValue.range;
    if (range === undefined) {
      values = rangeValue.valuesFromTopLeftCorner();
    } else {
      values = this.dependencyGraph.computeListOfValuesInRange(range);
    }
    for (let i = 0; i < values.length; i++) {
      if (keyMatcher((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.getRawValue)(values[i]))) {
        return i;
      }
    }
    return -1;
  }
  /*
   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true
   */
  basicFind(searchKey, rangeValue, searchCoordinate, {
    ordering,
    matchExactly
  }) {
    const normalizedSearchKey = typeof searchKey === 'string' ? (0,_interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_1__.forceNormalizeString)(searchKey) : searchKey;
    const range = rangeValue.range;
    if (range === undefined) {
      return this.findNormalizedValue(normalizedSearchKey, rangeValue.valuesFromTopLeftCorner());
    }
    if (ordering === 'none') {
      return this.findNormalizedValue(normalizedSearchKey, this.dependencyGraph.computeListOfValuesInRange(range));
    }
    return (0,_interpreter_binarySearch__WEBPACK_IMPORTED_MODULE_2__.findLastOccurrenceInOrderedRange)(normalizedSearchKey, range, {
      searchCoordinate,
      orderingDirection: ordering,
      matchExactly
    }, this.dependencyGraph);
  }
  findNormalizedValue(searchKey, searchArray) {
    return searchArray.map(_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.getRawValue).map(val => typeof val === 'string' ? (0,_interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_1__.forceNormalizeString)(val) : val).indexOf(searchKey);
  }
}

/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compare: () => (/* binding */ compare),
/* harmony export */   findLastMatchingIndex: () => (/* binding */ findLastMatchingIndex),
/* harmony export */   findLastOccurrenceInOrderedArray: () => (/* binding */ findLastOccurrenceInOrderedArray),
/* harmony export */   findLastOccurrenceInOrderedRange: () => (/* binding */ findLastOccurrenceInOrderedRange)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


const NOT_FOUND = -1;
/*
 * Searches for the searchKey in a sorted 1-D range.
 *
 * Options:
 * - searchCoordinate - must be set to either 'row' or 'col' to indicate the dimension of the search,
 * - orderingDirection - must be set to either 'asc' or 'desc' to indicate the ordering direction for the search range,
 * - matchExactly - when set to false, searches for the lower/upper bound.
 *
 * Semantics:
 * - If orderingDirection === 'asc', searches for the lower bound for the searchKey value (unless marchExactly === true).
 * - If orderingDirection === 'desc', searches for the upper bound for the searchKey value (unless marchExactly === true).
 * - If the search range contains duplicates, returns the last matching value.
 * - If no value in the range satisfies the above, returns -1.
 *
 * Note: this function does not normalize input strings.
 */
function findLastOccurrenceInOrderedRange(searchKey, range, {
  searchCoordinate,
  orderingDirection,
  matchExactly
}, dependencyGraph) {
  const start = range.start[searchCoordinate];
  const end = searchCoordinate === 'col' ? range.effectiveEndColumn(dependencyGraph) : range.effectiveEndRow(dependencyGraph);
  const getValueFromIndexFn = searchCoordinate === 'col' ? index => (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.getRawValue)(dependencyGraph.getCellValue((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(range.sheet, index, range.start.row))) : index => (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.getRawValue)(dependencyGraph.getCellValue((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(range.sheet, range.start.col, index)));
  const compareFn = orderingDirection === 'asc' ? (left, right) => compare(left, right) : (left, right) => -compare(left, right);
  const foundIndex = findLastMatchingIndex(index => compareFn(searchKey, getValueFromIndexFn(index)) >= 0, start, end);
  const foundValue = getValueFromIndexFn(foundIndex);
  if (foundIndex === NOT_FOUND || typeof foundValue !== typeof searchKey) {
    return NOT_FOUND;
  }
  if (matchExactly && foundValue !== searchKey) {
    return NOT_FOUND;
  }
  return foundIndex - start;
}
/*
 * Searches for the searchKey in a sorted array.
 * Param orderingDirection must be set to either 'asc' or 'desc' to indicate the ordering direction of the array.
 *
 * Semantics:
 * - If orderingDirection === 'asc', searches for the lower bound for the searchKey value.
 * - If orderingDirection === 'desc', searches for the upper bound for the searchKey value.
 * - If the array contains duplicates, returns the last matching value.
 * - If no value in the range satisfies the above, returns -1.
 */
function findLastOccurrenceInOrderedArray(searchKey, array, orderingDirection = 'asc') {
  const predicate = orderingDirection === 'asc' ? index => compare(searchKey, array[index]) >= 0 : index => -compare(searchKey, array[index]) >= 0;
  return findLastMatchingIndex(predicate, 0, array.length - 1);
}
/*
 * Returns:
 *   - the last element in the range for which predicate === true or,
 *   - value -1 if predicate === false for all elements.
 * Assumption: All elements for which predicate === true are before the elements for which predicate === false.
 */
function findLastMatchingIndex(predicate, startRange, endRange) {
  let start = startRange;
  let end = endRange;
  while (start < end) {
    const pivot = Math.ceil((start + end) / 2);
    if (predicate(pivot)) {
      start = pivot;
    } else {
      end = pivot - 1;
    }
  }
  if (start === end && predicate(start)) {
    return start;
  }
  return NOT_FOUND;
}
/*
 * numbers < strings < false < true
 */
function compare(left, right) {
  if (typeof left === typeof right) {
    if (left === _InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.EmptyValue) {
      return 0;
    }
    return left < right ? -1 : left > right ? 1 : 0;
  }
  if (left === _InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.EmptyValue) {
    return -1;
  }
  if (right === _InterpreterValue__WEBPACK_IMPORTED_MODULE_1__.EmptyValue) {
    return 1;
  }
  if (right instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
    return -1;
  }
  if (typeof left === 'number' && typeof right === 'string') {
    return -1;
  }
  if (typeof left === 'number' && typeof right === 'boolean') {
    return -1;
  }
  if (typeof left === 'string' && typeof right === 'number') {
    return 1;
  }
  if (typeof left === 'string' && typeof right === 'boolean') {
    return -1;
  }
  return 1;
}

/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ColumnIndex: () => (/* binding */ ColumnIndex),
/* harmony export */   findInOrderedArray: () => (/* binding */ findInOrderedArray)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _dependencyTransformers_AddRowsTransformer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(119);
/* harmony import */ var _dependencyTransformers_RemoveRowsTransformer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(123);
/* harmony import */ var _interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);
/* harmony import */ var _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(69);
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(72);
/* harmony import */ var _ColumnBinarySearch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(137);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */








class ColumnIndex {
  constructor(dependencyGraph, config, stats) {
    this.dependencyGraph = dependencyGraph;
    this.config = config;
    this.stats = stats;
    this.index = new Map();
    this.transformingService = this.dependencyGraph.lazilyTransformingAstService;
    this.binarySearchStrategy = new _ColumnBinarySearch__WEBPACK_IMPORTED_MODULE_7__.ColumnBinarySearch(dependencyGraph);
  }
  add(value, address) {
    if (value === _interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.EmptyValue || value instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return;
    } else if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__.SimpleRangeValue) {
      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {
        this.addSingleCellValue((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.getRawValue)(arrayValue), cellAddress);
      }
    } else {
      this.addSingleCellValue(value, address);
    }
  }
  remove(value, address) {
    if (value === undefined) {
      return;
    }
    if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__.SimpleRangeValue) {
      for (const [arrayValue, cellAddress] of value.entriesFromTopLeftCorner(address)) {
        this.removeSingleValue((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.getRawValue)(arrayValue), cellAddress);
      }
    } else {
      this.removeSingleValue(value, address);
    }
  }
  change(oldValue, newValue, address) {
    if (oldValue === newValue) {
      return;
    }
    this.remove(oldValue, address);
    this.add(newValue, address);
  }
  applyChanges(contentChanges) {
    for (const change of contentChanges) {
      if (change.oldValue !== undefined) {
        this.change((0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.getRawValue)(change.oldValue), (0,_interpreter_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.getRawValue)(change.value), change.address);
      }
    }
  }
  moveValues(sourceRange, toRight, toBottom, toSheet) {
    for (const [value, address] of sourceRange) {
      const targetAddress = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.movedSimpleCellAddress)(address, toSheet, toRight, toBottom);
      this.remove(value, address);
      this.add(value, targetAddress);
    }
  }
  removeValues(range) {
    for (const [value, address] of range) {
      this.remove(value, address);
    }
  }
  /*
   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true
   */
  find(searchKey, rangeValue, {
    ordering,
    matchExactly
  }) {
    const handlingDuplicates = matchExactly === true ? 'findFirst' : 'findLast';
    const resultUsingColumnIndex = this.findUsingColumnIndex(searchKey, rangeValue, handlingDuplicates);
    return resultUsingColumnIndex !== undefined ? resultUsingColumnIndex : this.binarySearchStrategy.find(searchKey, rangeValue, {
      ordering,
      matchExactly
    });
  }
  findUsingColumnIndex(key, rangeValue, handlingDuplicates) {
    const range = rangeValue.range;
    if (range === undefined) {
      return undefined;
    }
    this.ensureRecentData(range.sheet, range.start.col, key);
    const columnMap = this.getColumnMap(range.sheet, range.start.col);
    if (!columnMap) {
      return -1;
    }
    const normalizedKey = typeof key === 'string' ? (0,_interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_3__.forceNormalizeString)(key) : key;
    const valueIndexForTheKey = columnMap.get(normalizedKey);
    if (!valueIndexForTheKey || !valueIndexForTheKey.index || valueIndexForTheKey.index.length === 0) {
      return undefined;
    }
    const rowNumber = ColumnIndex.findRowBelongingToRange(valueIndexForTheKey, range, handlingDuplicates);
    return rowNumber !== undefined ? rowNumber - range.start.row : undefined;
  }
  static findRowBelongingToRange(valueIndex, range, handlingDuplicates) {
    const start = range.start.row;
    const end = range.end.row;
    const positionInIndex = handlingDuplicates === 'findFirst' ? findInOrderedArray(start, valueIndex.index, 'upperBound') : findInOrderedArray(end, valueIndex.index, 'lowerBound');
    if (positionInIndex === -1) {
      return undefined;
    }
    const rowNumber = valueIndex.index[positionInIndex];
    const isRowNumberBelongingToRange = rowNumber >= start && rowNumber <= end;
    return isRowNumberBelongingToRange ? rowNumber : undefined;
  }
  advancedFind(keyMatcher, range) {
    return this.binarySearchStrategy.advancedFind(keyMatcher, range);
  }
  addColumns(columnsSpan) {
    const sheetIndex = this.index.get(columnsSpan.sheet);
    if (!sheetIndex) {
      return;
    }
    sheetIndex.splice(columnsSpan.columnStart, 0, ...Array(columnsSpan.numberOfColumns));
  }
  removeColumns(columnsSpan) {
    const sheetIndex = this.index.get(columnsSpan.sheet);
    if (!sheetIndex) {
      return;
    }
    sheetIndex.splice(columnsSpan.columnStart, columnsSpan.numberOfColumns);
  }
  removeSheet(sheetId) {
    this.index.delete(sheetId);
  }
  getColumnMap(sheet, col) {
    if (!this.index.has(sheet)) {
      this.index.set(sheet, []);
    }
    const sheetMap = this.index.get(sheet); // eslint-disable-line @typescript-eslint/no-non-null-assertion
    let columnMap = sheetMap[col];
    if (!columnMap) {
      columnMap = new Map();
      sheetMap[col] = columnMap;
    }
    return columnMap;
  }
  getValueIndex(sheet, col, value) {
    const columnMap = this.getColumnMap(sheet, col);
    let index = this.getColumnMap(sheet, col).get(value);
    if (!index) {
      index = {
        version: this.transformingService.version(),
        index: []
      };
      columnMap.set(value, index);
    }
    return index;
  }
  ensureRecentData(sheet, col, value) {
    const valueIndex = this.getValueIndex(sheet, col, value);
    const actualVersion = this.transformingService.version();
    if (valueIndex.version === actualVersion) {
      return;
    }
    const relevantTransformations = this.transformingService.getTransformationsFrom(valueIndex.version, transformation => {
      return transformation.sheet === sheet && (transformation instanceof _dependencyTransformers_AddRowsTransformer__WEBPACK_IMPORTED_MODULE_1__.AddRowsTransformer || transformation instanceof _dependencyTransformers_RemoveRowsTransformer__WEBPACK_IMPORTED_MODULE_2__.RemoveRowsTransformer);
    });
    for (const transformation of relevantTransformations) {
      if (transformation instanceof _dependencyTransformers_AddRowsTransformer__WEBPACK_IMPORTED_MODULE_1__.AddRowsTransformer) {
        this.addRows(col, transformation.rowsSpan, value);
      } else if (transformation instanceof _dependencyTransformers_RemoveRowsTransformer__WEBPACK_IMPORTED_MODULE_2__.RemoveRowsTransformer) {
        this.removeRows(col, transformation.rowsSpan, value);
      }
    }
    valueIndex.version = actualVersion;
  }
  addSingleCellValue(value, address) {
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_6__.StatType.BUILD_COLUMN_INDEX, () => {
      this.ensureRecentData(address.sheet, address.col, value);
      if (typeof value === 'string') {
        value = (0,_interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_3__.forceNormalizeString)(value);
      }
      const valueIndex = this.getValueIndex(address.sheet, address.col, value);
      ColumnIndex.addValue(valueIndex, address.row);
    });
  }
  removeSingleValue(value, address) {
    this.stats.measure(_statistics__WEBPACK_IMPORTED_MODULE_6__.StatType.BUILD_COLUMN_INDEX, () => {
      this.ensureRecentData(address.sheet, address.col, value);
      const columnMap = this.getColumnMap(address.sheet, address.col);
      if (typeof value === 'string') {
        value = (0,_interpreter_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_3__.forceNormalizeString)(value);
      }
      const valueIndex = columnMap.get(value);
      if (!valueIndex) {
        return;
      }
      const positionInIndex = findInOrderedArray(address.row, valueIndex.index);
      if (positionInIndex > -1) {
        valueIndex.index.splice(positionInIndex, 1);
      }
      if (valueIndex.index.length === 0) {
        columnMap.delete(value);
      }
      if (columnMap.size === 0) {
        delete this.index.get(address.sheet)[address.col]; // eslint-disable-line @typescript-eslint/no-non-null-assertion
      }
    });
  }
  addRows(col, rowsSpan, value) {
    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);
    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowStart, rowsSpan.numberOfRows);
  }
  removeRows(col, rowsSpan, value) {
    const valueIndex = this.getValueIndex(rowsSpan.sheet, col, value);
    ColumnIndex.removeRowsFromValues(valueIndex, rowsSpan);
    ColumnIndex.shiftRows(valueIndex, rowsSpan.rowEnd + 1, -rowsSpan.numberOfRows);
  }
  static addValue(valueIndex, rowNumber) {
    const rowIndex = findInOrderedArray(rowNumber, valueIndex.index, 'lowerBound');
    const isRowNumberAlreadyInIndex = valueIndex.index[rowIndex] === rowNumber;
    if (!isRowNumberAlreadyInIndex) {
      valueIndex.index.splice(rowIndex + 1, 0, rowNumber);
    }
  }
  static removeRowsFromValues(valueIndex, rowsSpan) {
    const start = findInOrderedArray(rowsSpan.rowStart, valueIndex.index, 'upperBound');
    const end = findInOrderedArray(rowsSpan.rowEnd, valueIndex.index, 'lowerBound');
    const isFoundSpanValid = start > -1 && end > -1 && start <= end && valueIndex.index[start] <= rowsSpan.rowEnd;
    if (isFoundSpanValid) {
      valueIndex.index.splice(start, end - start + 1);
    }
  }
  static shiftRows(valueIndex, afterRow, numberOfRows) {
    const positionInIndex = findInOrderedArray(afterRow, valueIndex.index, 'upperBound');
    if (positionInIndex === -1) {
      return;
    }
    for (let i = positionInIndex; i < valueIndex.index.length; ++i) {
      valueIndex.index[i] += numberOfRows;
    }
  }
}
/*
 * Returns:
 * - index of the key, if the key exists in the array,
 * - index of the lower/upper bound (depending on handlingMisses parameter) otherwise.
 * Assumption: The array is ordered ascending and contains no repetitions.
 */
function findInOrderedArray(key, values, handlingMisses = 'upperBound') {
  let start = 0;
  let end = values.length - 1;
  while (start <= end) {
    const center = Math.floor((start + end) / 2);
    if (key > values[center]) {
      start = center + 1;
    } else if (key < values[center]) {
      end = center - 1;
    } else {
      return center;
    }
  }
  const foundIndex = handlingMisses === 'lowerBound' ? end : start;
  const isIndexInRange = foundIndex >= 0 && foundIndex <= values.length;
  return isIndexInRange ? foundIndex : -1;
}

/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumberLiteralHelper: () => (/* binding */ NumberLiteralHelper)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
class NumberLiteralHelper {
  constructor(config) {
    this.config = config;
    const thousandSeparator = this.config.thousandSeparator === '.' ? `\\${this.config.thousandSeparator}` : this.config.thousandSeparator;
    const decimalSeparator = this.config.decimalSeparator === '.' ? `\\${this.config.decimalSeparator}` : this.config.decimalSeparator;
    this.numberPattern = new RegExp(`^([+-]?((${decimalSeparator}\\d+)|(\\d+(${thousandSeparator}\\d{3,})*(${decimalSeparator}\\d*)?)))(e[+-]?\\d+)?$`);
    this.allThousandSeparatorsRegex = new RegExp(`${thousandSeparator}`, 'g');
  }
  numericStringToMaybeNumber(input) {
    if (this.numberPattern.test(input)) {
      const num = this.numericStringToNumber(input);
      if (isNaN(num)) {
        return undefined;
      }
      return num;
    }
    return undefined;
  }
  numericStringToNumber(input) {
    const normalized = input.replace(this.allThousandSeparatorsRegex, '').replace(this.config.decimalSeparator, '.');
    return Number(normalized);
  }
}

/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Serialization: () => (/* binding */ Serialization)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _DependencyGraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class Serialization {
  constructor(dependencyGraph, unparser, exporter) {
    this.dependencyGraph = dependencyGraph;
    this.unparser = unparser;
    this.exporter = exporter;
  }
  getCellHyperlink(address) {
    const formulaVertex = this.dependencyGraph.getCell(address);
    if (formulaVertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_1__.FormulaCellVertex) {
      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);
      if ('HYPERLINK' === formula.procedureName) {
        return formula.hyperlink;
      }
    }
    return undefined;
  }
  getCellFormula(address, targetAddress) {
    const formulaVertex = this.dependencyGraph.getCell(address);
    if (formulaVertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_1__.FormulaCellVertex) {
      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);
      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;
      return this.unparser.unparse(formula, targetAddress);
    } else if (formulaVertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_1__.ArrayVertex) {
      const arrayVertexAddress = formulaVertex.getAddress(this.dependencyGraph.lazilyTransformingAstService);
      if (arrayVertexAddress.row !== address.row || arrayVertexAddress.col !== address.col || arrayVertexAddress.sheet !== address.sheet) {
        return undefined;
      }
      targetAddress = targetAddress !== null && targetAddress !== void 0 ? targetAddress : address;
      const formula = formulaVertex.getFormula(this.dependencyGraph.lazilyTransformingAstService);
      if (formula !== undefined) {
        return this.unparser.unparse(formula, targetAddress);
      }
    } else if (formulaVertex instanceof _DependencyGraph__WEBPACK_IMPORTED_MODULE_1__.ParsingErrorVertex) {
      return formulaVertex.getFormula();
    }
    return undefined;
  }
  getCellSerialized(address, targetAddress) {
    var _a;
    return (_a = this.getCellFormula(address, targetAddress)) !== null && _a !== void 0 ? _a : this.getRawValue(address);
  }
  getCellValue(address) {
    return this.exporter.exportValue(this.dependencyGraph.getScalarValue(address));
  }
  getRawValue(address) {
    return this.dependencyGraph.getRawValue(address);
  }
  getSheetValues(sheet) {
    return this.genericSheetGetter(sheet, arg => this.getCellValue(arg));
  }
  getSheetFormulas(sheet) {
    return this.genericSheetGetter(sheet, arg => this.getCellFormula(arg));
  }
  genericSheetGetter(sheet, getter) {
    const sheetHeight = this.dependencyGraph.getSheetHeight(sheet);
    const sheetWidth = this.dependencyGraph.getSheetWidth(sheet);
    const arr = new Array(sheetHeight);
    for (let i = 0; i < sheetHeight; i++) {
      arr[i] = new Array(sheetWidth);
      for (let j = 0; j < sheetWidth; j++) {
        const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(sheet, j, i);
        arr[i][j] = getter(address);
      }
      for (let j = sheetWidth - 1; j >= 0; j--) {
        if (arr[i][j] === null || arr[i][j] === undefined) {
          arr[i].pop();
        } else {
          break;
        }
      }
    }
    for (let i = sheetHeight - 1; i >= 0; i--) {
      if (arr[i].length === 0) {
        arr.pop();
      } else {
        break;
      }
    }
    return arr;
  }
  genericAllSheetsGetter(sheetGetter) {
    const result = {};
    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {
      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);
      result[sheetName] = sheetGetter(sheetId);
    }
    return result;
  }
  getSheetSerialized(sheet) {
    return this.genericSheetGetter(sheet, arg => this.getCellSerialized(arg));
  }
  getAllSheetsValues() {
    return this.genericAllSheetsGetter(arg => this.getSheetValues(arg));
  }
  getAllSheetsFormulas() {
    return this.genericAllSheetsGetter(arg => this.getSheetFormulas(arg));
  }
  getAllSheetsSerialized() {
    return this.genericAllSheetsGetter(arg => this.getSheetSerialized(arg));
  }
  getAllNamedExpressionsSerialized() {
    const idMap = [];
    let id = 0;
    for (const sheetName of this.dependencyGraph.sheetMapping.displayNames()) {
      const sheetId = this.dependencyGraph.sheetMapping.fetch(sheetName);
      idMap[sheetId] = id;
      id++;
    }
    return this.dependencyGraph.namedExpressions.getAllNamedExpressions().map(entry => {
      return {
        name: entry.expression.displayName,
        expression: this.getCellSerialized(entry.expression.address),
        scope: entry.scope !== undefined ? idMap[entry.scope] : undefined,
        options: entry.expression.options
      };
    });
  }
  withNewConfig(newConfig, namedExpressions) {
    const newUnparser = new _parser__WEBPACK_IMPORTED_MODULE_2__.Unparser(newConfig, (0,_parser__WEBPACK_IMPORTED_MODULE_2__.buildLexerConfig)(newConfig), this.dependencyGraph.sheetMapping.fetchDisplayName, namedExpressions);
    return new Serialization(this.dependencyGraph, newUnparser, this.exporter);
  }
}

/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   objectDestroy: () => (/* binding */ objectDestroy)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
function objectDestroy(object) {
  for (const [key, value] of Object.entries(object)) {
    if (value instanceof Function) {
      object[key] = postMortem(value);
    } else {
      delete object[key];
    }
  }
}
function postMortem(method) {
  return () => {
    throw new Error(`The "${method}" method cannot be called because this HyperFormula instance has been destroyed`);
  };
}

/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Emitter: () => (/* binding */ Emitter),
/* harmony export */   Events: () => (/* binding */ Events)
/* harmony export */ });
/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(145);
/* harmony import */ var tiny_emitter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tiny_emitter__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

var Events;
(function (Events) {
  Events["SheetAdded"] = "sheetAdded";
  Events["SheetRemoved"] = "sheetRemoved";
  Events["SheetRenamed"] = "sheetRenamed";
  Events["NamedExpressionAdded"] = "namedExpressionAdded";
  Events["NamedExpressionRemoved"] = "namedExpressionRemoved";
  Events["ValuesUpdated"] = "valuesUpdated";
  Events["EvaluationSuspended"] = "evaluationSuspended";
  Events["EvaluationResumed"] = "evaluationResumed";
})(Events || (Events = {}));
class Emitter extends tiny_emitter__WEBPACK_IMPORTED_MODULE_0__.TinyEmitter {
  emit(event, ...args) {
    super.emit(event, ...args);
    return this;
  }
}

/***/ }),
/* 145 */
/***/ ((module) => {

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;
module.exports.TinyEmitter = E;


/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
const dictionary = {
  errors: {
    CYCLE: '#CYCLE!',
    DIV_BY_ZERO: '#DIV/0!',
    ERROR: '#ERROR!',
    NA: '#N/A',
    NAME: '#NAME?',
    NUM: '#NUM!',
    REF: '#REF!',
    SPILL: '#SPILL!',
    VALUE: '#VALUE!'
  },
  functions: {
    FILTER: 'FILTER',
    ADDRESS: 'ADDRESS',
    'ARRAY_CONSTRAIN': 'ARRAY_CONSTRAIN',
    ARRAYFORMULA: 'ARRAYFORMULA',
    ABS: 'ABS',
    ACOS: 'ACOS',
    ACOSH: 'ACOSH',
    ACOT: 'ACOT',
    ACOTH: 'ACOTH',
    AND: 'AND',
    ARABIC: 'ARABIC',
    ASIN: 'ASIN',
    ASINH: 'ASINH',
    ATAN2: 'ATAN2',
    ATAN: 'ATAN',
    ATANH: 'ATANH',
    AVERAGE: 'AVERAGE',
    AVERAGEA: 'AVERAGEA',
    AVERAGEIF: 'AVERAGEIF',
    BASE: 'BASE',
    BIN2DEC: 'BIN2DEC',
    BIN2HEX: 'BIN2HEX',
    BIN2OCT: 'BIN2OCT',
    BITAND: 'BITAND',
    BITLSHIFT: 'BITLSHIFT',
    BITOR: 'BITOR',
    BITRSHIFT: 'BITRSHIFT',
    BITXOR: 'BITXOR',
    CEILING: 'CEILING',
    CHAR: 'CHAR',
    CHOOSE: 'CHOOSE',
    CLEAN: 'CLEAN',
    CODE: 'CODE',
    COLUMN: 'COLUMN',
    COLUMNS: 'COLUMNS',
    CONCATENATE: 'CONCATENATE',
    CORREL: 'CORREL',
    COS: 'COS',
    COSH: 'COSH',
    COT: 'COT',
    COTH: 'COTH',
    COUNT: 'COUNT',
    COUNTA: 'COUNTA',
    COUNTBLANK: 'COUNTBLANK',
    COUNTIF: 'COUNTIF',
    COUNTIFS: 'COUNTIFS',
    COUNTUNIQUE: 'COUNTUNIQUE',
    CSC: 'CSC',
    CSCH: 'CSCH',
    CUMIPMT: 'CUMIPMT',
    CUMPRINC: 'CUMPRINC',
    DATE: 'DATE',
    DATEDIF: 'DATEDIF',
    DATEVALUE: 'DATEVALUE',
    DAY: 'DAY',
    DAYS360: 'DAYS360',
    DAYS: 'DAYS',
    DB: 'DB',
    DDB: 'DDB',
    DEC2BIN: 'DEC2BIN',
    DEC2HEX: 'DEC2HEX',
    DEC2OCT: 'DEC2OCT',
    DECIMAL: 'DECIMAL',
    DEGREES: 'DEGREES',
    DELTA: 'DELTA',
    DOLLARDE: 'DOLLARDE',
    DOLLARFR: 'DOLLARFR',
    EDATE: 'EDATE',
    EFFECT: 'EFFECT',
    EOMONTH: 'EOMONTH',
    ERF: 'ERF',
    ERFC: 'ERFC',
    EVEN: 'EVEN',
    EXACT: 'EXACT',
    EXP: 'EXP',
    FALSE: 'FALSE',
    FIND: 'FIND',
    FORMULATEXT: 'FORMULATEXT',
    FV: 'FV',
    FVSCHEDULE: 'FVSCHEDULE',
    HEX2BIN: 'HEX2BIN',
    HEX2DEC: 'HEX2DEC',
    HEX2OCT: 'HEX2OCT',
    HLOOKUP: 'HLOOKUP',
    HOUR: 'HOUR',
    HYPERLINK: 'HYPERLINK',
    IF: 'IF',
    IFERROR: 'IFERROR',
    IFNA: 'IFNA',
    IFS: 'IFS',
    INDEX: 'INDEX',
    INT: 'INT',
    INTERVAL: 'INTERVAL',
    IPMT: 'IPMT',
    ISBINARY: 'ISBINARY',
    ISBLANK: 'ISBLANK',
    ISERR: 'ISERR',
    ISERROR: 'ISERROR',
    ISEVEN: 'ISEVEN',
    ISFORMULA: 'ISFORMULA',
    ISLOGICAL: 'ISLOGICAL',
    ISNA: 'ISNA',
    ISNONTEXT: 'ISNONTEXT',
    ISNUMBER: 'ISNUMBER',
    ISODD: 'ISODD',
    ISOWEEKNUM: 'ISOWEEKNUM',
    ISPMT: 'ISPMT',
    ISREF: 'ISREF',
    ISTEXT: 'ISTEXT',
    LEFT: 'LEFT',
    LEN: 'LEN',
    LN: 'LN',
    LOG10: 'LOG10',
    LOG: 'LOG',
    LOWER: 'LOWER',
    MATCH: 'MATCH',
    MAX: 'MAX',
    MAXA: 'MAXA',
    MAXIFS: 'MAXIFS',
    MAXPOOL: 'MAXPOOL',
    MEDIAN: 'MEDIAN',
    MEDIANPOOL: 'MEDIANPOOL',
    MID: 'MID',
    MIN: 'MIN',
    MINA: 'MINA',
    MINIFS: 'MINIFS',
    MINUTE: 'MINUTE',
    MIRR: 'MIRR',
    MMULT: 'MMULT',
    MOD: 'MOD',
    MONTH: 'MONTH',
    NA: 'NA',
    NETWORKDAYS: 'NETWORKDAYS',
    'NETWORKDAYS.INTL': 'NETWORKDAYS.INTL',
    NOMINAL: 'NOMINAL',
    NOT: 'NOT',
    NOW: 'NOW',
    NPER: 'NPER',
    NPV: 'NPV',
    OCT2BIN: 'OCT2BIN',
    OCT2DEC: 'OCT2DEC',
    OCT2HEX: 'OCT2HEX',
    ODD: 'ODD',
    OFFSET: 'OFFSET',
    OR: 'OR',
    PI: 'PI',
    PMT: 'PMT',
    PDURATION: 'PDURATION',
    PRODUCT: 'PRODUCT',
    POWER: 'POWER',
    PPMT: 'PPMT',
    PROPER: 'PROPER',
    PV: 'PV',
    RADIANS: 'RADIANS',
    RAND: 'RAND',
    RATE: 'RATE',
    REPLACE: 'REPLACE',
    REPT: 'REPT',
    RIGHT: 'RIGHT',
    ROMAN: 'ROMAN',
    ROUND: 'ROUND',
    ROUNDDOWN: 'ROUNDDOWN',
    ROUNDUP: 'ROUNDUP',
    ROW: 'ROW',
    ROWS: 'ROWS',
    RRI: 'RRI',
    SEARCH: 'SEARCH',
    SEC: 'SEC',
    SECH: 'SECH',
    SECOND: 'SECOND',
    SHEET: 'SHEET',
    SHEETS: 'SHEETS',
    SIN: 'SIN',
    SINH: 'SINH',
    SLN: 'SLN',
    SPLIT: 'SPLIT',
    SQRT: 'SQRT',
    STDEVA: 'STDEVA',
    'STDEV.P': 'STDEV.P',
    STDEVPA: 'STDEVPA',
    'STDEV.S': 'STDEV.S',
    SUBSTITUTE: 'SUBSTITUTE',
    SUBTOTAL: 'SUBTOTAL',
    SUM: 'SUM',
    SUMIF: 'SUMIF',
    SUMIFS: 'SUMIFS',
    SUMPRODUCT: 'SUMPRODUCT',
    SUMSQ: 'SUMSQ',
    SWITCH: 'SWITCH',
    SYD: 'SYD',
    T: 'T',
    TAN: 'TAN',
    TANH: 'TANH',
    TBILLEQ: 'TBILLEQ',
    TBILLPRICE: 'TBILLPRICE',
    TBILLYIELD: 'TBILLYIELD',
    TEXT: 'TEXT',
    TIME: 'TIME',
    TIMEVALUE: 'TIMEVALUE',
    TODAY: 'TODAY',
    TRANSPOSE: 'TRANSPOSE',
    TRIM: 'TRIM',
    TRUE: 'TRUE',
    TRUNC: 'TRUNC',
    UNICHAR: 'UNICHAR',
    UNICODE: 'UNICODE',
    UPPER: 'UPPER',
    VARA: 'VARA',
    'VAR.P': 'VAR.P',
    VARPA: 'VARPA',
    'VAR.S': 'VAR.S',
    VLOOKUP: 'VLOOKUP',
    WEEKDAY: 'WEEKDAY',
    WEEKNUM: 'WEEKNUM',
    WORKDAY: 'WORKDAY',
    'WORKDAY.INTL': 'WORKDAY.INTL',
    XNPV: 'XNPV',
    XOR: 'XOR',
    YEAR: 'YEAR',
    YEARFRAC: 'YEARFRAC',
    'HF.ADD': 'HF.ADD',
    'HF.CONCAT': 'HF.CONCAT',
    'HF.DIVIDE': 'HF.DIVIDE',
    'HF.EQ': 'HF.EQ',
    'HF.GT': 'HF.GT',
    'HF.GTE': 'HF.GTE',
    'HF.LT': 'HF.LT',
    'HF.LTE': 'HF.LTE',
    'HF.MINUS': 'HF.MINUS',
    'HF.MULTIPLY': 'HF.MULTIPLY',
    'HF.NE': 'HF.NE',
    'HF.POW': 'HF.POW',
    'HF.UMINUS': 'HF.UMINUS',
    'HF.UNARY_PERCENT': 'HF.UNARY_PERCENT',
    'HF.UPLUS': 'HF.UPLUS',
    VARP: 'VARP',
    VAR: 'VAR',
    STDEVP: 'STDEVP',
    STDEV: 'STDEV',
    'EXPON.DIST': 'EXPON.DIST',
    FISHER: 'FISHER',
    FISHERINV: 'FISHERINV',
    GAMMA: 'GAMMA',
    'GAMMA.DIST': 'GAMMA.DIST',
    GAMMALN: 'GAMMALN',
    'GAMMALN.PRECISE': 'GAMMALN.PRECISE',
    'GAMMA.INV': 'GAMMA.INV',
    GAUSS: 'GAUSS',
    FACT: 'FACT',
    FACTDOUBLE: 'FACTDOUBLE',
    COMBIN: 'COMBIN',
    COMBINA: 'COMBINA',
    GCD: 'GCD',
    LCM: 'LCM',
    MROUND: 'MROUND',
    MULTINOMIAL: 'MULTINOMIAL',
    QUOTIENT: 'QUOTIENT',
    RANDBETWEEN: 'RANDBETWEEN',
    SERIESSUM: 'SERIESSUM',
    SIGN: 'SIGN',
    SQRTPI: 'SQRTPI',
    SUMX2MY2: 'SUMX2MY2',
    SUMX2PY2: 'SUMX2PY2',
    SUMXMY2: 'SUMXMY2',
    'EXPONDIST': 'EXPONDIST',
    GAMMADIST: 'GAMMADIST',
    GAMMAINV: 'GAMMAINV',
    'BETA.DIST': 'BETA.DIST',
    BETADIST: 'BETADIST',
    'BETA.INV': 'BETA.INV',
    BETAINV: 'BETAINV',
    'BINOM.DIST': 'BINOM.DIST',
    BINOMDIST: 'BINOMDIST',
    'BINOM.INV': 'BINOM.INV',
    BESSELI: 'BESSELI',
    BESSELJ: 'BESSELJ',
    BESSELK: 'BESSELK',
    BESSELY: 'BESSELY',
    'CHISQ.DIST': 'CHISQ.DIST',
    'CHISQ.DIST.RT': 'CHISQ.DIST.RT',
    'CHISQ.INV': 'CHISQ.INV',
    'CHISQ.INV.RT': 'CHISQ.INV.RT',
    CHIDIST: 'CHIDIST',
    CHIINV: 'CHIINV',
    'F.DIST': 'F.DIST',
    'F.DIST.RT': 'F.DIST.RT',
    'F.INV': 'F.INV',
    'F.INV.RT': 'F.INV.RT',
    FDIST: 'FDIST',
    FINV: 'FINV',
    WEIBULL: 'WEIBULL',
    'WEIBULL.DIST': 'WEIBULL.DIST',
    POISSON: 'POISSON',
    'POISSON.DIST': 'POISSON.DIST',
    'HYPGEOM.DIST': 'HYPGEOM.DIST',
    HYPGEOMDIST: 'HYPGEOMDIST',
    'T.DIST': 'T.DIST',
    'T.DIST.2T': 'T.DIST.2T',
    'T.DIST.RT': 'T.DIST.RT',
    'T.INV': 'T.INV',
    'T.INV.2T': 'T.INV.2T',
    TDIST: 'TDIST',
    TINV: 'TINV',
    LOGINV: 'LOGINV',
    'LOGNORM.DIST': 'LOGNORM.DIST',
    'LOGNORM.INV': 'LOGNORM.INV',
    LOGNORMDIST: 'LOGNORMDIST',
    'NORM.DIST': 'NORM.DIST',
    'NORM.INV': 'NORM.INV',
    'NORM.S.DIST': 'NORM.S.DIST',
    'NORM.S.INV': 'NORM.S.INV',
    NORMDIST: 'NORMDIST',
    NORMINV: 'NORMINV',
    NORMSDIST: 'NORMSDIST',
    NORMSINV: 'NORMSINV',
    PHI: 'PHI',
    'NEGBINOM.DIST': 'NEGBINOM.DIST',
    'NEGBINOMDIST': 'NEGBINOMDIST',
    COMPLEX: 'COMPLEX',
    IMABS: 'IMABS',
    IMAGINARY: 'IMAGINARY',
    IMARGUMENT: 'IMARGUMENT',
    IMCONJUGATE: 'IMCONJUGATE',
    IMCOS: 'IMCOS',
    IMCOSH: 'IMCOSH',
    IMCOT: 'IMCOT',
    IMCSC: 'IMCSC',
    IMCSCH: 'IMCSCH',
    IMDIV: 'IMDIV',
    IMEXP: 'IMEXP',
    IMLN: 'IMLN',
    IMLOG10: 'IMLOG10',
    IMLOG2: 'IMLOG2',
    IMPOWER: 'IMPOWER',
    IMPRODUCT: 'IMPRODUCT',
    IMREAL: 'IMREAL',
    IMSEC: 'IMSEC',
    IMSECH: 'IMSECH',
    IMSIN: 'IMSIN',
    IMSINH: 'IMSINH',
    IMSQRT: 'IMSQRT',
    IMSUB: 'IMSUB',
    IMSUM: 'IMSUM',
    IMTAN: 'IMTAN',
    LARGE: 'LARGE',
    SMALL: 'SMALL',
    AVEDEV: 'AVEDEV',
    CONFIDENCE: 'CONFIDENCE',
    'CONFIDENCE.NORM': 'CONFIDENCE.NORM',
    'CONFIDENCE.T': 'CONFIDENCE.T',
    DEVSQ: 'DEVSQ',
    GEOMEAN: 'GEOMEAN',
    HARMEAN: 'HARMEAN',
    CRITBINOM: 'CRITBINOM',
    'COVARIANCE.P': 'COVARIANCE.P',
    'COVARIANCE.S': 'COVARIANCE.S',
    'COVAR': 'COVAR',
    PEARSON: 'PEARSON',
    RSQ: 'RSQ',
    STANDARDIZE: 'STANDARDIZE',
    'Z.TEST': 'Z.TEST',
    ZTEST: 'ZTEST',
    'F.TEST': 'F.TEST',
    FTEST: 'FTEST',
    STEYX: 'STEYX',
    SLOPE: 'SLOPE',
    'CHISQ.TEST': 'CHISQ.TEST',
    CHITEST: 'CHITEST',
    'T.TEST': 'T.TEST',
    TTEST: 'TTEST',
    SKEW: 'SKEW',
    'SKEW.P': 'SKEW.P',
    WEIBULLDIST: 'WEIBULLDIST',
    VARS: 'VARS',
    TINV2T: 'TINV2T',
    TDISTRT: 'TDISTRT',
    TDIST2T: 'TDIST2T',
    STDEVS: 'STDEVS',
    FINVRT: 'FINVRT',
    FDISTRT: 'FDISTRT',
    CHIDISTRT: 'CHIDISTRT',
    CHIINVRT: 'CHIINVRT',
    COVARIANCEP: 'COVARIANCEP',
    COVARIANCES: 'COVARIANCES',
    LOGNORMINV: 'LOGNORMINV',
    POISSONDIST: 'POISSONDIST',
    SKEWP: 'SKEWP',
    'CEILING.MATH': 'CEILING.MATH',
    FLOOR: 'FLOOR',
    'FLOOR.MATH': 'FLOOR.MATH',
    'CEILING.PRECISE': 'CEILING.PRECISE',
    'FLOOR.PRECISE': 'FLOOR.PRECISE',
    'ISO.CEILING': 'ISO.CEILING'
  },
  langCode: 'enGB',
  ui: {
    NEW_SHEET_PREFIX: 'Sheet'
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dictionary);

/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbsPlugin: () => (/* reexport safe */ _AbsPlugin__WEBPACK_IMPORTED_MODULE_2__.AbsPlugin),
/* harmony export */   AddressPlugin: () => (/* reexport safe */ _AddressPlugin__WEBPACK_IMPORTED_MODULE_0__.AddressPlugin),
/* harmony export */   ArrayPlugin: () => (/* reexport safe */ _ArrayPlugin__WEBPACK_IMPORTED_MODULE_1__.ArrayPlugin),
/* harmony export */   BitShiftPlugin: () => (/* reexport safe */ _BitShiftPlugin__WEBPACK_IMPORTED_MODULE_3__.BitShiftPlugin),
/* harmony export */   BitwiseLogicOperationsPlugin: () => (/* reexport safe */ _BitwiseLogicOperationsPlugin__WEBPACK_IMPORTED_MODULE_4__.BitwiseLogicOperationsPlugin),
/* harmony export */   BooleanPlugin: () => (/* reexport safe */ _BooleanPlugin__WEBPACK_IMPORTED_MODULE_5__.BooleanPlugin),
/* harmony export */   CharPlugin: () => (/* reexport safe */ _CharPlugin__WEBPACK_IMPORTED_MODULE_6__.CharPlugin),
/* harmony export */   CodePlugin: () => (/* reexport safe */ _CodePlugin__WEBPACK_IMPORTED_MODULE_7__.CodePlugin),
/* harmony export */   ComplexPlugin: () => (/* reexport safe */ _ComplexPlugin__WEBPACK_IMPORTED_MODULE_41__.ComplexPlugin),
/* harmony export */   ConditionalAggregationPlugin: () => (/* reexport safe */ _ConditionalAggregationPlugin__WEBPACK_IMPORTED_MODULE_32__.ConditionalAggregationPlugin),
/* harmony export */   CountBlankPlugin: () => (/* reexport safe */ _CountBlankPlugin__WEBPACK_IMPORTED_MODULE_8__.CountBlankPlugin),
/* harmony export */   CountUniquePlugin: () => (/* reexport safe */ _CountUniquePlugin__WEBPACK_IMPORTED_MODULE_9__.CountUniquePlugin),
/* harmony export */   DateTimePlugin: () => (/* reexport safe */ _DateTimePlugin__WEBPACK_IMPORTED_MODULE_10__.DateTimePlugin),
/* harmony export */   DegreesPlugin: () => (/* reexport safe */ _DegreesPlugin__WEBPACK_IMPORTED_MODULE_11__.DegreesPlugin),
/* harmony export */   DeltaPlugin: () => (/* reexport safe */ _DeltaPlugin__WEBPACK_IMPORTED_MODULE_12__.DeltaPlugin),
/* harmony export */   ExpPlugin: () => (/* reexport safe */ _ExpPlugin__WEBPACK_IMPORTED_MODULE_13__.ExpPlugin),
/* harmony export */   FinancialPlugin: () => (/* reexport safe */ _FinancialPlugin__WEBPACK_IMPORTED_MODULE_14__.FinancialPlugin),
/* harmony export */   FormulaTextPlugin: () => (/* reexport safe */ _FormulaTextPlugin__WEBPACK_IMPORTED_MODULE_15__.FormulaTextPlugin),
/* harmony export */   HyperlinkPlugin: () => (/* reexport safe */ _HyperlinkPlugin__WEBPACK_IMPORTED_MODULE_16__.HyperlinkPlugin),
/* harmony export */   InformationPlugin: () => (/* reexport safe */ _InformationPlugin__WEBPACK_IMPORTED_MODULE_17__.InformationPlugin),
/* harmony export */   IsEvenPlugin: () => (/* reexport safe */ _IsEvenPlugin__WEBPACK_IMPORTED_MODULE_18__.IsEvenPlugin),
/* harmony export */   IsOddPlugin: () => (/* reexport safe */ _IsOddPlugin__WEBPACK_IMPORTED_MODULE_19__.IsOddPlugin),
/* harmony export */   LogarithmPlugin: () => (/* reexport safe */ _LogarithmPlugin__WEBPACK_IMPORTED_MODULE_20__.LogarithmPlugin),
/* harmony export */   LookupPlugin: () => (/* reexport safe */ _LookupPlugin__WEBPACK_IMPORTED_MODULE_36__.LookupPlugin),
/* harmony export */   MathConstantsPlugin: () => (/* reexport safe */ _MathConstantsPlugin__WEBPACK_IMPORTED_MODULE_21__.MathConstantsPlugin),
/* harmony export */   MathPlugin: () => (/* reexport safe */ _MathPlugin__WEBPACK_IMPORTED_MODULE_40__.MathPlugin),
/* harmony export */   MatrixPlugin: () => (/* reexport safe */ _MatrixPlugin__WEBPACK_IMPORTED_MODULE_22__.MatrixPlugin),
/* harmony export */   MedianPlugin: () => (/* reexport safe */ _MedianPlugin__WEBPACK_IMPORTED_MODULE_23__.MedianPlugin),
/* harmony export */   ModuloPlugin: () => (/* reexport safe */ _ModuloPlugin__WEBPACK_IMPORTED_MODULE_24__.ModuloPlugin),
/* harmony export */   NumericAggregationPlugin: () => (/* reexport safe */ _NumericAggregationPlugin__WEBPACK_IMPORTED_MODULE_25__.NumericAggregationPlugin),
/* harmony export */   PowerPlugin: () => (/* reexport safe */ _PowerPlugin__WEBPACK_IMPORTED_MODULE_26__.PowerPlugin),
/* harmony export */   RadiansPlugin: () => (/* reexport safe */ _RadiansPlugin__WEBPACK_IMPORTED_MODULE_27__.RadiansPlugin),
/* harmony export */   RadixConversionPlugin: () => (/* reexport safe */ _RadixConversionPlugin__WEBPACK_IMPORTED_MODULE_28__.RadixConversionPlugin),
/* harmony export */   RandomPlugin: () => (/* reexport safe */ _RandomPlugin__WEBPACK_IMPORTED_MODULE_29__.RandomPlugin),
/* harmony export */   RomanPlugin: () => (/* reexport safe */ _RomanPlugin__WEBPACK_IMPORTED_MODULE_37__.RomanPlugin),
/* harmony export */   RoundingPlugin: () => (/* reexport safe */ _RoundingPlugin__WEBPACK_IMPORTED_MODULE_30__.RoundingPlugin),
/* harmony export */   SimpleArithmerticPlugin: () => (/* reexport safe */ _SimpleArithmertic__WEBPACK_IMPORTED_MODULE_38__.SimpleArithmerticPlugin),
/* harmony export */   SqrtPlugin: () => (/* reexport safe */ _SqrtPlugin__WEBPACK_IMPORTED_MODULE_31__.SqrtPlugin),
/* harmony export */   StatisticalAggregationPlugin: () => (/* reexport safe */ _StatisticalAggregationPlugin__WEBPACK_IMPORTED_MODULE_42__.StatisticalAggregationPlugin),
/* harmony export */   StatisticalPlugin: () => (/* reexport safe */ _StatisticalPlugin__WEBPACK_IMPORTED_MODULE_39__.StatisticalPlugin),
/* harmony export */   SumprodPlugin: () => (/* reexport safe */ _SumprodPlugin__WEBPACK_IMPORTED_MODULE_33__.SumprodPlugin),
/* harmony export */   TextPlugin: () => (/* reexport safe */ _TextPlugin__WEBPACK_IMPORTED_MODULE_34__.TextPlugin),
/* harmony export */   TrigonometryPlugin: () => (/* reexport safe */ _TrigonometryPlugin__WEBPACK_IMPORTED_MODULE_35__.TrigonometryPlugin)
/* harmony export */ });
/* harmony import */ var _AddressPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(148);
/* harmony import */ var _ArrayPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(149);
/* harmony import */ var _AbsPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(150);
/* harmony import */ var _BitShiftPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(151);
/* harmony import */ var _BitwiseLogicOperationsPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(152);
/* harmony import */ var _BooleanPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(153);
/* harmony import */ var _CharPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(154);
/* harmony import */ var _CodePlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(155);
/* harmony import */ var _CountBlankPlugin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(156);
/* harmony import */ var _CountUniquePlugin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(157);
/* harmony import */ var _DateTimePlugin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(158);
/* harmony import */ var _DegreesPlugin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(159);
/* harmony import */ var _DeltaPlugin__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(160);
/* harmony import */ var _ExpPlugin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(161);
/* harmony import */ var _FinancialPlugin__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(162);
/* harmony import */ var _FormulaTextPlugin__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(163);
/* harmony import */ var _HyperlinkPlugin__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(164);
/* harmony import */ var _InformationPlugin__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(165);
/* harmony import */ var _IsEvenPlugin__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(166);
/* harmony import */ var _IsOddPlugin__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(167);
/* harmony import */ var _LogarithmPlugin__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(168);
/* harmony import */ var _MathConstantsPlugin__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(169);
/* harmony import */ var _MatrixPlugin__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(170);
/* harmony import */ var _MedianPlugin__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(171);
/* harmony import */ var _ModuloPlugin__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(172);
/* harmony import */ var _NumericAggregationPlugin__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(173);
/* harmony import */ var _PowerPlugin__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(174);
/* harmony import */ var _RadiansPlugin__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(175);
/* harmony import */ var _RadixConversionPlugin__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(176);
/* harmony import */ var _RandomPlugin__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(177);
/* harmony import */ var _RoundingPlugin__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(178);
/* harmony import */ var _SqrtPlugin__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(179);
/* harmony import */ var _ConditionalAggregationPlugin__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(180);
/* harmony import */ var _SumprodPlugin__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(183);
/* harmony import */ var _TextPlugin__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(184);
/* harmony import */ var _TrigonometryPlugin__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(185);
/* harmony import */ var _LookupPlugin__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(186);
/* harmony import */ var _RomanPlugin__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(188);
/* harmony import */ var _SimpleArithmertic__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(189);
/* harmony import */ var _StatisticalPlugin__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(190);
/* harmony import */ var _MathPlugin__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(193);
/* harmony import */ var _ComplexPlugin__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(194);
/* harmony import */ var _StatisticalAggregationPlugin__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(195);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */












































/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddressPlugin: () => (/* binding */ AddressPlugin)
/* harmony export */ });
/* harmony import */ var _parser_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(61);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




var AbsStyle;
(function (AbsStyle) {
  AbsStyle[AbsStyle["FullyAbsolute"] = 1] = "FullyAbsolute";
  AbsStyle[AbsStyle["RowAbsoluteColRelative"] = 2] = "RowAbsoluteColRelative";
  AbsStyle[AbsStyle["RowRelativeColAbsolute"] = 3] = "RowRelativeColAbsolute";
  AbsStyle[AbsStyle["FullyRelative"] = 4] = "FullyRelative";
})(AbsStyle || (AbsStyle = {}));
class AddressPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionPlugin {
  verifyAddressArguments(row, col, abs, useA1Style) {
    if (useA1Style) {
      if (row < 1 || col < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.LessThanOne);
      }
    } else {
      if (AbsStyle.FullyAbsolute == abs) {
        if (row < 1 || col < 1) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.LessThanOne);
        }
      } else if (AbsStyle.RowAbsoluteColRelative == abs) {
        if (row < 1) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.LessThanOne);
        }
      } else if (AbsStyle.RowRelativeColAbsolute == abs) {
        if (col < 1) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_2__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_2__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_3__.ErrorMessage.LessThanOne);
        }
      }
    }
    return undefined;
  }
  address(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ADDRESS'), (row, col, abs, useA1Style, sheetName) => {
      const argumentError = this.verifyAddressArguments(row, col, abs, useA1Style);
      if (argumentError !== undefined) {
        return argumentError;
      }
      const colLetter = (0,_parser_addressRepresentationConverters__WEBPACK_IMPORTED_MODULE_0__.columnIndexToLabel)(col - 1);
      let sheetPrefix = '';
      if (sheetName !== undefined && sheetName !== null) {
        sheetPrefix = `${sheetName}!`;
      }
      const r1c1ColSegment = col == 0 ? 'C' : `C[${col}]`;
      const r1c1RowSegment = row == 0 ? 'R' : `R[${row}]`;
      if (AbsStyle.FullyRelative == abs) {
        return useA1Style ? `${sheetPrefix}${colLetter}${row}` : `${sheetPrefix}${r1c1RowSegment}${r1c1ColSegment}`;
      } else if (AbsStyle.RowRelativeColAbsolute == abs) {
        return useA1Style ? `${sheetPrefix}$${colLetter}${row}` : `${sheetPrefix}${r1c1RowSegment}C${col}`;
      } else if (AbsStyle.RowAbsoluteColRelative == abs) {
        return useA1Style ? `${sheetPrefix}${colLetter}$${row}` : `${sheetPrefix}R${row}${r1c1ColSegment}`;
      }
      return useA1Style ? `${sheetPrefix}$${colLetter}$${row}` : `${sheetPrefix}R${row}C${col}`;
    });
  }
}
AddressPlugin.implementedFunctions = {
  'ADDRESS': {
    method: 'address',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      defaultValue: 1,
      minValue: 1,
      maxValue: 4
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.BOOLEAN,
      optionalArg: true,
      defaultValue: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.STRING,
      optionalArg: true
    }]
  }
};

/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArrayPlugin: () => (/* binding */ ArrayPlugin)
/* harmony export */ });
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98);
/* harmony import */ var _InterpreterState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(95);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(69);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */








class ArrayPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionPlugin {
  arrayformula(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ARRAYFORMULA'), value => value);
  }
  arrayformulaArraySize(ast, state) {
    if (ast.args.length !== 1) {
      return _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize.error();
    }
    const metadata = this.metadata('ARRAYFORMULA');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new _InterpreterState__WEBPACK_IMPORTED_MODULE_5__.InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    return subChecks[0];
  }
  arrayconstrain(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ARRAY_CONSTRAIN'), (range, numRows, numCols) => {
      numRows = Math.min(numRows, range.height());
      numCols = Math.min(numCols, range.width());
      const data = range.data;
      const ret = [];
      for (let i = 0; i < numRows; i++) {
        ret.push(data[i].slice(0, numCols));
      }
      return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue.onlyValues(ret);
    });
  }
  arrayconstrainArraySize(ast, state) {
    if (ast.args.length !== 3) {
      return _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize.error();
    }
    const metadata = this.metadata('ARRAY_CONSTRAIN');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new _InterpreterState__WEBPACK_IMPORTED_MODULE_5__.InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    let {
      height,
      width
    } = subChecks[0];
    if (ast.args[1].type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.NUMBER) {
      height = Math.min(height, ast.args[1].value);
    }
    if (ast.args[2].type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.NUMBER) {
      width = Math.min(width, ast.args[2].value);
    }
    if (height < 1 || width < 1 || !Number.isInteger(height) || !Number.isInteger(width)) {
      return _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize.error();
    }
    return new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize(width, height);
  }
  filter(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FILTER'), (rangeVals, ...rangeFilters) => {
      for (const filter of rangeFilters) {
        if (rangeVals.width() !== filter.width() || rangeVals.height() !== filter.height()) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.EqualLength);
        }
      }
      if (rangeVals.width() > 1 && rangeVals.height() > 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongDimension);
      }
      const vals = rangeVals.data;
      const ret = [];
      for (let i = 0; i < rangeVals.height(); i++) {
        const row = [];
        for (let j = 0; j < rangeVals.width(); j++) {
          let ok = true;
          for (const filter of rangeFilters) {
            const val = (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_4__.coerceScalarToBoolean)(filter.data[i][j]);
            if (val !== true) {
              ok = false;
              break;
            }
          }
          if (ok) {
            row.push(vals[i][j]);
          }
        }
        if (row.length > 0) {
          ret.push(row);
        }
      }
      if (ret.length > 0) {
        return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue.onlyValues(ret);
      } else {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.EmptyRange);
      }
    });
  }
  filterArraySize(ast, state) {
    if (ast.args.length <= 1) {
      return _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize.error();
    }
    const metadata = this.metadata('FILTER');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new _InterpreterState__WEBPACK_IMPORTED_MODULE_5__.InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const width = Math.max(...subChecks.map(val => val.width));
    const height = Math.max(...subChecks.map(val => val.height));
    return new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize(width, height);
  }
}
ArrayPlugin.implementedFunctions = {
  'ARRAYFORMULA': {
    method: 'arrayformula',
    arraySizeMethod: 'arrayformulaArraySize',
    arrayFunction: true,
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.ANY
    }]
  },
  'ARRAY_CONSTRAIN': {
    method: 'arrayconstrain',
    arraySizeMethod: 'arrayconstrainArraySize',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.INTEGER,
      minValue: 1
    }],
    vectorizationForbidden: true
  },
  'FILTER': {
    method: 'filter',
    arraySizeMethod: 'filterArraySize',
    arrayFunction: true,
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.RANGE
    }],
    repeatLastArgs: 1
  }
};

/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbsPlugin: () => (/* binding */ AbsPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class AbsPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  abs(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ABS'), Math.abs);
  }
}
AbsPlugin.implementedFunctions = {
  'ABS': {
    method: 'abs',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitShiftPlugin: () => (/* binding */ BitShiftPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



const MAX_48BIT_INTEGER = 281474976710655;
const SHIFT_MIN_POSITIONS = -53;
const SHIFT_MAX_POSITIONS = 53;
class BitShiftPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  bitlshift(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITLSHIFT'), shiftLeft);
  }
  bitrshift(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITRSHIFT'), shiftRight);
  }
}
BitShiftPlugin.implementedFunctions = {
  'BITLSHIFT': {
    method: 'bitlshift',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.INTEGER,
      minValue: SHIFT_MIN_POSITIONS,
      maxValue: SHIFT_MAX_POSITIONS
    }]
  },
  'BITRSHIFT': {
    method: 'bitrshift',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.INTEGER,
      minValue: SHIFT_MIN_POSITIONS,
      maxValue: SHIFT_MAX_POSITIONS
    }]
  }
};
function shiftLeft(value, positions) {
  if (positions < 0) {
    return shiftRight(value, -positions);
  } else {
    return validate(value * Math.pow(2, positions));
  }
}
function shiftRight(value, positions) {
  if (positions < 0) {
    return shiftLeft(value, -positions);
  } else {
    return validate(Math.floor(value / Math.pow(2, positions)));
  }
}
function validate(result) {
  if (result > MAX_48BIT_INTEGER) {
    return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.BitshiftLong);
  } else {
    return result;
  }
}

/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitwiseLogicOperationsPlugin: () => (/* binding */ BitwiseLogicOperationsPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class BitwiseLogicOperationsPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  bitand(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITAND'), (left, right) => left & right);
  }
  bitor(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITOR'), (left, right) => left | right);
  }
  bitxor(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BITXOR'), (left, right) => left ^ right);
  }
}
BitwiseLogicOperationsPlugin.implementedFunctions = {
  'BITAND': {
    method: 'bitand',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.INTEGER,
      minValue: 0
    }]
  },
  'BITOR': {
    method: 'bitor',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.INTEGER,
      minValue: 0
    }]
  },
  'BITXOR': {
    method: 'bitxor',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.INTEGER,
      minValue: 0
    }]
  }
};

/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BooleanPlugin: () => (/* binding */ BooleanPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



/**
 * Interpreter plugin containing boolean functions
 */
class BooleanPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  /**
   * Corresponds to TRUE()
   *
   * Returns the logical true
   *
   * @param ast
   * @param state
   */
  literalTrue(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TRUE'), () => true);
  }
  /**
   * Corresponds to FALSE()
   *
   * Returns the logical false
   *
   * @param ast
   * @param state
   */
  literalFalse(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FALSE'), () => false);
  }
  /**
   * Corresponds to IF(expression, value_if_true, value_if_false)
   *
   * Returns value specified as second argument if expression is true and third argument if expression is false
   *
   * @param ast
   * @param state
   */
  conditionalIf(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IF'), (condition, arg2, arg3) => {
      return condition ? arg2 : arg3;
    });
  }
  /**
   * Implementation for the IFS function. Returns the value that corresponds to the first true condition.
   *
   * @param ast
   * @param state
   */
  ifs(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IFS'), (...args) => {
      for (let idx = 0; idx < args.length; idx += 2) {
        if (args[idx]) {
          return args[idx + 1];
        }
      }
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NoConditionMet);
    });
  }
  /**
   * Corresponds to AND(expression1, [expression2, ...])
   *
   * Returns true if all of the provided arguments are logically true, and false if any of it is logically false
   *
   * @param ast
   * @param state
   */
  and(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('AND'), (...args) => args.filter(arg => arg !== undefined).every(arg => !!arg));
  }
  /**
   * Corresponds to OR(expression1, [expression2, ...])
   *
   * Returns true if any of the provided arguments are logically true, and false otherwise
   *
   * @param ast
   * @param state
   */
  or(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('OR'), (...args) => args.filter(arg => arg !== undefined).some(arg => arg));
  }
  not(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NOT'), arg => !arg);
  }
  xor(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('XOR'), (...args) => {
      let cnt = 0;
      args.filter(arg => arg !== undefined).forEach(arg => {
        if (arg) {
          cnt++;
        }
      });
      return cnt % 2 === 1;
    });
  }
  switch(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SWITCH'), (selector, ...args) => {
      const n = args.length;
      let i = 0;
      for (; i + 1 < n; i += 2) {
        if (args[i] instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          continue;
        }
        if (this.arithmeticHelper.eq(selector, args[i])) {
          return args[i + 1];
        }
      }
      if (i < n) {
        return args[i];
      } else {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NoDefault);
      }
    });
  }
  iferror(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IFERROR'), (arg1, arg2) => {
      if (arg1 instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return arg2;
      } else {
        return arg1;
      }
    });
  }
  ifna(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IFNA'), (arg1, arg2) => {
      if (arg1 instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError && arg1.type === _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA) {
        return arg2;
      } else {
        return arg1;
      }
    });
  }
  choose(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHOOSE'), (selector, ...args) => {
      if (selector > args.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.Selector);
      }
      return args[selector - 1];
    });
  }
}
BooleanPlugin.implementedFunctions = {
  'TRUE': {
    method: 'literalTrue',
    parameters: []
  },
  'FALSE': {
    method: 'literalFalse',
    parameters: []
  },
  'IF': {
    method: 'conditionalIf',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.BOOLEAN
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      defaultValue: false,
      passSubtype: true
    }]
  },
  'IFS': {
    method: 'ifs',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.BOOLEAN
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }],
    repeatLastArgs: 2
  },
  'AND': {
    method: 'and',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.BOOLEAN
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'OR': {
    method: 'or',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.BOOLEAN
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'XOR': {
    method: 'xor',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.BOOLEAN
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'NOT': {
    method: 'not',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.BOOLEAN
    }]
  },
  'SWITCH': {
    method: 'switch',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NOERROR
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }],
    repeatLastArgs: 1
  },
  'IFERROR': {
    method: 'iferror',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }]
  },
  'IFNA': {
    method: 'ifna',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }]
  },
  'CHOOSE': {
    method: 'choose',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR,
      passSubtype: true
    }],
    repeatLastArgs: 1
  }
};

/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CharPlugin: () => (/* binding */ CharPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class CharPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  char(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHAR'), value => {
      if (value < 1 || value >= 256) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.CharacterCodeBounds);
      }
      return String.fromCharCode(Math.trunc(value));
    });
  }
  unichar(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHAR'), value => {
      if (value < 1 || value >= 1114112) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.CharacterCodeBounds);
      }
      return String.fromCodePoint(Math.trunc(value));
    });
  }
}
CharPlugin.implementedFunctions = {
  'CHAR': {
    method: 'char',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'UNICHAR': {
    method: 'unichar',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodePlugin: () => (/* binding */ CodePlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class CodePlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  code(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CODE'), value => {
      if (value.length === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EmptyString);
      }
      return value.charCodeAt(0);
    });
  }
  unicode(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('UNICODE'), value => {
      var _a;
      return (_a = value.codePointAt(0)) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EmptyString);
    });
  }
}
CodePlugin.implementedFunctions = {
  'CODE': {
    method: 'code',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  },
  'UNICODE': {
    method: 'unicode',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  }
};

/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CountBlankPlugin: () => (/* binding */ CountBlankPlugin)
/* harmony export */ });
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


/**
 * Interpreter plugin containing MEDIAN function
 */
class CountBlankPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionPlugin {
  countblank(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COUNTBLANK'), (...args) => {
      let counter = 0;
      args.forEach(arg => {
        if (arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_0__.EmptyValue) {
          counter++;
        }
      });
      return counter;
    });
  }
}
CountBlankPlugin.implementedFunctions = {
  'COUNTBLANK': {
    method: 'countblank',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.SCALAR
    }],
    repeatLastArgs: 1,
    expandRanges: true
  }
};

/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CountUniquePlugin: () => (/* binding */ CountUniquePlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


/**
 * Interpreter plugin containing COUNTUNIQUE function
 */
class CountUniquePlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionPlugin {
  /**
   * Corresponds to COUNTUNIQUE(Number1, Number2, ...).
   *
   * Returns number of unique numbers from arguments
   *
   * @param ast
   * @param state
   */
  countunique(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COUNTUNIQUE'), (...args) => {
      const valuesSet = new Set();
      const errorsSet = new Set();
      for (const scalarValue of args) {
        if (scalarValue instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          errorsSet.add(scalarValue.type);
        } else if (scalarValue !== '') {
          valuesSet.add(scalarValue);
        }
      }
      return valuesSet.size + errorsSet.size;
    });
  }
}
CountUniquePlugin.implementedFunctions = {
  'COUNTUNIQUE': {
    method: 'countunique',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.SCALAR
    }],
    repeatLastArgs: 1,
    expandRanges: true
  }
};

/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DateTimePlugin: () => (/* binding */ DateTimePlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(104);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _format_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(106);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */






/**
 * Interpreter plugin containing date-specific functions
 */
class DateTimePlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionPlugin {
  constructor() {
    super(...arguments);
    this.isoweeknumCore = day => {
      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));
      const date = this.dateTimeHelper.numberToSimpleDate(day);
      const yearStart = this.dateTimeHelper.dateToNumber({
        year: date.year,
        month: 1,
        day: 1
      });
      const yearStartAbsolute = this.dateTimeHelper.relativeNumberToAbsoluteNumber(yearStart);
      const firstThursdayAbs = yearStartAbsolute + ((4 - yearStartAbsolute) % 7 + 7) % 7;
      const ret = Math.floor((absoluteDay - 1) / 7) - Math.floor((firstThursdayAbs - 1) / 7) + 1;
      if (ret === 0) {
        return this.isoweeknumCore(day - 7) + 1;
      }
      return ret;
    };
    this.days360Core = (startDate, endDate, mode) => {
      const start = this.dateTimeHelper.numberToSimpleDate(startDate);
      const end = this.dateTimeHelper.numberToSimpleDate(endDate);
      let nStart, nEnd;
      if (mode) {
        nStart = (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.toBasisEU)(start);
        nEnd = (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.toBasisEU)(end);
      } else {
        [nStart, nEnd] = this.dateTimeHelper.toBasisUS(start, end);
      }
      return 360 * (nEnd.year - nStart.year) + 30 * (nEnd.month - nStart.month) + nEnd.day - nStart.day;
    };
  }
  /**
   * Corresponds to DATE(year, month, day)
   *
   * Converts a provided year, month and day into date
   *
   * @param ast
   * @param state
   */
  date(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DATE'), (year, month, day) => {
      const d = Math.trunc(day);
      let m = Math.trunc(month);
      let y = Math.trunc(year);
      if (y < this.dateTimeHelper.getEpochYearZero()) {
        y += this.dateTimeHelper.getEpochYearZero();
      }
      const delta = Math.floor((m - 1) / 12);
      y += delta;
      m -= delta * 12;
      const date = {
        year: y,
        month: m,
        day: 1
      };
      if (this.dateTimeHelper.isValidDate(date)) {
        let ret = this.dateTimeHelper.dateToNumber(date) + (d - 1);
        ret = this.dateTimeHelper.getWithinBounds(ret);
        if (ret === undefined) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.DateBounds);
        }
        return ret;
      }
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.InvalidDate);
    });
  }
  time(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TIME'), (h, m, s) => {
      const ret = (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.timeToNumber)({
        hours: Math.trunc(h),
        minutes: Math.trunc(m),
        seconds: Math.trunc(s)
      });
      if (ret < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.NegativeTime);
      }
      return ret % 1;
    });
  }
  /**
   * Implementation for the EOMONTH function
   */
  eomonth(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EOMONTH'), (dateNumber, numberOfMonthsToShift) => {
      const date = this.dateTimeHelper.numberToSimpleDate(dateNumber);
      let ret = this.dateTimeHelper.dateToNumber(this.dateTimeHelper.endOfMonth((0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.offsetMonth)(date, numberOfMonthsToShift)));
      ret = this.dateTimeHelper.getWithinBounds(ret);
      if (ret === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.DateBounds);
      }
      return ret;
    });
  }
  day(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DAY'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).day);
  }
  days(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DAYS'), (endDate, startDate) => Math.trunc(endDate) - Math.trunc(startDate));
  }
  /**
   * Corresponds to MONTH(date)
   *
   * Returns the month of the year specified by a given date
   *
   * @param ast
   * @param state
   */
  month(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MONTH'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).month);
  }
  /**
   * Corresponds to YEAR(date)
   *
   * Returns the year specified by a given date
   *
   * @param ast
   * @param state
   */
  year(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('YEAR'), dateNumber => this.dateTimeHelper.numberToSimpleDate(dateNumber).year);
  }
  hour(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HOUR'), timeNumber => (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.numberToSimpleTime)((0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.roundToNearestSecond)(timeNumber) % 1).hours);
  }
  minute(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MINUTE'), timeNumber => (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.numberToSimpleTime)((0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.roundToNearestSecond)(timeNumber) % 1).minutes);
  }
  second(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SECOND'), timeNumber => (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.numberToSimpleTime)((0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.roundToNearestSecond)(timeNumber) % 1).seconds);
  }
  /**
   * Corresponds to TEXT(number, format)
   *
   * Tries to convert number to specified date format.
   *
   * @param ast
   * @param state
   */
  text(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TEXT'), (numberRepresentation, formatArg) => (0,_format_format__WEBPACK_IMPORTED_MODULE_3__.format)(numberRepresentation, formatArg, this.config, this.dateTimeHelper));
  }
  weekday(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WEEKDAY'), (day, type) => {
      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));
      if (type === 3) {
        return (absoluteDay - 1) % 7;
      }
      const offset = weekdayOffsets.get(type);
      if (offset === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.BadMode);
      }
      return (absoluteDay - offset) % 7 + 1;
    });
  }
  weeknum(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WEEKNUM'), (day, type) => {
      const absoluteDay = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(day));
      const date = this.dateTimeHelper.numberToSimpleDate(day);
      const yearStart = this.dateTimeHelper.dateToNumber({
        year: date.year,
        month: 1,
        day: 1
      });
      const yearStartAbsolute = this.dateTimeHelper.relativeNumberToAbsoluteNumber(yearStart);
      if (type === 21) {
        return this.isoweeknumCore(day);
      }
      const offset = weekdayOffsets.get(type);
      if (offset === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.BadMode);
      }
      return Math.floor((absoluteDay - offset) / 7) - Math.floor((yearStartAbsolute - offset) / 7) + 1;
    });
  }
  isoweeknum(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISOWEEKNUM'), this.isoweeknumCore);
  }
  datevalue(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DATEVALUE'), date => {
      const {
        dateTime
      } = this.dateTimeHelper.parseDateTimeFromConfigFormats(date);
      if (dateTime === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.IncorrectDateTime);
      }
      if (!(0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.instanceOfSimpleDate)(dateTime)) {
        return 0;
      }
      return ((0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.instanceOfSimpleTime)(dateTime) ? Math.trunc((0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.timeToNumber)(dateTime)) : 0) + this.dateTimeHelper.dateToNumber(dateTime);
    });
  }
  timevalue(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TIMEVALUE'), date => {
      const dateNumber = this.dateTimeHelper.dateStringToDateNumber(date);
      if (dateNumber === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.IncorrectDateTime);
      }
      return (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.getRawValue)(dateNumber) % 1;
    });
  }
  now(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NOW'), () => {
      const now = new Date(Date.now());
      return (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.timeToNumber)({
        hours: now.getHours(),
        minutes: now.getMinutes(),
        seconds: now.getSeconds()
      }) + this.dateTimeHelper.dateToNumber({
        year: now.getFullYear(),
        month: now.getMonth() + 1,
        day: now.getDate()
      });
    });
  }
  today(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TODAY'), () => {
      const now = new Date(Date.now());
      return this.dateTimeHelper.dateToNumber({
        year: now.getFullYear(),
        month: now.getMonth() + 1,
        day: now.getDate()
      });
    });
  }
  edate(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EDATE'), (dateNumber, delta) => {
      const date = this.dateTimeHelper.numberToSimpleDate(dateNumber);
      const newDate = (0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.truncateDayInMonth)((0,_DateTimeHelper__WEBPACK_IMPORTED_MODULE_1__.offsetMonth)(date, delta));
      let ret = this.dateTimeHelper.dateToNumber(newDate);
      ret = this.dateTimeHelper.getWithinBounds(ret);
      if (ret === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.DateBounds);
      }
      return ret;
    });
  }
  datedif(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DATEDIF'), (startDate, endDate, unit) => {
      if (startDate > endDate) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.StartEndDate);
      }
      if (unit === 'D') {
        return Math.floor(endDate) - Math.floor(startDate);
      }
      const start = this.dateTimeHelper.numberToSimpleDate(startDate);
      const end = this.dateTimeHelper.numberToSimpleDate(endDate);
      switch (unit) {
        case 'M':
          return (end.year - start.year) * 12 + (end.month - start.month) - (end.day < start.day ? 1 : 0);
        case 'YM':
          return (12 + (end.month - start.month) - (end.day < start.day ? 1 : 0)) % 12;
        case 'Y':
          if (end.month > start.month || end.month === start.month && end.day >= start.day) {
            return end.year - start.year;
          } else {
            return end.year - start.year - 1;
          }
        case 'MD':
          if (end.day >= start.day) {
            return end.day - start.day;
          } else {
            const m = end.month === 1 ? 12 : end.month - 1;
            const y = end.month === 1 ? end.year - 1 : end.year;
            return this.dateTimeHelper.daysInMonth(y, m) + end.day - start.day;
          }
        case 'YD':
          if (end.month > start.month || end.month === start.month && end.day >= start.day) {
            return Math.floor(endDate) - this.dateTimeHelper.dateToNumber({
              year: end.year,
              month: start.month,
              day: start.day
            });
          } else {
            return Math.floor(endDate) - Math.floor(startDate) - 365 * (end.year - start.year - 1) - this.dateTimeHelper.leapYearsCount(end.year - 1) + this.dateTimeHelper.leapYearsCount(start.year);
          }
        default:
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.BadMode);
      }
    });
  }
  days360(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DAYS360'), this.days360Core);
  }
  yearfrac(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('YEARFRAC'), (startDate, endDate, mode) => {
      startDate = Math.trunc(startDate);
      endDate = Math.trunc(endDate);
      if (startDate > endDate) {
        [startDate, endDate] = [endDate, startDate];
      }
      switch (mode) {
        case 0:
          return this.days360Core(startDate, endDate, false) / 360;
        case 1:
          return (endDate - startDate) / this.dateTimeHelper.yearLengthForBasis(this.dateTimeHelper.numberToSimpleDate(startDate), this.dateTimeHelper.numberToSimpleDate(endDate));
        case 2:
          return (endDate - startDate) / 360;
        case 3:
          return (endDate - startDate) / 365;
        case 4:
          return this.days360Core(startDate, endDate, true) / 360;
      }
      throw new Error('Should not be reachable.');
    });
  }
  interval(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('INTERVAL'), arg => {
      arg = Math.trunc(arg);
      const second = arg % 60;
      arg = Math.trunc(arg / 60);
      const minute = arg % 60;
      arg = Math.trunc(arg / 60);
      const hour = arg % 24;
      arg = Math.trunc(arg / 24);
      const day = arg % 30;
      arg = Math.trunc(arg / 30);
      const month = arg % 12;
      const year = Math.trunc(arg / 12);
      return 'P' + (year > 0 ? `${year}Y` : '') + (month > 0 ? `${month}M` : '') + (day > 0 ? `${day}D` : '') + 'T' + (hour > 0 ? `${hour}H` : '') + (minute > 0 ? `${minute}M` : '') + (second > 0 ? `${second}S` : '');
    });
  }
  networkdays(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NETWORKDAYS'), (start, end, holidays) => this.networkdayscore(start, end, 1, holidays));
  }
  networkdaysintl(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NETWORKDAYS.INTL'), (start, end, weekend, holidays) => this.networkdayscore(start, end, weekend, holidays));
  }
  workday(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WORKDAY'), (start, end, holidays) => this.workdaycore(start, end, 1, holidays));
  }
  workdayintl(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WORKDAY.INTL'), (start, end, weekend, holidays) => this.workdaycore(start, end, weekend, holidays));
  }
  networkdayscore(start, end, weekend, holidays) {
    start = Math.trunc(start);
    end = Math.trunc(end);
    let multiplier = 1;
    if (start > end) {
      [start, end] = [end, start];
      multiplier = -1;
    }
    const weekendPattern = computeWeekendPattern(weekend);
    if (weekendPattern instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return weekendPattern;
    }
    const filteredHolidays = this.simpleRangeToFilteredHolidays(weekendPattern, holidays);
    if (filteredHolidays instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return filteredHolidays;
    }
    return multiplier * this.countWorkdays(start, end, weekendPattern, filteredHolidays);
  }
  workdaycore(start, delta, weekend, holidays) {
    start = Math.trunc(start);
    delta = Math.trunc(delta);
    const weekendPattern = computeWeekendPattern(weekend);
    if (weekendPattern instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return weekendPattern;
    }
    const filteredHolidays = this.simpleRangeToFilteredHolidays(weekendPattern, holidays);
    if (filteredHolidays instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return filteredHolidays;
    }
    if (delta > 0) {
      let upper = 1;
      while (this.countWorkdays(start + 1, start + upper, weekendPattern, filteredHolidays) < delta) {
        upper *= 2;
      }
      let lower = 1;
      while (lower + 1 < upper) {
        const mid = Math.trunc((lower + upper) / 2);
        if (this.countWorkdays(start + 1, start + mid, weekendPattern, filteredHolidays) < delta) {
          lower = mid;
        } else {
          upper = mid;
        }
      }
      return start + upper;
    } else if (delta < 0) {
      delta *= -1;
      let upper = 1;
      while (this.countWorkdays(start - upper, start - 1, weekendPattern, filteredHolidays) < delta) {
        upper *= 2;
      }
      let lower = 1;
      while (lower + 1 < upper) {
        const mid = Math.trunc((lower + upper) / 2);
        if (this.countWorkdays(start - mid, start - 1, weekendPattern, filteredHolidays) < delta) {
          lower = mid;
        } else {
          upper = mid;
        }
      }
      return start - upper;
    } else {
      return start;
    }
  }
  countWorkdays(start, end, weekendPattern, sortedHolidays) {
    const absoluteEnd = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(end));
    const absoluteStart = Math.floor(this.dateTimeHelper.relativeNumberToAbsoluteNumber(start));
    let ans = 0;
    for (let i = 0; i < 7; i++) {
      if (weekendPattern.charAt(i) === '0') {
        ans += Math.floor((absoluteEnd + 6 - i) / 7);
        ans -= Math.floor((absoluteStart - 1 + 6 - i) / 7);
      }
    }
    ans -= lowerBound(end + 1, sortedHolidays) - lowerBound(start, sortedHolidays);
    return ans;
  }
  simpleRangeToFilteredHolidays(weekendPattern, holidays) {
    var _a;
    const holidaysArr = (_a = holidays === null || holidays === void 0 ? void 0 : holidays.valuesFromTopLeftCorner()) !== null && _a !== void 0 ? _a : [];
    for (const val of holidaysArr) {
      if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return val;
      }
    }
    const processedHolidays = [];
    for (const val of holidaysArr) {
      if (val === _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.EmptyValue) {
        continue;
      }
      if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.isExtendedNumber)(val)) {
        processedHolidays.push(Math.trunc((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.getRawValue)(val)));
      } else {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongType);
      }
    }
    return [...new Set(processedHolidays)].sort((a, b) => a - b).filter(arg => {
      const val = this.dateTimeHelper.relativeNumberToAbsoluteNumber(arg);
      const i = (val - 1) % 7;
      return weekendPattern.charAt(i) === '0';
    });
  }
}
DateTimePlugin.implementedFunctions = {
  'DATE': {
    method: 'date',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.NumberType.NUMBER_DATE
  },
  'TIME': {
    method: 'time',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.NumberType.NUMBER_TIME
  },
  'MONTH': {
    method: 'month',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'YEAR': {
    method: 'year',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'HOUR': {
    method: 'hour',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'MINUTE': {
    method: 'minute',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'SECOND': {
    method: 'second',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'TEXT': {
    method: 'text',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.STRING
    }]
  },
  'EOMONTH': {
    method: 'eomonth',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.NumberType.NUMBER_DATE
  },
  'DAY': {
    method: 'day',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'DAYS': {
    method: 'days',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'WEEKDAY': {
    method: 'weekday',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'WEEKNUM': {
    method: 'weeknum',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'ISOWEEKNUM': {
    method: 'isoweeknum',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'DATEVALUE': {
    method: 'datevalue',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.STRING
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.NumberType.NUMBER_DATE
  },
  'TIMEVALUE': {
    method: 'timevalue',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.STRING
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.NumberType.NUMBER_TIME
  },
  'NOW': {
    method: 'now',
    parameters: [],
    isVolatile: true,
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.NumberType.NUMBER_DATETIME
  },
  'TODAY': {
    method: 'today',
    parameters: [],
    isVolatile: true,
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.NumberType.NUMBER_DATE
  },
  'EDATE': {
    method: 'edate',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.NumberType.NUMBER_DATE
  },
  'DAYS360': {
    method: 'days360',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.BOOLEAN,
      defaultValue: false
    }]
  },
  'DATEDIF': {
    method: 'datedif',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.STRING
    }]
  },
  'YEARFRAC': {
    method: 'yearfrac',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.INTEGER,
      defaultValue: 0,
      minValue: 0,
      maxValue: 4
    }]
  },
  'INTERVAL': {
    method: 'interval',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'NETWORKDAYS': {
    method: 'networkdays',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  'NETWORKDAYS.INTL': {
    method: 'networkdaysintl',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NOERROR,
      defaultValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  'WORKDAY': {
    method: 'workday',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  'WORKDAY.INTL': {
    method: 'workdayintl',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.NOERROR,
      defaultValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_5__.FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  }
};
/**
 * Returns i such that:
 * sortedArray[i-1] < val <= sortedArray[i]
 *
 */
function lowerBound(val, sortedArray) {
  if (sortedArray.length === 0) {
    return 0;
  }
  if (val <= sortedArray[0]) {
    return 0;
  }
  if (sortedArray[sortedArray.length - 1] < val) {
    return sortedArray.length;
  }
  let lower = 0; //sortedArray[lower] < val
  let upper = sortedArray.length - 1; //sortedArray[upper] >= val
  while (lower + 1 < upper) {
    const mid = Math.floor((upper + lower) / 2);
    if (sortedArray[mid] >= val) {
      upper = mid;
    } else {
      lower = mid;
    }
  }
  return upper;
}
function computeWeekendPattern(weekend) {
  var _a;
  if (typeof weekend !== 'number' && typeof weekend !== 'string') {
    return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongType);
  }
  if (typeof weekend === 'string') {
    if (weekend.length !== 7 || !/^(0|1)*$/.test(weekend) || weekend === '1111111') {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WeekendString);
    } else {
      return weekend;
    }
  } else {
    return (_a = workdayPatterns.get(weekend)) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.BadMode);
  }
}
const weekdayOffsets = new Map([[1, 0], [2, 1], [11, 1], [12, 2], [13, 3], [14, 4], [15, 5], [16, 6], [17, 0]]);
const workdayPatterns = new Map([[1, '0000011'], [2, '1000001'], [3, '1100000'], [4, '0110000'], [5, '0011000'], [6, '0001100'], [7, '0000110'], [11, '0000001'], [12, '1000000'], [13, '0100000'], [14, '0010000'], [15, '0001000'], [16, '0000100'], [17, '0000010']]);

/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DegreesPlugin: () => (/* binding */ DegreesPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class DegreesPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  degrees(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEGREES'), arg => arg * (180 / Math.PI));
  }
}
DegreesPlugin.implementedFunctions = {
  'DEGREES': {
    method: 'degrees',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DeltaPlugin: () => (/* binding */ DeltaPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class DeltaPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  delta(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DELTA'), (left, right) => left === right ? 1 : 0);
  }
}
DeltaPlugin.implementedFunctions = {
  'DELTA': {
    method: 'delta',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  }
};

/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ExpPlugin: () => (/* binding */ ExpPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class ExpPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  /**
   * Corresponds to EXP(value)
   *
   * Calculates the exponent for basis e
   *
   * @param ast
   * @param state
   */
  exp(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EXP'), Math.exp);
  }
}
ExpPlugin.implementedFunctions = {
  'EXP': {
    method: 'exp',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FinancialPlugin: () => (/* binding */ FinancialPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class FinancialPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionPlugin {
  pmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PMT'), pmtCore);
  }
  ipmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IPMT'), ipmtCore);
  }
  ppmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PPMT'), ppmtCore);
  }
  fv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FV'), fvCore);
  }
  cumipmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CUMIPMT'), (rate, periods, value, start, end, type) => {
      if (start > end) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EndStartPeriod);
      }
      let acc = 0;
      for (let i = start; i <= end; i++) {
        acc += ipmtCore(rate, i, periods, value, 0, type);
      }
      return acc;
    });
  }
  cumprinc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CUMPRINC'), (rate, periods, value, start, end, type) => {
      if (start > end) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EndStartPeriod);
      }
      let acc = 0;
      for (let i = start; i <= end; i++) {
        acc += ppmtCore(rate, i, periods, value, 0, type);
      }
      return acc;
    });
  }
  db(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DB'), (cost, salvage, life, period, month) => {
      if (month === 12 && period > life || period > life + 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.PeriodLong);
      }
      if (salvage >= cost) {
        return 0;
      }
      const rate = Math.round((1 - Math.pow(salvage / cost, 1 / life)) * 1000) / 1000;
      const initial = cost * rate * month / 12;
      if (period === 1) {
        return initial;
      }
      let total = initial;
      for (let i = 0; i < period - 2; i++) {
        total += (cost - total) * rate;
      }
      if (period === life + 1) {
        return (cost - total) * rate * (12 - month) / 12;
      }
      return (cost - total) * rate;
    });
  }
  ddb(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DDB'), (cost, salvage, life, period, factor) => {
      if (period > life) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      let rate = factor / life;
      let oldValue;
      if (rate >= 1) {
        rate = 1;
        if (period === 1) {
          oldValue = cost;
        } else {
          oldValue = 0;
        }
      } else {
        oldValue = cost * Math.pow(1 - rate, period - 1);
      }
      const newValue = cost * Math.pow(1 - rate, period);
      return Math.max(oldValue - Math.max(salvage, newValue), 0);
    });
  }
  dollarde(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DOLLARDE'), (dollar, fraction) => {
      if (fraction < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      fraction = Math.trunc(fraction);
      while (fraction > 10) {
        fraction /= 10;
      }
      return Math.trunc(dollar) + (dollar - Math.trunc(dollar)) * 10 / fraction;
    });
  }
  dollarfr(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DOLLARFR'), (dollar, fraction) => {
      if (fraction < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      fraction = Math.trunc(fraction);
      while (fraction > 10) {
        fraction /= 10;
      }
      return Math.trunc(dollar) + (dollar - Math.trunc(dollar)) * fraction / 10;
    });
  }
  effect(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EFFECT'), (rate, periods) => {
      periods = Math.trunc(periods);
      return Math.pow(1 + rate / periods, periods) - 1;
    });
  }
  ispmt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISPMT'), (rate, period, periods, value) => {
      if (periods === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      return value * rate * (period / periods - 1);
    });
  }
  nominal(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NOMINAL'), (rate, periods) => {
      periods = Math.trunc(periods);
      return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
    });
  }
  nper(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NPER'), (rate, payment, present, future, type) => {
      if (rate === 0) {
        if (payment === 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
        }
        return (-present - future) / payment;
      }
      if (type) {
        payment *= 1 + rate;
      }
      return Math.log((payment - future * rate) / (present * rate + payment)) / Math.log(1 + rate);
    });
  }
  rate(ast, state) {
    // Newton's method: https://en.wikipedia.org/wiki/Newton%27s_method
    return this.runFunction(ast.args, state, this.metadata('RATE'), (periods, payment, present, future, type, guess) => {
      if (guess <= -1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE);
      }
      const epsMax = 1e-7;
      const iterMax = 50;
      let rate = guess;
      type = type ? 1 : 0;
      for (let i = 0; i < iterMax; i++) {
        if (rate <= -1) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
        }
        let y;
        if (Math.abs(rate) < epsMax) {
          y = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;
        } else {
          const f = Math.pow(1 + rate, periods);
          y = present * f + payment * (1 / rate + type) * (f - 1) + future;
        }
        if (Math.abs(y) < epsMax) {
          return rate;
        }
        let dy;
        if (Math.abs(rate) < epsMax) {
          dy = present * periods + payment * type * periods;
        } else {
          const f = Math.pow(1 + rate, periods);
          const df = periods * Math.pow(1 + rate, periods - 1);
          dy = present * df + payment * (1 / rate + type) * df + payment * (-1 / (rate * rate)) * (f - 1);
        }
        rate -= y / dy;
      }
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
    });
  }
  pv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PV'), (rate, periods, payment, future, type) => {
      type = type ? 1 : 0;
      if (rate === -1) {
        if (periods === 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
        } else {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
        }
      }
      if (rate === 0) {
        return -payment * periods - future;
      } else {
        return ((1 - Math.pow(1 + rate, periods)) * payment * (1 + rate * type) / rate - future) / Math.pow(1 + rate, periods);
      }
    });
  }
  rri(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RRI'), (periods, present, future) => {
      if (present === 0 || future < 0 && present > 0 || future > 0 && present < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      return Math.pow(future / present, 1 / periods) - 1;
    });
  }
  sln(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SLN'), (cost, salvage, life) => {
      if (life === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      return (cost - salvage) / life;
    });
  }
  syd(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SYD'), (cost, salvage, life, period) => {
      if (period > life) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      return (cost - salvage) * (life - period + 1) * 2 / (life * (life + 1));
    });
  }
  tbilleq(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TBILLEQ'), (settlement, maturity, discount) => {
      settlement = Math.round(settlement);
      maturity = Math.round(maturity);
      if (settlement >= maturity) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);
      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);
      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      const denom = 360 - discount * (maturity - settlement);
      if (denom === 0) {
        return 0;
      }
      if (denom < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      return 365 * discount / denom;
    });
  }
  tbillprice(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TBILLPRICE'), (settlement, maturity, discount) => {
      settlement = Math.round(settlement);
      maturity = Math.round(maturity);
      if (settlement >= maturity) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);
      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);
      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      const denom = 360 - discount * (maturity - settlement);
      if (denom === 0) {
        return 0;
      }
      if (denom < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      return 100 * (1 - discount * (maturity - settlement) / 360);
    });
  }
  tbillyield(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TBILLYIELD'), (settlement, maturity, price) => {
      settlement = Math.round(settlement);
      maturity = Math.round(maturity);
      if (settlement >= maturity) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      const startDate = this.dateTimeHelper.numberToSimpleDate(settlement);
      const endDate = this.dateTimeHelper.numberToSimpleDate(maturity);
      if (endDate.year > startDate.year + 1 || endDate.year === startDate.year + 1 && (endDate.month > startDate.month || endDate.month === startDate.month && endDate.day > startDate.day)) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM);
      }
      return (100 - price) * 360 / (price * (maturity - settlement));
    });
  }
  fvschedule(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FVSCHEDULE'), (value, ratios) => {
      const vals = ratios.valuesFromTopLeftCorner();
      for (const val of vals) {
        if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return val;
        }
      }
      for (const val of vals) {
        if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.isExtendedNumber)(val)) {
          value *= 1 + (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.getRawValue)(val);
        } else if (val !== _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.EmptyValue) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NumberExpected);
        }
      }
      return value;
    });
  }
  npv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NPV'), (rate, ...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      return npvCore(rate, coerced);
    });
  }
  mirr(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MIRR'), (range, frate, rrate) => {
      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());
      if (vals instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return vals;
      }
      let posFlag = false;
      let negFlag = false;
      const posValues = [];
      const negValues = [];
      for (const val of vals) {
        if (val > 0) {
          posFlag = true;
          posValues.push(val);
          negValues.push(0);
        } else if (val < 0) {
          negFlag = true;
          negValues.push(val);
          posValues.push(0);
        } else {
          negValues.push(0);
          posValues.push(0);
        }
      }
      if (!posFlag || !negFlag) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      const n = vals.length;
      const nom = npvCore(rrate, posValues);
      if (nom instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return nom;
      }
      const denom = npvCore(frate, negValues);
      if (denom instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return denom;
      }
      return Math.pow(-nom * Math.pow(1 + rrate, n) / denom / (1 + frate), 1 / (n - 1)) - 1;
    });
  }
  pduration(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PDURATION'), (rate, pv, fv) => (Math.log(fv) - Math.log(pv)) / Math.log(1 + rate));
  }
  xnpv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('XNPV'), (rate, values, dates) => {
      const valArr = values.valuesFromTopLeftCorner();
      for (const val of valArr) {
        if (typeof val !== 'number') {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NumberExpected);
        }
      }
      const valArrNum = valArr;
      const dateArr = dates.valuesFromTopLeftCorner();
      for (const date of dateArr) {
        if (typeof date !== 'number') {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NumberExpected);
        }
      }
      const dateArrNum = dateArr;
      if (dateArrNum.length !== valArrNum.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const n = dateArrNum.length;
      let ret = 0;
      if (dateArrNum[0] < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
      }
      for (let i = 0; i < n; i++) {
        dateArrNum[i] = Math.floor(dateArrNum[i]);
        if (dateArrNum[i] < dateArrNum[0]) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
        }
        ret += valArrNum[i] / Math.pow(1 + rate, (dateArrNum[i] - dateArrNum[0]) / 365);
      }
      return ret;
    });
  }
}
FinancialPlugin.implementedFunctions = {
  'PMT': {
    method: 'pmt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'IPMT': {
    method: 'ipmt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'PPMT': {
    method: 'ppmt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'FV': {
    method: 'fv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'CUMIPMT': {
    method: 'cumipmt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 0,
      maxValue: 1
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'CUMPRINC': {
    method: 'cumprinc',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 0,
      maxValue: 1
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'DB': {
    method: 'db',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 1,
      maxValue: 12,
      defaultValue: 12
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'DDB': {
    method: 'ddb',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.INTEGER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      defaultValue: 2
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'DOLLARDE': {
    method: 'dollarde',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'DOLLARFR': {
    method: 'dollarfr',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'EFFECT': {
    method: 'effect',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 1
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_PERCENT
  },
  'ISPMT': {
    method: 'ispmt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }]
  },
  'NOMINAL': {
    method: 'nominal',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 1
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_PERCENT
  },
  'NPER': {
    method: 'nper',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'PV': {
    method: 'pv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'RATE': {
    method: 'rate',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      defaultValue: 0.1
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_PERCENT
  },
  'RRI': {
    method: 'rri',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_PERCENT
  },
  'SLN': {
    method: 'sln',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'SYD': {
    method: 'syd',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'TBILLEQ': {
    method: 'tbilleq',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_PERCENT
  },
  'TBILLPRICE': {
    method: 'tbillprice',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'TBILLYIELD': {
    method: 'tbillyield',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_PERCENT
  },
  'FVSCHEDULE': {
    method: 'fvschedule',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.RANGE
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'NPV': {
    method: 'npv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1,
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_CURRENCY
  },
  'MIRR': {
    method: 'mirr',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }],
    returnNumberType: _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.NumberType.NUMBER_PERCENT
  },
  'PDURATION': {
    method: 'pduration',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'XNPV': {
    method: 'xnpv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      greaterThan: -1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.RANGE
    }]
  }
};
function pmtCore(rate, periods, present, future, type) {
  if (rate === 0) {
    return (-present - future) / periods;
  } else {
    const term = Math.pow(1 + rate, periods);
    return (future * rate + present * rate * term) * (type ? 1 / (1 + rate) : 1) / (1 - term);
  }
}
function ipmtCore(rate, period, periods, present, future, type) {
  const payment = pmtCore(rate, periods, present, future, type);
  if (period === 1) {
    return rate * (type ? 0 : -present);
  } else {
    return rate * (type ? fvCore(rate, period - 2, payment, present, type) - payment : fvCore(rate, period - 1, payment, present, type));
  }
}
function fvCore(rate, periods, payment, value, type) {
  if (rate === 0) {
    return -value - payment * periods;
  } else {
    const term = Math.pow(1 + rate, periods);
    return payment * (type ? 1 + rate : 1) * (1 - term) / rate - value * term;
  }
}
function ppmtCore(rate, period, periods, present, future, type) {
  return pmtCore(rate, periods, present, future, type) - ipmtCore(rate, period, periods, present, future, type);
}
function npvCore(rate, args) {
  let acc = 0;
  for (let i = args.length - 1; i >= 0; i--) {
    acc += args[i];
    if (rate === -1) {
      if (acc === 0) {
        continue;
      } else {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
    }
    acc /= 1 + rate;
  }
  return acc;
}

/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FormulaTextPlugin: () => (/* binding */ FormulaTextPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class FormulaTextPlugin extends _index__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  /**
   * Corresponds to FORMULATEXT(value)
   *
   * Returns a formula in a given cell as a string.
   *
   * @param ast
   * @param state
   */
  formulatext(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('FORMULATEXT'), () => new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.WrongArgNumber), cellReference => {
      var _a;
      return (_a = this.serialization.getCellFormula(cellReference)) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.Formula);
    });
  }
}
FormulaTextPlugin.implementedFunctions = {
  'FORMULATEXT': {
    method: 'formulatext',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NOERROR
    }],
    doesNotNeedArgumentsToBeComputed: true,
    isDependentOnSheetStructureChange: true,
    vectorizationForbidden: true
  }
};

/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HyperlinkPlugin: () => (/* binding */ HyperlinkPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class HyperlinkPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  hyperlink(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HYPERLINK'), (url, linkLabel) => {
      ast.hyperlink = url;
      return linkLabel !== null && linkLabel !== void 0 ? linkLabel : url;
    });
  }
}
HyperlinkPlugin.implementedFunctions = {
  'HYPERLINK': {
    method: 'hyperlink',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.STRING,
      optionalArg: true
    }]
  }
};

/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InformationPlugin: () => (/* binding */ InformationPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(69);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







/**
 * Interpreter plugin containing information functions
 */
class InformationPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionPlugin {
  /**
   * Corresponds to ISBINARY(value)
   *
   * Returns true if provided value is a valid binary number
   *
   * @param ast
   * @param state
   */
  isbinary(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISBINARY'), arg => /^[01]{1,10}$/.test(arg));
  }
  /**
   * Corresponds to ISERR(value)
   *
   * Returns true if provided value is an error except #N/A!
   *
   * @param ast
   * @param state
   */
  iserr(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISERR'), arg => arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError && arg.type !== _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA);
  }
  /**
   * Corresponds to ISERROR(value)
   *
   * Checks whether provided value is an error
   *
   * @param ast
   * @param state
   */
  iserror(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISERROR'), arg => arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError);
  }
  /**
   * Corresponds to ISFORMULA(value)
   *
   * Checks whether referenced cell is a formula
   *
   * @param ast
   * @param state
   */
  isformula(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ISFORMULA'), () => new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongArgNumber), reference => {
      const vertex = this.dependencyGraph.addressMapping.getCell(reference);
      return vertex instanceof _DependencyGraph_FormulaCellVertex__WEBPACK_IMPORTED_MODULE_1__.FormulaVertex;
    });
  }
  /**
   * Corresponds to ISBLANK(value)
   *
   * Checks whether provided cell reference is empty
   *
   * @param ast
   * @param state
   */
  isblank(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISBLANK'), arg => arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.EmptyValue);
  }
  /**
   * Corresponds to ISNA(value)
   *
   * Returns true if provided value is #N/A! error
   *
   * @param ast
   * @param state
   */
  isna(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISNA'), arg => arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError && arg.type == _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA);
  }
  /**
   * Corresponds to ISNUMBER(value)
   *
   * Checks whether provided cell reference is a number
   *
   * @param ast
   * @param state
   */
  isnumber(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISNUMBER'), _InterpreterValue__WEBPACK_IMPORTED_MODULE_4__.isExtendedNumber);
  }
  /**
   * Corresponds to ISLOGICAL(value)
   *
   * Checks whether provided cell reference is of logical type
   *
   * @param ast
   * @param state
   */
  islogical(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISLOGICAL'), arg => typeof arg === 'boolean');
  }
  /**
   * Corresponds to ISREF(value)
   *
   * Returns true if provided value is #REF! error
   *
   * @param ast
   * @param state
   */
  isref(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISREF'), arg => arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError && (arg.type == _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.REF || arg.type == _Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.CYCLE));
  }
  /**
   * Corresponds to ISTEXT(value)
   *
   * Checks whether provided cell reference is of logical type
   *
   * @param ast
   * @param state
   */
  istext(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISTEXT'), arg => typeof arg === 'string');
  }
  /**
   * Corresponds to ISNONTEXT(value)
   *
   * Checks whether provided cell reference is of logical type
   *
   * @param ast
   * @param state
   */
  isnontext(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISNONTEXT'), arg => !(typeof arg === 'string'));
  }
  /**
   * Corresponds to COLUMN(reference)
   *
   * Returns column number of a reference or a formula cell if reference not provided
   *
   * @param ast
   * @param state
   */
  column(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('COLUMN'), () => state.formulaAddress.col + 1, reference => reference.col + 1);
  }
  /**
   * Corresponds to COLUMNS(range)
   *
   * Returns number of columns in provided range of cells
   *
   * @param ast
   * @param state
   */
  columns(ast, state) {
    if (ast.args.length !== 1) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongArgNumber);
    }
    if (ast.args.some(astIt => astIt.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.EMPTY)) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.EmptyArg);
    }
    let argAst = ast.args[0];
    while (argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PARENTHESIS) {
      argAst = argAst.expression;
    }
    if (argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_RANGE || argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.COLUMN_RANGE) {
      return argAst.end.col - argAst.start.col + 1;
    } else if (argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_REFERENCE) {
      return 1;
    } else if (argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ROW_RANGE) {
      return this.config.maxColumns;
    } else {
      const val = this.evaluateAst(argAst, state);
      if (val instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__.SimpleRangeValue) {
        return val.width();
      } else if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return val;
      } else {
        return 1;
      }
    }
  }
  /**
   * Corresponds to ROW(reference)
   *
   * Returns row number of a reference or a formula cell if reference not provided
   *
   * @param ast
   * @param state
   */
  row(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('ROW'), () => state.formulaAddress.row + 1, reference => reference.row + 1);
  }
  /**
   * Corresponds to ROWS(range)
   *
   * Returns number of rows in provided range of cells
   *
   * @param ast
   * @param state
   */
  rows(ast, state) {
    if (ast.args.length !== 1) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongArgNumber);
    }
    if (ast.args.some(astIt => astIt.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.EMPTY)) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.EmptyArg);
    }
    let argAst = ast.args[0];
    while (argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.PARENTHESIS) {
      argAst = argAst.expression;
    }
    if (argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_RANGE || argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.ROW_RANGE) {
      return argAst.end.row - argAst.start.row + 1;
    } else if (argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.CELL_REFERENCE) {
      return 1;
    } else if (argAst.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.COLUMN_RANGE) {
      return this.config.maxRows;
    } else {
      const val = this.evaluateAst(argAst, state);
      if (val instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__.SimpleRangeValue) {
        return val.height();
      } else if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return val;
      } else {
        return 1;
      }
    }
  }
  /**
   * Corresponds to INDEX
   *
   * Returns specific position in 2d array.
   *
   * @param ast
   * @param state
   */
  index(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('INDEX'), (rangeValue, row, col) => {
      var _a, _b, _c, _d, _e, _f;
      if (col < 1 || row < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.LessThanOne);
      }
      if (col > rangeValue.width() || row > rangeValue.height()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueLarge);
      }
      return (_f = (_c = (_b = (_a = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _a === void 0 ? void 0 : _a[row - 1]) === null || _b === void 0 ? void 0 : _b[col - 1]) !== null && _c !== void 0 ? _c : (_e = (_d = rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.data) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e[0]) !== null && _f !== void 0 ? _f : new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.CellRangeExpected);
    });
  }
  /**
   * Corresponds to NA()
   *
   * Returns #N/A!
   *
   * @param _ast
   * @param _state
   */
  na(_ast, _state) {
    return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA);
  }
  /**
   * Corresponds to SHEET(value)
   *
   * Returns sheet number of a given value or a formula sheet number if no argument is provided
   *
   * @param ast
   * @param state
   */
  sheet(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEET'), () => state.formulaAddress.sheet + 1, reference => reference.sheet + 1, value => {
      const sheetNumber = this.dependencyGraph.sheetMapping.get(value);
      if (sheetNumber !== undefined) {
        return sheetNumber + 1;
      } else {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.SheetRef);
      }
    });
  }
  /**
   * Corresponds to SHEETS(value)
   *
   * Returns number of sheet of a given reference or number of all sheets in workbook when no argument is provided.
   * It returns always 1 for a valid reference as 3D references are not supported.
   *
   * @param ast
   * @param state
   */
  sheets(ast, state) {
    return this.runFunctionWithReferenceArgument(ast.args, state, this.metadata('SHEETS'), () => this.dependencyGraph.sheetMapping.numberOfSheets(),
    // return number of sheets if no argument
    () => 1,
    // return 1 for valid reference
    () => new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.CellRefExpected) // error otherwise
    );
  }
}
InformationPlugin.implementedFunctions = {
  'COLUMN': {
    method: 'column',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NOERROR,
      optionalArg: true
    }],
    isDependentOnSheetStructureChange: true,
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'COLUMNS': {
    method: 'columns',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.RANGE
    }],
    isDependentOnSheetStructureChange: true,
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'ISBINARY': {
    method: 'isbinary',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.STRING
    }]
  },
  'ISERR': {
    method: 'iserr',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }]
  },
  'ISFORMULA': {
    method: 'isformula',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NOERROR
    }],
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'ISNA': {
    method: 'isna',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }]
  },
  'ISREF': {
    method: 'isref',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }],
    vectorizationForbidden: true
  },
  'ISERROR': {
    method: 'iserror',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }]
  },
  'ISBLANK': {
    method: 'isblank',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }]
  },
  'ISNUMBER': {
    method: 'isnumber',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }]
  },
  'ISLOGICAL': {
    method: 'islogical',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }]
  },
  'ISTEXT': {
    method: 'istext',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }]
  },
  'ISNONTEXT': {
    method: 'isnontext',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.SCALAR
    }]
  },
  'INDEX': {
    method: 'index',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'NA': {
    method: 'na',
    parameters: []
  },
  'ROW': {
    method: 'row',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NOERROR,
      optionalArg: true
    }],
    isDependentOnSheetStructureChange: true,
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'ROWS': {
    method: 'rows',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.RANGE
    }],
    isDependentOnSheetStructureChange: true,
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'SHEET': {
    method: 'sheet',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.STRING
    }],
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  },
  'SHEETS': {
    method: 'sheets',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.STRING
    }],
    doesNotNeedArgumentsToBeComputed: true,
    vectorizationForbidden: true
  }
};

/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IsEvenPlugin: () => (/* binding */ IsEvenPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class IsEvenPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  iseven(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISEVEN'), val => val % 2 === 0);
  }
}
IsEvenPlugin.implementedFunctions = {
  'ISEVEN': {
    method: 'iseven',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IsOddPlugin: () => (/* binding */ IsOddPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class IsOddPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  isodd(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ISODD'), val => val % 2 === 1);
  }
}
IsOddPlugin.implementedFunctions = {
  'ISODD': {
    method: 'isodd',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LogarithmPlugin: () => (/* binding */ LogarithmPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class LogarithmPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  log10(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOG10'), Math.log10);
  }
  log(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOG'), (arg, base) => Math.log(arg) / Math.log(base));
  }
  ln(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LN'), Math.log);
  }
}
LogarithmPlugin.implementedFunctions = {
  'LOG10': {
    method: 'log10',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  },
  'LOG': {
    method: 'log',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      defaultValue: 10,
      greaterThan: 0
    }]
  },
  'LN': {
    method: 'ln',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MathConstantsPlugin: () => (/* binding */ MathConstantsPlugin),
/* harmony export */   PI: () => (/* binding */ PI)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

const PI = parseFloat(Math.PI.toFixed(14));
class MathConstantsPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  pi(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PI'), () => PI);
  }
  sqrtpi(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SQRTPI'), arg => Math.sqrt(PI * arg));
  }
}
MathConstantsPlugin.implementedFunctions = {
  'PI': {
    method: 'pi',
    parameters: []
  },
  'SQRTPI': {
    method: 'sqrtpi',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  }
};

/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MatrixPlugin: () => (/* binding */ MatrixPlugin)
/* harmony export */ });
/* harmony import */ var _ArraySize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _InterpreterState__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(69);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */







function arraySizeForMultiplication(leftArraySize, rightArraySize) {
  return new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize(rightArraySize.width, leftArraySize.height);
}
function arraySizeForPoolFunction(inputArray, windowSize, stride) {
  return new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize(1 + (inputArray.width - windowSize) / stride, 1 + (inputArray.height - windowSize) / stride);
}
class MatrixPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionPlugin {
  mmult(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MMULT'), (leftMatrix, rightMatrix) => {
      if (!leftMatrix.hasOnlyNumbers() || !rightMatrix.hasOnlyNumbers()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.NumberRange);
      }
      if (rightMatrix.height() !== leftMatrix.width()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ArrayDimensions);
      }
      const outputSize = arraySizeForMultiplication(leftMatrix.size, rightMatrix.size);
      const result = this.createKernel(function (a, b, width) {
        let sum = 0;
        for (let i = 0; i < width; ++i) {
          sum += a[this.thread.y][i] * b[i][this.thread.x];
        }
        return sum;
      }, outputSize)(leftMatrix.rawNumbers(), rightMatrix.rawNumbers(), leftMatrix.width());
      return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__.SimpleRangeValue.onlyNumbers(result);
    });
  }
  mmultArraySize(ast, state) {
    if (ast.args.length !== 2) {
      return _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize.error();
    }
    const metadata = this.metadata('MMULT');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new _InterpreterState__WEBPACK_IMPORTED_MODULE_4__.InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const [left, right] = subChecks;
    return arraySizeForMultiplication(left, right);
  }
  maxpool(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MAXPOOL'), (matrix, windowSize, stride = windowSize) => {
      if (!matrix.hasOnlyNumbers()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.NumberRange);
      }
      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);
      const result = this.createKernel(function (a, windowSize, stride) {
        const leftCornerX = this.thread.x * stride;
        const leftCornerY = this.thread.y * stride;
        let currentMax = a[leftCornerY][leftCornerX];
        for (let i = 0; i < windowSize; i++) {
          for (let j = 0; j < windowSize; j++) {
            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);
          }
        }
        return currentMax;
      }, outputSize)(matrix.rawNumbers(), windowSize, stride);
      return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__.SimpleRangeValue.onlyNumbers(result);
    });
  }
  medianpool(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MEDIANPOOL'), (matrix, windowSize, stride = windowSize) => {
      if (!matrix.hasOnlyNumbers()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.NumberRange);
      }
      const outputSize = arraySizeForPoolFunction(matrix.size, windowSize, stride);
      const result = this.createKernel(function (a, windowSize, stride) {
        const leftCornerX = this.thread.x * stride;
        const leftCornerY = this.thread.y * stride;
        let currentMax = a[leftCornerY][leftCornerX];
        for (let i = 0; i < windowSize; i++) {
          for (let j = 0; j < windowSize; j++) {
            currentMax = Math.max(currentMax, a[leftCornerY + i][leftCornerX + j]);
          }
        }
        let currentMin = a[leftCornerY][leftCornerX];
        for (let i2 = 0; i2 < windowSize; i2++) {
          for (let j2 = 0; j2 < windowSize; j2++) {
            currentMin = Math.min(currentMin, a[leftCornerY + i2][leftCornerX + j2]);
          }
        }
        const numberOfElements = windowSize * windowSize;
        let leftEnd = currentMin;
        let rightEnd = currentMax;
        let result = 42;
        for (let iter = 0; iter < 32; iter++) {
          const medianGuess = (leftEnd + rightEnd) / 2;
          let medianGuessCount = 0;
          for (let i3 = 0; i3 < windowSize; i3++) {
            for (let j3 = 0; j3 < windowSize; j3++) {
              if (a[leftCornerY + i3][leftCornerX + j3] > medianGuess) {
                medianGuessCount++;
              }
            }
          }
          if (windowSize % 2 === 0) {
            if (medianGuessCount === numberOfElements / 2) {
              result = medianGuess;
              break;
            } else if (medianGuessCount > numberOfElements / 2) {
              leftEnd = medianGuess;
            } else {
              rightEnd = medianGuess;
            }
          } else {
            if (medianGuessCount === (numberOfElements - 1) / 2) {
              result = medianGuess;
              break;
            } else if (medianGuessCount > (numberOfElements - 1) / 2) {
              leftEnd = medianGuess;
            } else {
              rightEnd = medianGuess;
            }
          }
        }
        return result;
      }, outputSize)(matrix.rawNumbers(), windowSize, stride);
      return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__.SimpleRangeValue.onlyNumbers(result);
    });
  }
  maxpoolArraySize(ast, state) {
    if (ast.args.length < 2 || ast.args.length > 3) {
      return _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize.error();
    }
    const metadata = this.metadata('MAXPOOL');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new _InterpreterState__WEBPACK_IMPORTED_MODULE_4__.InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const array = subChecks[0];
    const windowArg = ast.args[1];
    let window;
    if (windowArg.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.NUMBER) {
      window = windowArg.value;
    } else {
      window = 1;
    }
    let stride = window;
    if (ast.args.length === 3) {
      const strideArg = ast.args[2];
      if (strideArg.type === _parser__WEBPACK_IMPORTED_MODULE_3__.AstNodeType.NUMBER) {
        stride = strideArg.value;
      } else {
        stride = 1; // codecov: unreachable - strideArg is always type AstNodeType.NUMBER due to FunctionPlugin argument checking+coersion
      }
    }
    if (window > array.width || window > array.height || stride > window || (array.width - window) % stride !== 0 || (array.height - window) % stride !== 0) {
      return _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize.error();
    }
    return arraySizeForPoolFunction(array, window, stride);
  }
  medianpoolArraySize(ast, state) {
    return this.maxpoolArraySize(ast, state);
  }
  transpose(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TRANSPOSE'), matrix => {
      const input = matrix.rawData();
      const inputSize = matrix.size;
      const result = [];
      for (let i = 0; i < inputSize.width; ++i) {
        result[i] = [];
        for (let j = 0; j < inputSize.height; ++j) {
          result[i][j] = input[j][i];
        }
      }
      return _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_5__.SimpleRangeValue.onlyValues(result);
    });
  }
  transposeArraySize(ast, state) {
    if (ast.args.length !== 1) {
      return _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize.error();
    }
    const metadata = this.metadata('TRANSPOSE');
    const subChecks = ast.args.map(arg => {
      var _a;
      return this.arraySizeForAst(arg, new _InterpreterState__WEBPACK_IMPORTED_MODULE_4__.InterpreterState(state.formulaAddress, state.arraysFlag || ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.arrayFunction) !== null && _a !== void 0 ? _a : false)));
    });
    const [size] = subChecks;
    return new _ArraySize__WEBPACK_IMPORTED_MODULE_0__.ArraySize(size.height, size.width);
  }
  createKernel(kernel, outputSize) {
    return function (...args) {
      const result = [];
      for (let y = 0; y < outputSize.height; ++y) {
        result.push([]);
        for (let x = 0; x < outputSize.width; ++x) {
          result[y][x] = kernel.apply({
            thread: {
              x,
              y
            }
          }, args);
        }
      }
      return result;
    };
  }
}
MatrixPlugin.implementedFunctions = {
  'MMULT': {
    method: 'mmult',
    arraySizeMethod: 'mmultArraySize',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.RANGE
    }],
    vectorizationForbidden: true
  },
  'TRANSPOSE': {
    method: 'transpose',
    arraySizeMethod: 'transposeArraySize',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.RANGE
    }],
    vectorizationForbidden: true
  },
  'MAXPOOL': {
    method: 'maxpool',
    arraySizeMethod: 'maxpoolArraySize',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NUMBER,
      optionalArg: true
    }],
    vectorizationForbidden: true
  },
  'MEDIANPOOL': {
    method: 'medianpool',
    arraySizeMethod: 'medianpoolArraySize',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_6__.FunctionArgumentType.NUMBER,
      optionalArg: true
    }],
    vectorizationForbidden: true
  }
};

/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MedianPlugin: () => (/* binding */ MedianPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



/**
 * Interpreter plugin containing MEDIAN function
 */
class MedianPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  /**
   * Corresponds to MEDIAN(Number1, Number2, ...).
   *
   * Returns a median of given numbers.
   *
   * @param ast
   * @param state
   */
  median(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MEDIAN'), (...args) => {
      const values = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (values instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return values;
      }
      if (values.length === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.OneValue);
      }
      values.sort((a, b) => a - b);
      if (values.length % 2 === 0) {
        return (values[values.length / 2 - 1] + values[values.length / 2]) / 2;
      } else {
        return values[Math.floor(values.length / 2)];
      }
    });
  }
  large(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LARGE'), (range, n) => {
      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());
      if (vals instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return vals;
      }
      vals.sort((a, b) => a - b);
      n = Math.trunc(n);
      if (n > vals.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      return vals[vals.length - n];
    });
  }
  small(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SMALL'), (range, n) => {
      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());
      if (vals instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return vals;
      }
      vals.sort((a, b) => a - b);
      n = Math.trunc(n);
      if (n > vals.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      return vals[n - 1];
    });
  }
}
MedianPlugin.implementedFunctions = {
  'MEDIAN': {
    method: 'median',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'LARGE': {
    method: 'large',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'SMALL': {
    method: 'small',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  }
};

/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModuloPlugin: () => (/* binding */ ModuloPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */


class ModuloPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionPlugin {
  mod(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MOD'), (dividend, divisor) => {
      if (divisor === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      } else {
        return dividend % divisor;
      }
    });
  }
}
ModuloPlugin.implementedFunctions = {
  'MOD': {
    method: 'mod',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_1__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 173 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NumericAggregationPlugin: () => (/* binding */ NumericAggregationPlugin)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(77);
/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var _ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(70);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(69);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */









function zeroForInfinite(value) {
  if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.isExtendedNumber)(value) && !Number.isFinite((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue)(value))) {
    return 0;
  } else {
    return value;
  }
}
class MomentsAggregate {
  constructor(sumsq, sum, count) {
    this.sumsq = sumsq;
    this.sum = sum;
    this.count = count;
  }
  static single(arg) {
    return new MomentsAggregate(arg * arg, arg, 1);
  }
  compose(other) {
    return new MomentsAggregate(this.sumsq + other.sumsq, this.sum + other.sum, this.count + other.count);
  }
  averageValue() {
    if (this.count > 0) {
      return this.sum / this.count;
    } else {
      return undefined;
    }
  }
  varSValue() {
    if (this.count > 1) {
      return (this.sumsq - this.sum * this.sum / this.count) / (this.count - 1);
    } else {
      return undefined;
    }
  }
  varPValue() {
    if (this.count > 0) {
      return (this.sumsq - this.sum * this.sum / this.count) / this.count;
    } else {
      return undefined;
    }
  }
}
MomentsAggregate.empty = new MomentsAggregate(0, 0, 0);
class NumericAggregationPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionPlugin {
  constructor() {
    super(...arguments);
    this.addWithEpsilonRaw = (left, right) => this.arithmeticHelper.addWithEpsilonRaw(left, right);
  }
  /**
   * Corresponds to SUM(Number1, Number2, ...).
   *
   * Returns a sum of given numbers.
   *
   * @param ast
   * @param state
   */
  sum(ast, state) {
    return this.doSum(ast.args, state);
  }
  sumsq(ast, state) {
    return this.reduce(ast.args, state, 0, 'SUMSQ', this.addWithEpsilonRaw, arg => Math.pow((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue)(arg), 2), strictlyNumbers);
  }
  /**
   * Corresponds to MAX(Number1, Number2, ...).
   *
   * Returns a max of given numbers.
   *
   * @param ast
   * @param state
   */
  max(ast, state) {
    return this.doMax(ast.args, state);
  }
  maxa(ast, state) {
    const value = this.reduce(ast.args, state, Number.NEGATIVE_INFINITY, 'MAXA', (left, right) => Math.max(left, right), _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue, numbersBooleans);
    return zeroForInfinite(value);
  }
  /**
   * Corresponds to MIN(Number1, Number2, ...).
   *
   * Returns a min of given numbers.
   *
   * @param ast
   * @param state
   */
  min(ast, state) {
    return this.doMin(ast.args, state);
  }
  mina(ast, state) {
    const value = this.reduce(ast.args, state, Number.POSITIVE_INFINITY, 'MINA', (left, right) => Math.min(left, right), _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue, numbersBooleans);
    return zeroForInfinite(value);
  }
  count(ast, state) {
    return this.doCount(ast.args, state);
  }
  counta(ast, state) {
    return this.doCounta(ast.args, state);
  }
  average(ast, state) {
    return this.doAverage(ast.args, state);
  }
  averagea(ast, state) {
    var _a;
    const result = this.reduce(ast.args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => left.compose(right), arg => MomentsAggregate.single((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue)(arg)), numbersBooleans);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO);
    }
  }
  vars(ast, state) {
    return this.doVarS(ast.args, state);
  }
  varp(ast, state) {
    return this.doVarP(ast.args, state);
  }
  vara(ast, state) {
    var _a;
    const result = this.reduceAggregateA(ast.args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO);
    }
  }
  varpa(ast, state) {
    var _a;
    const result = this.reduceAggregateA(ast.args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO);
    }
  }
  stdevs(ast, state) {
    return this.doStdevS(ast.args, state);
  }
  stdevp(ast, state) {
    return this.doStdevP(ast.args, state);
  }
  stdeva(ast, state) {
    const result = this.reduceAggregateA(ast.args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      const val = result.varSValue();
      return val === undefined ? new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
    }
  }
  stdevpa(ast, state) {
    const result = this.reduceAggregateA(ast.args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      const val = result.varPValue();
      return val === undefined ? new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
    }
  }
  product(ast, state) {
    return this.doProduct(ast.args, state);
  }
  subtotal(ast, state) {
    if (ast.args.length < 2) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongArgNumber);
    }
    const functionType = this.coerceToType(this.evaluateAst(ast.args[0], state), {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.NUMBER
    }, state);
    const args = ast.args.slice(1);
    switch (functionType) {
      case 1:
      case 101:
        return this.doAverage(args, state);
      case 2:
      case 102:
        return this.doCount(args, state);
      case 3:
      case 103:
        return this.doCounta(args, state);
      case 4:
      case 104:
        return this.doMax(args, state);
      case 5:
      case 105:
        return this.doMin(args, state);
      case 6:
      case 106:
        return this.doProduct(args, state);
      case 7:
      case 107:
        return this.doStdevS(args, state);
      case 8:
      case 108:
        return this.doStdevP(args, state);
      case 9:
      case 109:
        return this.doSum(args, state);
      case 10:
      case 110:
        return this.doVarS(args, state);
      case 11:
      case 111:
        return this.doVarP(args, state);
      default:
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.BadMode);
    }
  }
  reduceAggregate(args, state) {
    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE', (left, right) => {
      return left.compose(right);
    }, arg => {
      return MomentsAggregate.single((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue)(arg));
    }, strictlyNumbers);
  }
  reduceAggregateA(args, state) {
    return this.reduce(args, state, MomentsAggregate.empty, '_AGGREGATE_A', (left, right) => {
      return left.compose(right);
    }, arg => {
      return MomentsAggregate.single((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue)(arg));
    }, numbersBooleans);
  }
  doAverage(args, state) {
    var _a;
    const result = this.reduceAggregate(args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      return (_a = result.averageValue()) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO);
    }
  }
  doVarS(args, state) {
    var _a;
    const result = this.reduceAggregate(args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      return (_a = result.varSValue()) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO);
    }
  }
  doVarP(args, state) {
    var _a;
    const result = this.reduceAggregate(args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      return (_a = result.varPValue()) !== null && _a !== void 0 ? _a : new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO);
    }
  }
  doStdevS(args, state) {
    const result = this.reduceAggregate(args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      const val = result.varSValue();
      return val === undefined ? new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
    }
  }
  doStdevP(args, state) {
    const result = this.reduceAggregate(args, state);
    if (result instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
      return result;
    } else {
      const val = result.varPValue();
      return val === undefined ? new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.DIV_BY_ZERO) : Math.sqrt(val);
    }
  }
  doCount(args, state) {
    return this.reduce(args, state, 0, 'COUNT', (left, right) => left + right, _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue, arg => (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.isExtendedNumber)(arg) ? 1 : 0);
  }
  doCounta(args, state) {
    return this.reduce(args, state, 0, 'COUNTA', (left, right) => left + right, _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue, arg => arg === _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.EmptyValue ? 0 : 1);
  }
  doMax(args, state) {
    const value = this.reduce(args, state, Number.NEGATIVE_INFINITY, 'MAX', (left, right) => Math.max(left, right), _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue, strictlyNumbers);
    return zeroForInfinite(value);
  }
  doMin(args, state) {
    const value = this.reduce(args, state, Number.POSITIVE_INFINITY, 'MIN', (left, right) => Math.min(left, right), _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue, strictlyNumbers);
    return zeroForInfinite(value);
  }
  doSum(args, state) {
    return this.reduce(args, state, 0, 'SUM', this.addWithEpsilonRaw, _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue, strictlyNumbers);
  }
  doProduct(args, state) {
    return this.reduce(args, state, 1, 'PRODUCT', (left, right) => left * right, _InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.getRawValue, strictlyNumbers);
  }
  /**
   * Reduces procedure arguments with given reducing function
   *
   * @param args
   * @param state
   * @param initialAccValue - "neutral" value (equivalent of 0)
   * @param functionName - function name to use as cache key
   * @param reducingFunction - reducing function
   * @param mapFunction
   * @param coercionFunction
   */
  reduce(args, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {
    if (args.length < 1) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongArgNumber);
    }
    return args.reduce((acc, arg) => {
      if (acc instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
        return acc;
      }
      if (arg.type === _parser__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CELL_RANGE || arg.type === _parser__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.COLUMN_RANGE || arg.type === _parser__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.ROW_RANGE) {
        const val = this.evaluateRange(arg, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction);
        if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
          return val;
        }
        return reducingFunction(val, acc);
      }
      let value;
      value = this.evaluateAst(arg, state);
      if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_7__.SimpleRangeValue) {
        const coercedRangeValues = Array.from(value.valuesFromTopLeftCorner()).map(coercionFunction).filter(arg => arg !== undefined);
        return coercedRangeValues.map(arg => {
          if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
            return arg;
          } else {
            return mapFunction(arg);
          }
        }).reduce((left, right) => {
          if (left instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
            return left;
          } else if (right instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
            return right;
          } else {
            return reducingFunction(left, right);
          }
        }, acc);
      } else if (arg.type === _parser__WEBPACK_IMPORTED_MODULE_4__.AstNodeType.CELL_REFERENCE) {
        value = coercionFunction(value);
        if (value === undefined) {
          return acc;
        }
      } else {
        value = this.coerceScalarToNumberOrError(value);
        value = coercionFunction(value);
        if (value === undefined) {
          return acc;
        }
      }
      if (value instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
        return value;
      }
      return reducingFunction(acc, mapFunction(value));
    }, initialAccValue);
  }
  /**
   * Performs range operation on given range
   *
   * @param ast - cell range ast
   * @param state
   * @param initialAccValue - initial accumulator value for reducing function
   * @param functionName - function name to use as cache key
   * @param reducingFunction - reducing function
   * @param mapFunction
   * @param coercionFunction
   */
  evaluateRange(ast, state, initialAccValue, functionName, reducingFunction, mapFunction, coercionFunction) {
    let range;
    try {
      range = _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.fromAst(ast, state.formulaAddress);
    } catch (err) {
      if (err instanceof _errors__WEBPACK_IMPORTED_MODULE_3__.SheetsNotEqual) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.RangeManySheets);
      } else {
        throw err;
      }
    }
    const rangeVertex = this.dependencyGraph.getRange(range.start, range.end);
    if (rangeVertex === undefined) {
      throw new Error('Range does not exists in graph');
    }
    let value = rangeVertex.getFunctionValue(functionName);
    if (value === undefined) {
      const rangeValues = this.getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction);
      value = rangeValues.reduce((arg1, arg2) => {
        if (arg1 instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
          return arg1;
        } else if (arg2 instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
          return arg2;
        } else {
          return reducingFunction(arg1, arg2);
        }
      }, initialAccValue);
      rangeVertex.setFunctionValue(functionName, value);
    }
    return value;
  }
  /**
   * Returns list of values for given range and function name
   *
   * If range is dependent on smaller range, list will contain value of smaller range for this function
   * and values of cells that are not present in smaller range
   *
   * @param functionName - function name (e.g., SUM)
   * @param range - cell range
   * @param rangeVertex
   * @param mapFunction
   * @param coercionFunction
   */
  getRangeValues(functionName, range, rangeVertex, mapFunction, coercionFunction) {
    const rangeResult = [];
    const {
      smallerRangeVertex,
      restRange
    } = this.dependencyGraph.rangeMapping.findSmallerRange(range);
    let actualRange;
    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, rangeVertex)) {
      const cachedValue = smallerRangeVertex.getFunctionValue(functionName);
      if (cachedValue !== undefined) {
        rangeResult.push(cachedValue);
      } else {
        for (const cellFromRange of smallerRangeVertex.range.addresses(this.dependencyGraph)) {
          const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));
          if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
            rangeResult.push(val);
          } else if (val !== undefined) {
            rangeResult.push(mapFunction(val));
          }
        }
      }
      actualRange = restRange;
    } else {
      actualRange = range;
    }
    for (const cellFromRange of actualRange.addresses(this.dependencyGraph)) {
      const val = coercionFunction(this.dependencyGraph.getScalarValue(cellFromRange));
      if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
        rangeResult.push(val);
      } else if (val !== undefined) {
        rangeResult.push(mapFunction(val));
      }
    }
    return rangeResult;
  }
}
NumericAggregationPlugin.implementedFunctions = {
  'SUM': {
    method: 'sum',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'SUMSQ': {
    method: 'sumsq',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MAX': {
    method: 'max',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MIN': {
    method: 'min',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MAXA': {
    method: 'maxa',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MINA': {
    method: 'mina',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'COUNT': {
    method: 'count',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'COUNTA': {
    method: 'counta',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'AVERAGE': {
    method: 'average',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'AVERAGEA': {
    method: 'averagea',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'PRODUCT': {
    method: 'product',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'VAR.S': {
    method: 'vars',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'VAR.P': {
    method: 'varp',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'VARA': {
    method: 'vara',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'VARPA': {
    method: 'varpa',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'STDEV.S': {
    method: 'stdevs',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'STDEV.P': {
    method: 'stdevp',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'STDEVA': {
    method: 'stdeva',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'STDEVPA': {
    method: 'stdevpa',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'SUBTOTAL': {
    method: 'subtotal',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_8__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  }
};
NumericAggregationPlugin.aliases = {
  VAR: 'VAR.S',
  VARP: 'VAR.P',
  STDEV: 'STDEV.S',
  STDEVP: 'STDEV.P',
  VARS: 'VAR.S',
  STDEVS: 'STDEV.S'
};
function strictlyNumbers(arg) {
  if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.isExtendedNumber)(arg) || arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
    return arg;
  } else {
    return undefined;
  }
}
function numbersBooleans(arg) {
  if (typeof arg === 'boolean') {
    return (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanToNumber)(arg);
  } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_6__.isExtendedNumber)(arg) || arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError) {
    return arg;
  } else if (typeof arg === 'string') {
    return 0;
  } else {
    return undefined;
  }
}

/***/ }),
/* 174 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PowerPlugin: () => (/* binding */ PowerPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class PowerPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  power(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('POWER'), Math.pow);
  }
}
PowerPlugin.implementedFunctions = {
  'POWER': {
    method: 'power',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadiansPlugin: () => (/* binding */ RadiansPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class RadiansPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  radians(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RADIANS'), arg => arg * (Math.PI / 180));
  }
}
RadiansPlugin.implementedFunctions = {
  'RADIANS': {
    method: 'radians',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadixConversionPlugin: () => (/* binding */ RadixConversionPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _format_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(106);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




const MAX_LENGTH = 10;
const DECIMAL_NUMBER_OF_BITS = 255;
const MIN_BASE = 2;
const MAX_BASE = 36;
const ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
class RadixConversionPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionPlugin {
  dec2bin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEC2BIN'), (value, places) => decimalToBaseWithExactPadding(value, 2, places));
  }
  dec2oct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEC2OCT'), (value, places) => decimalToBaseWithExactPadding(value, 8, places));
  }
  dec2hex(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEC2HEX'), (value, places) => decimalToBaseWithExactPadding(value, 16, places));
  }
  bin2dec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BIN2DEC'), binary => {
      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);
      if (binaryWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotBinary);
      }
      return twoComplementToDecimal(binaryWithSign, 2);
    });
  }
  bin2oct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BIN2OCT'), (binary, places) => {
      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);
      if (binaryWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotBinary);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(binaryWithSign, 2), 8, places);
    });
  }
  bin2hex(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BIN2HEX'), (binary, places) => {
      const binaryWithSign = coerceStringToBase(binary, 2, MAX_LENGTH);
      if (binaryWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotBinary);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(binaryWithSign, 2), 16, places);
    });
  }
  oct2dec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('OCT2DEC'), octal => {
      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);
      if (octalWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotOctal);
      }
      return twoComplementToDecimal(octalWithSign, 8);
    });
  }
  oct2bin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('OCT2BIN'), (octal, places) => {
      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);
      if (octalWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotOctal);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(octalWithSign, 8), 2, places);
    });
  }
  oct2hex(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('OCT2HEX'), (octal, places) => {
      const octalWithSign = coerceStringToBase(octal, 8, MAX_LENGTH);
      if (octalWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotOctal);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(octalWithSign, 8), 16, places);
    });
  }
  hex2dec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HEX2DEC'), hexadecimal => {
      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);
      if (hexadecimalWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotHex);
      }
      return twoComplementToDecimal(hexadecimalWithSign, 16);
    });
  }
  hex2bin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HEX2BIN'), (hexadecimal, places) => {
      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);
      if (hexadecimalWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotHex);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(hexadecimalWithSign, 16), 2, places);
    });
  }
  hex2oct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HEX2OCT'), (hexadecimal, places) => {
      const hexadecimalWithSign = coerceStringToBase(hexadecimal, 16, MAX_LENGTH);
      if (hexadecimalWithSign === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotHex);
      }
      return decimalToBaseWithExactPadding(twoComplementToDecimal(hexadecimalWithSign, 16), 8, places);
    });
  }
  base(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BASE'), decimalToBaseWithMinimumPadding);
  }
  decimal(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DECIMAL'), (arg, base) => {
      const input = coerceStringToBase(arg, base, DECIMAL_NUMBER_OF_BITS);
      if (input === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NotHex);
      }
      return parseInt(input, base);
    });
  }
}
RadixConversionPlugin.implementedFunctions = {
  'DEC2BIN': {
    method: 'dec2bin',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'DEC2OCT': {
    method: 'dec2oct',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'DEC2HEX': {
    method: 'dec2hex',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 1,
      maxValue: 10
    }]
  },
  'BIN2DEC': {
    method: 'bin2dec',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }]
  },
  'BIN2OCT': {
    method: 'bin2oct',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'BIN2HEX': {
    method: 'bin2hex',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'OCT2DEC': {
    method: 'oct2dec',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }]
  },
  'OCT2BIN': {
    method: 'oct2bin',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'OCT2HEX': {
    method: 'oct2hex',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'HEX2DEC': {
    method: 'hex2dec',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }]
  },
  'HEX2BIN': {
    method: 'hex2bin',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'HEX2OCT': {
    method: 'hex2oct',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: MAX_LENGTH
    }]
  },
  'DECIMAL': {
    method: 'decimal',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: MIN_BASE,
      maxValue: MAX_BASE
    }]
  },
  'BASE': {
    method: 'base',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: MIN_BASE,
      maxValue: MAX_BASE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      optionalArg: true,
      minValue: 0,
      maxValue: DECIMAL_NUMBER_OF_BITS
    }]
  }
};
function coerceStringToBase(value, base, maxLength) {
  const baseAlphabet = ALPHABET.substr(0, base);
  const regex = new RegExp(`^[${baseAlphabet}]+$`);
  if (value.length > maxLength || !regex.test(value)) {
    return undefined;
  }
  return value;
}
function decimalToBaseWithExactPadding(value, base, places) {
  if (value > maxValFromBase(base)) {
    return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueBaseLarge);
  }
  if (value < minValFromBase(base)) {
    return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueBaseSmall);
  }
  const result = decimalToRadixComplement(value, base);
  if (places === undefined || value < 0) {
    return result;
  } else if (result.length > places) {
    return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueBaseLong);
  } else {
    return (0,_format_format__WEBPACK_IMPORTED_MODULE_2__.padLeft)(result, places);
  }
}
function minValFromBase(base) {
  return -Math.pow(base, MAX_LENGTH) / 2;
}
function maxValFromBase(base) {
  return -minValFromBase(base) - 1;
}
function decimalToBaseWithMinimumPadding(value, base, places) {
  const result = decimalToRadixComplement(value, base);
  if (places !== undefined && places > result.length) {
    return (0,_format_format__WEBPACK_IMPORTED_MODULE_2__.padLeft)(result, places);
  } else {
    return result;
  }
}
function decimalToRadixComplement(value, base) {
  const offset = value < 0 ? Math.pow(base, MAX_LENGTH) : 0;
  return (value + offset).toString(base).toUpperCase();
}
function twoComplementToDecimal(value, base) {
  const parsed = parseInt(value, base);
  const offset = Math.pow(base, MAX_LENGTH);
  return parsed >= offset / 2 ? parsed - offset : parsed;
}

/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RandomPlugin: () => (/* binding */ RandomPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class RandomPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  /**
   * Corresponds to RAND()
   *
   * Returns a pseudo-random floating-point random number
   * in the range [0,1).
   *
   * @param ast
   * @param state
   */
  rand(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RAND'), Math.random);
  }
  randbetween(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RANDBETWEEN'), (lower, upper) => {
      if (upper < lower) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.WrongOrder);
      }
      lower = Math.ceil(lower);
      upper = Math.floor(upper) + 1;
      if (lower === upper) {
        upper += 1;
      }
      return lower + Math.floor(Math.random() * (upper - lower));
    });
  }
}
RandomPlugin.implementedFunctions = {
  'RAND': {
    method: 'rand',
    parameters: [],
    isVolatile: true
  },
  'RANDBETWEEN': {
    method: 'randbetween',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }],
    isVolatile: true
  }
};

/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RoundingPlugin: () => (/* binding */ RoundingPlugin),
/* harmony export */   findNextEvenNumber: () => (/* binding */ findNextEvenNumber),
/* harmony export */   findNextOddNumber: () => (/* binding */ findNextOddNumber)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



function findNextOddNumber(arg) {
  const ceiled = Math.ceil(arg);
  return ceiled % 2 === 1 ? ceiled : ceiled + 1;
}
function findNextEvenNumber(arg) {
  const ceiled = Math.ceil(arg);
  return ceiled % 2 === 0 ? ceiled : ceiled + 1;
}
class RoundingPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  roundup(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ROUNDDOWN'), (numberToRound, places) => {
      const placesMultiplier = Math.pow(10, places);
      if (numberToRound < 0) {
        return -Math.ceil(-numberToRound * placesMultiplier) / placesMultiplier;
      } else {
        return Math.ceil(numberToRound * placesMultiplier) / placesMultiplier;
      }
    });
  }
  rounddown(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ROUNDDOWN'), (numberToRound, places) => {
      const placesMultiplier = Math.pow(10, places);
      if (numberToRound < 0) {
        return -Math.floor(-numberToRound * placesMultiplier) / placesMultiplier;
      } else {
        return Math.floor(numberToRound * placesMultiplier) / placesMultiplier;
      }
    });
  }
  round(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ROUND'), (numberToRound, places) => {
      const placesMultiplier = Math.pow(10, places);
      if (numberToRound < 0) {
        return -Math.round(-numberToRound * placesMultiplier) / placesMultiplier;
      } else {
        return Math.round(numberToRound * placesMultiplier) / placesMultiplier;
      }
    });
  }
  intFunc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('INT'), coercedNumberToRound => {
      if (coercedNumberToRound < 0) {
        return -Math.floor(-coercedNumberToRound);
      } else {
        return Math.floor(coercedNumberToRound);
      }
    });
  }
  even(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EVEN'), coercedNumberToRound => {
      if (coercedNumberToRound < 0) {
        return -findNextEvenNumber(-coercedNumberToRound);
      } else {
        return findNextEvenNumber(coercedNumberToRound);
      }
    });
  }
  odd(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ODD'), coercedNumberToRound => {
      if (coercedNumberToRound < 0) {
        return -findNextOddNumber(-coercedNumberToRound);
      } else {
        return findNextOddNumber(coercedNumberToRound);
      }
    });
  }
  ceilingmath(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CEILING.MATH'), (value, significance, mode) => {
      if (significance === 0 || value === 0) {
        return 0;
      }
      significance = Math.abs(significance);
      if (mode === 1 && value < 0) {
        significance = -significance;
      }
      return Math.ceil(value / significance) * significance;
    });
  }
  ceiling(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CEILING'), (value, significance) => {
      if (value === 0) {
        return 0;
      }
      if (significance === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      if (value > 0 && significance < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.DistinctSigns);
      }
      return Math.ceil(value / significance) * significance;
    });
  }
  ceilingprecise(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CEILING.PRECISE'), (value, significance) => {
      if (significance === 0 || value === 0) {
        return 0;
      }
      significance = Math.abs(significance);
      return Math.ceil(value / significance) * significance;
    });
  }
  floormath(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FLOOR.MATH'), (value, significance, mode) => {
      if (significance === 0 || value === 0) {
        return 0;
      }
      significance = Math.abs(significance);
      if (mode === 1 && value < 0) {
        significance *= -1;
      }
      return Math.floor(value / significance) * significance;
    });
  }
  floor(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FLOOR'), (value, significance) => {
      if (value === 0) {
        return 0;
      }
      if (significance === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      if (value > 0 && significance < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.DistinctSigns);
      }
      return Math.floor(value / significance) * significance;
    });
  }
  floorprecise(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FLOOR.PRECISE'), (value, significance) => {
      if (significance === 0 || value === 0) {
        return 0;
      }
      significance = Math.abs(significance);
      return Math.floor(value / significance) * significance;
    });
  }
}
RoundingPlugin.implementedFunctions = {
  'ROUNDUP': {
    method: 'roundup',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'ROUNDDOWN': {
    method: 'rounddown',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'ROUND': {
    method: 'round',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'INT': {
    method: 'intFunc',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'EVEN': {
    method: 'even',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ODD': {
    method: 'odd',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'CEILING.MATH': {
    method: 'ceilingmath',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'CEILING': {
    method: 'ceiling',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'CEILING.PRECISE': {
    method: 'ceilingprecise',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'FLOOR.MATH': {
    method: 'floormath',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }]
  },
  'FLOOR': {
    method: 'floor',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'FLOOR.PRECISE': {
    method: 'floorprecise',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  }
};
RoundingPlugin.aliases = {
  'ISO.CEILING': 'CEILING.PRECISE',
  'TRUNC': 'ROUNDDOWN'
};

/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SqrtPlugin: () => (/* binding */ SqrtPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class SqrtPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  sqrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SQRT'), Math.sqrt);
  }
}
SqrtPlugin.implementedFunctions = {
  'SQRT': {
    method: 'sqrt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 180 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConditionalAggregationPlugin: () => (/* binding */ ConditionalAggregationPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _CriterionFunctionCompute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(181);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





class AverageResult {
  constructor(sum, count) {
    this.sum = sum;
    this.count = count;
  }
  static single(arg) {
    return new AverageResult(arg, 1);
  }
  compose(other) {
    return new AverageResult(this.sum + other.sum, this.count + other.count);
  }
  averageValue() {
    if (this.count > 0) {
      return this.sum / this.count;
    } else {
      return undefined;
    }
  }
}
AverageResult.empty = new AverageResult(0, 0);
/** Computes key for criterion function cache */
function conditionalAggregationFunctionCacheKey(functionName) {
  return conditions => {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const conditionsStrings = conditions.map(c => `${c.conditionRange.range.sheet},${c.conditionRange.range.start.col},${c.conditionRange.range.start.row}`);
    return [functionName, ...conditionsStrings].join(',');
  };
}
function zeroForInfinite(value) {
  if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(value) && !Number.isFinite((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(value))) {
    return 0;
  } else {
    return value;
  }
}
function mapToRawScalarValue(arg) {
  if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
    return arg;
  }
  if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg)) {
    return (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg);
  }
  return undefined;
}
class ConditionalAggregationPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionPlugin {
  /**
   * Corresponds to SUMIF(Range, Criterion, SumRange)
   *
   * Range is the range to which criterion is to be applied.
   * Criterion is the criteria used to choose which cells will be included in sum.
   * SumRange is the range on which adding will be performed.
   *
   * @param ast
   * @param state
   */
  sumif(ast, state) {
    const functionName = 'SUMIF';
    const computeFn = (conditionRange, criterion, values) => this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  sumifs(ast, state) {
    const functionName = 'SUMIFS';
    const computeFn = (values, ...args) => this.computeConditionalAggregationFunction(values, args, functionName, 0, (left, right) => this.arithmeticHelper.nonstrictadd(left, right), mapToRawScalarValue);
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  averageif(ast, state) {
    const functionName = 'AVERAGEIF';
    const computeFn = (conditionRange, criterion, values) => {
      const averageResult = this.computeConditionalAggregationFunction(values !== null && values !== void 0 ? values : conditionRange, [conditionRange, criterion], functionName, AverageResult.empty, (left, right) => left.compose(right), arg => (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.isExtendedNumber)(arg) ? AverageResult.single((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(arg)) : AverageResult.empty);
      if (averageResult instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return averageResult;
      } else {
        return averageResult.averageValue() || new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
    };
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  /**
   * Corresponds to COUNTIF(Range, Criterion)
   *
   * Range is the range to which criterion is to be applied.
   * Criterion is the criteria used to choose which cells will be included in sum.
   *
   * Returns number of cells on which criteria evaluate to true.
   *
   * @param ast
   * @param state
   */
  countif(ast, state) {
    const functionName = 'COUNTIF';
    const computeFn = (conditionRange, criterion) => this.computeConditionalAggregationFunction(conditionRange, [conditionRange, criterion], functionName, 0, (left, right) => left + right, () => 1);
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  countifs(ast, state) {
    const functionName = 'COUNTIFS';
    const computeFn = (...args) => this.computeConditionalAggregationFunction(args[0], args, functionName, 0, (left, right) => left + right, () => 1);
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  minifs(ast, state) {
    const functionName = 'MINIFS';
    const composeFunction = (left, right) => {
      if (right === undefined || left === undefined) {
        return right === undefined ? left : right;
      }
      return Math.min(left, right);
    };
    const computeFn = (values, ...args) => {
      const minResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.POSITIVE_INFINITY, composeFunction, mapToRawScalarValue);
      return zeroForInfinite(minResult);
    };
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  maxifs(ast, state) {
    const functionName = 'MAXIFS';
    const composeFunction = (left, right) => {
      if (right === undefined || left === undefined) {
        return right === undefined ? left : right;
      }
      return Math.max(left, right);
    };
    const computeFn = (values, ...args) => {
      const maxResult = this.computeConditionalAggregationFunction(values, args, functionName, Number.NEGATIVE_INFINITY, composeFunction, mapToRawScalarValue);
      return zeroForInfinite(maxResult);
    };
    return this.runFunction(ast.args, state, this.metadata(functionName), computeFn);
  }
  computeConditionalAggregationFunction(valuesRange, conditionArgs, functionName, reduceInitialValue, composeFunction, mapFunction) {
    const conditions = [];
    for (let i = 0; i < conditionArgs.length; i += 2) {
      const conditionArg = conditionArgs[i];
      const criterionPackage = this.interpreter.criterionBuilder.fromCellValue(conditionArgs[i + 1], this.arithmeticHelper);
      if (criterionPackage === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.BadCriterion);
      }
      conditions.push(new _CriterionFunctionCompute__WEBPACK_IMPORTED_MODULE_2__.Condition(conditionArg, criterionPackage));
    }
    return new _CriterionFunctionCompute__WEBPACK_IMPORTED_MODULE_2__.CriterionFunctionCompute(this.interpreter, conditionalAggregationFunctionCacheKey(functionName), reduceInitialValue, composeFunction, mapFunction).compute(valuesRange, conditions);
  }
}
ConditionalAggregationPlugin.implementedFunctions = {
  SUMIF: {
    method: 'sumif',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NOERROR
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  COUNTIF: {
    method: 'countif',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NOERROR
    }]
  },
  AVERAGEIF: {
    method: 'averageif',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NOERROR
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE,
      optionalArg: true
    }]
  },
  SUMIFS: {
    method: 'sumifs',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NOERROR
    }],
    repeatLastArgs: 2
  },
  COUNTIFS: {
    method: 'countifs',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NOERROR
    }],
    repeatLastArgs: 2
  },
  MINIFS: {
    method: 'minifs',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NOERROR
    }],
    repeatLastArgs: 2
  },
  MAXIFS: {
    method: 'maxifs',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NOERROR
    }],
    repeatLastArgs: 2
  }
};

/***/ }),
/* 181 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Condition: () => (/* binding */ Condition),
/* harmony export */   CriterionFunctionCompute: () => (/* binding */ CriterionFunctionCompute)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _generatorUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(182);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




const findSmallerRangeForMany = (dependencyGraph, conditionRanges, valuesRange) => {
  if (valuesRange.end.row > valuesRange.start.row) {
    const valuesRangeEndRowLess = (0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(valuesRange.end.sheet, valuesRange.end.col, valuesRange.end.row - 1);
    const rowLessVertex = dependencyGraph.getRange(valuesRange.start, valuesRangeEndRowLess);
    if (rowLessVertex !== undefined) {
      return {
        smallerRangeVertex: rowLessVertex,
        restValuesRange: valuesRange.withStart((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(valuesRange.start.sheet, valuesRange.start.col, valuesRange.end.row)),
        restConditionRanges: conditionRanges.map(conditionRange => conditionRange.withStart((0,_Cell__WEBPACK_IMPORTED_MODULE_0__.simpleCellAddress)(conditionRange.start.sheet, conditionRange.start.col, conditionRange.end.row)))
      };
    }
  }
  return {
    restValuesRange: valuesRange,
    restConditionRanges: conditionRanges
  };
};
class CriterionFunctionCompute {
  constructor(interpreter, cacheKey, reduceInitialValue, composeFunction, mapFunction) {
    this.interpreter = interpreter;
    this.cacheKey = cacheKey;
    this.reduceInitialValue = reduceInitialValue;
    this.composeFunction = composeFunction;
    this.mapFunction = mapFunction;
    this.dependencyGraph = this.interpreter.dependencyGraph;
  }
  compute(simpleValuesRange, conditions) {
    for (const condition of conditions) {
      if (!condition.conditionRange.sameDimensionsAs(simpleValuesRange)) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
    }
    const valuesRangeVertex = this.tryToGetRangeVertexForRangeValue(simpleValuesRange);
    const conditionsVertices = conditions.map(c => this.tryToGetRangeVertexForRangeValue(c.conditionRange));
    if (valuesRangeVertex && conditionsVertices.every(e => e !== undefined)) {
      const fullCriterionString = conditions.map(c => c.criterionPackage.raw).join(',');
      const cachedResult = this.findAlreadyComputedValueInCache(valuesRangeVertex, this.cacheKey(conditions), fullCriterionString);
      if (cachedResult !== undefined) {
        this.interpreter.stats.incrementCriterionFunctionFullCacheUsed();
        return cachedResult;
      }
      const cache = this.buildNewCriterionCache(this.cacheKey(conditions), conditions.map(c => c.conditionRange.range), simpleValuesRange.range);
      if (!cache.has(fullCriterionString)) {
        cache.set(fullCriterionString, [this.evaluateRangeValue(simpleValuesRange, conditions), conditions.map(condition => condition.criterionPackage.lambda)]);
      }
      valuesRangeVertex.setCriterionFunctionValues(this.cacheKey(conditions), cache);
      conditionsVertices.forEach(range => {
        if (range !== undefined) {
          range.addDependentCacheRange(valuesRangeVertex);
        }
      });
      return cache.get(fullCriterionString)[0];
    } else {
      return this.evaluateRangeValue(simpleValuesRange, conditions);
    }
  }
  tryToGetRangeVertexForRangeValue(rangeValue) {
    const maybeRange = rangeValue.range;
    if (maybeRange === undefined) {
      return undefined;
    } else {
      return this.dependencyGraph.getRange(maybeRange.start, maybeRange.end);
    }
  }
  reduceFunction(iterable) {
    let acc = this.reduceInitialValue;
    for (const val of iterable) {
      acc = this.composeFunction(acc, val);
    }
    return acc;
  }
  findAlreadyComputedValueInCache(rangeVertex, cacheKey, criterionString) {
    return rangeVertex.getCriterionFunctionValue(cacheKey, criterionString);
  }
  evaluateRangeValue(simpleValuesRange, conditions) {
    const criterionLambdas = conditions.map(condition => condition.criterionPackage.lambda);
    const values = Array.from(simpleValuesRange.valuesFromTopLeftCorner()).map(this.mapFunction)[Symbol.iterator]();
    const conditionsIterators = conditions.map(condition => condition.conditionRange.iterateValuesFromTopLeftCorner());
    const filteredValues = ifFilter(criterionLambdas, conditionsIterators, values);
    return this.reduceFunction(filteredValues);
  }
  buildNewCriterionCache(cacheKey, simpleConditionRanges, simpleValuesRange) {
    const currentRangeVertex = this.dependencyGraph.getRange(simpleValuesRange.start, simpleValuesRange.end);
    const {
      smallerRangeVertex,
      restConditionRanges,
      restValuesRange
    } = findSmallerRangeForMany(this.dependencyGraph, simpleConditionRanges, simpleValuesRange);
    let smallerCache;
    if (smallerRangeVertex !== undefined && this.dependencyGraph.existsEdge(smallerRangeVertex, currentRangeVertex)) {
      smallerCache = smallerRangeVertex.getCriterionFunctionValues(cacheKey);
    } else {
      smallerCache = new Map();
    }
    const newCache = new Map();
    smallerCache.forEach(([value, criterionLambdas], key) => {
      const filteredValues = ifFilter(criterionLambdas, restConditionRanges.map(rcr => getRangeValues(this.dependencyGraph, rcr)), Array.from(getRangeValues(this.dependencyGraph, restValuesRange)).map(this.mapFunction)[Symbol.iterator]());
      const newCacheValue = this.composeFunction(value, this.reduceFunction(filteredValues));
      this.interpreter.stats.incrementCriterionFunctionPartialCacheUsed();
      newCache.set(key, [newCacheValue, criterionLambdas]);
    });
    return newCache;
  }
}
class Condition {
  constructor(conditionRange, criterionPackage) {
    this.conditionRange = conditionRange;
    this.criterionPackage = criterionPackage;
  }
}
function* getRangeValues(dependencyGraph, cellRange) {
  for (const cellFromRange of cellRange.addresses(dependencyGraph)) {
    yield (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(dependencyGraph.getScalarValue(cellFromRange));
  }
}
function* ifFilter(criterionLambdas, conditionalIterables, computableIterable) {
  for (const computable of computableIterable) {
    const conditionalSplits = conditionalIterables.map(conditionalIterable => (0,_generatorUtils__WEBPACK_IMPORTED_MODULE_2__.split)(conditionalIterable));
    if (!conditionalSplits.every(cs => Object.prototype.hasOwnProperty.call(cs, 'value'))) {
      return;
    }
    const conditionalFirsts = conditionalSplits.map(cs => (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_3__.getRawValue)(cs.value));
    if (zip(conditionalFirsts, criterionLambdas).every(([conditionalFirst, criterionLambda]) => criterionLambda(conditionalFirst))) {
      yield computable;
    }
    conditionalIterables = conditionalSplits.map(cs => cs.rest);
  }
}
function zip(arr1, arr2) {
  const result = [];
  for (let i = 0; i < Math.min(arr1.length, arr2.length); i++) {
    result.push([arr1[i], arr2[i]]);
  }
  return result;
}

/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   first: () => (/* binding */ first),
/* harmony export */   split: () => (/* binding */ split)
/* harmony export */ });
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */
function* empty() {}
function split(iterable) {
  const iterator = iterable[Symbol.iterator]();
  const {
    done,
    value
  } = iterator.next();
  if (done) {
    return {
      rest: empty()
    };
  } else {
    return {
      value,
      rest: iterator
    };
  }
}
function first(iterable) {
  const iterator = iterable[Symbol.iterator]();
  const {
    done,
    value
  } = iterator.next();
  if (!done) {
    return value;
  }
  return undefined;
}

/***/ }),
/* 183 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SumprodPlugin: () => (/* binding */ SumprodPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class SumprodPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionPlugin {
  sumproduct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUMPRODUCT'), (...args) => {
      const width = args[0].width();
      const height = args[0].height();
      for (const arg of args) {
        if (arg.width() !== width || arg.height() !== height) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
        }
      }
      let ret = 0;
      const iterators = args.map(arg => arg.iterateValuesFromTopLeftCorner());
      for (let i = 0; i < width * height; i++) {
        let acc = 1;
        for (const it of iterators) {
          const val = it.next().value;
          if (val instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
            return val;
          }
          const coercedVal = this.coerceScalarToNumberOrError(val);
          if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.isExtendedNumber)(coercedVal)) {
            acc *= (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.getRawValue)(coercedVal);
          } else {
            acc = 0;
          }
        }
        ret += acc;
      }
      return ret;
    });
  }
}
SumprodPlugin.implementedFunctions = {
  'SUMPRODUCT': {
    method: 'sumproduct',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.RANGE
    }],
    repeatLastArgs: 1
  }
};

/***/ }),
/* 184 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextPlugin: () => (/* binding */ TextPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



/**
 * Interpreter plugin containing text-specific functions
 */
class TextPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  /**
   * Corresponds to CONCATENATE(value1, [value2, ...])
   *
   * Concatenates provided arguments to one string.
   *
   * @param ast
   * @param state
   */
  concatenate(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CONCATENATE'), (...args) => {
      return ''.concat(...args);
    });
  }
  /**
   * Corresponds to SPLIT(string, index)
   *
   * Splits provided string using space separator and returns chunk at zero-based position specified by second argument
   *
   * @param ast
   * @param state
   */
  split(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SPLIT'), (stringToSplit, indexToUse) => {
      const splittedString = stringToSplit.split(' ');
      if (indexToUse >= splittedString.length || indexToUse < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.IndexBounds);
      }
      return splittedString[indexToUse];
    });
  }
  len(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LEN'), arg => {
      return arg.length;
    });
  }
  lower(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOWER'), arg => {
      return arg.toLowerCase();
    });
  }
  trim(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TRIM'), arg => {
      return arg.replace(/^ +| +$/g, '').replace(/ +/g, ' ');
    });
  }
  proper(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PROPER'), arg => {
      return arg.replace(/\p{L}+/gu, word => word.charAt(0).toUpperCase() + word.substring(1).toLowerCase());
    });
  }
  clean(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CLEAN'), arg => {
      // eslint-disable-next-line no-control-regex
      return arg.replace(/[\u0000-\u001F]/g, '');
    });
  }
  exact(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EXACT'), (left, right) => {
      return left === right;
    });
  }
  rept(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('REPT'), (text, count) => {
      if (count < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NegativeCount);
      }
      return text.repeat(count);
    });
  }
  right(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RIGHT'), (text, length) => {
      if (length < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NegativeLength);
      } else if (length === 0) {
        return '';
      }
      return text.slice(-length);
    });
  }
  left(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LEFT'), (text, length) => {
      if (length < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NegativeLength);
      }
      return text.slice(0, length);
    });
  }
  mid(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MID'), (text, startPosition, numberOfChars) => {
      if (startPosition < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.LessThanOne);
      }
      if (numberOfChars < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NegativeLength);
      }
      return text.substring(startPosition - 1, startPosition + numberOfChars - 1);
    });
  }
  replace(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('REPLACE'), (text, startPosition, numberOfChars, newText) => {
      if (startPosition < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.LessThanOne);
      }
      if (numberOfChars < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NegativeLength);
      }
      return text.substring(0, startPosition - 1) + newText + text.substring(startPosition + numberOfChars - 1);
    });
  }
  search(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SEARCH'), (pattern, text, startIndex) => {
      if (startIndex < 1 || startIndex > text.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.LengthBounds);
      }
      const normalizedPattern = pattern.toLowerCase();
      const normalizedText = text.substring(startIndex - 1).toLowerCase();
      const index = this.arithmeticHelper.requiresRegex(normalizedPattern) ? this.arithmeticHelper.searchString(normalizedPattern, normalizedText) : normalizedText.indexOf(normalizedPattern);
      return index > -1 ? index + startIndex : new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.PatternNotFound);
    });
  }
  substitute(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUBSTITUTE'), (text, searchString, replacementString, occurrenceNum) => {
      const escapedSearchString = this.escapeRegExpSpecialCharacters(searchString);
      const searchRegExp = new RegExp(escapedSearchString, 'g');
      if (occurrenceNum === undefined) {
        return text.replace(searchRegExp, replacementString);
      }
      if (occurrenceNum < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.LessThanOne);
      }
      let match;
      let i = 0;
      while ((match = searchRegExp.exec(text)) !== null) {
        if (occurrenceNum === ++i) {
          return text.substring(0, match.index) + replacementString + text.substring(searchRegExp.lastIndex);
        }
      }
      return text;
    });
  }
  find(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FIND'), (pattern, text, startIndex) => {
      if (startIndex < 1 || startIndex > text.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.IndexBounds);
      }
      const shiftedText = text.substring(startIndex - 1);
      const index = shiftedText.indexOf(pattern) + startIndex;
      return index > 0 ? index : new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.PatternNotFound);
    });
  }
  t(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T'), arg => {
      if (arg instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return arg;
      }
      return typeof arg === 'string' ? arg : '';
    });
  }
  upper(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('UPPER'), arg => {
      return arg.toUpperCase();
    });
  }
  escapeRegExpSpecialCharacters(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}
TextPlugin.implementedFunctions = {
  'CONCATENATE': {
    method: 'concatenate',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'EXACT': {
    method: 'exact',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  },
  'SPLIT': {
    method: 'split',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'LEN': {
    method: 'len',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  },
  'LOWER': {
    method: 'lower',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  },
  'MID': {
    method: 'mid',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'TRIM': {
    method: 'trim',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  },
  'T': {
    method: 't',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.SCALAR
    }]
  },
  'PROPER': {
    method: 'proper',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  },
  'CLEAN': {
    method: 'clean',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  },
  'REPT': {
    method: 'rept',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'RIGHT': {
    method: 'right',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'LEFT': {
    method: 'left',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'REPLACE': {
    method: 'replace',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  },
  'SEARCH': {
    method: 'search',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'SUBSTITUTE': {
    method: 'substitute',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      optionalArg: true
    }]
  },
  'FIND': {
    method: 'find',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'UPPER': {
    method: 'upper',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.STRING
    }]
  }
};

/***/ }),
/* 185 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TrigonometryPlugin: () => (/* binding */ TrigonometryPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/* harmony import */ var _MathConstantsPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(169);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




/**
 * Interpreter plugin containing trigonometric functions
 */
class TrigonometryPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  /**
   * Corresponds to ACOS(value)
   *
   * Returns the arc cosine (or inverse cosine) of a number.
   *
   * @param ast
   * @param state
   */
  acos(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ACOS'), Math.acos);
  }
  asin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ASIN'), Math.asin);
  }
  cos(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COS'), Math.cos);
  }
  sin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SIN'), Math.sin);
  }
  tan(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TAN'), Math.tan);
  }
  atan(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ATAN'), Math.atan);
  }
  atan2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ATAN2'), (x, y) => {
      if (x === 0 && y === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      return Math.atan2(y, x);
    });
  }
  cot(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COT'), arg => arg === 0 ? new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO) : 1 / Math.tan(arg));
  }
  acot(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ACOT'), arg => arg === 0 ? _MathConstantsPlugin__WEBPACK_IMPORTED_MODULE_3__.PI / 2 : Math.atan(1 / arg));
  }
  sec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SEC'), arg => 1 / Math.cos(arg));
  }
  csc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CSC'), arg => arg === 0 ? new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO) : 1 / Math.sin(arg));
  }
  sinh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SINH'), Math.sinh);
  }
  asinh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ASINH'), Math.asinh);
  }
  cosh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COSH'), Math.cosh);
  }
  acosh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ACOSH'), Math.acosh);
  }
  tanh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TANH'), Math.tanh);
  }
  atanh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ATANH'), Math.atanh);
  }
  coth(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COTH'), arg => arg === 0 ? new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO) : 1 / Math.tanh(arg));
  }
  acoth(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ACOTH'), arg => arg === 0 ? new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NonZero) : Math.atanh(1 / arg));
  }
  sech(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SECH'), arg => 1 / Math.cosh(arg));
  }
  csch(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CSCH'), arg => arg === 0 ? new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO) : 1 / Math.sinh(arg));
  }
}
TrigonometryPlugin.implementedFunctions = {
  'ACOS': {
    method: 'acos',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ASIN': {
    method: 'asin',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'COS': {
    method: 'cos',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'SIN': {
    method: 'sin',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'TAN': {
    method: 'tan',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ATAN': {
    method: 'atan',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ATAN2': {
    method: 'atan2',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'COT': {
    method: 'cot',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'SEC': {
    method: 'sec',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'CSC': {
    method: 'csc',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'SINH': {
    method: 'sinh',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'COSH': {
    method: 'cosh',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'TANH': {
    method: 'tanh',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'COTH': {
    method: 'coth',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'SECH': {
    method: 'sech',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'CSCH': {
    method: 'csch',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ACOT': {
    method: 'acot',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ASINH': {
    method: 'asinh',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ACOSH': {
    method: 'acosh',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ATANH': {
    method: 'atanh',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'ACOTH': {
    method: 'acoth',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  }
};

/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LookupPlugin: () => (/* binding */ LookupPlugin)
/* harmony export */ });
/* harmony import */ var _AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _Lookup_RowSearchStrategy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(187);
/* harmony import */ var _statistics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(72);
/* harmony import */ var _ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98);
/* harmony import */ var _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(69);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */








class LookupPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionPlugin {
  constructor() {
    super(...arguments);
    this.rowSearch = new _Lookup_RowSearchStrategy__WEBPACK_IMPORTED_MODULE_3__.RowSearchStrategy(this.dependencyGraph);
  }
  /**
   * Corresponds to VLOOKUP(key, range, index, [sorted])
   *
   * @param ast
   * @param state
   */
  vlookup(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('VLOOKUP'), (key, rangeValue, index, sorted) => {
      const range = rangeValue.range;
      if (range === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongType);
      }
      if (index < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.LessThanOne);
      }
      if (index > range.width()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.IndexLarge);
      }
      return this.doVlookup((0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.zeroIfEmpty)(key), rangeValue, index - 1, sorted);
    });
  }
  /**
   * Corresponds to HLOOKUP(key, range, index, [sorted])
   *
   * @param ast
   * @param state
   */
  hlookup(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HLOOKUP'), (key, rangeValue, index, sorted) => {
      const range = rangeValue.range;
      if (range === undefined) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongType);
      }
      if (index < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.LessThanOne);
      }
      if (index > range.height()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.REF, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.IndexLarge);
      }
      return this.doHlookup((0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.zeroIfEmpty)(key), rangeValue, index - 1, sorted);
    });
  }
  match(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MATCH'), (key, rangeValue, type) => {
      return this.doMatch((0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_5__.zeroIfEmpty)(key), rangeValue, type);
    });
  }
  searchInRange(key, range, sorted, searchStrategy) {
    if (!sorted && typeof key === 'string' && this.arithmeticHelper.requiresRegex(key)) {
      return searchStrategy.advancedFind(this.arithmeticHelper.eqMatcherFunction(key), range);
    } else {
      const searchOptions = sorted ? {
        ordering: 'asc'
      } : {
        ordering: 'none',
        matchExactly: true
      };
      return searchStrategy.find(key, range, searchOptions);
    }
  }
  doVlookup(key, rangeValue, index, sorted) {
    this.dependencyGraph.stats.start(_statistics__WEBPACK_IMPORTED_MODULE_4__.StatType.VLOOKUP);
    const range = rangeValue.range;
    let searchedRange;
    if (range === undefined) {
      searchedRange = _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue.onlyValues(rangeValue.data.map(arg => [arg[0]]));
    } else {
      searchedRange = _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue.onlyRange(_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(range.start, 1, range.height()), this.dependencyGraph);
    }
    const rowIndex = this.searchInRange(key, searchedRange, sorted, this.columnSearch);
    this.dependencyGraph.stats.end(_statistics__WEBPACK_IMPORTED_MODULE_4__.StatType.VLOOKUP);
    if (rowIndex === -1) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueNotFound);
    }
    let value;
    if (range === undefined) {
      value = rangeValue.data[rowIndex][index];
    } else {
      const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(range.sheet, range.start.col + index, range.start.row + rowIndex);
      value = this.dependencyGraph.getCellValue(address);
    }
    if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongType);
    }
    return value;
  }
  doHlookup(key, rangeValue, index, sorted) {
    const range = rangeValue.range;
    let searchedRange;
    if (range === undefined) {
      searchedRange = _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue.onlyValues([rangeValue.data[0]]);
    } else {
      searchedRange = _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue.onlyRange(_AbsoluteCellRange__WEBPACK_IMPORTED_MODULE_0__.AbsoluteCellRange.spanFrom(range.start, range.width(), 1), this.dependencyGraph);
    }
    const colIndex = this.searchInRange(key, searchedRange, sorted, this.rowSearch);
    if (colIndex === -1) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueNotFound);
    }
    let value;
    if (range === undefined) {
      value = rangeValue.data[index][colIndex];
    } else {
      const address = (0,_Cell__WEBPACK_IMPORTED_MODULE_1__.simpleCellAddress)(range.sheet, range.start.col + colIndex, range.start.row + index);
      value = this.dependencyGraph.getCellValue(address);
    }
    if (value instanceof _SimpleRangeValue__WEBPACK_IMPORTED_MODULE_6__.SimpleRangeValue) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.WrongType);
    }
    return value;
  }
  doMatch(key, rangeValue, type) {
    if (![-1, 0, 1].includes(type)) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.BadMode);
    }
    if (rangeValue.width() > 1 && rangeValue.height() > 1) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA);
    }
    const searchStrategy = rangeValue.width() === 1 ? this.columnSearch : this.rowSearch;
    const searchOptions = type === 0 ? {
      ordering: 'none',
      matchExactly: true
    } : {
      ordering: type === -1 ? 'desc' : 'asc'
    };
    const index = searchStrategy.find(key, rangeValue, searchOptions);
    if (index === -1) {
      return new _Cell__WEBPACK_IMPORTED_MODULE_1__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_1__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_2__.ErrorMessage.ValueNotFound);
    }
    return index + 1;
  }
}
LookupPlugin.implementedFunctions = {
  'VLOOKUP': {
    method: 'vlookup',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.NOERROR
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.BOOLEAN,
      defaultValue: true
    }]
  },
  'HLOOKUP': {
    method: 'hlookup',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.NOERROR
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.BOOLEAN,
      defaultValue: true
    }]
  },
  'MATCH': {
    method: 'match',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.NOERROR
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_7__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  }
};

/***/ }),
/* 187 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RowSearchStrategy: () => (/* binding */ RowSearchStrategy)
/* harmony export */ });
/* harmony import */ var _AdvancedFind__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(138);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class RowSearchStrategy extends _AdvancedFind__WEBPACK_IMPORTED_MODULE_0__.AdvancedFind {
  constructor(dependencyGraph) {
    super(dependencyGraph);
    this.dependencyGraph = dependencyGraph;
  }
  /*
   * WARNING: Finding lower/upper bounds in unordered ranges is not supported. When ordering === 'none', assumes matchExactly === true
   */
  find(searchKey, rangeValue, searchOptions) {
    return this.basicFind(searchKey, rangeValue, 'col', searchOptions);
  }
}

/***/ }),
/* 188 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RomanPlugin: () => (/* binding */ RomanPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class RomanPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionPlugin {
  roman(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ROMAN'), (val, mode) => {
      val = Math.trunc(val);
      if (mode === false) {
        mode = 4;
      } else if (mode === true) {
        mode = 0;
      }
      mode = (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.getRawValue)(this.coerceScalarToNumberOrError(mode));
      if (mode instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return mode;
      }
      mode = Math.trunc(mode);
      if (mode < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
      }
      if (mode > 4) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      return romanMode(val, mode);
    });
  }
  arabic(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ARABIC'), inputString => {
      inputString = inputString.trim().toUpperCase();
      let minusSign = false;
      if (inputString.startsWith('-')) {
        inputString = inputString.slice(1);
        minusSign = true;
        if (inputString === '') {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.InvalidRoman);
        }
      }
      const work = {
        input: inputString,
        acc: 0
      };
      eatToken(work, {
        token: 'MMM',
        val: 3000
      }, {
        token: 'MM',
        val: 2000
      }, {
        token: 'M',
        val: 1000
      });
      eatToken(work, {
        token: 'IM',
        val: 999
      }, {
        token: 'VM',
        val: 995
      }, {
        token: 'XM',
        val: 990
      }, {
        token: 'LM',
        val: 950
      }, {
        token: 'CM',
        val: 900
      });
      eatToken(work, {
        token: 'D',
        val: 500
      }, {
        token: 'ID',
        val: 499
      }, {
        token: 'VD',
        val: 495
      }, {
        token: 'XD',
        val: 490
      }, {
        token: 'LD',
        val: 450
      }, {
        token: 'CD',
        val: 400
      });
      eatToken(work, {
        token: 'CCC',
        val: 300
      }, {
        token: 'CC',
        val: 200
      }, {
        token: 'C',
        val: 100
      });
      eatToken(work, {
        token: 'IC',
        val: 99
      }, {
        token: 'VC',
        val: 95
      }, {
        token: 'XC',
        val: 90
      });
      eatToken(work, {
        token: 'L',
        val: 50
      }, {
        token: 'IL',
        val: 49
      }, {
        token: 'VL',
        val: 45
      }, {
        token: 'XL',
        val: 40
      });
      eatToken(work, {
        token: 'XXX',
        val: 30
      }, {
        token: 'XX',
        val: 20
      }, {
        token: 'X',
        val: 10
      });
      eatToken(work, {
        token: 'IX',
        val: 9
      });
      eatToken(work, {
        token: 'V',
        val: 5
      }, {
        token: 'IV',
        val: 4
      });
      eatToken(work, {
        token: 'III',
        val: 3
      }, {
        token: 'II',
        val: 2
      }, {
        token: 'I',
        val: 1
      });
      if (work.input !== '') {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.InvalidRoman);
      } else {
        return minusSign ? -work.acc : work.acc;
      }
    });
  }
}
RomanPlugin.implementedFunctions = {
  'ROMAN': {
    method: 'roman',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER,
      minValue: 1,
      lessThan: 4000
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NOERROR,
      optionalArg: true,
      defaultValue: 0
    }]
  },
  'ARABIC': {
    method: 'arabic',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING
    }]
  }
};
function eatToken(inputAcc, ...tokens) {
  for (const token of tokens) {
    if (inputAcc.input.startsWith(token.token)) {
      inputAcc.input = inputAcc.input.slice(token.token.length);
      inputAcc.acc += token.val;
      break;
    }
  }
}
function romanMode(input, mode) {
  const work = {
    val: input % 1000,
    acc: 'M'.repeat(Math.floor(input / 1000))
  };
  if (mode === 4) {
    absorb(work, 'IM', 999, 1000);
    absorb(work, 'ID', 499, 500);
  }
  if (mode >= 3) {
    absorb(work, 'VM', 995, 1000);
    absorb(work, 'VD', 495, 500);
  }
  if (mode >= 2) {
    absorb(work, 'XM', 990, 1000);
    absorb(work, 'XD', 490, 500);
  }
  if (mode >= 1) {
    absorb(work, 'LM', 950, 1000);
    absorb(work, 'LD', 450, 500);
  }
  absorb(work, 'CM', 900, 1000);
  absorb(work, 'CD', 400, 500);
  absorb(work, 'D', 500, 900);
  work.acc += 'C'.repeat(Math.floor(work.val / 100));
  work.val %= 100;
  if (mode >= 2) {
    absorb(work, 'IC', 99, 100);
    absorb(work, 'IL', 49, 50);
  }
  if (mode >= 1) {
    absorb(work, 'VC', 95, 100);
    absorb(work, 'VL', 45, 50);
  }
  absorb(work, 'XC', 90, 100);
  absorb(work, 'XL', 40, 50);
  absorb(work, 'L', 50, 90);
  work.acc += 'X'.repeat(Math.floor(work.val / 10));
  work.val %= 10;
  absorb(work, 'IX', 9, 10);
  absorb(work, 'IV', 4, 5);
  absorb(work, 'V', 5, 9);
  work.acc += 'I'.repeat(work.val);
  return work.acc;
}
function absorb(valAcc, token, lower, upper) {
  if (valAcc.val >= lower && valAcc.val < upper) {
    valAcc.val -= lower;
    valAcc.acc += token;
  }
}

/***/ }),
/* 189 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SimpleArithmerticPlugin: () => (/* binding */ SimpleArithmerticPlugin)
/* harmony export */ });
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */

class SimpleArithmerticPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionPlugin {
  add(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.ADD'), this.arithmeticHelper.addWithEpsilon);
  }
  concat(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.CONCAT'), this.arithmeticHelper.concat);
  }
  divide(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.DIVIDE'), this.arithmeticHelper.divide);
  }
  eq(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.EQ'), this.arithmeticHelper.eq);
  }
  gt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.GT'), this.arithmeticHelper.gt);
  }
  gte(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.GTE'), this.arithmeticHelper.geq);
  }
  lt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.LT'), this.arithmeticHelper.lt);
  }
  lte(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.LTE'), this.arithmeticHelper.leq);
  }
  minus(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.MINUS'), this.arithmeticHelper.subtract);
  }
  multiply(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.MULTIPLY'), this.arithmeticHelper.multiply);
  }
  ne(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.NE'), this.arithmeticHelper.neq);
  }
  pow(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.POW'), this.arithmeticHelper.pow);
  }
  uminus(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.UMINUS'), this.arithmeticHelper.unaryMinus);
  }
  upercent(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.UNARY_PERCENT'), this.arithmeticHelper.unaryPercent);
  }
  uplus(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HF.UPLUS'), this.arithmeticHelper.unaryPlus);
  }
}
SimpleArithmerticPlugin.implementedFunctions = {
  'HF.ADD': {
    method: 'add',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.CONCAT': {
    method: 'concat',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.STRING,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.STRING,
      passSubtype: true
    }]
  },
  'HF.DIVIDE': {
    method: 'divide',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.EQ': {
    method: 'eq',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.GT': {
    method: 'gt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.GTE': {
    method: 'gte',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.LT': {
    method: 'lt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.LTE': {
    method: 'lte',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.MINUS': {
    method: 'minus',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.MULTIPLY': {
    method: 'multiply',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.NE': {
    method: 'ne',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NOERROR,
      passSubtype: true
    }]
  },
  'HF.POW': {
    method: 'pow',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.UMINUS': {
    method: 'uminus',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.UNARY_PERCENT': {
    method: 'upercent',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  },
  'HF.UPLUS': {
    method: 'uplus',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_0__.FunctionArgumentType.NUMBER,
      passSubtype: true
    }]
  }
};

/***/ }),
/* 190 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StatisticalPlugin: () => (/* binding */ StatisticalPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _3rdparty_bessel_bessel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(191);
/* harmony import */ var _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(192);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





class StatisticalPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionPlugin {
  erf(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ERF'), (lowerBound, upperBound) => {
      if (upperBound === undefined) {
        return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.erf)(lowerBound);
      } else {
        return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.erf)(upperBound) - (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.erf)(lowerBound);
      }
    });
  }
  erfc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('ERFC'), _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.erfc);
  }
  expondist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('EXPON.DIST'), (x, lambda, cumulative) => {
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.exponential.cdf(x, lambda);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.exponential.pdf(x, lambda);
      }
    });
  }
  fisher(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FISHER'), x => Math.log((1 + x) / (1 - x)) / 2);
  }
  fisherinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FISHERINV'), y => 1 - 2 / (Math.exp(2 * y) + 1));
  }
  gamma(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAMMA'), _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.gammafn);
  }
  gammadist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAMMA.DIST'), (value, alphaVal, betaVal, cumulative) => {
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.gamma.cdf(value, alphaVal, betaVal);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.gamma.pdf(value, alphaVal, betaVal);
      }
    });
  }
  gammaln(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAMMALN'), _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.gammaln);
  }
  gammainv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAMMA.INV'), _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.gamma.inv);
  }
  gauss(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GAUSS'), z => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.cdf(z, 0, 1) - 0.5);
  }
  betadist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BETA.DIST'), (x, alphaVal, betaVal, cumulative, A, B) => {
      if (x <= A) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
      } else if (x >= B) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      x = (x - A) / (B - A);
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.beta.cdf(x, alphaVal, betaVal);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.beta.pdf(x, alphaVal, betaVal);
      }
    });
  }
  betainv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BETA.INV'), (x, alphaVal, betaVal, A, B) => {
      if (A >= B) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.WrongOrder);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.beta.inv(x, alphaVal, betaVal) * (B - A) + A;
      }
    });
  }
  binomialdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BINOM.DIST'), (succ, trials, prob, cumulative) => {
      if (succ > trials) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.WrongOrder);
      }
      succ = Math.trunc(succ);
      trials = Math.trunc(trials);
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.binomial.cdf(succ, trials, prob);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.binomial.pdf(succ, trials, prob);
      }
    });
  }
  binomialinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BINOM.INV'), (trials, prob, alpha) => {
      trials = Math.trunc(trials);
      let lower = -1;
      let upper = trials;
      while (upper > lower + 1) {
        const mid = Math.trunc((lower + upper) / 2);
        if (_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.binomial.cdf(mid, trials, prob) >= alpha) {
          upper = mid;
        } else {
          lower = mid;
        }
      }
      return upper;
    });
  }
  besselifn(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BESSELI'), (x, n) => (0,_3rdparty_bessel_bessel__WEBPACK_IMPORTED_MODULE_2__.besseli)(x, Math.trunc(n)));
  }
  besseljfn(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BESSELJ'), (x, n) => (0,_3rdparty_bessel_bessel__WEBPACK_IMPORTED_MODULE_2__.besselj)(x, Math.trunc(n)));
  }
  besselkfn(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BESSELK'), (x, n) => (0,_3rdparty_bessel_bessel__WEBPACK_IMPORTED_MODULE_2__.besselk)(x, Math.trunc(n)));
  }
  besselyfn(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('BESSELY'), (x, n) => (0,_3rdparty_bessel_bessel__WEBPACK_IMPORTED_MODULE_2__.bessely)(x, Math.trunc(n)));
  }
  chisqdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.DIST'), (x, deg, cumulative) => {
      deg = Math.trunc(deg);
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.chisquare.cdf(x, deg);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.chisquare.pdf(x, deg);
      }
    });
  }
  chisqdistrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.DIST.RT'), (x, deg) => 1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.chisquare.cdf(x, Math.trunc(deg)));
  }
  chisqinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.INV'), (p, deg) => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.chisquare.inv(p, Math.trunc(deg)));
  }
  chisqinvrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.INV.RT'), (p, deg) => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.chisquare.inv(1.0 - p, Math.trunc(deg)));
  }
  fdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.DIST'), (x, deg1, deg2, cumulative) => {
      deg1 = Math.trunc(deg1);
      deg2 = Math.trunc(deg2);
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.centralF.cdf(x, deg1, deg2);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.centralF.pdf(x, deg1, deg2);
      }
    });
  }
  fdistrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.DIST.RT'), (x, deg1, deg2) => 1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.centralF.cdf(x, Math.trunc(deg1), Math.trunc(deg2)));
  }
  finv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.INV'), (p, deg1, deg2) => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.centralF.inv(p, Math.trunc(deg1), Math.trunc(deg2)));
  }
  finvrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.INV.RT'), (p, deg1, deg2) => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.centralF.inv(1.0 - p, Math.trunc(deg1), Math.trunc(deg2)));
  }
  weibulldist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('WEIBULL.DIST'), (x, shape, scale, cumulative) => {
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.weibull.cdf(x, scale, shape);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.weibull.pdf(x, scale, shape);
      }
    });
  }
  poissondist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('POISSON.DIST'), (x, mean, cumulative) => {
      x = Math.trunc(x);
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.poisson.cdf(x, mean);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.poisson.pdf(x, mean);
      }
    });
  }
  hypgeomdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HYPGEOM.DIST'), (s, numberS, populationS, numberPop, cumulative) => {
      if (s > numberS || s > populationS || numberS > numberPop || populationS > numberPop) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      if (s + numberPop < populationS + numberS) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      s = Math.trunc(s);
      numberS = Math.trunc(numberS);
      populationS = Math.trunc(populationS);
      numberPop = Math.trunc(numberPop);
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.hypgeom.cdf(s, numberPop, populationS, numberS);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.hypgeom.pdf(s, numberPop, populationS, numberS);
      }
    });
  }
  tdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.DIST'), (x, deg, cumulative) => {
      deg = Math.trunc(deg);
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.cdf(x, deg);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.pdf(x, deg);
      }
    });
  }
  tdist2t(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.DIST.2T'), (x, deg) => (1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.cdf(x, Math.trunc(deg))) * 2);
  }
  tdistrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.DIST.RT'), (x, deg) => 1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.cdf(x, Math.trunc(deg)));
  }
  tdistold(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('TDIST'), (x, deg, mode) => mode * (1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.cdf(x, Math.trunc(deg))));
  }
  tinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.INV'), (p, deg) => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.inv(p, Math.trunc(deg)));
  }
  tinv2t(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.INV.2T'), (p, deg) => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.inv(1 - p / 2, Math.trunc(deg)));
  }
  lognormdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOGNORM.DIST'), (x, mean, stddev, cumulative) => {
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.lognormal.cdf(x, mean, stddev);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.lognormal.pdf(x, mean, stddev);
      }
    });
  }
  lognorminv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LOGNORM.INV'), (p, mean, stddev) => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.lognormal.inv(p, mean, stddev));
  }
  normdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NORM.DIST'), (x, mean, stddev, cumulative) => {
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.cdf(x, mean, stddev);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.pdf(x, mean, stddev);
      }
    });
  }
  norminv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NORM.INV'), (p, mean, stddev) => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.inv(p, mean, stddev));
  }
  normsdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NORM.S.DIST'), (x, cumulative) => {
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.cdf(x, 0, 1);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.pdf(x, 0, 1);
      }
    });
  }
  normsinv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NORM.S.INV'), p => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.inv(p, 0, 1));
  }
  phi(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('PHI'), x => _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.pdf(x, 0, 1));
  }
  negbinomdist(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('NEGBINOM.DIST'), (nf, ns, p, cumulative) => {
      nf = Math.trunc(nf);
      ns = Math.trunc(ns);
      if (cumulative) {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.negbin.cdf(nf, ns, p);
      } else {
        return _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.negbin.pdf(nf, ns, p);
      }
    });
  }
  confidencenorm(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CONFIDENCE.NORM'),
    // eslint-disable-next-line
    // @ts-ignore
    (alpha, stddev, size) => (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normalci)(1, alpha, stddev, Math.trunc(size))[1] - 1);
  }
  confidencet(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CONFIDENCE.T'), (alpha, stddev, size) => {
      size = Math.trunc(size);
      if (size === 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      // eslint-disable-next-line
      // @ts-ignore
      return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.tci)(1, alpha, stddev, size)[1] - 1;
    });
  }
  standardize(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('STANDARDIZE'), (x, mean, stddev) => (x - mean) / stddev);
  }
}
StatisticalPlugin.implementedFunctions = {
  'ERF': {
    method: 'erf',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      optionalArg: true
    }]
  },
  'ERFC': {
    method: 'erfc',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }]
  },
  'EXPON.DIST': {
    method: 'expondist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'FISHER': {
    method: 'fisher',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: -1,
      lessThan: 1
    }]
  },
  'FISHERINV': {
    method: 'fisherinv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }]
  },
  'GAMMA': {
    method: 'gamma',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }]
  },
  'GAMMA.DIST': {
    method: 'gammadist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'GAMMALN': {
    method: 'gammaln',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'GAMMA.INV': {
    method: 'gammainv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0,
      lessThan: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'GAUSS': {
    method: 'gauss',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }]
  },
  'BETA.DIST': {
    method: 'betadist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'BETA.INV': {
    method: 'betainv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      defaultValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      defaultValue: 1
    }]
  },
  'BINOM.DIST': {
    method: 'binomialdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'BINOM.INV': {
    method: 'binomialinv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }]
  },
  'BESSELI': {
    method: 'besselifn',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'BESSELJ': {
    method: 'besseljfn',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'BESSELK': {
    method: 'besselkfn',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'BESSELY': {
    method: 'besselyfn',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'CHISQ.DIST': {
    method: 'chisqdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'CHISQ.DIST.RT': {
    method: 'chisqdistrt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }]
  },
  'CHISQ.INV': {
    method: 'chisqinv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1,
      maxValue: 1e10
    }]
  },
  'CHISQ.INV.RT': {
    method: 'chisqinvrt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'F.DIST': {
    method: 'fdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'F.DIST.RT': {
    method: 'fdistrt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'F.INV': {
    method: 'finv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'F.INV.RT': {
    method: 'finvrt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'WEIBULL.DIST': {
    method: 'weibulldist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'POISSON.DIST': {
    method: 'poissondist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'HYPGEOM.DIST': {
    method: 'hypgeomdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'T.DIST': {
    method: 'tdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'T.DIST.2T': {
    method: 'tdist2t',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'T.DIST.RT': {
    method: 'tdistrt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'TDIST': {
    method: 'tdistold',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.INTEGER,
      minValue: 1,
      maxValue: 2
    }]
  },
  'T.INV': {
    method: 'tinv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'T.INV.2T': {
    method: 'tinv2t',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'LOGNORM.DIST': {
    method: 'lognormdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'LOGNORM.INV': {
    method: 'lognorminv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'NORM.DIST': {
    method: 'normdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'NORM.INV': {
    method: 'norminv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  },
  'NORM.S.DIST': {
    method: 'normsdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'NORM.S.INV': {
    method: 'normsinv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }]
  },
  'PHI': {
    method: 'phi',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }]
  },
  'NEGBINOM.DIST': {
    method: 'negbinomdist',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.BOOLEAN
    }]
  },
  'CONFIDENCE.NORM': {
    method: 'confidencenorm',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'CONFIDENCE.T': {
    method: 'confidencet',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0,
      lessThan: 1
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      minValue: 1
    }]
  },
  'STANDARDIZE': {
    method: 'standardize',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      greaterThan: 0
    }]
  }
};
StatisticalPlugin.aliases = {
  NEGBINOMDIST: 'NEGBINOM.DIST',
  EXPONDIST: 'EXPON.DIST',
  BETADIST: 'BETA.DIST',
  NORMDIST: 'NORM.DIST',
  NORMINV: 'NORM.INV',
  NORMSDIST: 'NORM.S.DIST',
  NORMSINV: 'NORM.S.INV',
  LOGNORMDIST: 'LOGNORM.DIST',
  LOGINV: 'LOGNORM.INV',
  TINV: 'T.INV.2T',
  HYPGEOMDIST: 'HYPGEOM.DIST',
  POISSON: 'POISSON.DIST',
  WEIBULL: 'WEIBULL.DIST',
  FINV: 'F.INV.RT',
  FDIST: 'F.DIST.RT',
  CHIDIST: 'CHISQ.DIST.RT',
  CHIINV: 'CHISQ.INV.RT',
  GAMMADIST: 'GAMMA.DIST',
  'GAMMALN.PRECISE': 'GAMMALN',
  GAMMAINV: 'GAMMA.INV',
  BETAINV: 'BETA.INV',
  BINOMDIST: 'BINOM.DIST',
  CONFIDENCE: 'CONFIDENCE.NORM',
  CRITBINOM: 'BINOM.INV',
  WEIBULLDIST: 'WEIBULL.DIST',
  TINV2T: 'T.INV.2T',
  TDISTRT: 'T.DIST.RT',
  TDIST2T: 'T.DIST.2T',
  FINVRT: 'F.INV.RT',
  FDISTRT: 'F.DIST.RT',
  CHIDISTRT: 'CHISQ.DIST.RT',
  CHIINVRT: 'CHISQ.INV.RT',
  LOGNORMINV: 'LOGNORM.INV',
  POISSONDIST: 'POISSON.DIST'
};

/***/ }),
/* 191 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   besseli: () => (/* binding */ besseli),
/* harmony export */   besselj: () => (/* binding */ besselj),
/* harmony export */   besselk: () => (/* binding */ besselk),
/* harmony export */   bessely: () => (/* binding */ bessely)
/* harmony export */ });
/**
 * @license
 bessel.js (C) 2013-present SheetJS -- http://sheetjs.com

 Apache License
 Version 2.0, January 2004
 http://www.apache.org/licenses/

 TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

 1. Definitions.

 "License" shall mean the terms and conditions for use, reproduction,
 and distribution as defined by Sections 1 through 9 of this document.

 "Licensor" shall mean the copyright owner or entity authorized by
 the copyright owner that is granting the License.

 "Legal Entity" shall mean the union of the acting entity and all
 other entities that control, are controlled by, or are under common
 control with that entity. For the purposes of this definition,
 "control" means (i) the power, direct or indirect, to cause the
 direction or management of such entity, whether by contract or
 otherwise, or (ii) ownership of fifty percent (50%) or more of the
 outstanding shares, or (iii) beneficial ownership of such entity.

 "You" (or "Your") shall mean an individual or Legal Entity
 exercising permissions granted by this License.

 "Source" form shall mean the preferred form for making modifications,
 including but not limited to software source code, documentation
 source, and configuration files.

 "Object" form shall mean any form resulting from mechanical
 transformation or translation of a Source form, including but
 not limited to compiled object code, generated documentation,
 and conversions to other media types.

 "Work" shall mean the work of authorship, whether in Source or
 Object form, made available under the License, as indicated by a
 copyright notice that is included in or attached to the work
 (an example is provided in the Appendix below).

 "Derivative Works" shall mean any work, whether in Source or Object
 form, that is based on (or derived from) the Work and for which the
 editorial revisions, annotations, elaborations, or other modifications
 represent, as a whole, an original work of authorship. For the purposes
 of this License, Derivative Works shall not include works that remain
 separable from, or merely link (or bind by name) to the interfaces of,
 the Work and Derivative Works thereof.

 "Contribution" shall mean any work of authorship, including
 the original version of the Work and any modifications or additions
 to that Work or Derivative Works thereof, that is intentionally
 submitted to Licensor for inclusion in the Work by the copyright owner
 or by an individual or Legal Entity authorized to submit on behalf of
 the copyright owner. For the purposes of this definition, "submitted"
 means any form of electronic, verbal, or written communication sent
 to the Licensor or its representatives, including but not limited to
 communication on electronic mailing lists, source code control systems,
 and issue tracking systems that are managed by, or on behalf of, the
 Licensor for the purpose of discussing and improving the Work, but
 excluding communication that is conspicuously marked or otherwise
 designated in writing by the copyright owner as "Not a Contribution."

 "Contributor" shall mean Licensor and any individual or Legal Entity
 on behalf of whom a Contribution has been received by Licensor and
 subsequently incorporated within the Work.

 2. Grant of Copyright License. Subject to the terms and conditions of
 this License, each Contributor hereby grants to You a perpetual,
 worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 copyright license to reproduce, prepare Derivative Works of,
 publicly display, publicly perform, sublicense, and distribute the
 Work and such Derivative Works in Source or Object form.

 3. Grant of Patent License. Subject to the terms and conditions of
 this License, each Contributor hereby grants to You a perpetual,
 worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 (except as stated in this section) patent license to make, have made,
 use, offer to sell, sell, import, and otherwise transfer the Work,
 where such license applies only to those patent claims licensable
 by such Contributor that are necessarily infringed by their
 Contribution(s) alone or by combination of their Contribution(s)
 with the Work to which such Contribution(s) was submitted. If You
 institute patent litigation against any entity (including a
 cross-claim or counterclaim in a lawsuit) alleging that the Work
 or a Contribution incorporated within the Work constitutes direct
 or contributory patent infringement, then any patent licenses
 granted to You under this License for that Work shall terminate
 as of the date such litigation is filed.

 4. Redistribution. You may reproduce and distribute copies of the
 Work or Derivative Works thereof in any medium, with or without
 modifications, and in Source or Object form, provided that You
 meet the following conditions:

 (a) You must give any other recipients of the Work or
 Derivative Works a copy of this License; and

 (b) You must cause any modified files to carry prominent notices
 stating that You changed the files; and

 (c) You must retain, in the Source form of any Derivative Works
 that You distribute, all copyright, patent, trademark, and
 attribution notices from the Source form of the Work,
 excluding those notices that do not pertain to any part of
 the Derivative Works; and

 (d) If the Work includes a "NOTICE" text file as part of its
 distribution, then any Derivative Works that You distribute must
 include a readable copy of the attribution notices contained
 within such NOTICE file, excluding those notices that do not
 pertain to any part of the Derivative Works, in at least one
 of the following places: within a NOTICE text file distributed
 as part of the Derivative Works; within the Source form or
 documentation, if provided along with the Derivative Works; or,
 within a display generated by the Derivative Works, if and
 wherever such third-party notices normally appear. The contents
 of the NOTICE file are for informational purposes only and
 do not modify the License. You may add Your own attribution
 notices within Derivative Works that You distribute, alongside
 or as an addendum to the NOTICE text from the Work, provided
 that such additional attribution notices cannot be construed
 as modifying the License.

 You may add Your own copyright statement to Your modifications and
 may provide additional or different license terms and conditions
 for use, reproduction, or distribution of Your modifications, or
 for any such Derivative Works as a whole, provided Your use,
 reproduction, and distribution of the Work otherwise complies with
 the conditions stated in this License.

 5. Submission of Contributions. Unless You explicitly state otherwise,
 any Contribution intentionally submitted for inclusion in the Work
 by You to the Licensor shall be under the terms and conditions of
 this License, without any additional terms or conditions.
 Notwithstanding the above, nothing herein shall supersede or modify
 the terms of any separate license agreement you may have executed
 with Licensor regarding such Contributions.

 6. Trademarks. This License does not grant permission to use the trade
 names, trademarks, service marks, or product names of the Licensor,
 except as required for reasonable and customary use in describing the
 origin of the Work and reproducing the content of the NOTICE file.

 7. Disclaimer of Warranty. Unless required by applicable law or
 agreed to in writing, Licensor provides the Work (and each
 Contributor provides its Contributions) on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 implied, including, without limitation, any warranties or conditions
 of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 PARTICULAR PURPOSE. You are solely responsible for determining the
 appropriateness of using or redistributing the Work and assume any
 risks associated with Your exercise of permissions under this License.

 8. Limitation of Liability. In no event and under no legal theory,
 whether in tort (including negligence), contract, or otherwise,
 unless required by applicable law (such as deliberate and grossly
 negligent acts) or agreed to in writing, shall any Contributor be
 liable to You for damages, including any direct, indirect, special,
 incidental, or consequential damages of any character arising as a
 result of this License or out of the use or inability to use the
 Work (including but not limited to damages for loss of goodwill,
 work stoppage, computer failure or malfunction, or any and all
 other commercial damages or losses), even if such Contributor
 has been advised of the possibility of such damages.

 9. Accepting Warranty or Additional Liability. While redistributing
 the Work or Derivative Works thereof, You may choose to offer,
 and charge a fee for, acceptance of support, warranty, indemnity,
 or other liability obligations and/or rights consistent with this
 License. However, in accepting such obligations, You may act only
 on Your own behalf and on Your sole responsibility, not on behalf
 of any other Contributor, and only if You agree to indemnify,
 defend, and hold each Contributor harmless for any liability
 incurred by, or claims asserted against, such Contributor by reason
 of your accepting any such warranty or additional liability.

 END OF TERMS AND CONDITIONS

 APPENDIX: How to apply the Apache License to your work.

 To apply the Apache License to your work, attach the following
 boilerplate notice, with the fields enclosed by brackets "{}"
 replaced with your own identifying information. (Don't include
 the brackets!)  The text should be enclosed in the appropriate
 comment syntax for the file format. We also recommend that a
 file or class name and description of purpose be included on the
 same "printed page" as the copyright notice for easier
 identification within third-party archives.

 Copyright (C) 2013-present   SheetJS LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 */
var M = Math;
// @ts-ignore
function _horner(arr, v) {
  for (var i = 0, z = 0; i < arr.length; ++i) {
    z = v * z + arr[i];
  }
  return z;
}
// @ts-ignore
function _bessel_iter(x, n, f0, f1, sign) {
  if (n === 0) {
    return f0;
  }
  if (n === 1) {
    return f1;
  }
  var tdx = 2 / x,
    f2 = f1;
  for (var o = 1; o < n; ++o) {
    f2 = f1 * o * tdx + sign * f0;
    f0 = f1;
    f1 = f2;
  }
  return f2;
}
// @ts-ignore
function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
  // @ts-ignore
  return function bessel(x, n) {
    if (nonzero) {
      if (x === 0) {
        return nonzero == 1 ? -Infinity : Infinity;
      } else if (x < 0) {
        return NaN;
      }
    }
    if (n === 0) {
      return bessel0(x);
    }
    if (n === 1) {
      return bessel1(x);
    }
    if (n < 0) {
      return NaN;
    }
    n |= 0;
    var b0 = bessel0(x),
      b1 = bessel1(x);
    return _bessel_iter(x, n, b0, b1, sign);
  };
}
var besselj = function () {
  var W = 0.636619772; // 2 / Math.PI
  var b0_a1a = [57568490574.0, -13362590354.0, 651619640.7, -11214424.18, 77392.33017, -184.9052456].reverse();
  var b0_a2a = [57568490411.0, 1029532985.0, 9494680.718, 59272.64853, 267.8532712, 1.0].reverse();
  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934935152e-7].reverse();
  // @ts-ignore
  function bessel0(x) {
    var a = 0,
      a1 = 0,
      a2 = 0,
      y = x * x;
    if (x < 8) {
      a1 = _horner(b0_a1a, y);
      a2 = _horner(b0_a2a, y);
      a = a1 / a2;
    } else {
      var xx = x - 0.785398164;
      y = 64 / y;
      a1 = _horner(b0_a1b, y);
      a2 = _horner(b0_a2b, y);
      a = M.sqrt(W / x) * (M.cos(xx) * a1 - M.sin(xx) * a2 * 8 / x);
    }
    return a;
  }
  var b1_a1a = [72362614232.0, -7895059235.0, 242396853.1, -2972611.439, 15704.48260, -30.16036606].reverse();
  var b1_a2a = [144725228442.0, 2300535178.0, 18583304.74, 99447.43394, 376.9991397, 1.0].reverse();
  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
  // @ts-ignore
  function bessel1(x) {
    var a = 0,
      a1 = 0,
      a2 = 0,
      y = x * x,
      xx = M.abs(x) - 2.356194491;
    if (Math.abs(x) < 8) {
      a1 = x * _horner(b1_a1a, y);
      a2 = _horner(b1_a2a, y);
      a = a1 / a2;
    } else {
      y = 64 / y;
      a1 = _horner(b1_a1b, y);
      a2 = _horner(b1_a2b, y);
      a = M.sqrt(W / M.abs(x)) * (M.cos(xx) * a1 - M.sin(xx) * a2 * 8 / M.abs(x));
      if (x < 0) {
        a = -a;
      }
    }
    return a;
  }
  // @ts-ignore
  return function besselj(x, n) {
    n = Math.round(n);
    if (!isFinite(x)) {
      return isNaN(x) ? x : 0;
    }
    if (n < 0) {
      return (n % 2 ? -1 : 1) * besselj(x, -n);
    }
    if (x < 0) {
      return (n % 2 ? -1 : 1) * besselj(-x, n);
    }
    if (n === 0) {
      return bessel0(x);
    }
    if (n === 1) {
      return bessel1(x);
    }
    if (x === 0) {
      return 0;
    }
    var ret = 0.0;
    if (x > n) {
      ret = _bessel_iter(x, n, bessel0(x), bessel1(x), -1);
    } else {
      var m = 2 * M.floor((n + M.floor(M.sqrt(40 * n))) / 2);
      var jsum = false;
      var bjp = 0.0,
        sum = 0.0;
      var bj = 1.0,
        bjm = 0.0;
      var tox = 2 / x;
      for (var j = m; j > 0; j--) {
        bjm = j * tox * bj - bjp;
        bjp = bj;
        bj = bjm;
        if (M.abs(bj) > 1E10) {
          bj *= 1E-10;
          bjp *= 1E-10;
          ret *= 1E-10;
          sum *= 1E-10;
        }
        if (jsum) {
          sum += bj;
        }
        jsum = !jsum;
        if (j == n) {
          ret = bjp;
        }
      }
      sum = 2.0 * sum - bj;
      ret /= sum;
    }
    return ret;
  };
}();
var bessely = function () {
  var W = 0.636619772;
  var b0_a1a = [-2957821389.0, 7062834065.0, -512359803.6, 10879881.29, -86327.92757, 228.4622733].reverse();
  var b0_a2a = [40076544269.0, 745249964.8, 7189466.438, 47447.26470, 226.1030244, 1.0].reverse();
  var b0_a1b = [1.0, -0.1098628627e-2, 0.2734510407e-4, -0.2073370639e-5, 0.2093887211e-6].reverse();
  var b0_a2b = [-0.1562499995e-1, 0.1430488765e-3, -0.6911147651e-5, 0.7621095161e-6, -0.934945152e-7].reverse();
  // @ts-ignore
  function bessel0(x) {
    var a = 0,
      a1 = 0,
      a2 = 0,
      y = x * x,
      xx = x - 0.785398164;
    if (x < 8) {
      a1 = _horner(b0_a1a, y);
      a2 = _horner(b0_a2a, y);
      a = a1 / a2 + W * besselj(x, 0) * M.log(x);
    } else {
      y = 64 / y;
      a1 = _horner(b0_a1b, y);
      a2 = _horner(b0_a2b, y);
      a = M.sqrt(W / x) * (M.sin(xx) * a1 + M.cos(xx) * a2 * 8 / x);
    }
    return a;
  }
  var b1_a1a = [-0.4900604943e13, 0.1275274390e13, -0.5153438139e11, 0.7349264551e9, -0.4237922726e7, 0.8511937935e4].reverse();
  var b1_a2a = [0.2499580570e14, 0.4244419664e12, 0.3733650367e10, 0.2245904002e8, 0.1020426050e6, 0.3549632885e3, 1].reverse();
  var b1_a1b = [1.0, 0.183105e-2, -0.3516396496e-4, 0.2457520174e-5, -0.240337019e-6].reverse();
  var b1_a2b = [0.04687499995, -0.2002690873e-3, 0.8449199096e-5, -0.88228987e-6, 0.105787412e-6].reverse();
  // @ts-ignore
  function bessel1(x) {
    var a = 0,
      a1 = 0,
      a2 = 0,
      y = x * x,
      xx = x - 2.356194491;
    if (x < 8) {
      a1 = x * _horner(b1_a1a, y);
      a2 = _horner(b1_a2a, y);
      a = a1 / a2 + W * (besselj(x, 1) * M.log(x) - 1 / x);
    } else {
      y = 64 / y;
      a1 = _horner(b1_a1b, y);
      a2 = _horner(b1_a2b, y);
      a = M.sqrt(W / x) * (M.sin(xx) * a1 + M.cos(xx) * a2 * 8 / x);
    }
    return a;
  }
  return _bessel_wrap(bessel0, bessel1, 'BESSELY', 1, -1);
}();
var besseli = function () {
  var b0_a = [1.0, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.360768e-1, 0.45813e-2].reverse();
  var b0_b = [0.39894228, 0.1328592e-1, 0.225319e-2, -0.157565e-2, 0.916281e-2, -0.2057706e-1, 0.2635537e-1, -0.1647633e-1, 0.392377e-2].reverse();
  // @ts-ignore
  function bessel0(x) {
    if (x <= 3.75) {
      return _horner(b0_a, x * x / (3.75 * 3.75));
    }
    return M.exp(M.abs(x)) / M.sqrt(M.abs(x)) * _horner(b0_b, 3.75 / M.abs(x));
  }
  var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.2658733e-1, 0.301532e-2, 0.32411e-3].reverse();
  var b1_b = [0.39894228, -0.3988024e-1, -0.362018e-2, 0.163801e-2, -0.1031555e-1, 0.2282967e-1, -0.2895312e-1, 0.1787654e-1, -0.420059e-2].reverse();
  // @ts-ignore
  function bessel1(x) {
    if (x < 3.75) {
      return x * _horner(b1_a, x * x / (3.75 * 3.75));
    }
    return (x < 0 ? -1 : 1) * M.exp(M.abs(x)) / M.sqrt(M.abs(x)) * _horner(b1_b, 3.75 / M.abs(x));
  }
  // @ts-ignore
  return function besseli(x, n) {
    n = Math.round(n);
    if (n === 0) {
      return bessel0(x);
    }
    if (n === 1) {
      return bessel1(x);
    }
    if (n < 0) {
      return NaN;
    }
    if (M.abs(x) === 0) {
      return 0;
    }
    if (x == Infinity) {
      return Infinity;
    }
    var ret = 0.0,
      j,
      tox = 2 / M.abs(x),
      bip = 0.0,
      bi = 1.0,
      bim = 0.0;
    var m = 2 * M.round((n + M.round(M.sqrt(40 * n))) / 2);
    for (j = m; j > 0; j--) {
      bim = j * tox * bi + bip;
      bip = bi;
      bi = bim;
      if (M.abs(bi) > 1E10) {
        bi *= 1E-10;
        bip *= 1E-10;
        ret *= 1E-10;
      }
      if (j == n) {
        ret = bip;
      }
    }
    ret *= besseli(x, 0) / bi;
    return x < 0 && n % 2 ? -ret : ret;
  };
}();
var besselk = function () {
  var b0_a = [-0.57721566, 0.42278420, 0.23069756, 0.3488590e-1, 0.262698e-2, 0.10750e-3, 0.74e-5].reverse();
  var b0_b = [1.25331414, -0.7832358e-1, 0.2189568e-1, -0.1062446e-1, 0.587872e-2, -0.251540e-2, 0.53208e-3].reverse();
  // @ts-ignore
  function bessel0(x) {
    if (x <= 2) {
      return -M.log(x / 2) * besseli(x, 0) + _horner(b0_a, x * x / 4);
    }
    return M.exp(-x) / M.sqrt(x) * _horner(b0_b, 2 / x);
  }
  var b1_a = [1.0, 0.15443144, -0.67278579, -0.18156897, -0.1919402e-1, -0.110404e-2, -0.4686e-4].reverse();
  var b1_b = [1.25331414, 0.23498619, -0.3655620e-1, 0.1504268e-1, -0.780353e-2, 0.325614e-2, -0.68245e-3].reverse();
  // @ts-ignore
  function bessel1(x) {
    if (x <= 2) {
      return M.log(x / 2) * besseli(x, 1) + 1 / x * _horner(b1_a, x * x / 4);
    }
    return M.exp(-x) / M.sqrt(x) * _horner(b1_b, 2 / x);
  }
  return _bessel_wrap(bessel0, bessel1, 'BESSELK', 2, 1);
}();

/***/ }),
/* 192 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   beta: () => (/* binding */ beta),
/* harmony export */   binomial: () => (/* binding */ binomial),
/* harmony export */   centralF: () => (/* binding */ centralF),
/* harmony export */   chisquare: () => (/* binding */ chisquare),
/* harmony export */   corrcoeff: () => (/* binding */ corrcoeff),
/* harmony export */   covariance: () => (/* binding */ covariance),
/* harmony export */   erf: () => (/* binding */ erf),
/* harmony export */   erfc: () => (/* binding */ erfc),
/* harmony export */   exponential: () => (/* binding */ exponential),
/* harmony export */   factorial: () => (/* binding */ factorial),
/* harmony export */   factorialln: () => (/* binding */ factorialln),
/* harmony export */   gamma: () => (/* binding */ gamma),
/* harmony export */   gammafn: () => (/* binding */ gammafn),
/* harmony export */   gammaln: () => (/* binding */ gammaln),
/* harmony export */   geomean: () => (/* binding */ geomean),
/* harmony export */   hypgeom: () => (/* binding */ hypgeom),
/* harmony export */   lognormal: () => (/* binding */ lognormal),
/* harmony export */   mean: () => (/* binding */ mean),
/* harmony export */   negbin: () => (/* binding */ negbin),
/* harmony export */   normal: () => (/* binding */ normal),
/* harmony export */   normalci: () => (/* binding */ normalci),
/* harmony export */   poisson: () => (/* binding */ poisson),
/* harmony export */   stdev: () => (/* binding */ stdev),
/* harmony export */   studentt: () => (/* binding */ studentt),
/* harmony export */   sumsqerr: () => (/* binding */ sumsqerr),
/* harmony export */   tci: () => (/* binding */ tci),
/* harmony export */   variance: () => (/* binding */ variance),
/* harmony export */   weibull: () => (/* binding */ weibull)
/* harmony export */ });
/**
 * @license
 Copyright (c) 2013 jStat

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */
function erf(x) {
  const cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2, -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4, 4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6, 1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8, 6.529054439e-9, 5.059343495e-9, -9.91364156e-10, -2.27365122e-10, 9.6467911e-11, 2.394038e-12, -6.886027e-12, 8.94487e-13, 3.13092e-13, -1.12708e-13, 3.81e-16, 7.106e-15, -1.523e-15, -9.4e-17, 1.21e-16, -2.8e-17];
  let j = cof.length - 1;
  let isneg = false;
  let d = 0;
  let dd = 0;
  let t, ty, tmp, res;
  if (x === 0) {
    return 0;
  }
  if (x < 0) {
    x = -x;
    isneg = true;
  }
  t = 2 / (2 + x);
  ty = 4 * t - 2;
  for (; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }
  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
}
function erfc(x) {
  return 1 - erf(x);
}
function erfcinv(p) {
  let j = 0;
  let x, err, t, pp;
  if (p >= 2) {
    return -100;
  }
  if (p <= 0) {
    return 100;
  }
  pp = p < 1 ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return p < 1 ? x : -x;
}
const exponential = {
  pdf: (x, rate) => {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },
  cdf: (x, rate) => {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  }
};
function gammafn(x) {
  const p = [-1.716185138865495, 24.76565080557592, -379.80425647094563, 629.3311553128184, 866.9662027904133, -31451.272968848367, -36144.413418691176, 66456.14382024054];
  const q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192, -3107.771671572311, 22538.118420980151, 4755.8462775278811, -134659.9598649693, -115132.2596755535];
  let fact = false;
  let n = 0;
  let xden = 0;
  let xnum = 0;
  let y = x;
  let i, z, yi, res;
  if (x > 171.6243769536076) {
    return Infinity;
  }
  if (y <= 0) {
    res = y % 1;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
}
const gamma = {
  pdf: function pdf(x, shape, scale) {
    if (x < 0) {
      return 0;
    }
    return x === 0 && shape === 1 ? 1 / scale : Math.exp((shape - 1) * Math.log(x) - x / scale - gammaln(shape) - shape * Math.log(scale));
  },
  cdf: function cdf(x, shape, scale) {
    if (x < 0) {
      return 0;
    }
    return lowRegGamma(shape, x / scale);
  },
  inv: function (p, shape, scale) {
    return gammapinv(p, shape) * scale;
  }
};
function gammaln(x) {
  let j = 0;
  const cof = [76.18009172947146, -86.50532032941677, 24.01409824083091, -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5];
  let ser = 1.000000000190015;
  let xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++) {
    ser += cof[j] / ++y;
  }
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
}
function lowRegGamma(a, x) {
  const aln = gammaln(a);
  let ap = a;
  let sum = 1 / a;
  let del = sum;
  let b = x + 1 - a;
  let c = 1 / 1.0e-30;
  let d = 1 / b;
  let h = d;
  let i = 1;
  // calculate maximum number of itterations required for a
  const ITMAX = -~(Math.log(a >= 1 ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  let an;
  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return sum * Math.exp(-x + a * Math.log(x) - aln);
  }
  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }
  return 1 - h * Math.exp(-x + a * Math.log(x) - aln);
}
function gammapinv(p, a) {
  let j = 0;
  const a1 = a - 1;
  const EPS = 1e-8;
  const gln = gammaln(a);
  let x, err, t, u, pp;
  let lna1;
  let afac;
  if (p >= 1) {
    return Math.max(100, a + 100 * Math.sqrt(a));
  }
  if (p <= 0) {
    return 0;
  }
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = p < 0.5 ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5) {
      x = -x;
    }
    x = Math.max(1e-3, a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t) {
      x = Math.pow(p / t, 1 / a);
    } else {
      x = 1 - Math.log(1 - (p - t) / (1 - t));
    }
  }
  for (; j < 12; j++) {
    if (x <= 0) {
      return 0;
    }
    err = lowRegGamma(a, x) - p;
    if (a > 1) {
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    } else {
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    }
    u = err / t;
    x -= t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1)));
    if (x <= 0) {
      x = 0.5 * (x + t);
    }
    if (Math.abs(t) < EPS * x) {
      break;
    }
  }
  return x;
}
const normal = {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) - Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },
  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + erf((x - mean) / Math.sqrt(2 * std * std)));
  },
  inv: function (p, mean, std) {
    return -1.41421356237309505 * std * erfcinv(2 * p) + mean;
  }
};
const beta = {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0) {
      return 0;
    }
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1) {
      return 1;
    }
    if (alpha < 512 && beta < 512) {
      return Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1) / betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) + (beta - 1) * Math.log(1 - x) - betaln(alpha, beta));
    }
  },
  cdf: function cdf(x, alpha, beta) {
    return x > 1 || x < 0 ? +(x > 1) : ibeta(x, alpha, beta);
  },
  inv: function inv(x, alpha, beta) {
    return ibetainv(x, alpha, beta);
  }
};
function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0) {
    return undefined;
  }
  // make sure x + y doesn't exceed the upper limit of usable values
  return x + y > 170 ? Math.exp(betaln(x, y)) : gammafn(x) * gammafn(y) / gammafn(x + y);
}
function betaln(x, y) {
  return gammaln(x) + gammaln(y) - gammaln(x + y);
}
function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0) {
    return 0;
  }
  if (p >= 1) {
    return 1;
  }
  if (a >= 1 && b >= 1) {
    pp = p < 0.5 ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5) {
      x = -x;
    }
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1) + 1 / (2 * b - 1));
    w = x * Math.sqrt(al + h) / h - (1 / (2 * b - 1) - 1 / (2 * a - 1)) * (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w) {
      x = Math.pow(a * w * p, 1 / a);
    } else {
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
    }
  }
  afac = -gammaln(a) - gammaln(b) + gammaln(a + b);
  for (; j < 10; j++) {
    if (x === 0 || x === 1) {
      return x;
    }
    // @ts-ignore
    err = ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x))));
    if (x <= 0) {
      x = 0.5 * (x + t);
    }
    if (x >= 1) {
      x = 0.5 * (x + t + 1);
    }
    if (Math.abs(t) < EPS * x && j > 0) {
      break;
    }
  }
  return x;
}
function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = x === 0 || x === 1 ? 0 : Math.exp(gammaln(a + b) - gammaln(a) - gammaln(b) + a * Math.log(x) + b * Math.log(1 - x));
  if (x < 0 || x > 1) {
    return false;
  }
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    {
      return bt * betacf(x, a, b) / a;
    }
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * betacf(1 - x, b, a) / b;
}
function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;
  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin) {
    d = fpmin;
  }
  d = 1 / d;
  h = d;
  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin) {
      d = fpmin;
    }
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin) {
      c = fpmin;
    }
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7) {
      break;
    }
  }
  return h;
}
const binomial = {
  pdf: function (k, n, p) {
    return p === 0 || p === 1 ? n * p === k ? 1 : 0 : combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },
  cdf: function (x, n, p) {
    var betacdf;
    var eps = 1e-10;
    if (x < 0) {
      return 0;
    }
    if (x >= n) {
      return 1;
    }
    if (p < 0 || p > 1 || n <= 0) {
      return NaN;
    }
    x = Math.floor(x);
    var z = p;
    var a = x + 1;
    var b = n - x;
    var s = a + b;
    var bt = Math.exp(gammaln(s) - gammaln(b) - gammaln(a) + a * Math.log(z) + b * Math.log(1 - z));
    if (z < (a + 1) / (s + 2)) {
      betacdf = bt * betinc(z, a, b, eps);
    } else {
      betacdf = 1 - bt * betinc(1 - z, b, a, eps);
    }
    return Math.round((1 - betacdf) * (1 / eps)) / (1 / eps);
  }
};
function betinc(x, a, b, eps) {
  var a0 = 0;
  var b0 = 1;
  var a1 = 1;
  var b1 = 1;
  var m9 = 0;
  var a2 = 0;
  var c9;
  while (Math.abs((a1 - a2) / a1) > eps) {
    a2 = a1;
    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);
    a0 = a1 + c9 * a0;
    b0 = b1 + c9 * b0;
    m9 = m9 + 1;
    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);
    a1 = a0 + c9 * a1;
    b1 = b0 + c9 * b1;
    a0 = a0 / b1;
    b0 = b0 / b1;
    a1 = a1 / b1;
    b1 = 1;
  }
  return a1 / a;
}
function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return n > 170 || m > 170 ? Math.exp(combinationln(n, m)) : factorial(n) / factorial(m) / factorial(n - m);
}
function combinationln(n, m) {
  return factorialln(n) - factorialln(m) - factorialln(n - m);
}
// natural log factorial of n
function factorialln(n) {
  return n < 0 ? NaN : gammaln(n + 1);
}
// factorial of n
function factorial(n) {
  return n < 0 ? NaN : gammafn(n + 1);
}
const chisquare = {
  pdf: function pdf(x, dof) {
    if (x < 0) {
      return 0;
    }
    return x === 0 && dof === 2 ? 0.5 : Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - dof / 2 * Math.log(2) - gammaln(dof / 2));
  },
  cdf: function cdf(x, dof) {
    if (x < 0) {
      return 0;
    }
    return lowRegGamma(dof / 2, x / 2);
  },
  inv: function (p, dof) {
    return 2 * gammapinv(p, 0.5 * dof);
  }
};
const centralF = {
  // This implementation of the pdf function avoids float overflow
  // See the way that R calculates this value:
  // https://svn.r-project.org/R/trunk/src/nmath/df.c
  pdf: function pdf(x, df1, df2) {
    var p, q, f;
    if (x < 0) {
      return 0;
    }
    if (df1 <= 2) {
      if (x === 0 && df1 < 2) {
        return Infinity;
      }
      if (x === 0 && df1 === 2) {
        return 1;
      }
      return 1 / betafn(df1 / 2, df2 / 2) * Math.pow(df1 / df2, df1 / 2) * Math.pow(x, df1 / 2 - 1) * Math.pow(1 + df1 / df2 * x, -(df1 + df2) / 2);
    }
    p = df1 * x / (df2 + x * df1);
    q = df2 / (df2 + x * df1);
    f = df1 * q / 2.0;
    return f * binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
  },
  cdf: function cdf(x, df1, df2) {
    if (x < 0) {
      return 0;
    }
    return ibeta(df1 * x / (df1 * x + df2), df1 / 2, df2 / 2);
  },
  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / ibetainv(x, df1 / 2, df2 / 2) - 1));
  }
};
const weibull = {
  pdf: function pdf(x, scale, shape) {
    if (x < 0 || scale < 0 || shape < 0) {
      return 0;
    }
    return shape / scale * Math.pow(x / scale, shape - 1) * Math.exp(-Math.pow(x / scale, shape));
  },
  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow(x / scale, shape));
  }
};
const poisson = {
  pdf: function pdf(k, l) {
    if (l < 0 || k % 1 !== 0 || k < 0) {
      return 0;
    }
    return Math.pow(l, k) * Math.exp(-l) / factorial(k);
  },
  cdf: function cdf(x, l) {
    var k = 0;
    if (x < 0) {
      return 0;
    }
    var sum = 0;
    for (; k <= x; k++) {
      sum += poisson.pdf(k, l);
    }
    return sum;
  }
};
const hypgeom = {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.
    // A simplification of the CDF algorithm below.
    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population
    // if(k !== k | 0) {
    //   return false;
    // } else
    if (k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if (k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.
      if (n * 2 > N) {
        // More than half the population is sampled.
        return hypgeom.pdf(N - m - n + k, N, N - m, N - n);
      } else {
        // Half or less of the population is sampled.
        return hypgeom.pdf(n - k, N, N - m, n);
      }
    } else if (n * 2 > N) {
      // Half or less is successes.
      return hypgeom.pdf(m - k, N, m, N - n);
    } else if (m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.
      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.
      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;
      // This keeps track of how much we have normalized.
      var samplesDone = 0;
      for (var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...
        while (scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.
          scaledPDF *= 1 - m / (N - samplesDone);
          // Say we've normalized by this sample already.
          samplesDone++;
        }
        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }
      for (; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - m / (N - samplesDone);
      }
      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },
  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.
    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.
    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population
    if (x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if (x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.
      if (n * 2 > N) {
        // More than half the population is sampled.
        return cdf(N - m - n + x, N, N - m, N - n);
      } else {
        // Half or less of the population is sampled.
        return 1 - hypgeom.cdf(n - x - 1, N, N - m, n);
      }
    } else if (n * 2 > N) {
      // Half or less is successes.
      return 1 - hypgeom.cdf(m - x - 1, N, m, N - n);
    } else if (m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.
      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.
      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;
      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;
      // This keeps track of how much we have normalized.
      var samplesDone = 0;
      for (var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...
        while (scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.
          var factor = 1 - m / (N - samplesDone);
          scaledPDF *= factor;
          scaledCDF *= factor;
          // Say we've normalized by this sample already.
          samplesDone++;
        }
        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }
      for (; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - m / (N - samplesDone);
      }
      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
};
const studentt = {
  pdf: function pdf(x, dof) {
    dof = dof > 1e100 ? 1e100 : dof;
    return 1 / (Math.sqrt(dof) * betafn(0.5, dof / 2)) * Math.pow(1 + x * x / dof, -((dof + 1) / 2));
  },
  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return ibeta((x + Math.sqrt(x * x + dof)) / (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },
  inv: function (p, dof) {
    var x = ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return p > 0.5 ? x : -x;
  }
};
const lognormal = {
  pdf: function pdf(x, mu, sigma) {
    if (x <= 0) {
      return 0;
    }
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) - Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) / (2 * sigma * sigma));
  },
  cdf: function cdf(x, mu, sigma) {
    if (x < 0) {
      return 0;
    }
    return 0.5 + 0.5 * erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma));
  },
  inv: function (p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * erfcinv(2 * p) + mu);
  }
};
const negbin = {
  pdf: function pdf(k, r, p) {
    if (k !== k >>> 0) {
      return false;
    }
    if (k < 0) {
      return 0;
    }
    return combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);
  },
  cdf: function cdf(x, r, p) {
    var sum = 0,
      k = 0;
    if (x < 0) {
      return 0;
    }
    for (; k <= x; k++) {
      sum += negbin.pdf(k, r, p);
    }
    return sum;
  }
};
function sum(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0) {
    sum += arr[i];
  }
  return sum;
}
function mean(arr) {
  return sum(arr) / arr.length;
}
function sumsqerr(arr) {
  var meanv = mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - meanv;
    sum += tmp * tmp;
  }
  return sum;
}
function variance(arr, flag) {
  return sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
}
function stdev(arr, flag) {
  return Math.sqrt(variance(arr, flag));
}
// 2 different parameter setups
// (value, alpha, sd, n)
// (value, alpha, array)
function normalci() {
  var args = [].slice.call(arguments),
    ans = new Array(2),
    change;
  if (args.length === 4) {
    change = Math.abs(normal.inv(args[1] / 2, 0, 1) * args[2] / Math.sqrt(args[3]));
  } else {
    // @ts-ignore
    change = Math.abs(normal.inv(args[1] / 2, 0, 1) * stdev(args[2]) / Math.sqrt(args[2].length));
  }
  ans[0] = args[0] - change;
  ans[1] = args[0] + change;
  return ans;
}
function tci() {
  var args = [].slice.call(arguments),
    ans = new Array(2),
    change;
  if (args.length === 4) {
    change = Math.abs(studentt.inv(args[1] / 2, args[3] - 1) * args[2] / Math.sqrt(args[3]));
  } else {
    // @ts-ignore
    change = Math.abs(studentt.inv(args[1] / 2, args[2].length - 1) * stdev(args[2], true) / Math.sqrt(args[2].length));
  }
  ans[0] = args[0] - change;
  ans[1] = args[0] + change;
  return ans;
}
function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0) {
    prod *= arr[i];
  }
  return prod;
}
function geomean(arr) {
  return Math.pow(product(arr), 1 / arr.length);
}
function covariance(arr1, arr2) {
  var u = mean(arr1);
  var v = mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;
  for (i = 0; i < arr1Len; i++) {
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);
  }
  return sum(sq_dev) / (arr1Len - 1);
}
function corrcoeff(arr1, arr2) {
  return covariance(arr1, arr2) / stdev(arr1, 1) / stdev(arr2, 1);
}

/***/ }),
/* 193 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MathPlugin: () => (/* binding */ MathPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */



class MathPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionPlugin {
  fact(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FACT'), arg => {
      arg = Math.trunc(arg);
      let ret = 1;
      for (let i = 1; i <= arg; i++) {
        ret *= i;
      }
      return ret;
    });
  }
  factdouble(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('FACTDOUBLE'), arg => {
      arg = Math.trunc(arg);
      let ret = 1;
      for (let i = arg; i >= 1; i -= 2) {
        ret *= i;
      }
      return ret;
    });
  }
  combin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COMBIN'), (n, m) => {
      if (m > n) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.WrongOrder);
      }
      n = Math.trunc(n);
      m = Math.trunc(m);
      return combin(n, m);
    });
  }
  combina(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COMBINA'), (n, m) => {
      n = Math.trunc(n);
      m = Math.trunc(m);
      if (n + m - 1 >= 1030) {
        //Product #2 does not enforce this
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      if (n === 0 && m === 0) {
        return 1;
      }
      return combin(n + m - 1, m);
    });
  }
  gcd(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GCD'), (...args) => {
      const processedArgs = this.arithmeticHelper.coerceNumbersCoerceRangesDropNulls(args);
      if (processedArgs instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return processedArgs;
      }
      let ret = 0;
      for (const val of processedArgs) {
        if (val < 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
        }
        ret = binaryGCD(ret, Math.trunc(val));
      }
      if (ret > Number.MAX_SAFE_INTEGER) {
        //inconsistency with product #1
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      return ret;
    });
  }
  lcm(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('LCM'), (...args) => {
      const processedArgs = this.arithmeticHelper.coerceNumbersCoerceRangesDropNulls(args);
      if (processedArgs instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return processedArgs;
      }
      let ret = 1;
      for (const val of processedArgs) {
        if (val < 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
        }
        ret = binaryLCM(ret, Math.trunc(val));
      }
      if (ret > Number.MAX_SAFE_INTEGER) {
        //inconsistency with product #1
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueLarge);
      }
      return ret;
    });
  }
  mround(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MROUND'), (nom, denom) => {
      if (denom === 0) {
        return 0;
      }
      if (nom > 0 && denom < 0 || nom < 0 && denom > 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.DistinctSigns);
      }
      return Math.round(nom / denom) * denom;
    });
  }
  multinomial(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('MULTINOMIAL'), (...args) => {
      let n = 0;
      let ans = 1;
      for (let arg of args) {
        if (arg < 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
        }
        arg = Math.trunc(arg);
        for (let i = 1; i <= arg; i++) {
          ans *= (n + i) / i;
        }
        n += arg;
      }
      return Math.round(ans);
    });
  }
  quotient(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('QUOTIENT'), (nom, denom) => {
      if (denom === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      return Math.trunc(nom / denom);
    });
  }
  seriessum(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SERIESSUM'), (x, n, m, range) => {
      const coefs = this.arithmeticHelper.manyToOnlyNumbersDropNulls(range.valuesFromTopLeftCorner());
      if (coefs instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coefs;
      }
      let ret = 0;
      coefs.reverse();
      for (const coef of coefs) {
        ret *= Math.pow(x, m);
        ret += coef;
      }
      return ret * Math.pow(x, n);
    });
  }
  sign(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SIGN'), arg => {
      if (arg > 0) {
        return 1;
      } else if (arg < 0) {
        return -1;
      } else {
        return 0;
      }
    });
  }
  sumx2my2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUMX2MY2'), (rangeX, rangeY) => {
      const valsX = rangeX.valuesFromTopLeftCorner();
      const valsY = rangeY.valuesFromTopLeftCorner();
      if (valsX.length !== valsY.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const n = valsX.length;
      let ret = 0;
      for (let i = 0; i < n; i++) {
        const valX = valsX[i];
        const valY = valsY[i];
        if (valX instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return valX;
        }
        if (valY instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return valY;
        }
        if (typeof valX === 'number' && typeof valY === 'number') {
          ret += Math.pow(valX, 2) - Math.pow(valY, 2);
        }
      }
      return ret;
    });
  }
  sumx2py2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUMX2PY2'), (rangeX, rangeY) => {
      const valsX = rangeX.valuesFromTopLeftCorner();
      const valsY = rangeY.valuesFromTopLeftCorner();
      if (valsX.length !== valsY.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const n = valsX.length;
      let ret = 0;
      for (let i = 0; i < n; i++) {
        const valX = valsX[i];
        const valY = valsY[i];
        if (valX instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return valX;
        }
        if (valY instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return valY;
        }
        if (typeof valX === 'number' && typeof valY === 'number') {
          ret += Math.pow(valX, 2) + Math.pow(valY, 2);
        }
      }
      return ret;
    });
  }
  sumxmy2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SUMXMY2'), (rangeX, rangeY) => {
      const valsX = rangeX.valuesFromTopLeftCorner();
      const valsY = rangeY.valuesFromTopLeftCorner();
      if (valsX.length !== valsY.length) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const n = valsX.length;
      let ret = 0;
      for (let i = 0; i < n; i++) {
        const valX = valsX[i];
        const valY = valsY[i];
        if (valX instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return valX;
        }
        if (valY instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
          return valY;
        }
        if (typeof valX === 'number' && typeof valY === 'number') {
          ret += Math.pow(valX - valY, 2);
        }
      }
      return ret;
    });
  }
}
MathPlugin.implementedFunctions = {
  'FACT': {
    method: 'fact',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 170
    }]
  },
  'FACTDOUBLE': {
    method: 'factdouble',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      minValue: 0,
      maxValue: 288
    }]
  },
  'COMBIN': {
    method: 'combin',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      minValue: 0,
      lessThan: 1030
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'COMBINA': {
    method: 'combina',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      minValue: 0
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER,
      minValue: 0
    }]
  },
  'GCD': {
    method: 'gcd',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'LCM': {
    method: 'lcm',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'MROUND': {
    method: 'mround',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'MULTINOMIAL': {
    method: 'multinomial',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }],
    repeatLastArgs: 1,
    expandRanges: true
  },
  'QUOTIENT': {
    method: 'quotient',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'SERIESSUM': {
    method: 'seriessum',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }]
  },
  'SIGN': {
    method: 'sign',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.NUMBER
    }]
  },
  'SUMX2MY2': {
    method: 'sumx2my2',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }]
  },
  'SUMX2PY2': {
    method: 'sumx2py2',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }]
  },
  'SUMXMY2': {
    method: 'sumxmy2',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_2__.FunctionArgumentType.RANGE
    }]
  }
};
function combin(n, m) {
  if (2 * m > n) {
    m = n - m;
  }
  let ret = 1;
  for (let i = 1; i <= m; i++) {
    ret *= (n - m + i) / i;
  }
  return Math.round(ret);
}
function binaryGCD(a, b) {
  if (a < b) {
    [a, b] = [b, a];
  }
  while (b > 0) {
    [a, b] = [b, a % b];
  }
  return a;
}
function binaryLCM(a, b) {
  if (a === 0 || b === 0) {
    return 0;
  }
  return a * (b / binaryGCD(a, b));
}

/***/ }),
/* 194 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComplexPlugin: () => (/* binding */ ComplexPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */




class ComplexPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionPlugin {
  complex(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COMPLEX'), (re, im, unit) => {
      if (unit !== 'i' && unit !== 'j') {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.VALUE, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ShouldBeIorJ);
      }
      return (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)([re, im], unit);
    });
  }
  imabs(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMABS'), abs);
  }
  imaginary(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMAGINARY'), ([_re, im]) => im);
  }
  imreal(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMREAL'), ([re, _im]) => re);
  }
  imargument(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMARGUMENT'), ([re, im]) => {
      if (re === 0 && im === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      return Math.atan2(im, re);
    });
  }
  imconjugate(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCONJUGATE'), ([re, im]) => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)([re, -im]));
  }
  imcos(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCOS'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(cos(arg)));
  }
  imcosh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCOSH'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(cosh(arg)));
  }
  imcot(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCOT'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(div(cos(arg), sin(arg))));
  }
  imcsc(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCSC'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(div([1, 0], sin(arg))));
  }
  imcsch(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMCSCH'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(div([1, 0], sinh(arg))));
  }
  imsec(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSEC'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(div([1, 0], cos(arg))));
  }
  imsech(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSECH'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(div([1, 0], cosh(arg))));
  }
  imsin(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSIN'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(sin(arg)));
  }
  imsinh(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSINH'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(sinh(arg)));
  }
  imtan(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMTAN'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(div(sin(arg), cos(arg))));
  }
  imdiv(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMDIV'), (arg1, arg2) => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(div(arg1, arg2)));
  }
  improduct(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMPRODUCT'), (...args) => {
      const coerced = this.arithmeticHelper.coerceComplexExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      let prod = [1, 0];
      for (const val of coerced) {
        prod = mul(prod, val);
      }
      return (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(prod);
    });
  }
  imsum(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSUM'), (...args) => {
      const coerced = this.arithmeticHelper.coerceComplexExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      let sum = [0, 0];
      for (const val of coerced) {
        sum = add(sum, val);
      }
      return (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(sum);
    });
  }
  imsub(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSUB'), (arg1, arg2) => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(sub(arg1, arg2)));
  }
  imexp(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMEXP'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(exp(arg)));
  }
  imln(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMLN'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(ln(arg)));
  }
  imlog10(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMLOG10'), arg => {
      const [re, im] = ln(arg);
      const c = Math.log(10);
      return (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)([re / c, im / c]);
    });
  }
  imlog2(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMLOG2'), arg => {
      const [re, im] = ln(arg);
      const c = Math.log(2);
      return (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)([re / c, im / c]);
    });
  }
  impower(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMPOWER'), (arg, n) => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(power(arg, n)));
  }
  imsqrt(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('IMSQRT'), arg => (0,_ArithmeticHelper__WEBPACK_IMPORTED_MODULE_2__.coerceComplexToString)(power(arg, 0.5)));
  }
}
ComplexPlugin.implementedFunctions = {
  'COMPLEX': {
    method: 'complex',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.STRING,
      defaultValue: 'i'
    }]
  },
  'IMABS': {
    method: 'imabs',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMAGINARY': {
    method: 'imaginary',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMREAL': {
    method: 'imreal',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMARGUMENT': {
    method: 'imargument',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMCONJUGATE': {
    method: 'imconjugate',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMCOS': {
    method: 'imcos',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMCOSH': {
    method: 'imcosh',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMCOT': {
    method: 'imcot',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMCSC': {
    method: 'imcsc',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMCSCH': {
    method: 'imcsch',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMSEC': {
    method: 'imsec',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMSECH': {
    method: 'imsech',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMSIN': {
    method: 'imsin',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMSINH': {
    method: 'imsinh',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMTAN': {
    method: 'imtan',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMDIV': {
    method: 'imdiv',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMPRODUCT': {
    method: 'improduct',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'IMSUM': {
    method: 'imsum',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'IMSUB': {
    method: 'imsub',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMEXP': {
    method: 'imexp',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMLN': {
    method: 'imln',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMLOG10': {
    method: 'imlog10',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMLOG2': {
    method: 'imlog2',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  },
  'IMPOWER': {
    method: 'impower',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.NUMBER
    }]
  },
  'IMSQRT': {
    method: 'imsqrt',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_3__.FunctionArgumentType.COMPLEX
    }]
  }
};
function add([re1, im1], [re2, im2]) {
  return [re1 + re2, im1 + im2];
}
function sub([re1, im1], [re2, im2]) {
  return [re1 - re2, im1 - im2];
}
function mul([re1, im1], [re2, im2]) {
  return [re1 * re2 - im1 * im2, re1 * im2 + re2 * im1];
}
function div([re1, im1], [re2, im2]) {
  const denom = Math.pow(re2, 2) + Math.pow(im2, 2);
  const [nomRe, nomIm] = mul([re1, im1], [re2, -im2]);
  return [nomRe / denom, nomIm / denom];
}
function cos([re, im]) {
  return [Math.cos(re) * Math.cosh(im), -Math.sin(re) * Math.sinh(im)];
}
function cosh([re, im]) {
  return [Math.cosh(re) * Math.cos(im), Math.sinh(re) * Math.sin(im)];
}
function sin([re, im]) {
  return [Math.sin(re) * Math.cosh(im), Math.cos(re) * Math.sinh(im)];
}
function sinh([re, im]) {
  return [Math.sinh(re) * Math.cos(im), Math.cosh(re) * Math.sin(im)];
}
function exp([re, im]) {
  return [Math.exp(re) * Math.cos(im), Math.exp(re) * Math.sin(im)];
}
function abs([re, im]) {
  return Math.sqrt(re * re + im * im);
}
function ln([re, im]) {
  return [Math.log(abs([re, im])), Math.atan2(im, re)];
}
function power(arg, n) {
  const [re, im] = ln(arg);
  return exp([n * re, n * im]);
}

/***/ }),
/* 195 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StatisticalAggregationPlugin: () => (/* binding */ StatisticalAggregationPlugin)
/* harmony export */ });
/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _InterpreterValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(192);
/* harmony import */ var _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(97);
/**
 * @license
 * Copyright (c) 2024 Handsoncode. All rights reserved.
 */





class StatisticalAggregationPlugin extends _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionPlugin {
  avedev(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('AVEDEV'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      if (coerced.length === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      const avg = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(coerced);
      return coerced.reduce((a, b) => a + Math.abs(b - avg), 0) / coerced.length;
    });
  }
  devsq(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('DEVSQ'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      if (coerced.length === 0) {
        return 0;
      }
      return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.sumsqerr)(coerced);
    });
  }
  geomean(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('GEOMEAN'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      if (coerced.length === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.OneValue);
      }
      for (const val of coerced) {
        if (val <= 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
        }
      }
      return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.geomean)(coerced);
    });
  }
  harmean(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('HARMEAN'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      if (coerced.length === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.OneValue);
      }
      for (const val of coerced) {
        if (val <= 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ValueSmall);
        }
      }
      return coerced.length / coerced.reduce((a, b) => a + 1 / b, 0);
    });
  }
  correl(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CORREL'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
      }
      return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.corrcoeff)(ret[0], ret[1]);
    });
  }
  rsq(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('RSQ'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
      }
      return Math.pow((0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.corrcoeff)(ret[0], ret[1]), 2);
    });
  }
  covariancep(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COVARIANCE.P'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.OneValue);
      }
      if (n === 1) {
        return 0;
      }
      return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.covariance)(ret[0], ret[1]) * (n - 1) / n;
    });
  }
  covariances(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('COVARIANCE.S'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
      }
      return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.covariance)(ret[0], ret[1]);
    });
  }
  ztest(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('Z.TEST'), (range, x, sigma) => {
      const vals = this.arithmeticHelper.manyToExactNumbers(range.valuesFromTopLeftCorner());
      if (vals instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return vals;
      }
      const n = vals.length;
      if (sigma === undefined) {
        if (n < 2) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
        }
        sigma = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.stdev)(vals, true);
      }
      if (n < 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.OneValue);
      }
      if (sigma === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      return 1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.normal.cdf(((0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(vals) - x) / (sigma / Math.sqrt(n)), 0, 1);
    });
  }
  ftest(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('F.TEST'), (dataX, dataY) => {
      const arrX = this.arithmeticHelper.manyToExactNumbers(dataX.valuesFromTopLeftCorner());
      const arrY = this.arithmeticHelper.manyToExactNumbers(dataY.valuesFromTopLeftCorner());
      if (arrX instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return arrX;
      }
      if (arrY instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return arrY;
      }
      if (arrX.length <= 1 || arrY.length <= 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      const vx = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.variance)(arrX, true);
      const vy = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.variance)(arrY, true);
      if (vx === 0 || vy === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      const r = vx / vy;
      const v = _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.centralF.cdf(r, arrX.length - 1, arrY.length - 1);
      return 2 * Math.min(v, 1 - v);
    });
  }
  steyx(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('STEYX'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 2) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ThreeValues);
      }
      return Math.sqrt(((0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.sumsqerr)(ret[0]) - Math.pow((0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.covariance)(ret[0], ret[1]) * (n - 1), 2) / (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.sumsqerr)(ret[1])) / (n - 2));
    });
  }
  slope(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SLOPE'), (dataX, dataY) => {
      if (dataX.numberOfElements() !== dataY.numberOfElements()) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return ret;
      }
      const n = ret[0].length;
      if (n <= 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
      }
      return (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.covariance)(ret[0], ret[1]) * (n - 1) / (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.sumsqerr)(ret[1]);
    });
  }
  chisqtest(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('CHISQ.TEST'), (dataX, dataY) => {
      const r = dataX.height();
      const c = dataX.width();
      if (dataY.height() !== r || dataY.width() !== c) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
      }
      const ret = parseTwoArrays(dataX, dataY);
      if (ret instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return ret;
      }
      if (ret[0].length <= 1) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
      }
      let sum = 0;
      for (let i = 0; i < ret[0].length; i++) {
        if (ret[1][i] === 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
        }
        sum += Math.pow(ret[0][i] - ret[1][i], 2) / ret[1][i];
      }
      if (sum < 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NUM, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.NaN);
      }
      return 1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.chisquare.cdf(sum, r > 1 && c > 1 ? (r - 1) * (c - 1) : r * c - 1);
    });
  }
  ttest(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('T.TEST'), (dataX, dataY, tails, type) => {
      const arrX = this.arithmeticHelper.manyToExactNumbers(dataX.valuesFromTopLeftCorner());
      const arrY = this.arithmeticHelper.manyToExactNumbers(dataY.valuesFromTopLeftCorner());
      if (arrX instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return arrX;
      }
      if (arrY instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return arrY;
      }
      const n = arrX.length;
      const m = arrY.length;
      if (type === 1) {
        if (m !== n) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.NA, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.EqualLength);
        }
        if (n <= 1) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
        }
        const sub = Array(n);
        for (let i = 0; i < n; i++) {
          sub[i] = arrX[i] - arrY[i];
        }
        const s = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.stdev)(sub, true);
        if (s === 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
        }
        const t = Math.abs(Math.sqrt(n) * (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(sub) / s);
        return tails * (1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.cdf(t, n - 1));
      } else if (type === 2) {
        if (n <= 1 || m <= 1) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
        }
        const s = ((0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.sumsqerr)(arrX) + (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.sumsqerr)(arrY)) / (n + m - 2);
        if (s === 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
        }
        const t = Math.abs(((0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(arrX) - (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(arrY)) / Math.sqrt(s * (1 / n + 1 / m)));
        return tails * (1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.cdf(t, n + m - 2));
      } else {
        //type === 3
        if (n <= 1 || m <= 1) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.TwoValues);
        }
        const sx = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.variance)(arrX, true);
        const sy = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.variance)(arrY, true);
        if (sx === 0 && sy === 0) {
          return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
        }
        const t = Math.abs(((0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(arrX) - (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(arrY)) / Math.sqrt(sx / n + sy / m));
        const v = Math.pow(sx / n + sy / m, 2) / (Math.pow(sx / n, 2) / (n - 1) + Math.pow(sy / m, 2) / (m - 1));
        return tails * (1 - _3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.studentt.cdf(t, v));
      }
    });
  }
  skew(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SKEW'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      const n = coerced.length;
      if (n < 3) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ThreeValues);
      }
      const avg = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(coerced);
      const s = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.stdev)(coerced, true);
      if (s === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      return coerced.reduce((a, b) => a + Math.pow((b - avg) / s, 3), 0) * n / (n - 1) / (n - 2);
    });
  }
  skewp(ast, state) {
    return this.runFunction(ast.args, state, this.metadata('SKEW.P'), (...args) => {
      const coerced = this.arithmeticHelper.coerceNumbersExactRanges(args);
      if (coerced instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
        return coerced;
      }
      const n = coerced.length;
      if (n < 3) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO, _error_message__WEBPACK_IMPORTED_MODULE_1__.ErrorMessage.ThreeValues);
      }
      const avg = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.mean)(coerced);
      const s = (0,_3rdparty_jstat_jstat__WEBPACK_IMPORTED_MODULE_3__.stdev)(coerced, false);
      if (s === 0) {
        return new _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError(_Cell__WEBPACK_IMPORTED_MODULE_0__.ErrorType.DIV_BY_ZERO);
      }
      return coerced.reduce((a, b) => a + Math.pow((b - avg) / s, 3), 0) / n;
    });
  }
}
StatisticalAggregationPlugin.implementedFunctions = {
  'AVEDEV': {
    method: 'avedev',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'DEVSQ': {
    method: 'devsq',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'GEOMEAN': {
    method: 'geomean',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'HARMEAN': {
    method: 'harmean',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'CORREL': {
    method: 'correl',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }]
  },
  'RSQ': {
    method: 'rsq',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }]
  },
  'COVARIANCE.P': {
    method: 'covariancep',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }]
  },
  'COVARIANCE.S': {
    method: 'covariances',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }]
  },
  'Z.TEST': {
    method: 'ztest',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.NUMBER,
      optionalArg: true
    }]
  },
  'F.TEST': {
    method: 'ftest',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }]
  },
  'STEYX': {
    method: 'steyx',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }]
  },
  'SLOPE': {
    method: 'slope',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }]
  },
  'CHISQ.TEST': {
    method: 'chisqtest',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }]
  },
  'T.TEST': {
    method: 'ttest',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.RANGE
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.INTEGER,
      minValue: 1,
      maxValue: 2
    }, {
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.INTEGER,
      minValue: 1,
      maxValue: 3
    }]
  },
  'SKEW': {
    method: 'skew',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  },
  'SKEW.P': {
    method: 'skewp',
    parameters: [{
      argumentType: _FunctionPlugin__WEBPACK_IMPORTED_MODULE_4__.FunctionArgumentType.ANY
    }],
    repeatLastArgs: 1
  }
};
StatisticalAggregationPlugin.aliases = {
  COVAR: 'COVARIANCE.P',
  FTEST: 'F.TEST',
  PEARSON: 'CORREL',
  ZTEST: 'Z.TEST',
  CHITEST: 'CHISQ.TEST',
  TTEST: 'T.TEST',
  COVARIANCEP: 'COVARIANCE.P',
  COVARIANCES: 'COVARIANCE.S',
  SKEWP: 'SKEW.P'
};
function parseTwoArrays(dataX, dataY) {
  const xit = dataX.iterateValuesFromTopLeftCorner();
  const yit = dataY.iterateValuesFromTopLeftCorner();
  let x, y;
  const arrX = [];
  const arrY = [];
  while (x = xit.next(), y = yit.next(), !x.done && !y.done) {
    const xval = x.value;
    const yval = y.value;
    if (xval instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return xval;
    } else if (yval instanceof _Cell__WEBPACK_IMPORTED_MODULE_0__.CellError) {
      return yval;
    } else if ((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.isExtendedNumber)(xval) && (0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.isExtendedNumber)(yval)) {
      arrX.push((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.getRawValue)(xval));
      arrY.push((0,_InterpreterValue__WEBPACK_IMPORTED_MODULE_2__.getRawValue)(yval));
    }
  }
  return [arrX, arrY];
}

/***/ }),
/* 196 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _base = _interopRequireWildcard(__webpack_require__(198));
exports.CellCoords = _base.CellCoords;
exports.CellRange = _base.CellRange;
var _registry = __webpack_require__(760);
var _eventManager = _interopRequireWildcard(__webpack_require__(522));
var _translations = __webpack_require__(621);
var _jquery = _interopRequireDefault(__webpack_require__(1083));
var _ghostTable = _interopRequireDefault(__webpack_require__(839));
var parseTableHelpers = _interopRequireWildcard(__webpack_require__(524));
var arrayHelpers = _interopRequireWildcard(__webpack_require__(495));
var browserHelpers = _interopRequireWildcard(__webpack_require__(498));
var dataHelpers = _interopRequireWildcard(__webpack_require__(618));
var dateHelpers = _interopRequireWildcard(__webpack_require__(806));
var featureHelpers = _interopRequireWildcard(__webpack_require__(502));
var functionHelpers = _interopRequireWildcard(__webpack_require__(497));
var mixedHelpers = _interopRequireWildcard(__webpack_require__(354));
var numberHelpers = _interopRequireWildcard(__webpack_require__(534));
var objectHelpers = _interopRequireWildcard(__webpack_require__(499));
var stringHelpers = _interopRequireWildcard(__webpack_require__(352));
var unicodeHelpers = _interopRequireWildcard(__webpack_require__(508));
var domHelpers = _interopRequireWildcard(__webpack_require__(351));
var domEventHelpers = _interopRequireWildcard(__webpack_require__(509));
var _registry2 = __webpack_require__(510);
var _registry3 = __webpack_require__(537);
var _registry4 = __webpack_require__(538);
var _registry5 = __webpack_require__(671);
var _registry6 = __webpack_require__(532);
var _base2 = __webpack_require__(837);
var _Handsontable$cellTyp, _Handsontable$editors, _Handsontable$rendere, _Handsontable$validat, _Handsontable$plugins;
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
(0, _registry.registerAllModules)();
(0, _jquery.default)(_base.default);

// TODO: Remove this exports after rewrite tests about this module
_base.default.__GhostTable = _ghostTable.default;
_base.default._getListenersCounter = _eventManager.getListenersCounter; // For MemoryLeak tests
_base.default._getRegisteredMapsCounter = _translations.getRegisteredMapsCounter; // For MemoryLeak tests
_base.default.EventManager = _eventManager.default;

// Export all helpers to the Handsontable object
const HELPERS = [arrayHelpers, browserHelpers, dataHelpers, dateHelpers, featureHelpers, functionHelpers, mixedHelpers, numberHelpers, objectHelpers, stringHelpers, unicodeHelpers, parseTableHelpers];
const DOM = [domHelpers, domEventHelpers];
_base.default.helper = {};
_base.default.dom = {};

// Fill general helpers.
arrayHelpers.arrayEach(HELPERS, helper => {
  arrayHelpers.arrayEach(Object.getOwnPropertyNames(helper), key => {
    if (key.charAt(0) !== '_') {
      _base.default.helper[key] = helper[key];
    }
  });
});

// Fill DOM helpers.
arrayHelpers.arrayEach(DOM, helper => {
  arrayHelpers.arrayEach(Object.getOwnPropertyNames(helper), key => {
    if (key.charAt(0) !== '_') {
      _base.default.dom[key] = helper[key];
    }
  });
});

// Export cell types.
_base.default.cellTypes = (_Handsontable$cellTyp = _base.default.cellTypes) !== null && _Handsontable$cellTyp !== void 0 ? _Handsontable$cellTyp : {};
arrayHelpers.arrayEach((0, _registry5.getRegisteredCellTypeNames)(), cellTypeName => {
  _base.default.cellTypes[cellTypeName] = (0, _registry5.getCellType)(cellTypeName);
});
_base.default.cellTypes.registerCellType = _registry5.registerCellType;
_base.default.cellTypes.getCellType = _registry5.getCellType;

// Export all registered editors from the Handsontable.
_base.default.editors = (_Handsontable$editors = _base.default.editors) !== null && _Handsontable$editors !== void 0 ? _Handsontable$editors : {};
arrayHelpers.arrayEach((0, _registry2.getRegisteredEditorNames)(), editorName => {
  _base.default.editors[`${stringHelpers.toUpperCaseFirst(editorName)}Editor`] = (0, _registry2.getEditor)(editorName);
});
_base.default.editors.registerEditor = _registry2.registerEditor;
_base.default.editors.getEditor = _registry2.getEditor;

// Export all registered renderers from the Handsontable.
_base.default.renderers = (_Handsontable$rendere = _base.default.renderers) !== null && _Handsontable$rendere !== void 0 ? _Handsontable$rendere : {};
arrayHelpers.arrayEach((0, _registry3.getRegisteredRendererNames)(), rendererName => {
  const renderer = (0, _registry3.getRenderer)(rendererName);
  if (rendererName === 'base') {
    _base.default.renderers.cellDecorator = renderer;
  }
  _base.default.renderers[`${stringHelpers.toUpperCaseFirst(rendererName)}Renderer`] = renderer;
});
_base.default.renderers.registerRenderer = _registry3.registerRenderer;
_base.default.renderers.getRenderer = _registry3.getRenderer;

// Export all registered validators from the Handsontable.
_base.default.validators = (_Handsontable$validat = _base.default.validators) !== null && _Handsontable$validat !== void 0 ? _Handsontable$validat : {};
arrayHelpers.arrayEach((0, _registry4.getRegisteredValidatorNames)(), validatorName => {
  _base.default.validators[`${stringHelpers.toUpperCaseFirst(validatorName)}Validator`] = (0, _registry4.getValidator)(validatorName);
});
_base.default.validators.registerValidator = _registry4.registerValidator;
_base.default.validators.getValidator = _registry4.getValidator;

// Export all registered plugins from the Handsontable.
// Make sure to initialize the plugin dictionary as an empty object. Otherwise, while
// transpiling the files into ES and CommonJS format, the injected CoreJS helper
// `import "core-js/modules/es.object.get-own-property-names";` won't be processed
// by the `./config/plugin/babel/add-import-extension` babel plugin. Thus, the distribution
// files will be broken. The reason is not known right now (probably it's caused by bug in
// the Babel or missing something in the plugin).
_base.default.plugins = (_Handsontable$plugins = _base.default.plugins) !== null && _Handsontable$plugins !== void 0 ? _Handsontable$plugins : {};
arrayHelpers.arrayEach((0, _registry6.getPluginsNames)(), pluginName => {
  _base.default.plugins[pluginName] = (0, _registry6.getPlugin)(pluginName);
});
_base.default.plugins[`${stringHelpers.toUpperCaseFirst(_base2.BasePlugin.PLUGIN_KEY)}Plugin`] = _base2.BasePlugin;
_base.default.plugins.registerPlugin = _registry6.registerPlugin;
_base.default.plugins.getPlugin = _registry6.getPlugin;
var _default = exports["default"] = _base.default;

/***/ }),
/* 197 */
/***/ ((module) => {

function _interopRequireDefault(e) {
  return e && e.__esModule ? e : {
    "default": e
  };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 198 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(199);
var _core = _interopRequireDefault(__webpack_require__(200));
var _rootInstance = __webpack_require__(616);
var _dataMap = __webpack_require__(664);
var _hooks = __webpack_require__(511);
var _registry = __webpack_require__(642);
var _registry2 = __webpack_require__(671);
var _textType = __webpack_require__(750);
var _baseEditor = __webpack_require__(689);
var _src = __webpack_require__(540);
exports.CellCoords = _src.CellCoords;
exports.CellRange = _src.CellRange;
// FIXME: Bug in eslint-plugin-import: https://github.com/benmosher/eslint-plugin-import/issues/1883
/* eslint-disable import/named */

/* eslint-enable import/named */

// register default mandatory cell type for the Base package
(0, _registry2.registerCellType)(_textType.TextCellType);

// export the `BaseEditor` class to the Handsontable global namespace
Handsontable.editors = {
  BaseEditor: _baseEditor.BaseEditor
};

/**
 * @param {HTMLElement} rootElement The element to which the Handsontable instance is injected.
 * @param {object} userSettings The user defined options.
 * @returns {Core}
 */
function Handsontable(rootElement, userSettings) {
  const instance = new _core.default(rootElement, userSettings || {}, _rootInstance.rootInstanceSymbol);
  instance.init();
  return instance;
}
Handsontable.Core = function (rootElement) {
  let userSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new _core.default(rootElement, userSettings, _rootInstance.rootInstanceSymbol);
};
Handsontable.DefaultSettings = (0, _dataMap.metaSchemaFactory)();
Handsontable.hooks = _hooks.Hooks.getSingleton();
Handsontable.CellCoords = _src.CellCoords;
Handsontable.CellRange = _src.CellRange;
Handsontable.packageName = 'handsontable';
Handsontable.buildDate = "16/12/2024 13:19:40";
Handsontable.version = "15.0.0";
Handsontable.languages = {
  dictionaryKeys: _registry.dictionaryKeys,
  getLanguageDictionary: _registry.getLanguageDictionary,
  getLanguagesDictionaries: _registry.getLanguagesDictionaries,
  registerLanguageDictionary: _registry.registerLanguageDictionary,
  getTranslatedPhrase: _registry.getTranslatedPhrase
};
var _default = exports["default"] = Handsontable;

/***/ }),
/* 199 */
/***/ (() => {



/***/ }),
/* 200 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports["default"] = Core;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(323);
__webpack_require__(329);
__webpack_require__(338);
__webpack_require__(341);
var _element = __webpack_require__(351);
var _function = __webpack_require__(497);
var _mixed = __webpack_require__(354);
var _browser = __webpack_require__(498);
var _editorManager = _interopRequireDefault(__webpack_require__(503));
var _eventManager = _interopRequireDefault(__webpack_require__(522));
var _object = __webpack_require__(499);
var _focusManager = __webpack_require__(523);
var _array = __webpack_require__(495);
var _parseTable = __webpack_require__(524);
var _registry = __webpack_require__(532);
var _registry2 = __webpack_require__(537);
var _registry3 = __webpack_require__(510);
var _registry4 = __webpack_require__(538);
var _string = __webpack_require__(352);
var _number = __webpack_require__(534);
var _tableView = _interopRequireDefault(__webpack_require__(539));
var _dataSource = _interopRequireDefault(__webpack_require__(617));
var _data = __webpack_require__(618);
var _translations = __webpack_require__(621);
var _rootInstance = __webpack_require__(616);
var _src = __webpack_require__(540);
var _hooks = __webpack_require__(511);
var _registry5 = __webpack_require__(642);
var _utils = __webpack_require__(643);
var _selection = __webpack_require__(648);
var _dataMap = __webpack_require__(664);
var _index3 = __webpack_require__(680);
var _uniqueMap = __webpack_require__(535);
var _shortcuts = __webpack_require__(743);
var _shortcutContexts = __webpack_require__(682);
var _themes = __webpack_require__(749);
let activeGuid = null;

/**
 * Keeps the collection of the all Handsontable instances created on the same page. The
 * list is then used to trigger the "afterUnlisten" hook when the "listen()" method was
 * called on another instance.
 *
 * @type {Map<string, Core>}
 */
const foreignHotInstances = new Map();

/**
 * A set of deprecated feature names.
 *
 * @type {Set<string>}
 */
// eslint-disable-next-line no-unused-vars
const deprecationWarns = new Set();

/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * Handsontable constructor.
 *
 * @core
 * @class Core
 * @description
 *
 * The `Handsontable` class (known as the `Core`) lets you modify the grid's behavior by using Handsontable's public API methods.
 *
 * ::: only-for react
 * To use these methods, associate a Handsontable instance with your instance
 * of the [`HotTable` component](@/guides/getting-started/installation/installation.md#_4-use-the-hottable-component),
 * by using React's `ref` feature (read more on the [Instance methods](@/guides/getting-started/react-methods/react-methods.md) page).
 * :::
 *
 * ## How to call a method
 *
 * ::: only-for javascript
 * ```js
 * // create a Handsontable instance
 * const hot = new Handsontable(document.getElementById('example'), options);
 *
 * // call a method
 * hot.setDataAtCell(0, 0, 'new value');
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * import { useRef } from 'react';
 *
 * const hotTableComponent = useRef(null);
 *
 * <HotTable
 *   // associate your `HotTable` component with a Handsontable instance
 *   ref={hotTableComponent}
 *   settings={options}
 * />
 *
 * // access the Handsontable instance, under the `.current.hotInstance` property
 * // call a method
 * hotTableComponent.current.hotInstance.setDataAtCell(0, 0, 'new value');
 * ```
 * :::
 *
 * @param {HTMLElement} rootElement The element to which the Handsontable instance is injected.
 * @param {object} userSettings The user defined options.
 * @param {boolean} [rootInstanceSymbol=false] Indicates if the instance is root of all later instances created.
 */
function Core(rootElement, userSettings) {
  var _userSettings$layoutD,
    _this = this;
  let rootInstanceSymbol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let instance = this;
  const eventManager = new _eventManager.default(instance);
  let datamap;
  let dataSource;
  let grid;
  let editorManager;
  let focusManager;
  let viewportScroller;
  let firstRun = true;
  if ((0, _rootInstance.hasValidParameter)(rootInstanceSymbol)) {
    (0, _rootInstance.registerAsRootInstance)(this);
  }

  // TODO: check if references to DOM elements should be move to UI layer (Walkontable)
  /**
   * Reference to the container element.
   *
   * @private
   * @type {HTMLElement}
   */
  this.rootElement = rootElement;
  /**
   * The nearest document over container.
   *
   * @private
   * @type {Document}
   */
  this.rootDocument = rootElement.ownerDocument;
  /**
   * Window object over container's document.
   *
   * @private
   * @type {Window}
   */
  this.rootWindow = this.rootDocument.defaultView;
  /**
   * A boolean to tell if the Handsontable has been fully destroyed. This is set to `true`
   * after `afterDestroy` hook is called.
   *
   * @memberof Core#
   * @member isDestroyed
   * @type {boolean}
   */
  this.isDestroyed = false;
  /**
   * The counter determines how many times the render suspending was called. It allows
   * tracking the nested suspending calls. For each render suspend resuming call the
   * counter is decremented. The value equal to 0 means the render suspending feature
   * is disabled.
   *
   * @private
   * @type {number}
   */
  this.renderSuspendedCounter = 0;
  /**
   * The counter determines how many times the execution suspending was called. It allows
   * tracking the nested suspending calls. For each execution suspend resuming call the
   * counter is decremented. The value equal to 0 means the execution suspending feature
   * is disabled.
   *
   * @private
   * @type {number}
   */
  this.executionSuspendedCounter = 0;
  const layoutDirection = (_userSettings$layoutD = userSettings === null || userSettings === void 0 ? void 0 : userSettings.layoutDirection) !== null && _userSettings$layoutD !== void 0 ? _userSettings$layoutD : 'inherit';
  const rootElementDirection = ['rtl', 'ltr'].includes(layoutDirection) ? layoutDirection : this.rootWindow.getComputedStyle(this.rootElement).direction;
  this.rootElement.setAttribute('dir', rootElementDirection);

  /**
   * Checks if the grid is rendered using the right-to-left layout direction.
   *
   * @since 12.0.0
   * @memberof Core#
   * @function isRtl
   * @returns {boolean} True if RTL.
   */
  this.isRtl = function () {
    return rootElementDirection === 'rtl';
  };

  /**
   * Checks if the grid is rendered using the left-to-right layout direction.
   *
   * @since 12.0.0
   * @memberof Core#
   * @function isLtr
   * @returns {boolean} True if LTR.
   */
  this.isLtr = function () {
    return !instance.isRtl();
  };

  /**
   * Returns 1 for LTR; -1 for RTL. Useful for calculations.
   *
   * @since 12.0.0
   * @memberof Core#
   * @function getDirectionFactor
   * @returns {number} Returns 1 for LTR; -1 for RTL.
   */
  this.getDirectionFactor = function () {
    return instance.isLtr() ? 1 : -1;
  };
  userSettings.language = (0, _registry5.getValidLanguageCode)(userSettings.language);
  const metaManager = new _dataMap.MetaManager(instance, userSettings, [_dataMap.DynamicCellMetaMod, _dataMap.ExtendMetaPropertiesMod]);
  const tableMeta = metaManager.getTableMeta();
  const globalMeta = metaManager.getGlobalMeta();
  const pluginsRegistry = (0, _uniqueMap.createUniqueMap)();
  this.container = this.rootDocument.createElement('div');
  this.renderCall = false;
  rootElement.insertBefore(this.container, rootElement.firstChild);
  if ((0, _rootInstance.isRootInstance)(this)) {
    (0, _mixed._injectProductInfo)(userSettings.licenseKey, rootElement);
    (0, _element.addClass)(rootElement, 'ht-wrapper');
  }
  this.guid = `ht_${(0, _string.randomString)()}`; // this is the namespace for global events

  foreignHotInstances.set(this.guid, this);

  /**
   * Instance of index mapper which is responsible for managing the column indexes.
   *
   * @memberof Core#
   * @member columnIndexMapper
   * @type {IndexMapper}
   */
  this.columnIndexMapper = new _translations.IndexMapper();
  /**
   * Instance of index mapper which is responsible for managing the row indexes.
   *
   * @memberof Core#
   * @member rowIndexMapper
   * @type {IndexMapper}
   */
  this.rowIndexMapper = new _translations.IndexMapper();
  this.columnIndexMapper.addLocalHook('indexesSequenceChange', source => {
    instance.runHooks('afterColumnSequenceChange', source);
  });
  this.rowIndexMapper.addLocalHook('indexesSequenceChange', source => {
    instance.runHooks('afterRowSequenceChange', source);
  });
  dataSource = new _dataSource.default(instance);
  if (!this.rootElement.id || this.rootElement.id.substring(0, 3) === 'ht_') {
    this.rootElement.id = this.guid; // if root element does not have an id, assign a random id
  }
  const visualToRenderableCoords = coords => {
    const {
      row: visualRow,
      col: visualColumn
    } = coords;
    return instance._createCellCoords(
    // We just store indexes for rows and columns without headers.
    visualRow >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRow) : visualRow, visualColumn >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumn) : visualColumn);
  };
  const renderableToVisualCoords = coords => {
    const {
      row: renderableRow,
      col: renderableColumn
    } = coords;
    return instance._createCellCoords(
    // We just store indexes for rows and columns without headers.
    renderableRow >= 0 ? instance.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow, renderableColumn >= 0 ? instance.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn // eslint-disable-line max-len
    );
  };
  const findFirstNonHiddenRenderableRow = (visualRowFrom, visualRowTo) => {
    const dir = visualRowTo > visualRowFrom ? 1 : -1;
    const minIndex = Math.min(visualRowFrom, visualRowTo);
    const maxIndex = Math.max(visualRowFrom, visualRowTo);
    const rowIndex = instance.rowIndexMapper.getNearestNotHiddenIndex(visualRowFrom, dir);
    if (rowIndex === null || dir === 1 && rowIndex > maxIndex || dir === -1 && rowIndex < minIndex) {
      return null;
    }
    return rowIndex >= 0 ? instance.rowIndexMapper.getRenderableFromVisualIndex(rowIndex) : rowIndex;
  };
  const findFirstNonHiddenRenderableColumn = (visualColumnFrom, visualColumnTo) => {
    const dir = visualColumnTo > visualColumnFrom ? 1 : -1;
    const minIndex = Math.min(visualColumnFrom, visualColumnTo);
    const maxIndex = Math.max(visualColumnFrom, visualColumnTo);
    const columnIndex = instance.columnIndexMapper.getNearestNotHiddenIndex(visualColumnFrom, dir);
    if (columnIndex === null || dir === 1 && columnIndex > maxIndex || dir === -1 && columnIndex < minIndex) {
      return null;
    }
    return columnIndex >= 0 ? instance.columnIndexMapper.getRenderableFromVisualIndex(columnIndex) : columnIndex;
  };
  let selection = new _selection.Selection(tableMeta, {
    rowIndexMapper: instance.rowIndexMapper,
    columnIndexMapper: instance.columnIndexMapper,
    countCols: () => instance.countCols(),
    countRows: () => instance.countRows(),
    propToCol: prop => datamap.propToCol(prop),
    isEditorOpened: () => instance.getActiveEditor() ? instance.getActiveEditor().isOpened() : false,
    countRenderableColumns: () => this.view.countRenderableColumns(),
    countRenderableRows: () => this.view.countRenderableRows(),
    countRowHeaders: () => this.countRowHeaders(),
    countColHeaders: () => this.countColHeaders(),
    countRenderableRowsInRange: function () {
      return _this.view.countRenderableRowsInRange(...arguments);
    },
    countRenderableColumnsInRange: function () {
      return _this.view.countRenderableColumnsInRange(...arguments);
    },
    getShortcutManager: () => instance.getShortcutManager(),
    createCellCoords: (row, column) => instance._createCellCoords(row, column),
    createCellRange: (highlight, from, to) => instance._createCellRange(highlight, from, to),
    visualToRenderableCoords,
    renderableToVisualCoords,
    findFirstNonHiddenRenderableRow,
    findFirstNonHiddenRenderableColumn,
    isDisabledCellSelection: (visualRow, visualColumn) => {
      if (visualRow < 0 || visualColumn < 0) {
        return instance.getSettings().disableVisualSelection;
      }
      return instance.getCellMeta(visualRow, visualColumn).disableVisualSelection;
    }
  });
  this.selection = selection;
  const onIndexMapperCacheUpdate = _ref => {
    let {
      hiddenIndexesChanged
    } = _ref;
    if (hiddenIndexesChanged) {
      this.selection.commit();
    }
  };
  this.columnIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);
  this.rowIndexMapper.addLocalHook('cacheUpdated', onIndexMapperCacheUpdate);
  this.selection.addLocalHook('afterSetRangeEnd', (cellCoords, isLastSelectionLayer) => {
    const preventScrolling = (0, _object.createObjectPropListener)(false);
    const selectionRange = this.selection.getSelectedRange();
    const {
      from,
      to
    } = selectionRange.current();
    const selectionLayerLevel = selectionRange.size() - 1;
    this.runHooks('afterSelection', from.row, from.col, to.row, to.col, preventScrolling, selectionLayerLevel);
    this.runHooks('afterSelectionByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), preventScrolling, selectionLayerLevel);
    if (isLastSelectionLayer && (!preventScrolling.isTouched() || preventScrolling.isTouched() && !preventScrolling.value)) {
      viewportScroller.scrollTo(cellCoords);
    }
    const isSelectedByRowHeader = selection.isSelectedByRowHeader();
    const isSelectedByColumnHeader = selection.isSelectedByColumnHeader();

    // @TODO: These CSS classes are no longer needed anymore. They are used only as a indicator of the selected
    // rows/columns in the MergedCells plugin (via border.js#L520 in the walkontable module). After fixing
    // the Border class this should be removed.
    if (isSelectedByRowHeader && isSelectedByColumnHeader) {
      (0, _element.addClass)(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);
    } else if (isSelectedByRowHeader) {
      (0, _element.removeClass)(this.rootElement, 'ht__selection--columns');
      (0, _element.addClass)(this.rootElement, 'ht__selection--rows');
    } else if (isSelectedByColumnHeader) {
      (0, _element.removeClass)(this.rootElement, 'ht__selection--rows');
      (0, _element.addClass)(this.rootElement, 'ht__selection--columns');
    } else {
      (0, _element.removeClass)(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);
    }
    if (selection.getSelectionSource() !== 'shift') {
      editorManager.closeEditor(null);
    }
    instance.view.render();
    editorManager.prepareEditor();
  });
  this.selection.addLocalHook('beforeSetFocus', cellCoords => {
    this.runHooks('beforeSelectionFocusSet', cellCoords.row, cellCoords.col);
  });
  this.selection.addLocalHook('afterSetFocus', cellCoords => {
    const preventScrolling = (0, _object.createObjectPropListener)(false);
    this.runHooks('afterSelectionFocusSet', cellCoords.row, cellCoords.col, preventScrolling);
    if (!preventScrolling.isTouched() || preventScrolling.isTouched() && !preventScrolling.value) {
      viewportScroller.scrollTo(cellCoords);
    }
    editorManager.closeEditor();
    instance.view.render();
    editorManager.prepareEditor();
  });
  this.selection.addLocalHook('afterSelectionFinished', cellRanges => {
    const selectionLayerLevel = cellRanges.length - 1;
    const {
      from,
      to
    } = cellRanges[selectionLayerLevel];
    this.runHooks('afterSelectionEnd', from.row, from.col, to.row, to.col, selectionLayerLevel);
    this.runHooks('afterSelectionEndByProp', from.row, instance.colToProp(from.col), to.row, instance.colToProp(to.col), selectionLayerLevel);
  });
  this.selection.addLocalHook('afterIsMultipleSelection', isMultiple => {
    const changedIsMultiple = this.runHooks('afterIsMultipleSelection', isMultiple.value);
    if (isMultiple.value) {
      isMultiple.value = changedIsMultiple;
    }
  });
  this.selection.addLocalHook('afterDeselect', () => {
    editorManager.closeEditor();
    instance.view.render();
    (0, _element.removeClass)(this.rootElement, ['ht__selection--rows', 'ht__selection--columns']);
    this.runHooks('afterDeselect');
  });
  this.selection.addLocalHook('beforeHighlightSet', () => this.runHooks('beforeSelectionHighlightSet')).addLocalHook('beforeSetRangeStart', function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _this.runHooks('beforeSetRangeStart', ...args);
  }).addLocalHook('beforeSetRangeStartOnly', function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return _this.runHooks('beforeSetRangeStartOnly', ...args);
  }).addLocalHook('beforeSetRangeEnd', function () {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return _this.runHooks('beforeSetRangeEnd', ...args);
  }).addLocalHook('beforeSelectColumns', function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return _this.runHooks('beforeSelectColumns', ...args);
  }).addLocalHook('afterSelectColumns', function () {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return _this.runHooks('afterSelectColumns', ...args);
  }).addLocalHook('beforeSelectRows', function () {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return _this.runHooks('beforeSelectRows', ...args);
  }).addLocalHook('afterSelectRows', function () {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return _this.runHooks('afterSelectRows', ...args);
  }).addLocalHook('beforeModifyTransformStart', function () {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return _this.runHooks('modifyTransformStart', ...args);
  }).addLocalHook('afterModifyTransformStart', function () {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return _this.runHooks('afterModifyTransformStart', ...args);
  }).addLocalHook('beforeModifyTransformFocus', function () {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return _this.runHooks('modifyTransformFocus', ...args);
  }).addLocalHook('afterModifyTransformFocus', function () {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return _this.runHooks('afterModifyTransformFocus', ...args);
  }).addLocalHook('beforeModifyTransformEnd', function () {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return _this.runHooks('modifyTransformEnd', ...args);
  }).addLocalHook('afterModifyTransformEnd', function () {
    for (var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      args[_key13] = arguments[_key13];
    }
    return _this.runHooks('afterModifyTransformEnd', ...args);
  }).addLocalHook('beforeRowWrap', function () {
    for (var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {
      args[_key14] = arguments[_key14];
    }
    return _this.runHooks('beforeRowWrap', ...args);
  }).addLocalHook('beforeColumnWrap', function () {
    for (var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++) {
      args[_key15] = arguments[_key15];
    }
    return _this.runHooks('beforeColumnWrap', ...args);
  }).addLocalHook('insertRowRequire', totalRows => this.alter('insert_row_above', totalRows, 1, 'auto')).addLocalHook('insertColRequire', totalCols => this.alter('insert_col_start', totalCols, 1, 'auto'));
  grid = {
    /**
     * Inserts or removes rows and columns.
     *
     * @private
     * @param {string} action Possible values: "insert_row_above", "insert_row_below", "insert_col_start", "insert_col_end",
     *                        "remove_row", "remove_col".
     * @param {number|Array} index Row or column visual index which from the alter action will be triggered.
     *                             Alter actions such as "remove_row" and "remove_col" support array indexes in the
     *                             format `[[index, amount], [index, amount]...]` this can be used to remove
     *                             non-consecutive columns or rows in one call.
     * @param {number} [amount=1] Amount of rows or columns to remove.
     * @param {string} [source] Optional. Source of hook runner.
     * @param {boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
     */
    alter(action, index) {
      var _index, _index2;
      let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      let source = arguments.length > 3 ? arguments[3] : undefined;
      let keepEmptyRows = arguments.length > 4 ? arguments[4] : undefined;
      const normalizeIndexesGroup = indexes => {
        if (indexes.length === 0) {
          return [];
        }
        const sortedIndexes = [...indexes];

        // Sort the indexes in ascending order.
        sortedIndexes.sort((_ref2, _ref3) => {
          let [indexA] = _ref2;
          let [indexB] = _ref3;
          if (indexA === indexB) {
            return 0;
          }
          return indexA > indexB ? 1 : -1;
        });

        // Normalize the {index, amount} groups into bigger groups.
        const normalizedIndexes = (0, _array.arrayReduce)(sortedIndexes, (acc, _ref4) => {
          let [groupIndex, groupAmount] = _ref4;
          const previousItem = acc[acc.length - 1];
          const [prevIndex, prevAmount] = previousItem;
          const prevLastIndex = prevIndex + prevAmount;
          if (groupIndex <= prevLastIndex) {
            const amountToAdd = Math.max(groupAmount - (prevLastIndex - groupIndex), 0);
            previousItem[1] += amountToAdd;
          } else {
            acc.push([groupIndex, groupAmount]);
          }
          return acc;
        }, [sortedIndexes[0]]);
        return normalizedIndexes;
      };

      /* eslint-disable no-case-declarations */
      switch (action) {
        case 'insert_row_below':
        case 'insert_row_above':
          const numberOfSourceRows = instance.countSourceRows();
          if (tableMeta.maxRows === numberOfSourceRows) {
            return;
          }

          // `above` is the default behavior for creating new rows
          const insertRowMode = action === 'insert_row_below' ? 'below' : 'above';

          // Calling the `insert_row_above` action adds a new row at the beginning of the data set.
          // eslint-disable-next-line no-param-reassign
          index = (_index = index) !== null && _index !== void 0 ? _index : insertRowMode === 'below' ? numberOfSourceRows : 0;
          const {
            delta: rowDelta,
            startPhysicalIndex: startRowPhysicalIndex
          } = datamap.createRow(index, amount, {
            source,
            mode: insertRowMode
          });
          selection.shiftRows(instance.toVisualRow(startRowPhysicalIndex), rowDelta);
          break;
        case 'insert_col_start':
        case 'insert_col_end':
          // "start" is a default behavior for creating new columns
          const insertColumnMode = action === 'insert_col_end' ? 'end' : 'start';

          // Calling the `insert_col_start` action adds a new column to the left of the data set.
          // eslint-disable-next-line no-param-reassign
          index = (_index2 = index) !== null && _index2 !== void 0 ? _index2 : insertColumnMode === 'end' ? instance.countSourceCols() : 0;
          const {
            delta: colDelta,
            startPhysicalIndex: startColumnPhysicalIndex
          } = datamap.createCol(index, amount, {
            source,
            mode: insertColumnMode
          });
          if (colDelta) {
            if (Array.isArray(tableMeta.colHeaders)) {
              const spliceArray = [instance.toVisualColumn(startColumnPhysicalIndex), 0];
              spliceArray.length += colDelta; // inserts empty (undefined) elements at the end of an array
              Array.prototype.splice.apply(tableMeta.colHeaders, spliceArray); // inserts empty (undefined) elements into the colHeader array
            }
            selection.shiftColumns(instance.toVisualColumn(startColumnPhysicalIndex), colDelta);
          }
          break;
        case 'remove_row':
          const removeRow = indexes => {
            let offset = 0;

            // Normalize the {index, amount} groups into bigger groups.
            (0, _array.arrayEach)(indexes, _ref5 => {
              let [groupIndex, groupAmount] = _ref5;
              const calcIndex = (0, _mixed.isEmpty)(groupIndex) ? instance.countRows() - 1 : Math.max(groupIndex - offset, 0);

              // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value
              // compatible with datamap.removeCol method.
              if (Number.isInteger(groupIndex)) {
                // eslint-disable-next-line no-param-reassign
                groupIndex = Math.max(groupIndex - offset, 0);
              }

              // TODO: for datamap.removeRow index should be passed as it is (with undefined and null values). If not, the logic
              // inside the datamap.removeRow breaks the removing functionality.
              const wasRemoved = datamap.removeRow(groupIndex, groupAmount, source);
              if (!wasRemoved) {
                return;
              }
              if (selection.isSelected()) {
                const {
                  row
                } = instance.getSelectedRangeLast().highlight;
                if (row >= groupIndex && row <= groupIndex + groupAmount - 1) {
                  editorManager.closeEditor(true);
                }
              }
              const totalRows = instance.countRows();
              if (totalRows === 0) {
                selection.deselect();
              } else if (source === 'ContextMenu.removeRow') {
                selection.refresh();
              } else {
                selection.shiftRows(groupIndex, -groupAmount);
              }
              const fixedRowsTop = tableMeta.fixedRowsTop;
              if (fixedRowsTop >= calcIndex + 1) {
                tableMeta.fixedRowsTop -= Math.min(groupAmount, fixedRowsTop - calcIndex);
              }
              const fixedRowsBottom = tableMeta.fixedRowsBottom;
              if (fixedRowsBottom && calcIndex >= totalRows - fixedRowsBottom) {
                tableMeta.fixedRowsBottom -= Math.min(groupAmount, fixedRowsBottom);
              }
              offset += groupAmount;
            });
          };
          if (Array.isArray(index)) {
            removeRow(normalizeIndexesGroup(index));
          } else {
            removeRow([[index, amount]]);
          }
          break;
        case 'remove_col':
          const removeCol = indexes => {
            let offset = 0;

            // Normalize the {index, amount} groups into bigger groups.
            (0, _array.arrayEach)(indexes, _ref6 => {
              let [groupIndex, groupAmount] = _ref6;
              const calcIndex = (0, _mixed.isEmpty)(groupIndex) ? instance.countCols() - 1 : Math.max(groupIndex - offset, 0);
              let physicalColumnIndex = instance.toPhysicalColumn(calcIndex);

              // If the 'index' is an integer decrease it by 'offset' otherwise pass it through to make the value
              // compatible with datamap.removeCol method.
              if (Number.isInteger(groupIndex)) {
                // eslint-disable-next-line no-param-reassign
                groupIndex = Math.max(groupIndex - offset, 0);
              }

              // TODO: for datamap.removeCol index should be passed as it is (with undefined and null values). If not, the logic
              // inside the datamap.removeCol breaks the removing functionality.
              const wasRemoved = datamap.removeCol(groupIndex, groupAmount, source);
              if (!wasRemoved) {
                return;
              }
              if (selection.isSelected()) {
                const {
                  col
                } = instance.getSelectedRangeLast().highlight;
                if (col >= groupIndex && col <= groupIndex + groupAmount - 1) {
                  editorManager.closeEditor(true);
                }
              }
              const totalColumns = instance.countCols();
              if (totalColumns === 0) {
                selection.deselect();
              } else if (source === 'ContextMenu.removeColumn') {
                selection.refresh();
              } else {
                selection.shiftColumns(groupIndex, -groupAmount);
              }
              const fixedColumnsStart = tableMeta.fixedColumnsStart;
              if (fixedColumnsStart >= calcIndex + 1) {
                tableMeta.fixedColumnsStart -= Math.min(groupAmount, fixedColumnsStart - calcIndex);
              }
              if (Array.isArray(tableMeta.colHeaders)) {
                if (typeof physicalColumnIndex === 'undefined') {
                  physicalColumnIndex = -1;
                }
                tableMeta.colHeaders.splice(physicalColumnIndex, groupAmount);
              }
              offset += groupAmount;
            });
          };
          if (Array.isArray(index)) {
            removeCol(normalizeIndexesGroup(index));
          } else {
            removeCol([[index, amount]]);
          }
          break;
        default:
          throw new Error(`There is no such action "${action}"`);
      }
      instance.view.render();
      if (!keepEmptyRows) {
        grid.adjustRowsAndCols(); // makes sure that we did not add rows that will be removed in next refresh
      }
    },
    /**
     * Makes sure there are empty rows at the bottom of the table.
     *
     * @private
     */
    adjustRowsAndCols() {
      const minRows = tableMeta.minRows;
      const minSpareRows = tableMeta.minSpareRows;
      const minCols = tableMeta.minCols;
      const minSpareCols = tableMeta.minSpareCols;
      if (minRows) {
        // should I add empty rows to data source to meet minRows?
        const nrOfRows = instance.countRows();
        if (nrOfRows < minRows) {
          // The synchronization with cell meta is not desired here. For `minRows` option,
          // we don't want to touch/shift cell meta objects.
          datamap.createRow(nrOfRows, minRows - nrOfRows, {
            source: 'auto'
          });
        }
      }
      if (minSpareRows) {
        const emptyRows = instance.countEmptyRows(true);

        // should I add empty rows to meet minSpareRows?
        if (emptyRows < minSpareRows) {
          const emptyRowsMissing = minSpareRows - emptyRows;
          const rowsToCreate = Math.min(emptyRowsMissing, tableMeta.maxRows - instance.countSourceRows());

          // The synchronization with cell meta is not desired here. For `minSpareRows` option,
          // we don't want to touch/shift cell meta objects.
          datamap.createRow(instance.countRows(), rowsToCreate, {
            source: 'auto'
          });
        }
      }
      {
        let emptyCols;

        // count currently empty cols
        if (minCols || minSpareCols) {
          emptyCols = instance.countEmptyCols(true);
        }
        let nrOfColumns = instance.countCols();

        // should I add empty cols to meet minCols?
        if (minCols && !tableMeta.columns && nrOfColumns < minCols) {
          // The synchronization with cell meta is not desired here. For `minSpareRows` option,
          // we don't want to touch/shift cell meta objects.
          const colsToCreate = minCols - nrOfColumns;
          emptyCols += colsToCreate;
          datamap.createCol(nrOfColumns, colsToCreate, {
            source: 'auto'
          });
        }
        // should I add empty cols to meet minSpareCols?
        if (minSpareCols && !tableMeta.columns && instance.dataType === 'array' && emptyCols < minSpareCols) {
          nrOfColumns = instance.countCols();
          const emptyColsMissing = minSpareCols - emptyCols;
          const colsToCreate = Math.min(emptyColsMissing, tableMeta.maxCols - nrOfColumns);

          // The synchronization with cell meta is not desired here. For `minSpareRows` option,
          // we don't want to touch/shift cell meta objects.
          datamap.createCol(nrOfColumns, colsToCreate, {
            source: 'auto'
          });
        }
      }
      if (instance.view) {
        instance.view.adjustElementsSize();
      }
    },
    /**
     * Populate the data from the provided 2d array from the given cell coordinates.
     *
     * @private
     * @param {object} start Start selection position. Visual indexes.
     * @param {Array} input 2d data array.
     * @param {object} [end] End selection position (only for drag-down mode). Visual indexes.
     * @param {string} [source="populateFromArray"] Source information string.
     * @param {string} [method="overwrite"] Populate method. Possible options: `shift_down`, `shift_right`, `overwrite`.
     * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).
     */
    populateFromArray(start, input, end, source, method) {
      let r;
      let rlen;
      let c;
      let clen;
      const setData = [];
      const current = {};
      const newDataByColumns = [];
      const startRow = start.row;
      const startColumn = start.col;
      rlen = input.length;
      if (rlen === 0) {
        return false;
      }
      let columnsPopulationEnd = 0;
      let rowsPopulationEnd = 0;
      if ((0, _object.isObject)(end)) {
        columnsPopulationEnd = end.col - startColumn + 1;
        rowsPopulationEnd = end.row - startRow + 1;
      }

      // insert data with specified pasteMode method
      switch (method) {
        case 'shift_down':
          // translate data from a list of rows to a list of columns
          const populatedDataByColumns = (0, _array.pivot)(input);
          const numberOfDataColumns = populatedDataByColumns.length;
          // method's argument can extend the range of data population (data would be repeated)
          const numberOfColumnsToPopulate = Math.max(numberOfDataColumns, columnsPopulationEnd);
          const pushedDownDataByRows = instance.getData().slice(startRow);

          // translate data from a list of rows to a list of columns
          const pushedDownDataByColumns = (0, _array.pivot)(pushedDownDataByRows).slice(startColumn, startColumn + numberOfColumnsToPopulate);
          for (c = 0; c < numberOfColumnsToPopulate; c += 1) {
            if (c < numberOfDataColumns) {
              for (r = 0, rlen = populatedDataByColumns[c].length; r < rowsPopulationEnd - rlen; r += 1) {
                // repeating data for rows
                populatedDataByColumns[c].push(populatedDataByColumns[c][r % rlen]);
              }
              if (c < pushedDownDataByColumns.length) {
                newDataByColumns.push(populatedDataByColumns[c].concat(pushedDownDataByColumns[c]));
              } else {
                // if before data population, there was no data in the column
                // we fill the required rows' newly-created cells with `null` values
                newDataByColumns.push(populatedDataByColumns[c].concat(new Array(pushedDownDataByRows.length).fill(null)));
              }
            } else {
              // Repeating data for columns.
              newDataByColumns.push(populatedDataByColumns[c % numberOfDataColumns].concat(pushedDownDataByColumns[c]));
            }
          }
          instance.populateFromArray(startRow, startColumn, (0, _array.pivot)(newDataByColumns));
          break;
        case 'shift_right':
          const numberOfDataRows = input.length;
          // method's argument can extend the range of data population (data would be repeated)
          const numberOfRowsToPopulate = Math.max(numberOfDataRows, rowsPopulationEnd);
          const pushedRightDataByRows = instance.getData().slice(startRow).map(rowData => rowData.slice(startColumn));
          for (r = 0; r < numberOfRowsToPopulate; r += 1) {
            if (r < numberOfDataRows) {
              for (c = 0, clen = input[r].length; c < columnsPopulationEnd - clen; c += 1) {
                // repeating data for rows
                input[r].push(input[r][c % clen]);
              }
              if (r < pushedRightDataByRows.length) {
                for (let i = 0; i < pushedRightDataByRows[r].length; i += 1) {
                  input[r].push(pushedRightDataByRows[r][i]);
                }
              } else {
                // if before data population, there was no data in the row
                // we fill the required columns' newly-created cells with `null` values
                input[r].push(...new Array(pushedRightDataByRows[0].length).fill(null));
              }
            } else {
              // Repeating data for columns.
              input.push(input[r % rlen].slice(0, numberOfRowsToPopulate).concat(pushedRightDataByRows[r]));
            }
          }
          instance.populateFromArray(startRow, startColumn, input);
          break;
        case 'overwrite':
        default:
          // overwrite and other not specified options
          current.row = start.row;
          current.col = start.col;
          let skippedRow = 0;
          let skippedColumn = 0;
          let pushData = true;
          let cellMeta;
          const getInputValue = function getInputValue(row) {
            let col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            const rowValue = input[row % input.length];
            if (col !== null) {
              return rowValue[col % rowValue.length];
            }
            return rowValue;
          };
          const rowInputLength = input.length;
          const rowSelectionLength = end ? end.row - start.row + 1 : 0;
          if (end) {
            rlen = rowSelectionLength;
          } else {
            rlen = Math.max(rowInputLength, rowSelectionLength);
          }
          for (r = 0; r < rlen; r++) {
            if (end && current.row > end.row && rowSelectionLength > rowInputLength || !tableMeta.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= tableMeta.maxRows) {
              break;
            }
            const visualRow = r - skippedRow;
            const colInputLength = getInputValue(visualRow).length;
            const colSelectionLength = end ? end.col - start.col + 1 : 0;
            if (end) {
              clen = colSelectionLength;
            } else {
              clen = Math.max(colInputLength, colSelectionLength);
            }
            current.col = start.col;
            cellMeta = instance.getCellMeta(current.row, current.col);
            if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipRowOnPaste) {
              skippedRow += 1;
              current.row += 1;
              rlen += 1;
              /* eslint-disable no-continue */
              continue;
            }
            skippedColumn = 0;
            for (c = 0; c < clen; c++) {
              if (end && current.col > end.col && colSelectionLength > colInputLength || !tableMeta.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= tableMeta.maxCols) {
                break;
              }
              cellMeta = instance.getCellMeta(current.row, current.col);
              if ((source === 'CopyPaste.paste' || source === 'Autofill.fill') && cellMeta.skipColumnOnPaste) {
                skippedColumn += 1;
                current.col += 1;
                clen += 1;
                continue;
              }
              if (cellMeta.readOnly && source !== 'UndoRedo.undo') {
                current.col += 1;
                /* eslint-disable no-continue */
                continue;
              }
              const visualColumn = c - skippedColumn;
              let value = getInputValue(visualRow, visualColumn);
              let orgValue = instance.getDataAtCell(current.row, current.col);
              if (value !== null && typeof value === 'object') {
                // when 'value' is array and 'orgValue' is null, set 'orgValue' to
                // an empty array so that the null value can be compared to 'value'
                // as an empty value for the array context
                if (Array.isArray(value) && orgValue === null) {
                  orgValue = [];
                }
                if (orgValue === null || typeof orgValue !== 'object') {
                  pushData = false;
                } else {
                  const orgValueSchema = (0, _object.duckSchema)(Array.isArray(orgValue) ? orgValue : orgValue[0] || orgValue);
                  const valueSchema = (0, _object.duckSchema)(Array.isArray(value) ? value : value[0] || value);

                  // Allow overwriting values with the same object-based schema or any array-based schema.
                  if ((0, _object.isObjectEqual)(orgValueSchema, valueSchema) || Array.isArray(orgValueSchema) && Array.isArray(valueSchema)) {
                    value = (0, _object.deepClone)(value);
                  } else {
                    pushData = false;
                  }
                }
              } else if (orgValue !== null && typeof orgValue === 'object') {
                pushData = false;
              }
              if (pushData) {
                setData.push([current.row, current.col, value]);
              }
              pushData = true;
              current.col += 1;
            }
            current.row += 1;
          }
          instance.setDataAtCell(setData, null, null, source || 'populateFromArray');
          break;
      }
    }
  };

  /**
   * Internal function to set `language` key of settings.
   *
   * @private
   * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.
   * @fires Hooks#afterLanguageChange
   */
  function setLanguage(languageCode) {
    const normalizedLanguageCode = (0, _utils.normalizeLanguageCode)(languageCode);
    if ((0, _registry5.hasLanguageDictionary)(normalizedLanguageCode)) {
      instance.runHooks('beforeLanguageChange', normalizedLanguageCode);
      globalMeta.language = normalizedLanguageCode;
      instance.runHooks('afterLanguageChange', normalizedLanguageCode);
    } else {
      (0, _utils.warnUserAboutLanguageRegistration)(languageCode);
    }
  }

  /**
   * Internal function to set `className` or `tableClassName`, depending on the key from the settings object.
   *
   * @private
   * @param {string} className `className` or `tableClassName` from the key in the settings object.
   * @param {string|string[]} classSettings String or array of strings. Contains class name(s) from settings object.
   */
  function setClassName(className, classSettings) {
    const element = className === 'className' ? instance.rootElement : instance.table;
    if (firstRun) {
      (0, _element.addClass)(element, classSettings);
    } else {
      let globalMetaSettingsArray = [];
      let settingsArray = [];
      if (globalMeta[className]) {
        globalMetaSettingsArray = Array.isArray(globalMeta[className]) ? globalMeta[className] : (0, _array.stringToArray)(globalMeta[className]);
      }
      if (classSettings) {
        settingsArray = Array.isArray(classSettings) ? classSettings : (0, _array.stringToArray)(classSettings);
      }
      const classNameToRemove = (0, _array.getDifferenceOfArrays)(globalMetaSettingsArray, settingsArray);
      const classNameToAdd = (0, _array.getDifferenceOfArrays)(settingsArray, globalMetaSettingsArray);
      if (classNameToRemove.length) {
        (0, _element.removeClass)(element, classNameToRemove);
      }
      if (classNameToAdd.length) {
        (0, _element.addClass)(element, classNameToAdd);
      }
    }
    globalMeta[className] = classSettings;
  }
  this.init = function () {
    dataSource.setData(tableMeta.data);
    instance.runHooks('beforeInit');
    if ((0, _browser.isMobileBrowser)() || (0, _browser.isIpadOS)()) {
      (0, _element.addClass)(instance.rootElement, 'mobile');
    }
    this.updateSettings(tableMeta, true);
    this.view = new _tableView.default(this);
    const themeName = tableMeta.themeName || (0, _themes.getThemeClassName)(instance.rootElement);

    // Use the theme defined as a root element class or in the settings (in that order).
    instance.useTheme(themeName);

    // Add the theme class name to the license info element.
    instance.view.addClassNameToLicenseElement(instance.getCurrentThemeName());
    editorManager = _editorManager.default.getInstance(instance, tableMeta, selection);
    viewportScroller = (0, _index3.createViewportScroller)(instance);
    focusManager = new _focusManager.FocusManager(instance);
    if ((0, _rootInstance.isRootInstance)(this)) {
      (0, _index3.installFocusCatcher)(instance);
    }
    instance.runHooks('init');
    this.forceFullRender = true; // used when data was changed
    this.view.render();

    // Run the logic only if it's the table's initialization and the root element is not visible.
    if (!!firstRun && instance.rootElement.offsetParent === null) {
      (0, _element.observeVisibilityChangeOnce)(instance.rootElement, () => {
        // Update the spreader size cache before rendering.
        instance.view._wt.wtOverlays.updateLastSpreaderSize();
        instance.render();
        instance.view.adjustElementsSize();
      });
    }
    if (typeof firstRun === 'object') {
      instance.runHooks('afterChange', firstRun[0], firstRun[1]);
      firstRun = false;
    }
    instance.runHooks('afterInit');
  };

  /**
   * @ignore
   * @returns {object}
   */
  function ValidatorsQueue() {
    // moved this one level up so it can be used in any function here. Probably this should be moved to a separate file
    let resolved = false;
    return {
      validatorsInQueue: 0,
      valid: true,
      addValidatorToQueue() {
        this.validatorsInQueue += 1;
        resolved = false;
      },
      removeValidatorFormQueue() {
        this.validatorsInQueue = this.validatorsInQueue - 1 < 0 ? 0 : this.validatorsInQueue - 1;
        this.checkIfQueueIsEmpty();
      },
      onQueueEmpty() {},
      checkIfQueueIsEmpty() {
        if (this.validatorsInQueue === 0 && resolved === false) {
          resolved = true;
          this.onQueueEmpty(this.valid);
        }
      }
    };
  }

  /**
   * Get parsed number from numeric string.
   *
   * @private
   * @param {string} numericData Float (separated by a dot or a comma) or integer.
   * @returns {number} Number if we get data in parsable format, not changed value otherwise.
   */
  function getParsedNumber(numericData) {
    // Unifying "float like" string. Change from value with comma determiner to value with dot determiner,
    // for example from `450,65` to `450.65`.
    const unifiedNumericData = numericData.replace(',', '.');
    if (isNaN(parseFloat(unifiedNumericData)) === false) {
      return parseFloat(unifiedNumericData);
    }
    return numericData;
  }

  /**
   * @ignore
   * @param {Array} changes The 2D array containing information about each of the edited cells.
   * @param {string} source The string that identifies source of validation.
   * @param {Function} callback The callback function fot async validation.
   */
  function validateChanges(changes, source, callback) {
    if (!changes.length) {
      callback();
      return;
    }
    const activeEditor = instance.getActiveEditor();
    const waitingForValidator = new ValidatorsQueue();
    let shouldBeCanceled = true;
    waitingForValidator.onQueueEmpty = () => {
      if (activeEditor && shouldBeCanceled) {
        activeEditor.cancelChanges();
      }
      callback(); // called when async validators are resolved and beforeChange was not async
    };
    for (let i = changes.length - 1; i >= 0; i--) {
      const [row, prop,, newValue] = changes[i];
      const visualCol = datamap.propToCol(prop);
      let cellProperties;
      if (Number.isInteger(visualCol)) {
        cellProperties = instance.getCellMeta(row, visualCol);
      } else {
        // If there's no requested visual column, we can use the table meta as the cell properties when retrieving
        // the cell validator.
        cellProperties = {
          ...Object.getPrototypeOf(tableMeta),
          ...tableMeta
        };
      }
      if (cellProperties.type === 'numeric' && typeof newValue === 'string' && (0, _number.isNumericLike)(newValue)) {
        changes[i][3] = getParsedNumber(newValue);
      }

      /* eslint-disable no-loop-func */
      if (instance.getCellValidator(cellProperties)) {
        waitingForValidator.addValidatorToQueue();
        instance.validateCell(changes[i][3], cellProperties, function (index, cellPropertiesReference) {
          return function (result) {
            if (typeof result !== 'boolean') {
              throw new Error('Validation error: result is not boolean');
            }
            if (result === false && cellPropertiesReference.allowInvalid === false) {
              shouldBeCanceled = false;
              changes.splice(index, 1); // cancel the change
              cellPropertiesReference.valid = true; // we cancelled the change, so cell value is still valid
            }
            waitingForValidator.removeValidatorFormQueue();
          };
        }(i, cellProperties), source);
      }
    }
    waitingForValidator.checkIfQueueIsEmpty();
  }

  /**
   * Internal function to apply changes. Called after validateChanges.
   *
   * @private
   * @param {Array} changes Array in form of [row, prop, oldValue, newValue].
   * @param {string} source String that identifies how this change will be described in changes array (useful in onChange callback).
   * @fires Hooks#beforeChangeRender
   * @fires Hooks#afterChange
   */
  function applyChanges(changes, source) {
    for (let i = changes.length - 1; i >= 0; i--) {
      let skipThisChange = false;
      if (changes[i] === null) {
        changes.splice(i, 1);
        /* eslint-disable no-continue */
        continue;
      }
      if ((changes[i][2] === null || changes[i][2] === undefined) && (changes[i][3] === null || changes[i][3] === undefined)) {
        /* eslint-disable no-continue */
        continue;
      }
      if (tableMeta.allowInsertRow) {
        while (changes[i][0] > instance.countRows() - 1) {
          const {
            delta: numberOfCreatedRows
          } = datamap.createRow(undefined, undefined, {
            source
          });
          if (numberOfCreatedRows === 0) {
            skipThisChange = true;
            break;
          }
        }
      }
      if (instance.dataType === 'array' && (!tableMeta.columns || tableMeta.columns.length === 0) && tableMeta.allowInsertColumn) {
        while (datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {
          const {
            delta: numberOfCreatedColumns
          } = datamap.createCol(undefined, undefined, {
            source
          });
          if (numberOfCreatedColumns === 0) {
            skipThisChange = true;
            break;
          }
        }
      }
      if (skipThisChange) {
        /* eslint-disable no-continue */
        continue;
      }
      datamap.set(changes[i][0], changes[i][1], changes[i][3]);
    }
    const hasChanges = changes.length > 0;
    instance.forceFullRender = true; // used when data was changed or when all cells need to be re-rendered

    if (hasChanges) {
      grid.adjustRowsAndCols();
      instance.runHooks('beforeChangeRender', changes, source);
      editorManager.closeEditor();
      instance.view.render();
      editorManager.prepareEditor();
      instance.view.adjustElementsSize();
      instance.runHooks('afterChange', changes, source || 'edit');
      const activeEditor = instance.getActiveEditor();
      if (activeEditor && (0, _mixed.isDefined)(activeEditor.refreshValue)) {
        activeEditor.refreshValue();
      }
    } else {
      instance.view.render();
    }
  }

  /**
   * Creates and returns the CellCoords object.
   *
   * @private
   * @memberof Core#
   * @function _createCellCoords
   * @param {number} row The row index.
   * @param {number} column The column index.
   * @returns {CellCoords}
   */
  this._createCellCoords = function (row, column) {
    return instance.view._wt.createCellCoords(row, column);
  };

  /**
   * Creates and returns the CellRange object.
   *
   * @private
   * @memberof Core#
   * @function _createCellRange
   * @param {CellCoords} highlight Defines the border around a cell where selection was started and to edit the cell
   *                               when you press Enter. The highlight cannot point to headers (negative values).
   * @param {CellCoords} from Initial coordinates.
   * @param {CellCoords} to Final coordinates.
   * @returns {CellRange}
   */
  this._createCellRange = function (highlight, from, to) {
    return instance.view._wt.createCellRange(highlight, from, to);
  };

  /**
   * Validate a single cell.
   *
   * @memberof Core#
   * @function validateCell
   * @param {string|number} value The value to validate.
   * @param {object} cellProperties The cell meta which corresponds with the value.
   * @param {Function} callback The callback function.
   * @param {string} source The string that identifies source of the validation.
   */
  this.validateCell = function (value, cellProperties, callback, source) {
    let validator = instance.getCellValidator(cellProperties);

    // the `canBeValidated = false` argument suggests, that the cell passes validation by default.
    /**
     * @private
     * @function done
     * @param {boolean} valid Indicates if the validation was successful.
     * @param {boolean} [canBeValidated=true] Flag which controls the validation process.
     */
    function done(valid) {
      let canBeValidated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      // Fixes GH#3903
      if (!canBeValidated || cellProperties.hidden === true) {
        callback(valid);
        return;
      }
      const col = cellProperties.visualCol;
      const row = cellProperties.visualRow;
      const td = instance.getCell(row, col, true);
      if (td && td.nodeName !== 'TH') {
        const renderableRow = instance.rowIndexMapper.getRenderableFromVisualIndex(row);
        const renderableColumn = instance.columnIndexMapper.getRenderableFromVisualIndex(col);
        instance.view._wt.getSetting('cellRenderer', renderableRow, renderableColumn, td);
      }
      callback(valid);
    }
    if ((0, _mixed.isRegExp)(validator)) {
      validator = function (expression) {
        return function (cellValue, validatorCallback) {
          validatorCallback(expression.test(cellValue));
        };
      }(validator);
    }
    if ((0, _function.isFunction)(validator)) {
      // eslint-disable-next-line no-param-reassign
      value = instance.runHooks('beforeValidate', value, cellProperties.visualRow, cellProperties.prop, source);

      // To provide consistent behaviour, validation should be always asynchronous
      instance._registerImmediate(() => {
        validator.call(cellProperties, value, valid => {
          if (!instance) {
            return;
          }
          // eslint-disable-next-line no-param-reassign
          valid = instance.runHooks('afterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);
          cellProperties.valid = valid;
          done(valid);
          instance.runHooks('postAfterValidate', valid, value, cellProperties.visualRow, cellProperties.prop, source);
        });
      });
    } else {
      // resolve callback even if validator function was not found
      instance._registerImmediate(() => {
        cellProperties.valid = true;
        done(cellProperties.valid, false);
      });
    }
  };

  /**
   * @ignore
   * @param {number} row The visual row index.
   * @param {string|number} propOrCol The visual prop or column index.
   * @param {*} value The cell value.
   * @returns {Array}
   */
  function setDataInputToArray(row, propOrCol, value) {
    if (Array.isArray(row)) {
      // it's an array of changes
      return row;
    }
    return [[row, propOrCol, value]];
  }

  /**
   * Process changes prepared for applying to the dataset (unifying list of changes, closing an editor - when needed,
   * calling a hook).
   *
   * @private
   * @param {Array} changes Array of changes in format `[[row, col, value],...]`.
   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.
   * @returns {Array} List of changes finally applied to the dataset.
   */
  function processChanges(changes, source) {
    const activeEditor = instance.getActiveEditor();
    const beforeChangeResult = instance.runHooks('beforeChange', changes, source || 'edit');
    // The `beforeChange` hook could add a `null` for purpose of cancelling some dataset's change.
    const filteredChanges = changes.filter(change => change !== null);
    if (beforeChangeResult === false || filteredChanges.length === 0) {
      if (activeEditor) {
        activeEditor.cancelChanges();
      }
      return [];
    }
    return filteredChanges;
  }

  /**
   * @description
   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format
   * `[[row, col, value],...]` as the first argument.
   *
   * @memberof Core#
   * @function setDataAtCell
   * @param {number|Array} row Visual row index or array of changes in format `[[row, col, value],...]`.
   * @param {number} [column] Visual column index.
   * @param {string} [value] New value.
   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.
   */
  this.setDataAtCell = function (row, column, value, source) {
    const input = setDataInputToArray(row, column, value);
    const changes = [];
    let changeSource = source;
    let i;
    let ilen;
    let prop;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      if (typeof input[i] !== 'object') {
        throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');
      }
      if (typeof input[i][1] !== 'number') {
        throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`'); // eslint-disable-line max-len
      }
      if (input[i][1] >= this.countCols()) {
        prop = input[i][1];
      } else {
        prop = datamap.colToProp(input[i][1]);
      }
      changes.push([input[i][0], prop, dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }
    if (!changeSource && typeof row === 'object') {
      changeSource = column;
    }
    const processedChanges = processChanges(changes, changeSource);
    instance.runHooks('afterSetDataAtCell', processedChanges, changeSource);
    validateChanges(processedChanges, changeSource, () => {
      applyChanges(processedChanges, changeSource);
    });
  };

  /**
   * @description
   * Set new value to a cell. To change many cells at once (recommended way), pass an array of `changes` in format
   * `[[row, prop, value],...]` as the first argument.
   *
   * @memberof Core#
   * @function setDataAtRowProp
   * @param {number|Array} row Visual row index or array of changes in format `[[row, prop, value], ...]`.
   * @param {string} prop Property name or the source string (e.g. `'first.name'` or `'0'`).
   * @param {string} value Value to be set.
   * @param {string} [source] String that identifies how this change will be described in changes array (useful in onChange callback).
   */
  this.setDataAtRowProp = function (row, prop, value, source) {
    const input = setDataInputToArray(row, prop, value);
    const changes = [];
    let changeSource = source;
    let i;
    let ilen;
    for (i = 0, ilen = input.length; i < ilen; i++) {
      changes.push([input[i][0], input[i][1], dataSource.getAtCell(this.toPhysicalRow(input[i][0]), input[i][1]), input[i][2]]);
    }

    // TODO: I don't think `prop` should be used as `changeSource` here, but removing it would be a breaking change.
    // We should remove it with the next major release.
    if (!changeSource && typeof row === 'object') {
      changeSource = prop;
    }
    const processedChanges = processChanges(changes, source);
    instance.runHooks('afterSetDataAtRowProp', processedChanges, changeSource);
    validateChanges(processedChanges, changeSource, () => {
      applyChanges(processedChanges, changeSource);
    });
  };

  /**
   * Listen to the keyboard input on document body. This allows Handsontable to capture keyboard events and respond
   * in the right way.
   *
   * @memberof Core#
   * @function listen
   * @fires Hooks#afterListen
   */
  this.listen = function () {
    if (instance && !instance.isListening()) {
      foreignHotInstances.forEach(foreignHot => {
        if (instance !== foreignHot) {
          foreignHot.unlisten();
        }
      });
      activeGuid = instance.guid;
      instance.runHooks('afterListen');
    }
  };

  /**
   * Stop listening to keyboard input on the document body. Calling this method makes the Handsontable inactive for
   * any keyboard events.
   *
   * @memberof Core#
   * @function unlisten
   */
  this.unlisten = function () {
    if (this.isListening()) {
      activeGuid = null;
      instance.runHooks('afterUnlisten');
    }
  };

  /**
   * Returns `true` if the current Handsontable instance is listening to keyboard input on document body.
   *
   * @memberof Core#
   * @function isListening
   * @returns {boolean} `true` if the instance is listening, `false` otherwise.
   */
  this.isListening = function () {
    return activeGuid === instance.guid;
  };

  /**
   * Destroys the current editor, render the table and prepares the editor of the newly selected cell.
   *
   * @memberof Core#
   * @function destroyEditor
   * @param {boolean} [revertOriginal=false] If `true`, the previous value will be restored. Otherwise, the edited value will be saved.
   * @param {boolean} [prepareEditorIfNeeded=true] If `true` the editor under the selected cell will be prepared to open.
   */
  this.destroyEditor = function () {
    let revertOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let prepareEditorIfNeeded = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    editorManager.closeEditor(revertOriginal);
    instance.view.render();
    if (prepareEditorIfNeeded && selection.isSelected()) {
      editorManager.prepareEditor();
    }
  };

  /**
   * Populates cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`). Use `endRow`, `endCol` when you
   * want to cut input when a certain row is reached.
   *
   * The `populateFromArray()` method can't change [`readOnly`](@/api/options.md#readonly) cells.
   *
   * Optional `method` argument has the same effect as pasteMode option (see {@link Options#pasteMode}).
   *
   * @memberof Core#
   * @function populateFromArray
   * @param {number} row Start visual row index.
   * @param {number} column Start visual column index.
   * @param {Array} input 2d array.
   * @param {number} [endRow] End visual row index (use when you want to cut input when certain row is reached).
   * @param {number} [endCol] End visual column index (use when you want to cut input when certain column is reached).
   * @param {string} [source=populateFromArray] Used to identify this call in the resulting events (beforeChange, afterChange).
   * @param {string} [method=overwrite] Populate method, possible values: `'shift_down'`, `'shift_right'`, `'overwrite'`.
   * @returns {object|undefined} Ending td in pasted area (only if any cell was changed).
   */
  this.populateFromArray = function (row, column, input, endRow, endCol, source, method) {
    if (!(typeof input === 'object' && typeof input[0] === 'object')) {
      throw new Error('populateFromArray parameter `input` must be an array of arrays'); // API changed in 0.9-beta2, let's check if you use it correctly
    }
    const c = typeof endRow === 'number' ? instance._createCellCoords(endRow, endCol) : null;
    return grid.populateFromArray(instance._createCellCoords(row, column), input, c, source, method);
  };

  /**
   * Adds/removes data from the column. This method works the same as Array.splice for arrays.
   *
   * @memberof Core#
   * @function spliceCol
   * @param {number} column Index of the column in which do you want to do splice.
   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.
   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.
   * @returns {Array} Returns removed portion of columns.
   */
  this.spliceCol = function (column, index, amount) {
    for (var _len16 = arguments.length, elements = new Array(_len16 > 3 ? _len16 - 3 : 0), _key16 = 3; _key16 < _len16; _key16++) {
      elements[_key16 - 3] = arguments[_key16];
    }
    return datamap.spliceCol(column, index, amount, ...elements);
  };

  /**
   * Adds/removes data from the row. This method works the same as Array.splice for arrays.
   *
   * @memberof Core#
   * @function spliceRow
   * @param {number} row Index of column in which do you want to do splice.
   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.
   * @param {...number} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array.
   * @returns {Array} Returns removed portion of rows.
   */
  this.spliceRow = function (row, index, amount) {
    for (var _len17 = arguments.length, elements = new Array(_len17 > 3 ? _len17 - 3 : 0), _key17 = 3; _key17 < _len17; _key17++) {
      elements[_key17 - 3] = arguments[_key17];
    }
    return datamap.spliceRow(row, index, amount, ...elements);
  };

  /**
   * Returns indexes of the currently selected cells as an array of arrays `[[startRow, startCol, endRow, endCol],...]`.
   *
   * Start row and start column are the coordinates of the active cell (where the selection was started).
   *
   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.
   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)
   * you need to use `getSelectedLast` method.
   *
   * @memberof Core#
   * @function getSelected
   * @returns {Array[]|undefined} An array of arrays of the selection's coordinates.
   */
  this.getSelected = function () {
    // https://github.com/handsontable/handsontable/issues/44  //cjl
    if (selection.isSelected()) {
      return (0, _array.arrayMap)(selection.getSelectedRange(), _ref7 => {
        let {
          from,
          to
        } = _ref7;
        return [from.row, from.col, to.row, to.col];
      });
    }
  };

  /**
   * Returns the last coordinates applied to the table as a an array `[startRow, startCol, endRow, endCol]`.
   *
   * @since 0.36.0
   * @memberof Core#
   * @function getSelectedLast
   * @returns {Array|undefined} An array of the selection's coordinates.
   */
  this.getSelectedLast = function () {
    const selected = this.getSelected();
    let result;
    if (selected && selected.length > 0) {
      result = selected[selected.length - 1];
    }
    return result;
  };

  /**
   * Returns the current selection as an array of CellRange objects.
   *
   * The version 0.36.0 adds a non-consecutive selection feature. Since this version, the method returns an array of arrays.
   * Additionally to collect the coordinates of the currently selected area (as it was previously done by the method)
   * you need to use `getSelectedRangeLast` method.
   *
   * @memberof Core#
   * @function getSelectedRange
   * @returns {CellRange[]|undefined} Selected range object or undefined if there is no selection.
   */
  this.getSelectedRange = function () {
    // https://github.com/handsontable/handsontable/issues/44  //cjl
    if (selection.isSelected()) {
      return Array.from(selection.getSelectedRange());
    }
  };

  /**
   * Returns the last coordinates applied to the table as a CellRange object.
   *
   * @memberof Core#
   * @function getSelectedRangeLast
   * @since 0.36.0
   * @returns {CellRange|undefined} Selected range object or undefined` if there is no selection.
   */
  this.getSelectedRangeLast = function () {
    const selectedRange = this.getSelectedRange();
    let result;
    if (selectedRange && selectedRange.length > 0) {
      result = selectedRange[selectedRange.length - 1];
    }
    return result;
  };

  /**
   * Erases content from cells that have been selected in the table.
   *
   * @memberof Core#
   * @function emptySelectedCells
   * @param {string} [source] String that identifies how this change will be described in the changes array (useful in afterChange or beforeChange callback). Set to 'edit' if left empty.
   * @since 0.36.0
   */
  this.emptySelectedCells = function (source) {
    if (!selection.isSelected() || this.countRows() === 0 || this.countCols() === 0) {
      return;
    }
    const changes = [];
    (0, _array.arrayEach)(selection.getSelectedRange(), cellRange => {
      if (cellRange.isSingleHeader()) {
        return;
      }
      const topStart = cellRange.getTopStartCorner();
      const bottomEnd = cellRange.getBottomEndCorner();
      (0, _number.rangeEach)(topStart.row, bottomEnd.row, row => {
        (0, _number.rangeEach)(topStart.col, bottomEnd.col, column => {
          if (!this.getCellMeta(row, column).readOnly) {
            changes.push([row, column, null]);
          }
        });
      });
    });
    if (changes.length > 0) {
      this.setDataAtCell(changes, source);
    }
  };

  /**
   * Checks if the table rendering process was suspended. See explanation in {@link Core#suspendRender}.
   *
   * @memberof Core#
   * @function isRenderSuspended
   * @since 8.3.0
   * @returns {boolean}
   */
  this.isRenderSuspended = function () {
    return this.renderSuspendedCounter > 0;
  };

  /**
   * Suspends the rendering process. It's helpful to wrap the table render
   * cycles triggered by API calls or UI actions (or both) and call the "render"
   * once in the end. As a result, it improves the performance of wrapped operations.
   * When the table is in the suspend state, most operations will have no visual
   * effect until the rendering state is resumed. Resuming the state automatically
   * invokes the table rendering. To make sure that after executing all operations,
   * the table will be rendered, it's highly recommended to use the {@link Core#batchRender}
   * method or {@link Core#batch}, which additionally aggregates the logic execution
   * that happens behind the table.
   *
   * The method is intended to be used by advanced users. Suspending the rendering
   * process could cause visual glitches when wrongly implemented.
   *
   * Every [`suspendRender()`](@/api/core.md#suspendrender) call needs to correspond with one [`resumeRender()`](@/api/core.md#resumerender) call.
   * For example, if you call [`suspendRender()`](@/api/core.md#suspendrender) 5 times, you need to call [`resumeRender()`](@/api/core.md#resumerender) 5 times as well.
   *
   * @memberof Core#
   * @function suspendRender
   * @since 8.3.0
   * @example
   * ```js
   * hot.suspendRender();
   * hot.alter('insert_row_above', 5, 45);
   * hot.alter('insert_col_start', 10, 40);
   * hot.setDataAtCell(1, 1, 'John');
   * hot.setDataAtCell(2, 2, 'Mark');
   * hot.setDataAtCell(3, 3, 'Ann');
   * hot.setDataAtCell(4, 4, 'Sophia');
   * hot.setDataAtCell(5, 5, 'Mia');
   * hot.selectCell(0, 0);
   * hot.resumeRender(); // It re-renders the table internally
   * ```
   */
  this.suspendRender = function () {
    this.renderSuspendedCounter += 1;
  };

  /**
   * Resumes the rendering process. In combination with the {@link Core#suspendRender}
   * method it allows aggregating the table render cycles triggered by API calls or UI
   * actions (or both) and calls the "render" once in the end. When the table is in
   * the suspend state, most operations will have no visual effect until the rendering
   * state is resumed. Resuming the state automatically invokes the table rendering.
   *
   * The method is intended to be used by advanced users. Suspending the rendering
   * process could cause visual glitches when wrongly implemented.
   *
   * Every [`suspendRender()`](@/api/core.md#suspendrender) call needs to correspond with one [`resumeRender()`](@/api/core.md#resumerender) call.
   * For example, if you call [`suspendRender()`](@/api/core.md#suspendrender) 5 times, you need to call [`resumeRender()`](@/api/core.md#resumerender) 5 times as well.
   *
   * @memberof Core#
   * @function resumeRender
   * @since 8.3.0
   * @example
   * ```js
   * hot.suspendRender();
   * hot.alter('insert_row_above', 5, 45);
   * hot.alter('insert_col_start', 10, 40);
   * hot.setDataAtCell(1, 1, 'John');
   * hot.setDataAtCell(2, 2, 'Mark');
   * hot.setDataAtCell(3, 3, 'Ann');
   * hot.setDataAtCell(4, 4, 'Sophia');
   * hot.setDataAtCell(5, 5, 'Mia');
   * hot.selectCell(0, 0);
   * hot.resumeRender(); // It re-renders the table internally
   * ```
   */
  this.resumeRender = function () {
    const nextValue = this.renderSuspendedCounter - 1;
    this.renderSuspendedCounter = Math.max(nextValue, 0);
    if (!this.isRenderSuspended() && nextValue === this.renderSuspendedCounter) {
      if (this.renderCall) {
        this.render();
      } else {
        instance.view.render();
      }
    }
  };

  /**
   * Rerender the table. Calling this method starts the process of recalculating, redrawing and applying the changes
   * to the DOM. While rendering the table all cell renderers are recalled.
   *
   * Calling this method manually is not recommended. Handsontable tries to render itself by choosing the most
   * optimal moments in its lifecycle.
   *
   * @memberof Core#
   * @function render
   */
  this.render = function () {
    if (this.view) {
      this.renderCall = true;
      this.forceFullRender = true; // used when data was changed or when all cells need to be re-rendered

      if (!this.isRenderSuspended()) {
        instance.view.render();
      }
    }
  };

  /**
   * The method aggregates multi-line API calls into a callback and postpones the
   * table rendering process. After the execution of the operations, the table is
   * rendered once. As a result, it improves the performance of wrapped operations.
   * Without batching, a similar case could trigger multiple table render calls.
   *
   * @memberof Core#
   * @function batchRender
   * @param {Function} wrappedOperations Batched operations wrapped in a function.
   * @returns {*} Returns result from the wrappedOperations callback.
   * @since 8.3.0
   * @example
   * ```js
   * hot.batchRender(() => {
   *   hot.alter('insert_row_above', 5, 45);
   *   hot.alter('insert_col_start', 10, 40);
   *   hot.setDataAtCell(1, 1, 'John');
   *   hot.setDataAtCell(2, 2, 'Mark');
   *   hot.setDataAtCell(3, 3, 'Ann');
   *   hot.setDataAtCell(4, 4, 'Sophia');
   *   hot.setDataAtCell(5, 5, 'Mia');
   *   hot.selectCell(0, 0);
   *   // The table will be rendered once after executing the callback
   * });
   * ```
   */
  this.batchRender = function (wrappedOperations) {
    this.suspendRender();
    const result = wrappedOperations();
    this.resumeRender();
    return result;
  };

  /**
   * Checks if the table indexes recalculation process was suspended. See explanation
   * in {@link Core#suspendExecution}.
   *
   * @memberof Core#
   * @function isExecutionSuspended
   * @since 8.3.0
   * @returns {boolean}
   */
  this.isExecutionSuspended = function () {
    return this.executionSuspendedCounter > 0;
  };

  /**
   * Suspends the execution process. It's helpful to wrap the table logic changes
   * such as index changes into one call after which the cache is updated. As a result,
   * it improves the performance of wrapped operations.
   *
   * The method is intended to be used by advanced users. Suspending the execution
   * process could cause visual glitches caused by not updated the internal table cache.
   *
   * @memberof Core#
   * @function suspendExecution
   * @since 8.3.0
   * @example
   * ```js
   * hot.suspendExecution();
   * const filters = hot.getPlugin('filters');
   *
   * filters.addCondition(2, 'contains', ['3']);
   * filters.filter();
   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
   * hot.resumeExecution(); // It updates the cache internally
   * ```
   */
  this.suspendExecution = function () {
    this.executionSuspendedCounter += 1;
    this.columnIndexMapper.suspendOperations();
    this.rowIndexMapper.suspendOperations();
  };

  /**
   * Resumes the execution process. In combination with the {@link Core#suspendExecution}
   * method it allows aggregating the table logic changes after which the cache is
   * updated. Resuming the state automatically invokes the table cache updating process.
   *
   * The method is intended to be used by advanced users. Suspending the execution
   * process could cause visual glitches caused by not updated the internal table cache.
   *
   * @memberof Core#
   * @function resumeExecution
   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache
   * is recalculated after the execution of the batched operations. For nested
   * {@link Core#batchExecution} calls, it can be desire to recalculate the table
   * after each batch.
   * @since 8.3.0
   * @example
   * ```js
   * hot.suspendExecution();
   * const filters = hot.getPlugin('filters');
   *
   * filters.addCondition(2, 'contains', ['3']);
   * filters.filter();
   * hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
   * hot.resumeExecution(); // It updates the cache internally
   * ```
   */
  this.resumeExecution = function () {
    let forceFlushChanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const nextValue = this.executionSuspendedCounter - 1;
    this.executionSuspendedCounter = Math.max(nextValue, 0);
    if (!this.isExecutionSuspended() && nextValue === this.executionSuspendedCounter || forceFlushChanges) {
      this.columnIndexMapper.resumeOperations();
      this.rowIndexMapper.resumeOperations();
    }
  };

  /**
   * The method aggregates multi-line API calls into a callback and postpones the
   * table execution process. After the execution of the operations, the internal table
   * cache is recalculated once. As a result, it improves the performance of wrapped
   * operations. Without batching, a similar case could trigger multiple table cache rebuilds.
   *
   * @memberof Core#
   * @function batchExecution
   * @param {Function} wrappedOperations Batched operations wrapped in a function.
   * @param {boolean} [forceFlushChanges=false] If `true`, the table internal data cache
   * is recalculated after the execution of the batched operations. For nested calls,
   * it can be a desire to recalculate the table after each batch.
   * @returns {*} Returns result from the wrappedOperations callback.
   * @since 8.3.0
   * @example
   * ```js
   * hot.batchExecution(() => {
   *   const filters = hot.getPlugin('filters');
   *
   *   filters.addCondition(2, 'contains', ['3']);
   *   filters.filter();
   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
   *   // The table cache will be recalculated once after executing the callback
   * });
   * ```
   */
  this.batchExecution = function (wrappedOperations) {
    let forceFlushChanges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    this.suspendExecution();
    const result = wrappedOperations();
    this.resumeExecution(forceFlushChanges);
    return result;
  };

  /**
   * It batches the rendering process and index recalculations. The method aggregates
   * multi-line API calls into a callback and postpones the table rendering process
   * as well aggregates the table logic changes such as index changes into one call
   * after which the cache is updated. After the execution of the operations, the
   * table is rendered, and the cache is updated once. As a result, it improves the
   * performance of wrapped operations.
   *
   * @memberof Core#
   * @function batch
   * @param {Function} wrappedOperations Batched operations wrapped in a function.
   * @returns {*} Returns result from the wrappedOperations callback.
   * @since 8.3.0
   * @example
   * ```js
   * hot.batch(() => {
   *   hot.alter('insert_row_above', 5, 45);
   *   hot.alter('insert_col_start', 10, 40);
   *   hot.setDataAtCell(1, 1, 'x');
   *   hot.setDataAtCell(2, 2, 'c');
   *   hot.setDataAtCell(3, 3, 'v');
   *   hot.setDataAtCell(4, 4, 'b');
   *   hot.setDataAtCell(5, 5, 'n');
   *   hot.selectCell(0, 0);
   *
   *   const filters = hot.getPlugin('filters');
   *
   *   filters.addCondition(2, 'contains', ['3']);
   *   filters.filter();
   *   hot.getPlugin('columnSorting').sort({ column: 1, sortOrder: 'desc' });
   *   // The table will be re-rendered and cache will be recalculated once after executing the callback
   * });
   * ```
   */
  this.batch = function (wrappedOperations) {
    this.suspendRender();
    this.suspendExecution();
    const result = wrappedOperations();
    this.resumeExecution();
    this.resumeRender();
    return result;
  };

  /**
   * Updates dimensions of the table. The method compares previous dimensions with the current ones and updates accordingly.
   *
   * @memberof Core#
   * @function refreshDimensions
   * @fires Hooks#beforeRefreshDimensions
   * @fires Hooks#afterRefreshDimensions
   */
  this.refreshDimensions = function () {
    if (!instance.view) {
      return;
    }
    const {
      width: lastWidth,
      height: lastHeight
    } = instance.view.getLastSize();
    const {
      width,
      height
    } = instance.rootElement.getBoundingClientRect();
    const isSizeChanged = width !== lastWidth || height !== lastHeight;
    const isResizeBlocked = instance.runHooks('beforeRefreshDimensions', {
      width: lastWidth,
      height: lastHeight
    }, {
      width,
      height
    }, isSizeChanged) === false;
    if (isResizeBlocked) {
      return;
    }
    if (isSizeChanged || instance.view._wt.wtOverlays.scrollableElement === instance.rootWindow) {
      instance.view.setLastSize(width, height);
      instance.render();
    }
    instance.runHooks('afterRefreshDimensions', {
      width: lastWidth,
      height: lastHeight
    }, {
      width,
      height
    }, isSizeChanged);
  };

  /**
   * The `updateData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.
   *
   * The `updateData()` method:
   * - Keeps cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)
   * - Keeps rows' states (e.g. row order)
   * - Keeps columns' states (e.g. column order)
   *
   * To replace Handsontable's [`data`](@/api/options.md#data) and reset states, use the [`loadData()`](#loaddata) method.
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)
   *
   * @memberof Core#
   * @function updateData
   * @since 11.1.0
   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {string} [source] The source of the `updateData()` call
   * @fires Hooks#beforeUpdateData
   * @fires Hooks#afterUpdateData
   * @fires Hooks#afterChange
   */
  this.updateData = function (data, source) {
    (0, _dataMap.replaceData)(data, newDataMap => {
      datamap = newDataMap;
    }, newDataMap => {
      datamap = newDataMap;
      instance.columnIndexMapper.fitToLength(this.getInitialColumnCount());
      instance.rowIndexMapper.fitToLength(this.countSourceRows());
      grid.adjustRowsAndCols();
      selection.refresh();
    }, {
      hotInstance: instance,
      dataMap: datamap,
      dataSource,
      internalSource: 'updateData',
      source,
      metaManager,
      firstRun
    });
  };

  /**
   * The `loadData()` method replaces Handsontable's [`data`](@/api/options.md#data) with a new dataset.
   *
   * Additionally, the `loadData()` method:
   * - Resets cells' states (e.g. cells' [formatting](@/guides/cell-features/formatting-cells/formatting-cells.md) and cells' [`readOnly`](@/api/options.md#readonly) states)
   * - Resets rows' states (e.g. row order)
   * - Resets columns' states (e.g. column order)
   *
   * To replace Handsontable's [`data`](@/api/options.md#data) without resetting states, use the [`updateData()`](#updatedata) method.
   *
   * Read more:
   * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)
   * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)
   *
   * @memberof Core#
   * @function loadData
   * @param {Array} data An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data
   * @param {string} [source] The source of the `loadData()` call
   * @fires Hooks#beforeLoadData
   * @fires Hooks#afterLoadData
   * @fires Hooks#afterChange
   */
  this.loadData = function (data, source) {
    (0, _dataMap.replaceData)(data, newDataMap => {
      datamap = newDataMap;
    }, () => {
      metaManager.clearCellsCache();
      instance.initIndexMappers();
      grid.adjustRowsAndCols();
      selection.refresh();
      if (firstRun) {
        firstRun = [null, 'loadData'];
      }
    }, {
      hotInstance: instance,
      dataMap: datamap,
      dataSource,
      internalSource: 'loadData',
      source,
      metaManager,
      firstRun
    });
  };

  /**
   * Gets the initial column count, calculated based on the `columns` setting.
   *
   * @private
   * @returns {number} The calculated number of columns.
   */
  this.getInitialColumnCount = function () {
    const columnsSettings = tableMeta.columns;
    let finalNrOfColumns = 0;

    // We will check number of columns when the `columns` property was defined as an array. Columns option may
    // narrow down or expand displayed dataset in that case.
    if (Array.isArray(columnsSettings)) {
      finalNrOfColumns = columnsSettings.length;
    } else if ((0, _function.isFunction)(columnsSettings)) {
      if (instance.dataType === 'array') {
        const nrOfSourceColumns = this.countSourceCols();
        for (let columnIndex = 0; columnIndex < nrOfSourceColumns; columnIndex += 1) {
          if (columnsSettings(columnIndex)) {
            finalNrOfColumns += 1;
          }
        }

        // Extended dataset by the `columns` property? Moved code right from the refactored `countCols` method.
      } else if (instance.dataType === 'object' || instance.dataType === 'function') {
        finalNrOfColumns = datamap.colToPropCache.length;
      }

      // In some cases we need to check columns length from the schema, i.e. `data` may be empty.
    } else if ((0, _mixed.isDefined)(tableMeta.dataSchema)) {
      const schema = datamap.getSchema();

      // Schema may be defined as an array of objects. Each object will define column.
      finalNrOfColumns = Array.isArray(schema) ? schema.length : (0, _object.deepObjectSize)(schema);
    } else {
      // We init index mappers by length of source data to provide indexes also for skipped indexes.
      finalNrOfColumns = this.countSourceCols();
    }
    return finalNrOfColumns;
  };

  /**
   * Init index mapper which manage indexes assigned to the data.
   *
   * @private
   */
  this.initIndexMappers = function () {
    this.columnIndexMapper.initToLength(this.getInitialColumnCount());
    this.rowIndexMapper.initToLength(this.countSourceRows());
  };

  /**
   * Returns the current data object (the same one that was passed by `data` configuration option or `loadData` method,
   * unless some modifications have been applied (i.e. Sequence of rows/columns was changed, some row/column was skipped).
   * If that's the case - use the {@link Core#getSourceData} method.).
   *
   * Optionally you can provide cell range by defining `row`, `column`, `row2`, `column2` to get only a fragment of table data.
   *
   * @memberof Core#
   * @function getData
   * @param {number} [row] From visual row index.
   * @param {number} [column] From visual column index.
   * @param {number} [row2] To visual row index.
   * @param {number} [column2] To visual column index.
   * @returns {Array[]} Array with the data.
   * @example
   * ```js
   * // Get all data (in order how it is rendered in the table).
   * hot.getData();
   * // Get data fragment (from top-left 0, 0 to bottom-right 3, 3).
   * hot.getData(3, 3);
   * // Get data fragment (from top-left 2, 1 to bottom-right 3, 3).
   * hot.getData(2, 1, 3, 3);
   * ```
   */
  this.getData = function (row, column, row2, column2) {
    if ((0, _mixed.isUndefined)(row)) {
      return datamap.getAll();
    }
    return datamap.getRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), datamap.DESTINATION_RENDERER);
  };

  /**
   * Returns a string value of the selected range. Each column is separated by tab, each row is separated by a new
   * line character.
   *
   * @memberof Core#
   * @function getCopyableText
   * @param {number} startRow From visual row index.
   * @param {number} startCol From visual column index.
   * @param {number} endRow To visual row index.
   * @param {number} endCol To visual column index.
   * @returns {string}
   */
  this.getCopyableText = function (startRow, startCol, endRow, endCol) {
    return datamap.getCopyableText(instance._createCellCoords(startRow, startCol), instance._createCellCoords(endRow, endCol));
  };

  /**
   * Returns the data's copyable value at specified `row` and `column` index.
   *
   * @memberof Core#
   * @function getCopyableData
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {string}
   */
  this.getCopyableData = function (row, column) {
    return datamap.getCopyable(row, datamap.colToProp(column));
  };

  /**
   * Returns schema provided by constructor settings. If it doesn't exist then it returns the schema based on the data
   * structure in the first row.
   *
   * @memberof Core#
   * @function getSchema
   * @returns {object} Schema object.
   */
  this.getSchema = function () {
    return datamap.getSchema();
  };

  /**
   * Use it if you need to change configuration after initialization. The `settings` argument is an object containing the changed
   * settings, declared the same way as in the initial settings object.
   *
   * __Note__, that although the `updateSettings` method doesn't overwrite the previously declared settings, it might reset
   * the settings made post-initialization. (for example - ignore changes made using the columnResize feature).
   *
   * Since 8.0.0 passing `columns` or `data` inside `settings` objects will result in resetting states corresponding to rows and columns
   * (for example, row/column sequence, column width, row height, frozen columns etc.).
   *
   * Since 12.0.0 passing `data` inside `settings` objects no longer results in resetting states corresponding to rows and columns
   * (for example, row/column sequence, column width, row height, frozen columns etc.).
   *
   * @memberof Core#
   * @function updateSettings
   * @param {object} settings A settings object (see {@link Options}). Only provide the settings that are changed, not the whole settings object that was used for initialization.
   * @param {boolean} [init=false] Internally used for in initialization mode.
   * @example
   * ```js
   * hot.updateSettings({
   *    contextMenu: true,
   *    colHeaders: true,
   *    fixedRowsTop: 2
   * });
   * ```
   * @fires Hooks#afterCellMetaReset
   * @fires Hooks#afterUpdateSettings
   */
  this.updateSettings = function (settings) {
    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const dataUpdateFunction = (firstRun ? instance.loadData : instance.updateData).bind(this);
    let columnsAsFunc = false;
    let i;
    let j;
    if ((0, _mixed.isDefined)(settings.rows)) {
      throw new Error('The "rows" setting is no longer supported. Do you mean startRows, minRows or maxRows?');
    }
    if ((0, _mixed.isDefined)(settings.cols)) {
      throw new Error('The "cols" setting is no longer supported. Do you mean startCols, minCols or maxCols?');
    }
    if ((0, _mixed.isDefined)(settings.ganttChart)) {
      throw new Error('Since 8.0.0 the "ganttChart" setting is no longer supported.');
    }

    // eslint-disable-next-line no-restricted-syntax
    for (i in settings) {
      if (i === 'data') {
        // Do nothing. loadData will be triggered later
      } else if (i === 'language') {
        setLanguage(settings.language);
      } else if (i === 'className') {
        setClassName('className', settings.className);
      } else if (i === 'tableClassName' && instance.table) {
        setClassName('tableClassName', settings.tableClassName);
        instance.view._wt.wtOverlays.syncOverlayTableClassNames();
      } else if (_hooks.Hooks.getSingleton().isRegistered(i) || _hooks.Hooks.getSingleton().isDeprecated(i)) {
        if ((0, _function.isFunction)(settings[i])) {
          _hooks.Hooks.getSingleton().addAsFixed(i, settings[i], instance);
        } else if (Array.isArray(settings[i])) {
          _hooks.Hooks.getSingleton().add(i, settings[i], instance);
        }
      } else if (!init && (0, _object.hasOwnProperty)(settings, i)) {
        // Update settings
        globalMeta[i] = settings[i];
      }
    }

    // Load data or create data map
    if (settings.data === undefined && tableMeta.data === undefined) {
      dataUpdateFunction(null, 'updateSettings'); // data source created just now
    } else if (settings.data !== undefined) {
      dataUpdateFunction(settings.data, 'updateSettings'); // data source given as option
    } else if (settings.columns !== undefined) {
      datamap.createMap();

      // The `column` property has changed - dataset may be expanded or narrowed down. The `loadData` do the same.
      instance.initIndexMappers();
    }
    const clen = instance.countCols();
    const columnSetting = tableMeta.columns;

    // Init columns constructors configuration
    if (columnSetting && (0, _function.isFunction)(columnSetting)) {
      columnsAsFunc = true;
    }

    // Clear cell meta cache
    if (settings.cell !== undefined || settings.cells !== undefined || settings.columns !== undefined) {
      metaManager.clearCache();
    }
    if (clen > 0) {
      for (i = 0, j = 0; i < clen; i++) {
        // Use settings provided by user
        if (columnSetting) {
          const column = columnsAsFunc ? columnSetting(i) : columnSetting[j];
          if (column) {
            metaManager.updateColumnMeta(j, column);
          }
        }
        j += 1;
      }
    }
    if ((0, _mixed.isDefined)(settings.cell)) {
      (0, _object.objectEach)(settings.cell, cell => {
        instance.setCellMetaObject(cell.row, cell.col, cell);
      });
    }
    instance.runHooks('afterCellMetaReset');
    let currentHeight = instance.rootElement.style.height;
    if (currentHeight !== '') {
      currentHeight = parseInt(instance.rootElement.style.height, 10);
    }
    let height = settings.height;
    if ((0, _function.isFunction)(height)) {
      height = height();
    }
    if (init) {
      const initialStyle = instance.rootElement.getAttribute('style');
      if (initialStyle) {
        instance.rootElement.setAttribute('data-initialstyle', instance.rootElement.getAttribute('style'));
      }
    }
    if (height === null) {
      const initialStyle = instance.rootElement.getAttribute('data-initialstyle');
      if (initialStyle && (initialStyle.indexOf('height') > -1 || initialStyle.indexOf('overflow') > -1)) {
        instance.rootElement.setAttribute('style', initialStyle);
      } else {
        instance.rootElement.style.height = '';
        instance.rootElement.style.overflow = '';
      }
    } else if (height !== undefined) {
      instance.rootElement.style.height = isNaN(height) ? `${height}` : `${height}px`;
      instance.rootElement.style.overflow = 'hidden';
    }
    if (typeof settings.width !== 'undefined') {
      let width = settings.width;
      if ((0, _function.isFunction)(width)) {
        width = width();
      }
      instance.rootElement.style.width = isNaN(width) ? `${width}` : `${width}px`;
    }
    if (!init) {
      if (instance.view) {
        instance.view._wt.wtViewport.resetHasOversizedColumnHeadersMarked();
        instance.view._wt.exportSettingsAsClassNames();
        const currentThemeName = instance.getCurrentThemeName();
        const themeNameOptionExists = (0, _object.hasOwnProperty)(settings, 'themeName');
        if (currentThemeName && themeNameOptionExists) {
          instance.view.getStylesHandler().removeClassNames();
          instance.view.removeClassNameFromLicenseElement(currentThemeName);
        }
        const themeName = themeNameOptionExists && settings.themeName || (0, _themes.getThemeClassName)(instance.rootElement);

        // Use the theme defined as a root element class or in the settings (in that order).
        instance.useTheme(themeName);

        // Add the theme class name to the license info element.
        instance.view.addClassNameToLicenseElement(instance.getCurrentThemeName());
      }
      instance.runHooks('afterUpdateSettings', settings);
    }
    grid.adjustRowsAndCols();
    if (instance.view && !firstRun) {
      instance.forceFullRender = true; // used when data was changed
      instance.view.render();
      instance.view._wt.wtOverlays.adjustElementsSize();
    }
    if (!init && instance.view && (currentHeight === '' || height === '' || height === undefined) && currentHeight !== height) {
      instance.view._wt.wtOverlays.updateMainScrollableElements();
    }
  };

  /**
   * Gets the value of the currently focused cell.
   *
   * For column headers and row headers, returns `null`.
   *
   * @memberof Core#
   * @function getValue
   * @returns {*} The value of the focused cell.
   */
  this.getValue = function () {
    const sel = instance.getSelectedLast();
    if (tableMeta.getValue) {
      if ((0, _function.isFunction)(tableMeta.getValue)) {
        return tableMeta.getValue.call(instance);
      } else if (sel) {
        return instance.getData()[sel[0][0]][tableMeta.getValue];
      }
    } else if (sel) {
      return instance.getDataAtCell(sel[0], sel[1]);
    }
  };

  /**
   * Returns the object settings.
   *
   * @memberof Core#
   * @function getSettings
   * @returns {TableMeta} Object containing the current table settings.
   */
  this.getSettings = function () {
    return tableMeta;
  };

  /**
   * Clears the data from the table (the table settings remain intact).
   *
   * @memberof Core#
   * @function clear
   */
  this.clear = function () {
    this.selectAll();
    this.emptySelectedCells();
  };

  /**
   * The `alter()` method lets you alter the grid's structure
   * by adding or removing rows and columns at specified positions.
   *
   * ::: tip
   * If you use an array of objects in your [`data`](@/api/options.md#data), the column-related actions won't work.
   * :::
   *
   * ```js
   * // above row 10 (by visual index), insert 1 new row
   * hot.alter('insert_row_above', 10);
   * ```
   *
   *  | Action               | With `index` | Without `index` |
   *  | -------------------- | ------------ | --------------- |
   *  | `'insert_row_above'` | Inserts rows above the `index` row. | Inserts rows above the first row. |
   *  | `'insert_row_below'` | Inserts rows below the `index` row. | Inserts rows below the last row. |
   *  | `'remove_row'`       | Removes rows, starting from the `index` row. | Removes rows, starting from the last row. |
   *  | `'insert_col_start'` | Inserts columns before the `index` column. | Inserts columns before the first column. |
   *  | `'insert_col_end'`   | Inserts columns after the `index` column. | Inserts columns after the last column. |
   *  | `'remove_col'`       | Removes columns, starting from the `index` column. | Removes columns, starting from the last column. |
   *
   * Additional information about `'insert_col_start'` and `'insert_col_end'`:
   * - Their behavior depends on your [`layoutDirection`](@/api/options.md#layoutdirection).
   * - If the provided `index` is higher than the actual number of columns, Handsontable doesn't generate
   * the columns missing in between. Instead, the new columns are inserted next to the last column.
   *
   * @memberof Core#
   * @function alter
   * @param {string} action Available operations:
   * <ul>
   *    <li> `'insert_row_above'` </li>
   *    <li> `'insert_row_below'` </li>
   *    <li> `'remove_row'` </li> </li>
   *    <li> `'insert_col_start'` </li>
   *    <li> `'insert_col_end'` </li>
   *    <li> `'remove_col'` </li>
   * </ul>
   * @param {number|number[]} [index] A visual index of the row/column before or after which the new row/column will be
   *                                inserted or removed. Can also be an array of arrays, in format `[[index, amount],...]`.
   * @param {number} [amount] The amount of rows or columns to be inserted or removed (default: `1`).
   * @param {string} [source] Source indicator.
   * @param {boolean} [keepEmptyRows] If set to `true`: prevents removing empty rows.
   * @example
   * ```js
   * // above row 10 (by visual index), insert 1 new row
   * hot.alter('insert_row_above', 10);
   *
   * // below row 10 (by visual index), insert 3 new rows
   * hot.alter('insert_row_below', 10, 3);
   *
   * // in the LTR layout direction: to the left of column 10 (by visual index), insert 3 new columns
   * // in the RTL layout direction: to the right of column 10 (by visual index), insert 3 new columns
   * hot.alter('insert_col_start', 10, 3);
   *
   * // in the LTR layout direction: to the right of column 10 (by visual index), insert 1 new column
   * // in the RTL layout direction: to the left of column 10 (by visual index), insert 1 new column
   * hot.alter('insert_col_end', 10);
   *
   * // remove 2 rows, starting from row 10 (by visual index)
   * hot.alter('remove_row', 10, 2);
   *
   * // remove 3 rows, starting from row 1 (by visual index)
   * // remove 2 rows, starting from row 5 (by visual index)
   * hot.alter('remove_row', [[1, 3], [5, 2]]);
   * ```
   */
  this.alter = function (action, index, amount, source, keepEmptyRows) {
    grid.alter(action, index, amount, source, keepEmptyRows);
  };

  /**
   * Returns a TD element for the given `row` and `column` arguments, if it is rendered on screen.
   * Returns `null` if the TD is not rendered on screen (probably because that part of the table is not visible).
   *
   * @memberof Core#
   * @function getCell
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,
   * if the wanted cell is in the range of fixed rows, it will return a TD element from the `top` overlay.
   * @returns {HTMLTableCellElement|null} The cell's TD element.
   */
  this.getCell = function (row, column) {
    let topmost = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let renderableColumnIndex = column; // Handling also column headers.
    let renderableRowIndex = row; // Handling also row headers.

    if (column >= 0) {
      if (this.columnIndexMapper.isHidden(this.toPhysicalColumn(column))) {
        return null;
      }
      renderableColumnIndex = this.columnIndexMapper.getRenderableFromVisualIndex(column);
    }
    if (row >= 0) {
      if (this.rowIndexMapper.isHidden(this.toPhysicalRow(row))) {
        return null;
      }
      renderableRowIndex = this.rowIndexMapper.getRenderableFromVisualIndex(row);
    }
    if (renderableRowIndex === null || renderableColumnIndex === null || renderableRowIndex === undefined || renderableColumnIndex === undefined) {
      return null;
    }
    return instance.view.getCellAtCoords(instance._createCellCoords(renderableRowIndex, renderableColumnIndex), topmost);
  };

  /**
   * Returns the coordinates of the cell, provided as a HTML table cell element.
   *
   * @memberof Core#
   * @function getCoords
   * @param {HTMLTableCellElement} element The HTML Element representing the cell.
   * @returns {CellCoords|null} Visual coordinates object.
   * @example
   * ```js
   * hot.getCoords(hot.getCell(1, 1));
   * // it returns CellCoords object instance with props row: 1 and col: 1.
   * ```
   */
  this.getCoords = function (element) {
    const renderableCoords = this.view._wt.wtTable.getCoords(element);
    if (renderableCoords === null) {
      return null;
    }
    const {
      row: renderableRow,
      col: renderableColumn
    } = renderableCoords;
    let visualRow = renderableRow;
    let visualColumn = renderableColumn;
    if (renderableRow >= 0) {
      visualRow = this.rowIndexMapper.getVisualFromRenderableIndex(renderableRow);
    }
    if (renderableColumn >= 0) {
      visualColumn = this.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn);
    }
    return instance._createCellCoords(visualRow, visualColumn);
  };

  /**
   * Returns the property name that corresponds with the given column index.
   * If the data source is an array of arrays, it returns the columns index.
   *
   * @memberof Core#
   * @function colToProp
   * @param {number} column Visual column index.
   * @returns {string|number} Column property or physical column index.
   */
  this.colToProp = function (column) {
    return datamap.colToProp(column);
  };

  /**
   * Returns column index that corresponds with the given property.
   *
   * @memberof Core#
   * @function propToCol
   * @param {string|number} prop Property name or physical column index.
   * @returns {number} Visual column index.
   */
  this.propToCol = function (prop) {
    return datamap.propToCol(prop);
  };

  /**
   * Translate physical row index into visual.
   *
   * This method is useful when you want to retrieve visual row index which can be reordered, moved or trimmed
   * based on a physical index.
   *
   * @memberof Core#
   * @function toVisualRow
   * @param {number} row Physical row index.
   * @returns {number} Returns visual row index.
   */
  this.toVisualRow = row => this.rowIndexMapper.getVisualFromPhysicalIndex(row);

  /**
   * Translate physical column index into visual.
   *
   * This method is useful when you want to retrieve visual column index which can be reordered, moved or trimmed
   * based on a physical index.
   *
   * @memberof Core#
   * @function toVisualColumn
   * @param {number} column Physical column index.
   * @returns {number} Returns visual column index.
   */
  this.toVisualColumn = column => this.columnIndexMapper.getVisualFromPhysicalIndex(column);

  /**
   * Translate visual row index into physical.
   *
   * This method is useful when you want to retrieve physical row index based on a visual index which can be
   * reordered, moved or trimmed.
   *
   * @memberof Core#
   * @function toPhysicalRow
   * @param {number} row Visual row index.
   * @returns {number} Returns physical row index.
   */
  this.toPhysicalRow = row => this.rowIndexMapper.getPhysicalFromVisualIndex(row);

  /**
   * Translate visual column index into physical.
   *
   * This method is useful when you want to retrieve physical column index based on a visual index which can be
   * reordered, moved or trimmed.
   *
   * @memberof Core#
   * @function toPhysicalColumn
   * @param {number} column Visual column index.
   * @returns {number} Returns physical column index.
   */
  this.toPhysicalColumn = column => this.columnIndexMapper.getPhysicalFromVisualIndex(column);

  /**
   * @description
   * Returns the cell value at `row`, `column`.
   *
   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.
   *
   * @memberof Core#
   * @function getDataAtCell
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {*} Data at cell.
   */
  this.getDataAtCell = function (row, column) {
    return datamap.get(row, datamap.colToProp(column));
  };

  /**
   * Returns value at visual `row` and `prop` indexes.
   *
   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.
   *
   * @memberof Core#
   * @function getDataAtRowProp
   * @param {number} row Visual row index.
   * @param {string} prop Property name.
   * @returns {*} Cell value.
   */
  this.getDataAtRowProp = function (row, prop) {
    return datamap.get(row, prop);
  };

  /**
   * @description
   * Returns array of column values from the data source.
   *
   * __Note__: If columns were reordered or sorted, the currently visible order will be used.
   *
   * @memberof Core#
   * @function getDataAtCol
   * @param {number} column Visual column index.
   * @returns {Array} Array of cell values.
   */
  this.getDataAtCol = function (column) {
    const columnData = [];
    const dataByRows = datamap.getRange(instance._createCellCoords(0, column), instance._createCellCoords(tableMeta.data.length - 1, column), datamap.DESTINATION_RENDERER);
    for (let i = 0; i < dataByRows.length; i += 1) {
      for (let j = 0; j < dataByRows[i].length; j += 1) {
        columnData.push(dataByRows[i][j]);
      }
    }
    return columnData;
  };

  /**
   * Given the object property name (e.g. `'first.name'` or `'0'`), returns an array of column's values from the table data.
   * You can also provide a column index as the first argument.
   *
   * @memberof Core#
   * @function getDataAtProp
   * @param {string|number} prop Property name or physical column index.
   * @returns {Array} Array of cell values.
   */
  // TODO: Getting data from `datamap` should work on visual indexes.
  this.getDataAtProp = function (prop) {
    const columnData = [];
    const dataByRows = datamap.getRange(instance._createCellCoords(0, datamap.propToCol(prop)), instance._createCellCoords(tableMeta.data.length - 1, datamap.propToCol(prop)), datamap.DESTINATION_RENDERER);
    for (let i = 0; i < dataByRows.length; i += 1) {
      for (let j = 0; j < dataByRows[i].length; j += 1) {
        columnData.push(dataByRows[i][j]);
      }
    }
    return columnData;
  };

  /**
   * Returns a clone of the source data object.
   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a
   * fragment of the table data.
   *
   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,
   * sorted or trimmed only physical indexes are correct.
   *
   * __Note__: This method may return incorrect values for cells that contain
   * [formulas](@/guides/formulas/formula-calculation/formula-calculation.md). This is because `getSourceData()`
   * operates on source data ([physical indexes](@/api/indexMapper.md)),
   * whereas formulas operate on visual data (visual indexes).
   *
   * @memberof Core#
   * @function getSourceData
   * @param {number} [row] From physical row index.
   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).
   * @param {number} [row2] To physical row index.
   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).
   * @returns {Array[]|object[]} The table data.
   */
  this.getSourceData = function (row, column, row2, column2) {
    let data;
    if (row === undefined) {
      data = dataSource.getData();
    } else {
      data = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2));
    }
    return data;
  };

  /**
   * Returns the source data object as an arrays of arrays format even when source data was provided in another format.
   * Optionally you can provide a cell range by using the `row`, `column`, `row2`, `column2` arguments, to get only a
   * fragment of the table data.
   *
   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,
   * sorted or trimmed only physical indexes are correct.
   *
   * @memberof Core#
   * @function getSourceDataArray
   * @param {number} [row] From physical row index.
   * @param {number} [column] From physical column index (or visual index, if data type is an array of objects).
   * @param {number} [row2] To physical row index.
   * @param {number} [column2] To physical column index (or visual index, if data type is an array of objects).
   * @returns {Array} An array of arrays.
   */
  this.getSourceDataArray = function (row, column, row2, column2) {
    let data;
    if (row === undefined) {
      data = dataSource.getData(true);
    } else {
      data = dataSource.getByRange(instance._createCellCoords(row, column), instance._createCellCoords(row2, column2), true);
    }
    return data;
  };

  /**
   * Returns an array of column values from the data source.
   *
   * @memberof Core#
   * @function getSourceDataAtCol
   * @param {number} column Visual column index.
   * @returns {Array} Array of the column's cell values.
   */
  // TODO: Getting data from `sourceData` should work always on physical indexes.
  this.getSourceDataAtCol = function (column) {
    return dataSource.getAtColumn(column);
  };

  /* eslint-disable jsdoc/require-param */
  /**
   * Set the provided value in the source data set at the provided coordinates.
   *
   * @memberof Core#
   * @function setSourceDataAtCell
   * @param {number|Array} row Physical row index or array of changes in format `[[row, prop, value], ...]`.
   * @param {number|string} column Physical column index / prop name.
   * @param {*} value The value to be set at the provided coordinates.
   * @param {string} [source] Source of the change as a string.
   */
  /* eslint-enable jsdoc/require-param */
  this.setSourceDataAtCell = function (row, column, value, source) {
    const input = setDataInputToArray(row, column, value);
    const isThereAnySetSourceListener = this.hasHook('afterSetSourceDataAtCell');
    const changesForHook = [];
    if (isThereAnySetSourceListener) {
      (0, _array.arrayEach)(input, _ref8 => {
        let [changeRow, changeProp, changeValue] = _ref8;
        changesForHook.push([changeRow, changeProp, dataSource.getAtCell(changeRow, changeProp),
        // The previous value.
        changeValue]);
      });
    }
    (0, _array.arrayEach)(input, _ref9 => {
      let [changeRow, changeProp, changeValue] = _ref9;
      dataSource.setAtCell(changeRow, changeProp, changeValue);
    });
    if (isThereAnySetSourceListener) {
      this.runHooks('afterSetSourceDataAtCell', changesForHook, source);
    }
    this.render();
    const activeEditor = instance.getActiveEditor();
    if (activeEditor && (0, _mixed.isDefined)(activeEditor.refreshValue)) {
      activeEditor.refreshValue();
    }
  };

  /**
   * Returns a single row of the data (array or object, depending on what data format you use).
   *
   * __Note__: This method does not participate in data transformation. If the visual data of the table is reordered,
   * sorted or trimmed only physical indexes are correct.
   *
   * @memberof Core#
   * @function getSourceDataAtRow
   * @param {number} row Physical row index.
   * @returns {Array|object} Single row of data.
   */
  this.getSourceDataAtRow = function (row) {
    return dataSource.getAtRow(row);
  };

  /**
   * Returns a single value from the data source.
   *
   * @memberof Core#
   * @function getSourceDataAtCell
   * @param {number} row Physical row index.
   * @param {number} column Visual column index.
   * @returns {*} Cell data.
   */
  // TODO: Getting data from `sourceData` should work always on physical indexes.
  this.getSourceDataAtCell = function (row, column) {
    return dataSource.getAtCell(row, column);
  };

  /**
   * @description
   * Returns a single row of the data.
   *
   * __Note__: If rows were reordered, sorted or trimmed, the currently visible order will be used.
   *
   * @memberof Core#
   * @function getDataAtRow
   * @param {number} row Visual row index.
   * @returns {Array} Array of row's cell data.
   */
  this.getDataAtRow = function (row) {
    const data = datamap.getRange(instance._createCellCoords(row, 0), instance._createCellCoords(row, this.countCols() - 1), datamap.DESTINATION_RENDERER);
    return data[0] || [];
  };

  /**
   * @description
   * Returns a data type defined in the Handsontable settings under the `type` key ({@link Options#type}).
   * If there are cells with different types in the selected range, it returns `'mixed'`.
   *
   * __Note__: If data is reordered, sorted or trimmed, the currently visible order will be used.
   *
   * @memberof Core#
   * @function getDataType
   * @param {number} rowFrom From visual row index.
   * @param {number} columnFrom From visual column index.
   * @param {number} rowTo To visual row index.
   * @param {number} columnTo To visual column index.
   * @returns {string} Cell type (e.q: `'mixed'`, `'text'`, `'numeric'`, `'autocomplete'`).
   */
  this.getDataType = function (rowFrom, columnFrom, rowTo, columnTo) {
    const coords = rowFrom === undefined ? [0, 0, this.countRows(), this.countCols()] : [rowFrom, columnFrom, rowTo, columnTo];
    const [rowStart, columnStart] = coords;
    let [,, rowEnd, columnEnd] = coords;
    let previousType = null;
    let currentType = null;
    if (rowEnd === undefined) {
      rowEnd = rowStart;
    }
    if (columnEnd === undefined) {
      columnEnd = columnStart;
    }
    let type = 'mixed';
    (0, _number.rangeEach)(Math.max(Math.min(rowStart, rowEnd), 0), Math.max(rowStart, rowEnd), row => {
      let isTypeEqual = true;
      (0, _number.rangeEach)(Math.max(Math.min(columnStart, columnEnd), 0), Math.max(columnStart, columnEnd), column => {
        const cellType = this.getCellMeta(row, column);
        currentType = cellType.type;
        if (previousType) {
          isTypeEqual = previousType === currentType;
        } else {
          previousType = currentType;
        }
        return isTypeEqual;
      });
      type = isTypeEqual ? currentType : 'mixed';
      return isTypeEqual;
    });
    return type;
  };

  /**
   * Remove a property defined by the `key` argument from the cell meta object for the provided `row` and `column` coordinates.
   *
   * @memberof Core#
   * @function removeCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key Property name.
   * @fires Hooks#beforeRemoveCellMeta
   * @fires Hooks#afterRemoveCellMeta
   */
  this.removeCellMeta = function (row, column, key) {
    const [physicalRow, physicalColumn] = [this.toPhysicalRow(row), this.toPhysicalColumn(column)];
    let cachedValue = metaManager.getCellMetaKeyValue(physicalRow, physicalColumn, key);
    const hookResult = instance.runHooks('beforeRemoveCellMeta', row, column, key, cachedValue);
    if (hookResult !== false) {
      metaManager.removeCellMeta(physicalRow, physicalColumn, key);
      instance.runHooks('afterRemoveCellMeta', row, column, key, cachedValue);
    }
    cachedValue = null;
  };

  /**
   * Removes or adds one or more rows of the cell meta objects to the cell meta collections.
   *
   * @since 0.30.0
   * @memberof Core#
   * @function spliceCellsMeta
   * @param {number} visualIndex A visual index that specifies at what position to add/remove items.
   * @param {number} [deleteAmount=0] The number of items to be removed. If set to 0, no cell meta objects will be removed.
   * @param {...object} [cellMetaRows] The new cell meta row objects to be added to the cell meta collection.
   */
  this.spliceCellsMeta = function (visualIndex) {
    let deleteAmount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    for (var _len18 = arguments.length, cellMetaRows = new Array(_len18 > 2 ? _len18 - 2 : 0), _key18 = 2; _key18 < _len18; _key18++) {
      cellMetaRows[_key18 - 2] = arguments[_key18];
    }
    if (cellMetaRows.length > 0 && !Array.isArray(cellMetaRows[0])) {
      throw new Error('The 3rd argument (cellMetaRows) has to be passed as an array of cell meta objects array.');
    }
    if (deleteAmount > 0) {
      metaManager.removeRow(this.toPhysicalRow(visualIndex), deleteAmount);
    }
    if (cellMetaRows.length > 0) {
      (0, _array.arrayEach)(cellMetaRows.reverse(), cellMetaRow => {
        metaManager.createRow(this.toPhysicalRow(visualIndex));
        (0, _array.arrayEach)(cellMetaRow, (cellMeta, columnIndex) => this.setCellMetaObject(visualIndex, columnIndex, cellMeta));
      });
    }
    instance.render();
  };

  /**
   * Set cell meta data object defined by `prop` to the corresponding params `row` and `column`.
   *
   * @memberof Core#
   * @function setCellMetaObject
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {object} prop Meta object.
   */
  this.setCellMetaObject = function (row, column, prop) {
    if (typeof prop === 'object') {
      (0, _object.objectEach)(prop, (value, key) => {
        this.setCellMeta(row, column, key, value);
      });
    }
  };

  /**
   * Sets a property defined by the `key` property to the meta object of a cell corresponding to params `row` and `column`.
   *
   * @memberof Core#
   * @function setCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @param {string} key Property name.
   * @param {string} value Property value.
   * @fires Hooks#beforeSetCellMeta
   * @fires Hooks#afterSetCellMeta
   */
  this.setCellMeta = function (row, column, key, value) {
    const allowSetCellMeta = instance.runHooks('beforeSetCellMeta', row, column, key, value);
    if (allowSetCellMeta === false) {
      return;
    }
    let physicalRow = row;
    let physicalColumn = column;
    if (row < this.countRows()) {
      physicalRow = this.toPhysicalRow(row);
    }
    if (column < this.countCols()) {
      physicalColumn = this.toPhysicalColumn(column);
    }
    metaManager.setCellMeta(physicalRow, physicalColumn, key, value);
    instance.runHooks('afterSetCellMeta', row, column, key, value);
  };

  /**
   * Get all the cells meta settings at least once generated in the table (in order of cell initialization).
   *
   * @memberof Core#
   * @function getCellsMeta
   * @returns {Array} Returns an array of ColumnSettings object instances.
   */
  this.getCellsMeta = function () {
    return metaManager.getCellsMeta();
  };

  /**
   * Returns the cell properties object for the given `row` and `column` coordinates.
   *
   * @memberof Core#
   * @function getCellMeta
   * @param {number} row Visual row index.
   * @param {number} column Visual column index.
   * @returns {object} The cell properties object.
   * @fires Hooks#beforeGetCellMeta
   * @fires Hooks#afterGetCellMeta
   */
  this.getCellMeta = function (row, column) {
    let physicalRow = this.toPhysicalRow(row);
    let physicalColumn = this.toPhysicalColumn(column);
    if (physicalRow === null) {
      physicalRow = row;
    }
    if (physicalColumn === null) {
      physicalColumn = column;
    }
    return metaManager.getCellMeta(physicalRow, physicalColumn, {
      visualRow: row,
      visualColumn: column
    });
  };

  /**
   * Returns the meta information for the provided column.
   *
   * @since 14.5.0
   * @memberof Core#
   * @function getColumnMeta
   * @param {number} column Visual column index.
   * @returns {object}
   */
  this.getColumnMeta = function (column) {
    return metaManager.getColumnMeta(this.toPhysicalColumn(column));
  };

  /**
   * Returns an array of cell meta objects for specified physical row index.
   *
   * @memberof Core#
   * @function getCellMetaAtRow
   * @param {number} row Physical row index.
   * @returns {Array}
   */
  this.getCellMetaAtRow = function (row) {
    return metaManager.getCellsMetaAtRow(row);
  };

  /**
   * Checks if your [data format](@/guides/getting-started/binding-to-data/binding-to-data.md#compatible-data-types)
   * and [configuration options](@/guides/getting-started/configuration-options/configuration-options.md)
   * allow for changing the number of columns.
   *
   * Returns `false` when your data is an array of objects,
   * or when you use the [`columns`](@/api/options.md#columns) option.
   * Otherwise, returns `true`.
   *
   * @memberof Core#
   * @function isColumnModificationAllowed
   * @returns {boolean}
   */
  this.isColumnModificationAllowed = function () {
    return !(instance.dataType === 'object' || tableMeta.columns);
  };

  /**
   * Returns the cell renderer function by given `row` and `column` arguments.
   *
   * @memberof Core#
   * @function getCellRenderer
   * @param {number|object} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).
   * @param {number} column Visual column index.
   * @returns {Function} Returns the renderer function.
   * @example
   * ```js
   * // Get cell renderer using `row` and `column` coordinates.
   * hot.getCellRenderer(1, 1);
   * // Get cell renderer using cell meta object.
   * hot.getCellRenderer(hot.getCellMeta(1, 1));
   * ```
   */
  this.getCellRenderer = function (rowOrMeta, column) {
    const cellRenderer = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).renderer : rowOrMeta.renderer;
    if (typeof cellRenderer === 'string') {
      return (0, _registry2.getRenderer)(cellRenderer);
    }
    return (0, _mixed.isUndefined)(cellRenderer) ? (0, _registry2.getRenderer)('text') : cellRenderer;
  };

  /**
   * Returns the cell editor class by the provided `row` and `column` arguments.
   *
   * @memberof Core#
   * @function getCellEditor
   * @param {number} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).
   * @param {number} column Visual column index.
   * @returns {Function|boolean} Returns the editor class or `false` is cell editor is disabled.
   * @example
   * ```js
   * // Get cell editor class using `row` and `column` coordinates.
   * hot.getCellEditor(1, 1);
   * // Get cell editor class using cell meta object.
   * hot.getCellEditor(hot.getCellMeta(1, 1));
   * ```
   */
  this.getCellEditor = function (rowOrMeta, column) {
    const cellEditor = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).editor : rowOrMeta.editor;
    if (typeof cellEditor === 'string') {
      return (0, _registry3.getEditor)(cellEditor);
    }
    return (0, _mixed.isUndefined)(cellEditor) ? (0, _registry3.getEditor)('text') : cellEditor;
  };

  /**
   * Returns the cell validator by `row` and `column`.
   *
   * @memberof Core#
   * @function getCellValidator
   * @param {number|object} rowOrMeta Visual row index or cell meta object (see {@link Core#getCellMeta}).
   * @param {number} column Visual column index.
   * @returns {Function|RegExp|undefined} The validator function.
   * @example
   * ```js
   * // Get cell validator using `row` and `column` coordinates.
   * hot.getCellValidator(1, 1);
   * // Get cell validator using cell meta object.
   * hot.getCellValidator(hot.getCellMeta(1, 1));
   * ```
   */
  this.getCellValidator = function (rowOrMeta, column) {
    const cellValidator = typeof rowOrMeta === 'number' ? instance.getCellMeta(rowOrMeta, column).validator : rowOrMeta.validator;
    if (typeof cellValidator === 'string') {
      return (0, _registry4.getValidator)(cellValidator);
    }
    return cellValidator;
  };

  /**
   * Validates every cell in the data set,
   * using a [validator function](@/guides/cell-functions/cell-validator/cell-validator.md) configured for each cell.
   *
   * Doesn't validate cells that are currently [trimmed](@/guides/rows/row-trimming/row-trimming.md),
   * [hidden](@/guides/rows/row-hiding/row-hiding.md), or [filtered](@/guides/columns/column-filter/column-filter.md),
   * as such cells are not included in the data set until you bring them back again.
   *
   * After the validation, the `callback` function is fired, with the `valid` argument set to:
   * - `true` for valid cells
   * - `false` for invalid cells
   *
   * @memberof Core#
   * @function validateCells
   * @param {Function} [callback] The callback function.
   * @example
   * ```js
   * hot.validateCells((valid) => {
   *   if (valid) {
   *     // ... code for validated cells
   *   }
   * })
   * ```
   */
  this.validateCells = function (callback) {
    this._validateCells(callback);
  };

  /**
   * Validates rows using their validator functions and calls callback when finished.
   *
   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it
   *  would equal `true`.
   *
   * @memberof Core#
   * @function validateRows
   * @param {Array} [rows] Array of validation target visual row indexes.
   * @param {Function} [callback] The callback function.
   * @example
   * ```js
   * hot.validateRows([3, 4, 5], (valid) => {
   *   if (valid) {
   *     // ... code for validated rows
   *   }
   * })
   * ```
   */
  this.validateRows = function (rows, callback) {
    if (!Array.isArray(rows)) {
      throw new Error('validateRows parameter `rows` must be an array');
    }
    this._validateCells(callback, rows);
  };

  /**
   * Validates columns using their validator functions and calls callback when finished.
   *
   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it
   *  would equal `true`.
   *
   * @memberof Core#
   * @function validateColumns
   * @param {Array} [columns] Array of validation target visual columns indexes.
   * @param {Function} [callback] The callback function.
   * @example
   * ```js
   * hot.validateColumns([3, 4, 5], (valid) => {
   *   if (valid) {
   *     // ... code for validated columns
   *   }
   * })
   * ```
   */
  this.validateColumns = function (columns, callback) {
    if (!Array.isArray(columns)) {
      throw new Error('validateColumns parameter `columns` must be an array');
    }
    this._validateCells(callback, undefined, columns);
  };

  /**
   * Validates all cells using their validator functions and calls callback when finished.
   *
   * If one of the cells is invalid, the callback will be fired with `'valid'` arguments as `false` - otherwise it would equal `true`.
   *
   * Private use intended.
   *
   * @private
   * @memberof Core#
   * @function _validateCells
   * @param {Function} [callback] The callback function.
   * @param {Array} [rows] An array of validation target visual row indexes.
   * @param {Array} [columns] An array of validation target visual column indexes.
   */
  this._validateCells = function (callback, rows, columns) {
    const waitingForValidator = new ValidatorsQueue();
    if (callback) {
      waitingForValidator.onQueueEmpty = callback;
    }
    let i = instance.countRows() - 1;
    while (i >= 0) {
      if (rows !== undefined && rows.indexOf(i) === -1) {
        i -= 1;
        continue;
      }
      let j = instance.countCols() - 1;
      while (j >= 0) {
        if (columns !== undefined && columns.indexOf(j) === -1) {
          j -= 1;
          continue;
        }
        waitingForValidator.addValidatorToQueue();
        instance.validateCell(instance.getDataAtCell(i, j), instance.getCellMeta(i, j), result => {
          if (typeof result !== 'boolean') {
            throw new Error('Validation error: result is not boolean');
          }
          if (result === false) {
            waitingForValidator.valid = false;
          }
          waitingForValidator.removeValidatorFormQueue();
        }, 'validateCells');
        j -= 1;
      }
      i -= 1;
    }
    waitingForValidator.checkIfQueueIsEmpty();
  };

  /**
   * Returns an array of row headers' values (if they are enabled). If param `row` was given, it returns the header of the given row as a string.
   *
   * @memberof Core#
   * @function getRowHeader
   * @param {number} [row] Visual row index.
   * @fires Hooks#modifyRowHeader
   * @returns {Array|string|number} Array of header values / single header value.
   */
  this.getRowHeader = function (row) {
    let rowHeader = tableMeta.rowHeaders;
    let physicalRow = row;
    if (physicalRow !== undefined) {
      physicalRow = instance.runHooks('modifyRowHeader', physicalRow);
    }
    if (physicalRow === undefined) {
      rowHeader = [];
      (0, _number.rangeEach)(instance.countRows() - 1, i => {
        rowHeader.push(instance.getRowHeader(i));
      });
    } else if (Array.isArray(rowHeader) && rowHeader[physicalRow] !== undefined) {
      rowHeader = rowHeader[physicalRow];
    } else if ((0, _function.isFunction)(rowHeader)) {
      rowHeader = rowHeader(physicalRow);
    } else if (rowHeader && typeof rowHeader !== 'string' && typeof rowHeader !== 'number') {
      rowHeader = physicalRow + 1;
    }
    return rowHeader;
  };

  /**
   * Returns information about if this table is configured to display row headers.
   *
   * @memberof Core#
   * @function hasRowHeaders
   * @returns {boolean} `true` if the instance has the row headers enabled, `false` otherwise.
   */
  this.hasRowHeaders = function () {
    return !!tableMeta.rowHeaders;
  };

  /**
   * Returns information about if this table is configured to display column headers.
   *
   * @memberof Core#
   * @function hasColHeaders
   * @returns {boolean} `true` if the instance has the column headers enabled, `false` otherwise.
   */
  this.hasColHeaders = function () {
    if (tableMeta.colHeaders !== undefined && tableMeta.colHeaders !== null) {
      // Polymer has empty value = null
      return !!tableMeta.colHeaders;
    }
    for (let i = 0, ilen = instance.countCols(); i < ilen; i++) {
      if (instance.getColHeader(i)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Gets the values of column headers (if column headers are [enabled](@/api/options.md#colheaders)).
   *
   * To get an array with the values of all
   * [bottom-most](@/guides/cell-features/clipboard/clipboard.md#copy-with-headers) column headers,
   * call `getColHeader()` with no arguments.
   *
   * To get the value of the bottom-most header of a specific column, use the `column` parameter.
   *
   * To get the value of a [specific-level](@/guides/columns/column-groups/column-groups.md) header
   * of a specific column, use the `column` and `headerLevel` parameters.
   *
   * Read more:
   * - [Guides: Column groups](@/guides/columns/column-groups/column-groups.md)
   * - [Options: `colHeaders`](@/api/options.md#colheaders)
   * - [Guides: Copy with headers](@/guides/cell-features/clipboard/clipboard.md#copy-with-headers)
   *
   * ```js
   * // get the contents of all bottom-most column headers
   * hot.getColHeader();
   *
   * // get the contents of the bottom-most header of a specific column
   * hot.getColHeader(5);
   *
   * // get the contents of a specific column header at a specific level
   * hot.getColHeader(5, -2);
   * ```
   *
   * @memberof Core#
   * @function getColHeader
   * @param {number} [column] A visual column index.
   * @param {number} [headerLevel=-1] (Since 12.3.0) Header level index. Accepts positive (0 to n)
   *                                  and negative (-1 to -n) values. For positive values, 0 points to the
   *                                  topmost header. For negative values, -1 points to the bottom-most
   *                                  header (the header closest to the cells).
   * @fires Hooks#modifyColHeader
   * @fires Hooks#modifyColumnHeaderValue
   * @returns {Array|string|number} Column header values.
   */
  this.getColHeader = function (column) {
    let headerLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    const columnIndex = instance.runHooks('modifyColHeader', column);
    if (columnIndex === undefined) {
      const out = [];
      const ilen = instance.countCols();
      for (let i = 0; i < ilen; i++) {
        out.push(instance.getColHeader(i));
      }
      return out;
    }
    let result = tableMeta.colHeaders;
    const translateVisualIndexToColumns = function (visualColumnIndex) {
      const arr = [];
      const columnsLen = instance.countCols();
      let index = 0;
      for (; index < columnsLen; index++) {
        if ((0, _function.isFunction)(tableMeta.columns) && tableMeta.columns(index)) {
          arr.push(index);
        }
      }
      return arr[visualColumnIndex];
    };
    const physicalColumn = instance.toPhysicalColumn(columnIndex);
    const prop = translateVisualIndexToColumns(physicalColumn);
    if (tableMeta.colHeaders === false) {
      result = null;
    } else if (tableMeta.columns && (0, _function.isFunction)(tableMeta.columns) && tableMeta.columns(prop) && tableMeta.columns(prop).title) {
      result = tableMeta.columns(prop).title;
    } else if (tableMeta.columns && tableMeta.columns[physicalColumn] && tableMeta.columns[physicalColumn].title) {
      result = tableMeta.columns[physicalColumn].title;
    } else if (Array.isArray(tableMeta.colHeaders) && tableMeta.colHeaders[physicalColumn] !== undefined) {
      result = tableMeta.colHeaders[physicalColumn];
    } else if ((0, _function.isFunction)(tableMeta.colHeaders)) {
      result = tableMeta.colHeaders(physicalColumn);
    } else if (tableMeta.colHeaders && typeof tableMeta.colHeaders !== 'string' && typeof tableMeta.colHeaders !== 'number') {
      result = (0, _data.spreadsheetColumnLabel)(columnIndex); // see #1458
    }
    result = instance.runHooks('modifyColumnHeaderValue', result, column, headerLevel);
    return result;
  };

  /**
   * Return column width from settings (no guessing). Private use intended.
   *
   * @private
   * @memberof Core#
   * @function _getColWidthFromSettings
   * @param {number} col Visual col index.
   * @returns {number}
   */
  this._getColWidthFromSettings = function (col) {
    let width;

    // We currently don't support cell meta objects for headers (negative values)
    if (col >= 0) {
      const cellProperties = instance.getCellMeta(0, col);
      width = cellProperties.width;
    }
    if (width === undefined || width === tableMeta.width) {
      width = tableMeta.colWidths;
    }
    if (width !== undefined && width !== null) {
      switch (typeof width) {
        case 'object':
          // array
          width = width[col];
          break;
        case 'function':
          width = width(col);
          break;
        default:
          break;
      }
      if (typeof width === 'string') {
        width = parseInt(width, 10);
      }
    }
    return width;
  };

  /**
   * Returns the width of the requested column.
   *
   * @memberof Core#
   * @function getColWidth
   * @param {number} column Visual column index.
   * @param {string} [source] The source of the call.
   * @returns {number} Column width.
   * @fires Hooks#modifyColWidth
   */
  this.getColWidth = function (column, source) {
    let width = instance._getColWidthFromSettings(column);
    width = instance.runHooks('modifyColWidth', width, column, source);
    if (width === undefined) {
      width = _src.DEFAULT_COLUMN_WIDTH;
    }
    return width;
  };

  /**
   * Return row height from settings (no guessing). Private use intended.
   *
   * @private
   * @memberof Core#
   * @function _getRowHeightFromSettings
   * @param {number} row Visual row index.
   * @returns {number}
   */
  this._getRowHeightFromSettings = function (row) {
    let height = tableMeta.rowHeights;
    if (height !== undefined && height !== null) {
      switch (typeof height) {
        case 'object':
          // array
          height = height[row];
          break;
        case 'function':
          height = height(row);
          break;
        default:
          break;
      }
      if (typeof height === 'string') {
        height = parseInt(height, 10);
      }
    }
    return height;
  };

  /**
   * Returns a row's height, as recognized by Handsontable.
   *
   * Depending on your configuration, the method returns (in order of priority):
   *   1. The row height set by the [`ManualRowResize`](@/api/manualRowResize.md) plugin
   *     (if the plugin is enabled).
   *   2. The row height set by the [`rowHeights`](@/api/options.md#rowheights) configuration option
   *     (if the option is set).
   *   3. The row height as measured in the DOM by the [`AutoRowSize`](@/api/autoRowSize.md) plugin
   *     (if the plugin is enabled).
   *   4. `undefined`, if neither [`ManualRowResize`](@/api/manualRowResize.md),
   *     nor [`rowHeights`](@/api/options.md#rowheights),
   *     nor [`AutoRowSize`](@/api/autoRowSize.md) is used.
   *
   * The height returned includes 1 px of the row's bottom border.
   *
   * Mind that this method is different from the
   * [`getRowHeight()`](@/api/autoRowSize.md#getrowheight) method
   * of the [`AutoRowSize`](@/api/autoRowSize.md) plugin.
   *
   * @memberof Core#
   * @function getRowHeight
   * @param {number} row A visual row index.
   * @param {string} [source] The source of the call.
   * @returns {number|undefined} The height of the specified row, in pixels.
   * @fires Hooks#modifyRowHeight
   */
  this.getRowHeight = function (row, source) {
    let height = instance._getRowHeightFromSettings(row);
    height = instance.runHooks('modifyRowHeight', height, row, source);
    return height;
  };

  /**
   * Returns the total number of rows in the data source.
   *
   * @memberof Core#
   * @function countSourceRows
   * @returns {number} Total number of rows.
   */
  this.countSourceRows = function () {
    return dataSource.countRows();
  };

  /**
   * Returns the total number of columns in the data source.
   *
   * @memberof Core#
   * @function countSourceCols
   * @returns {number} Total number of columns.
   */
  this.countSourceCols = function () {
    return dataSource.countFirstRowKeys();
  };

  /**
   * Returns the total number of visual rows in the table.
   *
   * @memberof Core#
   * @function countRows
   * @returns {number} Total number of rows.
   */
  this.countRows = function () {
    return datamap.getLength();
  };

  /**
   * Returns the total number of visible columns in the table.
   *
   * @memberof Core#
   * @function countCols
   * @returns {number} Total number of columns.
   */
  this.countCols = function () {
    const maxCols = tableMeta.maxCols;
    const dataLen = this.columnIndexMapper.getNotTrimmedIndexesLength();
    return Math.min(maxCols, dataLen);
  };

  /**
   * Returns the number of rendered rows including rows that are partially or fully rendered
   * outside the table viewport.
   *
   * @memberof Core#
   * @function countRenderedRows
   * @returns {number} Returns -1 if table is not visible.
   */
  this.countRenderedRows = function () {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedRowsCount() : -1;
  };

  /**
   * Returns the number of rendered rows that are only visible in the table viewport.
   * The rows that are partially visible are not counted.
   *
   * @memberof Core#
   * @function countVisibleRows
   * @returns {number} Number of visible rows or -1.
   */
  this.countVisibleRows = function () {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleRowsCount() : -1;
  };

  /**
   * Returns the number of rendered rows including columns that are partially or fully rendered
   * outside the table viewport.
   *
   * @memberof Core#
   * @function countRenderedCols
   * @returns {number} Returns -1 if table is not visible.
   */
  this.countRenderedCols = function () {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getRenderedColumnsCount() : -1;
  };

  /**
   * Returns the number of rendered columns that are only visible in the table viewport.
   * The columns that are partially visible are not counted.
   *
   * @memberof Core#
   * @function countVisibleCols
   * @returns {number} Number of visible columns or -1.
   */
  this.countVisibleCols = function () {
    return instance.view._wt.drawn ? instance.view._wt.wtTable.getVisibleColumnsCount() : -1;
  };

  /**
   * Returns the number of rendered row headers.
   *
   * @since 14.0.0
   * @memberof Core#
   * @function countRowHeaders
   * @returns {number} Number of row headers.
   */
  this.countRowHeaders = function () {
    return this.view.getRowHeadersCount();
  };

  /**
   * Returns the number of rendered column headers.
   *
   * @since 14.0.0
   * @memberof Core#
   * @function countColHeaders
   * @returns {number} Number of column headers.
   */
  this.countColHeaders = function () {
    return this.view.getColumnHeadersCount();
  };

  /**
   * Returns the number of empty rows. If the optional ending parameter is `true`, returns the
   * number of empty rows at the bottom of the table.
   *
   * @memberof Core#
   * @function countEmptyRows
   * @param {boolean} [ending=false] If `true`, will only count empty rows at the end of the data source.
   * @returns {number} Count empty rows.
   */
  this.countEmptyRows = function () {
    let ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let emptyRows = 0;
    (0, _number.rangeEachReverse)(instance.countRows() - 1, visualIndex => {
      if (instance.isEmptyRow(visualIndex)) {
        emptyRows += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyRows;
  };

  /**
   * Returns the number of empty columns. If the optional ending parameter is `true`, returns the number of empty
   * columns at right hand edge of the table.
   *
   * @memberof Core#
   * @function countEmptyCols
   * @param {boolean} [ending=false] If `true`, will only count empty columns at the end of the data source row.
   * @returns {number} Count empty cols.
   */
  this.countEmptyCols = function () {
    let ending = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let emptyColumns = 0;
    (0, _number.rangeEachReverse)(instance.countCols() - 1, visualIndex => {
      if (instance.isEmptyCol(visualIndex)) {
        emptyColumns += 1;
      } else if (ending === true) {
        return false;
      }
    });
    return emptyColumns;
  };

  /**
   * Check if all cells in the row declared by the `row` argument are empty.
   *
   * @memberof Core#
   * @function isEmptyRow
   * @param {number} row Visual row index.
   * @returns {boolean} `true` if the row at the given `row` is empty, `false` otherwise.
   */
  this.isEmptyRow = function (row) {
    return tableMeta.isEmptyRow.call(instance, row);
  };

  /**
   * Check if all cells in the the column declared by the `column` argument are empty.
   *
   * @memberof Core#
   * @function isEmptyCol
   * @param {number} column Column index.
   * @returns {boolean} `true` if the column at the given `col` is empty, `false` otherwise.
   */
  this.isEmptyCol = function (column) {
    return tableMeta.isEmptyCol.call(instance, column);
  };

  /**
   * Select a single cell, or a single range of adjacent cells.
   *
   * To select a cell, pass its visual row and column indexes, for example: `selectCell(2, 4)`.
   *
   * To select a range, pass the visual indexes of the first and last cell in the range, for example: `selectCell(2, 4, 3, 5)`.
   *
   * If your columns have properties, you can pass those properties' values instead of column indexes, for example: `selectCell(2, 'first_name')`.
   *
   * By default, `selectCell()` also:
   *  - Scrolls the viewport to the newly-selected cells.
   *  - Switches the keyboard focus to Handsontable (by calling Handsontable's [`listen()`](#listen) method).
   *
   * @example
   * ```js
   * // select a single cell
   * hot.selectCell(2, 4);
   *
   * // select a range of cells
   * hot.selectCell(2, 4, 3, 5);
   *
   * // select a single cell, using a column property
   * hot.selectCell(2, 'first_name');
   *
   * // select a range of cells, using column properties
   * hot.selectCell(2, 'first_name', 3, 'last_name');
   *
   * // select a range of cells, without scrolling to them
   * hot.selectCell(2, 4, 3, 5, false);
   *
   * // select a range of cells, without switching the keyboard focus to Handsontable
   * hot.selectCell(2, 4, 3, 5, null, false);
   * ```
   *
   * @memberof Core#
   * @function selectCell
   * @param {number} row A visual row index.
   * @param {number|string} column A visual column index (`number`), or a column property's value (`string`).
   * @param {number} [endRow] If selecting a range: the visual row index of the last cell in the range.
   * @param {number|string} [endColumn] If selecting a range: the visual column index (or a column property's value) of the last cell in the range.
   * @param {boolean} [scrollToCell=true] `true`: scroll the viewport to the newly-selected cells. `false`: keep the previous viewport.
   * @param {boolean} [changeListener=true] `true`: switch the keyboard focus to Handsontable. `false`: keep the previous keyboard focus.
   * @returns {boolean} `true`: the selection was successful, `false`: the selection failed.
   */
  this.selectCell = function (row, column, endRow, endColumn) {
    let scrollToCell = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    let changeListener = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
    if ((0, _mixed.isUndefined)(row) || (0, _mixed.isUndefined)(column)) {
      return false;
    }
    return this.selectCells([[row, column, endRow, endColumn]], scrollToCell, changeListener);
  };

  /**
   * Select multiple cells or ranges of cells, adjacent or non-adjacent.
   *
   * You can pass one of the below:
   * - An array of arrays (which matches the output of Handsontable's [`getSelected()`](#getselected) method).
   * - An array of [`CellRange`](@/api/cellRange.md) objects (which matches the output of Handsontable's [`getSelectedRange()`](#getselectedrange) method).
   *
   * To select multiple cells, pass the visual row and column indexes of each cell, for example: `hot.selectCells([[1, 1], [5, 5]])`.
   *
   * To select multiple ranges, pass the visual indexes of the first and last cell in each range, for example: `hot.selectCells([[1, 1, 2, 2], [6, 2, 0, 2]])`.
   *
   * If your columns have properties, you can pass those properties' values instead of column indexes, for example: `hot.selectCells([[1, 'first_name'], [5, 'last_name']])`.
   *
   * By default, `selectCell()` also:
   *  - Scrolls the viewport to the newly-selected cells.
   *  - Switches the keyboard focus to Handsontable (by calling Handsontable's [`listen()`](#listen) method).
   *
   * @example
   * ```js
   * // select non-adjacent cells
   * hot.selectCells([[1, 1], [5, 5], [10, 10]]);
   *
   * // select non-adjacent ranges of cells
   * hot.selectCells([[1, 1, 2, 2], [10, 10, 20, 20]]);
   *
   * // select cells and ranges of cells
   * hot.selectCells([[1, 1, 2, 2], [3, 3], [6, 2, 0, 2]]);
   *
   * // select cells, using column properties
   * hot.selectCells([[1, 'id', 2, 'first_name'], [3, 'full_name'], [6, 'last_name', 0, 'first_name']]);
   *
   * // select multiple ranges, using an array of `CellRange` objects
   * const selected = hot.getSelectedRange();
   *
   * selected[0].from.row = 0;
   * selected[0].from.col = 0;
   * selected[0].to.row = 5;
   * selected[0].to.col = 5;
   *
   * selected[1].from.row = 10;
   * selected[1].from.col = 10;
   * selected[1].to.row = 20;
   * selected[1].to.col = 20;
   *
   * hot.selectCells(selected);
   * ```
   *
   * @memberof Core#
   * @since 0.38.0
   * @function selectCells
   * @param {Array[]|CellRange[]} coords Visual coordinates,
   * passed either as an array of arrays (`[[rowStart, columnStart, rowEnd, columnEnd], ...]`)
   * or as an array of [`CellRange`](@/api/cellRange.md) objects.
   * @param {boolean} [scrollToCell=true] `true`: scroll the viewport to the newly-selected cells. `false`: keep the previous viewport.
   * @param {boolean} [changeListener=true] `true`: switch the keyboard focus to Handsontable. `false`: keep the previous keyboard focus.
   * @returns {boolean} `true`: the selection was successful, `false`: the selection failed.
   */
  this.selectCells = function () {
    let coords = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[]];
    let scrollToCell = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    let changeListener = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (scrollToCell === false) {
      viewportScroller.suspend();
    }
    const wasSelected = selection.selectCells(coords);
    if (wasSelected && changeListener) {
      instance.listen();
    }
    viewportScroller.resume();
    return wasSelected;
  };

  /**
   * Select column specified by `startColumn` visual index, column property or a range of columns finishing at `endColumn`.
   *
   * @example
   * ```js
   * // Select column using visual index.
   * hot.selectColumns(1);
   * // Select column using column property.
   * hot.selectColumns('id');
   * // Select range of columns using visual indexes.
   * hot.selectColumns(1, 4);
   * // Select range of columns using visual indexes and mark the first header as highlighted.
   * hot.selectColumns(1, 2, -1);
   * // Select range of columns using visual indexes and mark the second cell as highlighted.
   * hot.selectColumns(2, 1, 1);
   * // Select range of columns using visual indexes and move the focus position somewhere in the middle of the range.
   * hot.selectColumns(2, 5, { row: 2, col: 3 });
   * // Select range of columns using column properties.
   * hot.selectColumns('id', 'last_name');
   * ```
   *
   * @memberof Core#
   * @since 0.38.0
   * @function selectColumns
   * @param {number} startColumn The visual column index from which the selection starts.
   * @param {number} [endColumn=startColumn] The visual column index to which the selection finishes. If `endColumn`
   * is not defined the column defined by `startColumn` will be selected.
   * @param {number | { row: number, col: number } | CellCoords} [focusPosition=0] The argument allows changing the cell/header focus
   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive
   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus
   * position horizontally.
   * @returns {boolean} `true` if selection was successful, `false` otherwise.
   */
  this.selectColumns = function (startColumn) {
    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;
    let focusPosition = arguments.length > 2 ? arguments[2] : undefined;
    return selection.selectColumns(startColumn, endColumn, focusPosition);
  };

  /**
   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.
   *
   * @example
   * ```js
   * // Select row using visual index.
   * hot.selectRows(1);
   * // select a range of rows, using visual indexes.
   * hot.selectRows(1, 4);
   * // select a range of rows, using visual indexes, and mark the header as highlighted.
   * hot.selectRows(1, 2, -1);
   * // Select range of rows using visual indexes and mark the second cell as highlighted.
   * hot.selectRows(2, 1, 1);
   * // Select range of rows using visual indexes and move the focus position somewhere in the middle of the range.
   * hot.selectRows(2, 5, { row: 2, col: 3 });
   * ```
   *
   * @memberof Core#
   * @since 0.38.0
   * @function selectRows
   * @param {number} startRow The visual row index from which the selection starts.
   * @param {number} [endRow=startRow] The visual row index to which the selection finishes. If `endRow`
   * is not defined the row defined by `startRow` will be selected.
   * @param {number | { row: number, col: number } | CellCoords} [focusPosition=0] The argument allows changing the cell/header focus
   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive
   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus
   * position vertically.
   * @returns {boolean} `true` if selection was successful, `false` otherwise.
   */
  this.selectRows = function (startRow) {
    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;
    let focusPosition = arguments.length > 2 ? arguments[2] : undefined;
    return selection.selectRows(startRow, endRow, focusPosition);
  };

  /**
   * Deselects the current cell selection on the table.
   *
   * @memberof Core#
   * @function deselectCell
   */
  this.deselectCell = function () {
    selection.deselect();
  };

  /**
   * Select all cells in the table excluding headers and corner elements.
   *
   * The previous selection is overwritten.
   *
   * ```js
   * // Select all cells in the table along with row headers, including all headers and the corner cell.
   * // Doesn't select column headers and corner elements.
   * hot.selectAll();
   *
   * // Select all cells in the table, including row headers but excluding the corner cell and column headers.
   * hot.selectAll(true, false);
   *
   * // Select all cells in the table, including all headers and the corner cell, but move the focus.
   * // highlight to position 2, 1
   * hot.selectAll(-2, -1, {
   *    focusPosition: { row: 2, col: 1 }
   * });
   *
   * // Select all cells in the table, without headers and corner elements.
   * hot.selectAll(false);
   * ```
   *
   * @since 0.38.2
   * @memberof Core#
   * @function selectAll
   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,
   * `false` otherwise.
   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column
   * headers, `false` otherwise.
   *
   * @param {object} [options] Additional object with options. Since 14.0.0
   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header
   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where
   * negative values point to the headers and positive values point to the cell range. If `false`, the focus
   * position won't be changed. Example:
   * ```js
   * hot.selectAll(0, 0, {
   * focusPosition: { row: 0, col: 1 },
   * disableHeadersHighlight: true
   * })
   * ```
   *
   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when
   * the logical coordinates points on them.
   */
  this.selectAll = function () {
    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : includeRowHeaders;
    let options = arguments.length > 2 ? arguments[2] : undefined;
    viewportScroller.skipNextScrollCycle();
    selection.selectAll(includeRowHeaders, includeColumnHeaders, options);
  };
  const getIndexToScroll = (indexMapper, visualIndex) => {
    // Looking for a visual index on the right and then (when not found) on the left.
    return indexMapper.getNearestNotHiddenIndex(visualIndex, 1, true);
  };

  /**
   * Scroll viewport to coordinates specified by the `row` and/or `col` object properties.
   *
   * ```js
   * // scroll the viewport to the visual row index (leave the horizontal scroll untouched)
   * hot.scrollViewportTo({ row: 50 });
   *
   * // scroll the viewport to the passed coordinates so that the cell at 50, 50 will be snapped to
   * // the bottom-end table's edge.
   * hot.scrollViewportTo({
   *   row: 50,
   *   col: 50,
   *   verticalSnap: 'bottom',
   *   horizontalSnap: 'end',
   * });
   * ```
   *
   * @memberof Core#
   * @function scrollViewportTo
   * @param {object} options A dictionary containing the following parameters:
   * @param {number} [options.row] Specifies the number of visual rows along the Y axis to scroll the viewport.
   * @param {number} [options.col] Specifies the number of visual columns along the X axis to scroll the viewport.
   * @param {'top' | 'bottom'} [options.verticalSnap] Determines to which edge of the table the viewport will be scrolled based on the passed coordinates.
   * This option is a string which must take one of the following values:
   * - `top`: The viewport will be scrolled to a row in such a way that it will be positioned on the top of the viewport;
   * - `bottom`: The viewport will be scrolled to a row in such a way that it will be positioned on the bottom of the viewport;
   * - If the property is not defined the vertical auto-snapping is enabled. Depending on where the viewport is scrolled from, a row will
   * be positioned at the top or bottom of the viewport.
   * @param {'start' | 'end'} [options.horizontalSnap] Determines to which edge of the table the viewport will be scrolled based on the passed coordinates.
   * This option is a string which must take one of the following values:
   * - `start`: The viewport will be scrolled to a column in such a way that it will be positioned on the start (left edge or right, if the layout direction is set to `rtl`) of the viewport;
   * - `end`: The viewport will be scrolled to a column in such a way that it will be positioned on the end (right edge or left, if the layout direction is set to `rtl`) of the viewport;
   * - If the property is not defined the horizontal auto-snapping is enabled. Depending on where the viewport is scrolled from, a column will
   * be positioned at the start or end of the viewport.
   * @param {boolean} [options.considerHiddenIndexes=true] If `true`, we handle visual indexes, otherwise we handle only indexes which
   * may be rendered when they are in the viewport (we don't consider hidden indexes as they aren't rendered).
   * @returns {boolean} `true` if viewport was scrolled, `false` otherwise.
   */
  this.scrollViewportTo = function (options) {
    var _options;
    // Support for backward compatibility arguments: (row, col, snapToBottom, snapToRight, considerHiddenIndexes)
    if (typeof options === 'number') {
      var _arguments$;
      /* eslint-disable prefer-rest-params */
      options = {
        row: arguments[0],
        col: arguments[1],
        verticalSnap: arguments[2] ? 'bottom' : 'top',
        horizontalSnap: arguments[3] ? 'end' : 'start',
        considerHiddenIndexes: (_arguments$ = arguments[4]) !== null && _arguments$ !== void 0 ? _arguments$ : true
      };
      /* eslint-enable prefer-rest-params */
    }
    const {
      row,
      col,
      considerHiddenIndexes
    } = (_options = options) !== null && _options !== void 0 ? _options : {};
    let renderableRow = row;
    let renderableColumn = col;
    if (considerHiddenIndexes === undefined || considerHiddenIndexes) {
      const isValidRowGrid = Number.isInteger(row) && row >= 0;
      const isValidColumnGrid = Number.isInteger(col) && col >= 0;
      const visualRowToScroll = isValidRowGrid ? getIndexToScroll(this.rowIndexMapper, row) : undefined;
      const visualColumnToScroll = isValidColumnGrid ? getIndexToScroll(this.columnIndexMapper, col) : undefined;
      if (visualRowToScroll === null || visualColumnToScroll === null) {
        return false;
      }
      renderableRow = isValidRowGrid ? instance.rowIndexMapper.getRenderableFromVisualIndex(visualRowToScroll) : row;
      renderableColumn = isValidColumnGrid ? instance.columnIndexMapper.getRenderableFromVisualIndex(visualColumnToScroll) : col;
    }
    const isRowInteger = Number.isInteger(renderableRow);
    const isColumnInteger = Number.isInteger(renderableColumn);
    if (isRowInteger && renderableRow >= 0 && isColumnInteger && renderableColumn >= 0) {
      return instance.view.scrollViewport(instance._createCellCoords(renderableRow, renderableColumn), options.horizontalSnap, options.verticalSnap);
    }
    if (isRowInteger && renderableRow >= 0 && (isColumnInteger && renderableColumn < 0 || !isColumnInteger)) {
      return instance.view.scrollViewportVertically(renderableRow, options.verticalSnap);
    }
    if (isColumnInteger && renderableColumn >= 0 && (isRowInteger && renderableRow < 0 || !isRowInteger)) {
      return instance.view.scrollViewportHorizontally(renderableColumn, options.horizontalSnap);
    }
    return false;
  };

  /**
   * Scrolls the viewport to coordinates specified by the currently focused cell.
   *
   * @since 14.0.0
   * @memberof Core#
   * @fires Hooks#afterScroll
   * @function scrollToFocusedCell
   * @param {Function} callback The callback function to call after the viewport is scrolled.
   */
  this.scrollToFocusedCell = function () {
    let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};
    if (!this.selection.isSelected()) {
      return;
    }
    this.addHookOnce('afterScroll', callback);
    const {
      highlight
    } = this.getSelectedRangeLast();
    const isScrolled = this.scrollViewportTo(highlight.toObject());
    if (isScrolled) {
      this.view.render();
    } else {
      this.removeHook('afterScroll', callback);
      this._registerImmediate(() => callback());
    }
  };

  /**
   * Removes the table from the DOM and destroys the instance of the Handsontable.
   *
   * @memberof Core#
   * @function destroy
   * @fires Hooks#afterDestroy
   */
  this.destroy = function () {
    instance._clearTimeouts();
    instance._clearImmediates();
    if (instance.view) {
      // in case HT is destroyed before initialization has finished
      instance.view.destroy();
    }
    if (dataSource) {
      dataSource.destroy();
    }
    dataSource = null;
    this.getShortcutManager().destroy();
    metaManager.clearCache();
    foreignHotInstances.delete(this.guid);
    if ((0, _rootInstance.isRootInstance)(instance)) {
      const licenseInfo = this.rootDocument.querySelector('.hot-display-license-info');
      if (licenseInfo) {
        licenseInfo.parentNode.removeChild(licenseInfo);
      }
    }
    (0, _element.empty)(instance.rootElement);
    eventManager.destroy();
    if (editorManager) {
      editorManager.destroy();
    }

    // The plugin's `destroy` method is called as a consequence and it should handle
    // unregistration of plugin's maps. Some unregistered maps reset the cache.
    instance.batchExecution(() => {
      instance.rowIndexMapper.unregisterAll();
      instance.columnIndexMapper.unregisterAll();
      pluginsRegistry.getItems().forEach(_ref10 => {
        let [, plugin] = _ref10;
        plugin.destroy();
      });
      pluginsRegistry.clear();
      instance.runHooks('afterDestroy');
    }, true);
    _hooks.Hooks.getSingleton().destroy(instance);
    (0, _object.objectEach)(instance, (property, key, obj) => {
      // replace instance methods with post mortem
      if ((0, _function.isFunction)(property)) {
        obj[key] = postMortem(key);
      } else if (key !== 'guid') {
        // replace instance properties with null (restores memory)
        // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests
        obj[key] = null;
      }
    });
    instance.isDestroyed = true;

    // replace private properties with null (restores memory)
    // it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests
    if (datamap) {
      datamap.destroy();
    }
    datamap = null;
    grid = null;
    selection = null;
    editorManager = null;
    instance = null;
  };

  /**
   * Replacement for all methods after the Handsontable was destroyed.
   *
   * @private
   * @param {string} method The method name.
   * @returns {Function}
   */
  function postMortem(method) {
    return () => {
      throw new Error(`The "${method}" method cannot be called because this Handsontable instance has been destroyed`);
    };
  }

  /**
   * Returns the active editor class instance.
   *
   * @memberof Core#
   * @function getActiveEditor
   * @returns {BaseEditor} The active editor instance.
   */
  this.getActiveEditor = function () {
    return editorManager.getActiveEditor();
  };

  /**
   * Returns the first rendered row in the DOM (usually, it is not visible in the table's viewport).
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getFirstRenderedVisibleRow
   * @returns {number | null}
   */
  this.getFirstRenderedVisibleRow = function () {
    return instance.view.getFirstRenderedVisibleRow();
  };

  /**
   * Returns the last rendered row in the DOM (usually, it is not visible in the table's viewport).
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getLastRenderedVisibleRow
   * @returns {number | null}
   */
  this.getLastRenderedVisibleRow = function () {
    return instance.view.getLastRenderedVisibleRow();
  };

  /**
   * Returns the first rendered column in the DOM (usually, it is not visible in the table's viewport).
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getFirstRenderedVisibleColumn
   * @returns {number | null}
   */
  this.getFirstRenderedVisibleColumn = function () {
    return instance.view.getFirstRenderedVisibleColumn();
  };

  /**
   * Returns the last rendered column in the DOM (usually, it is not visible in the table's viewport).
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getLastRenderedVisibleColumn
   * @returns {number | null}
   */
  this.getLastRenderedVisibleColumn = function () {
    return instance.view.getLastRenderedVisibleColumn();
  };

  /**
   * Returns the first fully visible row in the table viewport. When the table has overlays the method returns
   * the first row of the main table that is not overlapped by overlay.
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getFirstFullyVisibleRow
   * @returns {number | null}
   */
  this.getFirstFullyVisibleRow = function () {
    return instance.view.getFirstFullyVisibleRow();
  };

  /**
   * Returns the last fully visible row in the table viewport. When the table has overlays the method returns
   * the first row of the main table that is not overlapped by overlay.
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getLastFullyVisibleRow
   * @returns {number | null}
   */
  this.getLastFullyVisibleRow = function () {
    return instance.view.getLastFullyVisibleRow();
  };

  /**
   * Returns the first fully visible column in the table viewport. When the table has overlays the method returns
   * the first row of the main table that is not overlapped by overlay.
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getFirstFullyVisibleColumn
   * @returns {number | null}
   */
  this.getFirstFullyVisibleColumn = function () {
    return instance.view.getFirstFullyVisibleColumn();
  };

  /**
   * Returns the last fully visible column in the table viewport. When the table has overlays the method returns
   * the first row of the main table that is not overlapped by overlay.
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getLastFullyVisibleColumn
   * @returns {number | null}
   */
  this.getLastFullyVisibleColumn = function () {
    return instance.view.getLastFullyVisibleColumn();
  };

  /**
   * Returns the first partially visible row in the table viewport. When the table has overlays the method returns
   * the first row of the main table that is not overlapped by overlay.
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getFirstPartiallyVisibleRow
   * @returns {number | null}
   */
  this.getFirstPartiallyVisibleRow = function () {
    return instance.view.getFirstPartiallyVisibleRow();
  };

  /**
   * Returns the last partially visible row in the table viewport. When the table has overlays the method returns
   * the first row of the main table that is not overlapped by overlay.
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getLastPartiallyVisibleRow
   * @returns {number | null}
   */
  this.getLastPartiallyVisibleRow = function () {
    return instance.view.getLastPartiallyVisibleRow();
  };

  /**
   * Returns the first partially visible column in the table viewport. When the table has overlays the method returns
   * the first row of the main table that is not overlapped by overlay.
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getFirstPartiallyVisibleColumn
   * @returns {number | null}
   */
  this.getFirstPartiallyVisibleColumn = function () {
    return instance.view.getFirstPartiallyVisibleColumn();
  };

  /**
   * Returns the last partially visible column in the table viewport. When the table has overlays the method returns
   * the first row of the main table that is not overlapped by overlay.
   *
   * @since 14.6.0
   * @memberof Core#
   * @function getLastPartiallyVisibleColumn
   * @returns {number | null}
   */
  this.getLastPartiallyVisibleColumn = function () {
    return instance.view.getLastPartiallyVisibleColumn();
  };

  /**
   * Returns plugin instance by provided its name.
   *
   * @memberof Core#
   * @function getPlugin
   * @param {string} pluginName The plugin name.
   * @returns {BasePlugin|undefined} The plugin instance or undefined if there is no plugin.
   */
  this.getPlugin = function (pluginName) {
    const unifiedPluginName = (0, _string.toUpperCaseFirst)(pluginName);

    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.
    if (unifiedPluginName === 'UndoRedo') {
      return this.undoRedo;
    }
    return pluginsRegistry.getItem(unifiedPluginName);
  };

  /**
   * Returns name of the passed plugin.
   *
   * @private
   * @memberof Core#
   * @param {BasePlugin} plugin The plugin instance.
   * @returns {string}
   */
  this.getPluginName = function (plugin) {
    // Workaround for the UndoRedo plugin which, currently doesn't follow the plugin architecture.
    if (plugin === this.undoRedo) {
      return this.undoRedo.constructor.PLUGIN_KEY;
    }
    return pluginsRegistry.getId(plugin);
  };

  /**
   * Returns the Handsontable instance.
   *
   * @memberof Core#
   * @function getInstance
   * @returns {Handsontable} The Handsontable instance.
   */
  this.getInstance = function () {
    return instance;
  };

  /**
   * Adds listener to the specified hook name (only for this Handsontable instance).
   *
   * @memberof Core#
   * @function addHook
   * @see Hooks#add
   * @param {string} key Hook name (see {@link Hooks}).
   * @param {Function|Array} callback Function or array of functions.
   * @param {number} [orderIndex] Order index of the callback.
   *                              If > 0, the callback will be added after the others, for example, with an index of 1, the callback will be added before the ones with an index of 2, 3, etc., but after the ones with an index of 0 and lower.
   *                              If < 0, the callback will be added before the others, for example, with an index of -1, the callback will be added after the ones with an index of -2, -3, etc., but before the ones with an index of 0 and higher.
   *                              If 0 or no order index is provided, the callback will be added between the "negative" and "positive" indexes.
   * @example
   * ```js
   * hot.addHook('beforeInit', myCallback);
   * ```
   */
  this.addHook = function (key, callback, orderIndex) {
    _hooks.Hooks.getSingleton().add(key, callback, instance, orderIndex);
  };

  /**
   * Check if for a specified hook name there are added listeners (only for this Handsontable instance). All available
   * hooks you will find {@link Hooks}.
   *
   * @memberof Core#
   * @function hasHook
   * @see Hooks#has
   * @param {string} key Hook name.
   * @returns {boolean}
   *
   * @example
   * ```js
   * const hasBeforeInitListeners = hot.hasHook('beforeInit');
   * ```
   */
  this.hasHook = function (key) {
    return _hooks.Hooks.getSingleton().has(key, instance) || _hooks.Hooks.getSingleton().has(key);
  };

  /**
   * Adds listener to specified hook name (only for this Handsontable instance). After the listener is triggered,
   * it will be automatically removed.
   *
   * @memberof Core#
   * @function addHookOnce
   * @see Hooks#once
   * @param {string} key Hook name (see {@link Hooks}).
   * @param {Function|Array} callback Function or array of functions.
   * @param {number} [orderIndex] Order index of the callback.
   *                              If > 0, the callback will be added after the others, for example, with an index of 1, the callback will be added before the ones with an index of 2, 3, etc., but after the ones with an index of 0 and lower.
   *                              If < 0, the callback will be added before the others, for example, with an index of -1, the callback will be added after the ones with an index of -2, -3, etc., but before the ones with an index of 0 and higher.
   *                              If 0 or no order index is provided, the callback will be added between the "negative" and "positive" indexes.
   * @example
   * ```js
   * hot.addHookOnce('beforeInit', myCallback);
   * ```
   */
  this.addHookOnce = function (key, callback, orderIndex) {
    _hooks.Hooks.getSingleton().once(key, callback, instance, orderIndex);
  };

  /**
   * Removes the hook listener previously registered with {@link Core#addHook}.
   *
   * @memberof Core#
   * @function removeHook
   * @see Hooks#remove
   * @param {string} key Hook name.
   * @param {Function} callback Reference to the function which has been registered using {@link Core#addHook}.
   *
   * @example
   * ```js
   * hot.removeHook('beforeInit', myCallback);
   * ```
   */
  this.removeHook = function (key, callback) {
    _hooks.Hooks.getSingleton().remove(key, callback, instance);
  };

  /**
   * Run the callbacks for the hook provided in the `key` argument using the parameters given in the other arguments.
   *
   * @memberof Core#
   * @function runHooks
   * @see Hooks#run
   * @param {string} key Hook name.
   * @param {*} [p1] Argument passed to the callback.
   * @param {*} [p2] Argument passed to the callback.
   * @param {*} [p3] Argument passed to the callback.
   * @param {*} [p4] Argument passed to the callback.
   * @param {*} [p5] Argument passed to the callback.
   * @param {*} [p6] Argument passed to the callback.
   * @returns {*}
   *
   * @example
   * ```js
   * // Run built-in hook
   * hot.runHooks('beforeInit');
   * // Run custom hook
   * hot.runHooks('customAction', 10, 'foo');
   * ```
   */
  this.runHooks = function (key, p1, p2, p3, p4, p5, p6) {
    return _hooks.Hooks.getSingleton().run(instance, key, p1, p2, p3, p4, p5, p6);
  };

  /**
   * Get language phrase for specified dictionary key.
   *
   * @memberof Core#
   * @function getTranslatedPhrase
   * @since 0.35.0
   * @param {string} dictionaryKey Constant which is dictionary key.
   * @param {*} extraArguments Arguments which will be handled by formatters.
   * @returns {string}
   */
  this.getTranslatedPhrase = function (dictionaryKey, extraArguments) {
    return (0, _registry5.getTranslatedPhrase)(tableMeta.language, dictionaryKey, extraArguments);
  };

  /**
   * Converts instance into outerHTML of HTMLTableElement.
   *
   * @memberof Core#
   * @function toHTML
   * @since 7.1.0
   * @returns {string}
   */
  this.toHTML = () => (0, _parseTable.instanceToHTML)(this);

  /**
   * Converts instance into HTMLTableElement.
   *
   * @memberof Core#
   * @function toTableElement
   * @since 7.1.0
   * @returns {HTMLTableElement}
   */
  this.toTableElement = () => {
    const tempElement = this.rootDocument.createElement('div');
    tempElement.insertAdjacentHTML('afterbegin', (0, _parseTable.instanceToHTML)(this));
    return tempElement.firstElementChild;
  };
  this.timeouts = [];

  /**
   * Use the theme specified by the provided name.
   *
   * @memberof Core#
   * @function useTheme
   * @since 15.0.0
   * @param {string|boolean|undefined} themeName The name of the theme to use.
   */
  this.useTheme = themeName => {
    this.view.getStylesHandler().useTheme(themeName);
    this.runHooks('afterSetTheme', themeName, !!firstRun);
  };

  /**
   * Gets the name of the currently used theme.
   *
   * @memberof Core#
   * @function getCurrentThemeName
   * @since 15.0.0
   * @returns {string|undefined} The name of the currently used theme.
   */
  this.getCurrentThemeName = () => {
    return this.view.getStylesHandler().getThemeName();
  };

  /**
   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.
   *
   * @param {number|Function} handle Handler returned from setTimeout or function to execute (it will be automatically wraped
   *                                 by setTimeout function).
   * @param {number} [delay=0] If first argument is passed as a function this argument set delay of the execution of that function.
   * @private
   */
  this._registerTimeout = function (handle) {
    let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let handleFunc = handle;
    if (typeof handleFunc === 'function') {
      handleFunc = setTimeout(handleFunc, delay);
    }
    this.timeouts.push(handleFunc);
  };

  /**
   * Clears all known timeouts.
   *
   * @private
   */
  this._clearTimeouts = function () {
    (0, _array.arrayEach)(this.timeouts, handler => {
      clearTimeout(handler);
    });
  };
  this.immediates = [];

  /**
   * Execute function execution to the next event loop cycle. Purpose of this method is to clear all known timeouts when `destroy` method is called.
   *
   * @param {Function} callback Function to be delayed in execution.
   * @private
   */
  this._registerImmediate = function (callback) {
    this.immediates.push(setImmediate(callback));
  };

  /**
   * Clears all known timeouts.
   *
   * @private
   */
  this._clearImmediates = function () {
    (0, _array.arrayEach)(this.immediates, handler => {
      clearImmediate(handler);
    });
  };

  /**
   * Gets the instance of the EditorManager.
   *
   * @private
   * @returns {EditorManager}
   */
  this._getEditorManager = function () {
    return editorManager;
  };

  /**
   * Check if currently it is RTL direction.
   *
   * @private
   * @memberof Core#
   * @function isRtl
   * @returns {boolean} True if RTL.
   */
  this.isRtl = function () {
    return instance.rootWindow.getComputedStyle(instance.rootElement).direction === 'rtl';
  };

  /**
   * Check if currently it is LTR direction.
   *
   * @private
   * @memberof Core#
   * @function isLtr
   * @returns {boolean} True if LTR.
   */
  this.isLtr = function () {
    return !instance.isRtl();
  };

  /**
   * Returns 1 for LTR; -1 for RTL. Useful for calculations.
   *
   * @private
   * @memberof Core#
   * @function getDirectionFactor
   * @returns {number} Returns 1 for LTR; -1 for RTL.
   */
  this.getDirectionFactor = function () {
    return instance.isLtr() ? 1 : -1;
  };
  const shortcutManager = (0, _shortcuts.createShortcutManager)({
    handleEvent() {
      return instance.isListening();
    },
    beforeKeyDown: event => {
      return this.runHooks('beforeKeyDown', event);
    },
    afterKeyDown: event => {
      if (this.isDestroyed) {
        // Handsontable could be destroyed after performing action (executing a callback).
        return;
      }
      instance.runHooks('afterDocumentKeyDown', event);
    },
    ownerWindow: this.rootWindow
  });
  this.addHook('beforeOnCellMouseDown', event => {
    // Releasing keys as some browser/system shortcuts break events sequence (thus the `keyup` event isn't triggered).
    if (event.ctrlKey === false && event.metaKey === false) {
      shortcutManager.releasePressedKeys();
    }
  });

  /**
   * Returns instance of a manager responsible for handling shortcuts stored in some contexts. It run actions after
   * pressing key combination in active Handsontable instance.
   *
   * @memberof Core#
   * @since 12.0.0
   * @function getShortcutManager
   * @returns {ShortcutManager} Instance of {@link ShortcutManager}
   */
  this.getShortcutManager = function () {
    return shortcutManager;
  };

  /**
   * Return the Focus Manager responsible for managing the browser's focus in the table.
   *
   * @memberof Core#
   * @since 14.0.0
   * @function getFocusManager
   * @returns {FocusManager}
   */
  this.getFocusManager = function () {
    return focusManager;
  };
  (0, _registry.getPluginsNames)().forEach(pluginName => {
    const PluginClass = (0, _registry.getPlugin)(pluginName);
    pluginsRegistry.addItem(pluginName, new PluginClass(this));
  });
  (0, _shortcutContexts.registerAllShortcutContexts)(instance);
  shortcutManager.setActiveContextName('grid');
  _hooks.Hooks.getSingleton().run(instance, 'construct');
}

/***/ }),
/* 201 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-unused-vars -- required for functions `.length` */
var $ = __webpack_require__(202);
var globalThis = __webpack_require__(203);
var apply = __webpack_require__(267);
var wrapErrorConstructorWithCause = __webpack_require__(268);

var WEB_ASSEMBLY = 'WebAssembly';
var WebAssembly = globalThis[WEB_ASSEMBLY];

// eslint-disable-next-line es/no-error-cause -- feature detection
var FORCED = new Error('e', { cause: 7 }).cause !== 7;

var exportGlobalErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  var O = {};
  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
  $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
};

var exportWebAssemblyErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  if (WebAssembly && WebAssembly[ERROR_NAME]) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
    $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
  }
};

// https://tc39.es/ecma262/#sec-nativeerror
exportGlobalErrorCauseWrapper('Error', function (init) {
  return function Error(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('EvalError', function (init) {
  return function EvalError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('RangeError', function (init) {
  return function RangeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
  return function ReferenceError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
  return function SyntaxError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('TypeError', function (init) {
  return function TypeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('URIError', function (init) {
  return function URIError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
  return function CompileError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
  return function LinkError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
  return function RuntimeError(message) { return apply(init, this, arguments); };
});


/***/ }),
/* 202 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);
var getOwnPropertyDescriptor = (__webpack_require__(204).f);
var createNonEnumerableProperty = __webpack_require__(242);
var defineBuiltIn = __webpack_require__(246);
var defineGlobalProperty = __webpack_require__(236);
var copyConstructorProperties = __webpack_require__(254);
var isForced = __webpack_require__(266);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = globalThis;
  } else if (STATIC) {
    target = globalThis[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = globalThis[TARGET] && globalThis[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),
/* 203 */
/***/ (function(module) {

"use strict";

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),
/* 204 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var call = __webpack_require__(207);
var propertyIsEnumerableModule = __webpack_require__(209);
var createPropertyDescriptor = __webpack_require__(210);
var toIndexedObject = __webpack_require__(211);
var toPropertyKey = __webpack_require__(217);
var hasOwn = __webpack_require__(237);
var IE8_DOM_DEFINE = __webpack_require__(240);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),
/* 205 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(206);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),
/* 206 */
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),
/* 207 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(208);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),
/* 208 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(206);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),
/* 209 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),
/* 210 */
/***/ ((module) => {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 211 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(212);
var requireObjectCoercible = __webpack_require__(215);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),
/* 212 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var fails = __webpack_require__(206);
var classof = __webpack_require__(214);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),
/* 213 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(208);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),
/* 214 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),
/* 215 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isNullOrUndefined = __webpack_require__(216);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),
/* 216 */
/***/ ((module) => {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),
/* 217 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(218);
var isSymbol = __webpack_require__(221);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),
/* 218 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(207);
var isObject = __webpack_require__(219);
var isSymbol = __webpack_require__(221);
var getMethod = __webpack_require__(228);
var ordinaryToPrimitive = __webpack_require__(231);
var wellKnownSymbol = __webpack_require__(232);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),
/* 219 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(220);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),
/* 220 */
/***/ ((module) => {

"use strict";

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),
/* 221 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(222);
var isCallable = __webpack_require__(220);
var isPrototypeOf = __webpack_require__(223);
var USE_SYMBOL_AS_UID = __webpack_require__(224);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),
/* 222 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);
var isCallable = __webpack_require__(220);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(globalThis[namespace]) : globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),
/* 223 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),
/* 224 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(225);

module.exports = NATIVE_SYMBOL &&
  !Symbol.sham &&
  typeof Symbol.iterator == 'symbol';


/***/ }),
/* 225 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(226);
var fails = __webpack_require__(206);
var globalThis = __webpack_require__(203);

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),
/* 226 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);
var userAgent = __webpack_require__(227);

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),
/* 227 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),
/* 228 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(229);
var isNullOrUndefined = __webpack_require__(216);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),
/* 229 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(220);
var tryToString = __webpack_require__(230);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),
/* 230 */
/***/ ((module) => {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),
/* 231 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(207);
var isCallable = __webpack_require__(220);
var isObject = __webpack_require__(219);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 232 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);
var shared = __webpack_require__(233);
var hasOwn = __webpack_require__(237);
var uid = __webpack_require__(239);
var NATIVE_SYMBOL = __webpack_require__(225);
var USE_SYMBOL_AS_UID = __webpack_require__(224);

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),
/* 233 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var store = __webpack_require__(234);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),
/* 234 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_PURE = __webpack_require__(235);
var globalThis = __webpack_require__(203);
var defineGlobalProperty = __webpack_require__(236);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.39.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),
/* 235 */
/***/ ((module) => {

"use strict";

module.exports = false;


/***/ }),
/* 236 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),
/* 237 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var toObject = __webpack_require__(238);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),
/* 238 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var requireObjectCoercible = __webpack_require__(215);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),
/* 239 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),
/* 240 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var fails = __webpack_require__(206);
var createElement = __webpack_require__(241);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),
/* 241 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);
var isObject = __webpack_require__(219);

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),
/* 242 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var definePropertyModule = __webpack_require__(243);
var createPropertyDescriptor = __webpack_require__(210);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 243 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var IE8_DOM_DEFINE = __webpack_require__(240);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(244);
var anObject = __webpack_require__(245);
var toPropertyKey = __webpack_require__(217);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 244 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var fails = __webpack_require__(206);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),
/* 245 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(219);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),
/* 246 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(220);
var definePropertyModule = __webpack_require__(243);
var makeBuiltIn = __webpack_require__(247);
var defineGlobalProperty = __webpack_require__(236);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),
/* 247 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var fails = __webpack_require__(206);
var isCallable = __webpack_require__(220);
var hasOwn = __webpack_require__(237);
var DESCRIPTORS = __webpack_require__(205);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(248).CONFIGURABLE);
var inspectSource = __webpack_require__(249);
var InternalStateModule = __webpack_require__(250);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),
/* 248 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var hasOwn = __webpack_require__(237);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),
/* 249 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var isCallable = __webpack_require__(220);
var store = __webpack_require__(234);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),
/* 250 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(251);
var globalThis = __webpack_require__(203);
var isObject = __webpack_require__(219);
var createNonEnumerableProperty = __webpack_require__(242);
var hasOwn = __webpack_require__(237);
var shared = __webpack_require__(234);
var sharedKey = __webpack_require__(252);
var hiddenKeys = __webpack_require__(253);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),
/* 251 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);
var isCallable = __webpack_require__(220);

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),
/* 252 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(233);
var uid = __webpack_require__(239);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),
/* 253 */
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),
/* 254 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(237);
var ownKeys = __webpack_require__(255);
var getOwnPropertyDescriptorModule = __webpack_require__(204);
var definePropertyModule = __webpack_require__(243);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),
/* 255 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(222);
var uncurryThis = __webpack_require__(213);
var getOwnPropertyNamesModule = __webpack_require__(256);
var getOwnPropertySymbolsModule = __webpack_require__(265);
var anObject = __webpack_require__(245);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),
/* 256 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(257);
var enumBugKeys = __webpack_require__(264);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),
/* 257 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var hasOwn = __webpack_require__(237);
var toIndexedObject = __webpack_require__(211);
var indexOf = (__webpack_require__(258).indexOf);
var hiddenKeys = __webpack_require__(253);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),
/* 258 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(211);
var toAbsoluteIndex = __webpack_require__(259);
var lengthOfArrayLike = __webpack_require__(262);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),
/* 259 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(260);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),
/* 260 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var trunc = __webpack_require__(261);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),
/* 261 */
/***/ ((module) => {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),
/* 262 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toLength = __webpack_require__(263);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),
/* 263 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(260);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),
/* 264 */
/***/ ((module) => {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),
/* 265 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 266 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(206);
var isCallable = __webpack_require__(220);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),
/* 267 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(208);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),
/* 268 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(222);
var hasOwn = __webpack_require__(237);
var createNonEnumerableProperty = __webpack_require__(242);
var isPrototypeOf = __webpack_require__(223);
var setPrototypeOf = __webpack_require__(269);
var copyConstructorProperties = __webpack_require__(254);
var proxyAccessor = __webpack_require__(273);
var inheritIfRequired = __webpack_require__(274);
var normalizeStringArgument = __webpack_require__(275);
var installErrorCause = __webpack_require__(279);
var installErrorStack = __webpack_require__(280);
var DESCRIPTORS = __webpack_require__(205);
var IS_PURE = __webpack_require__(235);

module.exports = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
  var STACK_TRACE_LIMIT = 'stackTraceLimit';
  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
  var path = FULL_NAME.split('.');
  var ERROR_NAME = path[path.length - 1];
  var OriginalError = getBuiltIn.apply(null, path);

  if (!OriginalError) return;

  var OriginalErrorPrototype = OriginalError.prototype;

  // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
  if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;

  if (!FORCED) return OriginalError;

  var BaseError = getBuiltIn('Error');

  var WrappedError = wrapper(function (a, b) {
    var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
    if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
    installErrorStack(result, WrappedError, result.stack, 2);
    if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
    if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
    return result;
  });

  WrappedError.prototype = OriginalErrorPrototype;

  if (ERROR_NAME !== 'Error') {
    if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
    else copyConstructorProperties(WrappedError, BaseError, { name: true });
  } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
    proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
    proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
  }

  copyConstructorProperties(WrappedError, OriginalError);

  if (!IS_PURE) try {
    // Safari 13- bug: WebAssembly errors does not have a proper `.name`
    if (OriginalErrorPrototype.name !== ERROR_NAME) {
      createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
    }
    OriginalErrorPrototype.constructor = WrappedError;
  } catch (error) { /* empty */ }

  return WrappedError;
};


/***/ }),
/* 269 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(270);
var isObject = __webpack_require__(219);
var requireObjectCoercible = __webpack_require__(215);
var aPossiblePrototype = __webpack_require__(271);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    requireObjectCoercible(O);
    aPossiblePrototype(proto);
    if (!isObject(O)) return O;
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),
/* 270 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var aCallable = __webpack_require__(229);

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),
/* 271 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPossiblePrototype = __webpack_require__(272);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (isPossiblePrototype(argument)) return argument;
  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),
/* 272 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(219);

module.exports = function (argument) {
  return isObject(argument) || argument === null;
};


/***/ }),
/* 273 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = (__webpack_require__(243).f);

module.exports = function (Target, Source, key) {
  key in Target || defineProperty(Target, key, {
    configurable: true,
    get: function () { return Source[key]; },
    set: function (it) { Source[key] = it; }
  });
};


/***/ }),
/* 274 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(220);
var isObject = __webpack_require__(219);
var setPrototypeOf = __webpack_require__(269);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),
/* 275 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toString = __webpack_require__(276);

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};


/***/ }),
/* 276 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(277);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),
/* 277 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(278);
var isCallable = __webpack_require__(220);
var classofRaw = __webpack_require__(214);
var wellKnownSymbol = __webpack_require__(232);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),
/* 278 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(232);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),
/* 279 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(219);
var createNonEnumerableProperty = __webpack_require__(242);

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function (O, options) {
  if (isObject(options) && 'cause' in options) {
    createNonEnumerableProperty(O, 'cause', options.cause);
  }
};


/***/ }),
/* 280 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createNonEnumerableProperty = __webpack_require__(242);
var clearErrorStack = __webpack_require__(281);
var ERROR_STACK_INSTALLABLE = __webpack_require__(282);

// non-standard V8
var captureStackTrace = Error.captureStackTrace;

module.exports = function (error, C, stack, dropEntries) {
  if (ERROR_STACK_INSTALLABLE) {
    if (captureStackTrace) captureStackTrace(error, C);
    else createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));
  }
};


/***/ }),
/* 281 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);

var $Error = Error;
var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String(new $Error(arg).stack); })('zxcasd');
// eslint-disable-next-line redos/no-vulnerable, sonarjs/slow-regex -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};


/***/ }),
/* 282 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(206);
var createPropertyDescriptor = __webpack_require__(210);

module.exports = !fails(function () {
  var error = new Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
  return error.stack !== 7;
});


/***/ }),
/* 283 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var toObject = __webpack_require__(238);
var lengthOfArrayLike = __webpack_require__(262);
var setArrayLength = __webpack_require__(284);
var doesNotExceedSafeInteger = __webpack_require__(286);
var fails = __webpack_require__(206);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),
/* 284 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var isArray = __webpack_require__(285);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),
/* 285 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(214);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),
/* 286 */
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),
/* 287 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var difference = __webpack_require__(288);
var setMethodAcceptSetLike = __webpack_require__(297);

// `Set.prototype.difference` method
// https://tc39.es/ecma262/#sec-set.prototype.difference
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('difference') }, {
  difference: difference
});


/***/ }),
/* 288 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(289);
var SetHelpers = __webpack_require__(290);
var clone = __webpack_require__(291);
var size = __webpack_require__(294);
var getSetRecord = __webpack_require__(295);
var iterateSet = __webpack_require__(292);
var iterateSimple = __webpack_require__(293);

var has = SetHelpers.has;
var remove = SetHelpers.remove;

// `Set.prototype.difference` method
// https://github.com/tc39/proposal-set-methods
module.exports = function difference(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  var result = clone(O);
  if (size(O) <= otherRec.size) iterateSet(O, function (e) {
    if (otherRec.includes(e)) remove(result, e);
  });
  else iterateSimple(otherRec.getIterator(), function (e) {
    if (has(O, e)) remove(result, e);
  });
  return result;
};


/***/ }),
/* 289 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var has = (__webpack_require__(290).has);

// Perform ? RequireInternalSlot(M, [[SetData]])
module.exports = function (it) {
  has(it);
  return it;
};


/***/ }),
/* 290 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);

// eslint-disable-next-line es/no-set -- safe
var SetPrototype = Set.prototype;

module.exports = {
  // eslint-disable-next-line es/no-set -- safe
  Set: Set,
  add: uncurryThis(SetPrototype.add),
  has: uncurryThis(SetPrototype.has),
  remove: uncurryThis(SetPrototype['delete']),
  proto: SetPrototype
};


/***/ }),
/* 291 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var SetHelpers = __webpack_require__(290);
var iterate = __webpack_require__(292);

var Set = SetHelpers.Set;
var add = SetHelpers.add;

module.exports = function (set) {
  var result = new Set();
  iterate(set, function (it) {
    add(result, it);
  });
  return result;
};


/***/ }),
/* 292 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var iterateSimple = __webpack_require__(293);
var SetHelpers = __webpack_require__(290);

var Set = SetHelpers.Set;
var SetPrototype = SetHelpers.proto;
var forEach = uncurryThis(SetPrototype.forEach);
var keys = uncurryThis(SetPrototype.keys);
var next = keys(new Set()).next;

module.exports = function (set, fn, interruptible) {
  return interruptible ? iterateSimple({ iterator: keys(set), next: next }, fn) : forEach(set, fn);
};


/***/ }),
/* 293 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(207);

module.exports = function (record, fn, ITERATOR_INSTEAD_OF_RECORD) {
  var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
  var next = record.next;
  var step, result;
  while (!(step = call(next, iterator)).done) {
    result = fn(step.value);
    if (result !== undefined) return result;
  }
};


/***/ }),
/* 294 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThisAccessor = __webpack_require__(270);
var SetHelpers = __webpack_require__(290);

module.exports = uncurryThisAccessor(SetHelpers.proto, 'size', 'get') || function (set) {
  return set.size;
};


/***/ }),
/* 295 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var call = __webpack_require__(207);
var toIntegerOrInfinity = __webpack_require__(260);
var getIteratorDirect = __webpack_require__(296);

var INVALID_SIZE = 'Invalid size';
var $RangeError = RangeError;
var $TypeError = TypeError;
var max = Math.max;

var SetRecord = function (set, intSize) {
  this.set = set;
  this.size = max(intSize, 0);
  this.has = aCallable(set.has);
  this.keys = aCallable(set.keys);
};

SetRecord.prototype = {
  getIterator: function () {
    return getIteratorDirect(anObject(call(this.keys, this.set)));
  },
  includes: function (it) {
    return call(this.has, this.set, it);
  }
};

// `GetSetRecord` abstract operation
// https://tc39.es/proposal-set-methods/#sec-getsetrecord
module.exports = function (obj) {
  anObject(obj);
  var numSize = +obj.size;
  // NOTE: If size is undefined, then numSize will be NaN
  // eslint-disable-next-line no-self-compare -- NaN check
  if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
  var intSize = toIntegerOrInfinity(numSize);
  if (intSize < 0) throw new $RangeError(INVALID_SIZE);
  return new SetRecord(obj, intSize);
};


/***/ }),
/* 296 */
/***/ ((module) => {

"use strict";

// `GetIteratorDirect(obj)` abstract operation
// https://tc39.es/proposal-iterator-helpers/#sec-getiteratordirect
module.exports = function (obj) {
  return {
    iterator: obj,
    next: obj.next,
    done: false
  };
};


/***/ }),
/* 297 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(222);

var createSetLike = function (size) {
  return {
    size: size,
    has: function () {
      return false;
    },
    keys: function () {
      return {
        next: function () {
          return { done: true };
        }
      };
    }
  };
};

module.exports = function (name) {
  var Set = getBuiltIn('Set');
  try {
    new Set()[name](createSetLike(0));
    try {
      // late spec change, early WebKit ~ Safari 17.0 beta implementation does not pass it
      // https://github.com/tc39/proposal-set-methods/pull/88
      new Set()[name](createSetLike(-1));
      return false;
    } catch (error2) {
      return true;
    }
  } catch (error) {
    return false;
  }
};


/***/ }),
/* 298 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var fails = __webpack_require__(206);
var intersection = __webpack_require__(299);
var setMethodAcceptSetLike = __webpack_require__(297);

var INCORRECT = !setMethodAcceptSetLike('intersection') || fails(function () {
  // eslint-disable-next-line es/no-array-from, es/no-set -- testing
  return String(Array.from(new Set([1, 2, 3]).intersection(new Set([3, 2])))) !== '3,2';
});

// `Set.prototype.intersection` method
// https://tc39.es/ecma262/#sec-set.prototype.intersection
$({ target: 'Set', proto: true, real: true, forced: INCORRECT }, {
  intersection: intersection
});


/***/ }),
/* 299 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(289);
var SetHelpers = __webpack_require__(290);
var size = __webpack_require__(294);
var getSetRecord = __webpack_require__(295);
var iterateSet = __webpack_require__(292);
var iterateSimple = __webpack_require__(293);

var Set = SetHelpers.Set;
var add = SetHelpers.add;
var has = SetHelpers.has;

// `Set.prototype.intersection` method
// https://github.com/tc39/proposal-set-methods
module.exports = function intersection(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  var result = new Set();

  if (size(O) > otherRec.size) {
    iterateSimple(otherRec.getIterator(), function (e) {
      if (has(O, e)) add(result, e);
    });
  } else {
    iterateSet(O, function (e) {
      if (otherRec.includes(e)) add(result, e);
    });
  }

  return result;
};


/***/ }),
/* 300 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var isDisjointFrom = __webpack_require__(301);
var setMethodAcceptSetLike = __webpack_require__(297);

// `Set.prototype.isDisjointFrom` method
// https://tc39.es/ecma262/#sec-set.prototype.isdisjointfrom
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('isDisjointFrom') }, {
  isDisjointFrom: isDisjointFrom
});


/***/ }),
/* 301 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(289);
var has = (__webpack_require__(290).has);
var size = __webpack_require__(294);
var getSetRecord = __webpack_require__(295);
var iterateSet = __webpack_require__(292);
var iterateSimple = __webpack_require__(293);
var iteratorClose = __webpack_require__(302);

// `Set.prototype.isDisjointFrom` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isDisjointFrom
module.exports = function isDisjointFrom(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) <= otherRec.size) return iterateSet(O, function (e) {
    if (otherRec.includes(e)) return false;
  }, true) !== false;
  var iterator = otherRec.getIterator();
  return iterateSimple(iterator, function (e) {
    if (has(O, e)) return iteratorClose(iterator, 'normal', false);
  }) !== false;
};


/***/ }),
/* 302 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(207);
var anObject = __webpack_require__(245);
var getMethod = __webpack_require__(228);

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),
/* 303 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var isSubsetOf = __webpack_require__(304);
var setMethodAcceptSetLike = __webpack_require__(297);

// `Set.prototype.isSubsetOf` method
// https://tc39.es/ecma262/#sec-set.prototype.issubsetof
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('isSubsetOf') }, {
  isSubsetOf: isSubsetOf
});


/***/ }),
/* 304 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(289);
var size = __webpack_require__(294);
var iterate = __webpack_require__(292);
var getSetRecord = __webpack_require__(295);

// `Set.prototype.isSubsetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSubsetOf
module.exports = function isSubsetOf(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) > otherRec.size) return false;
  return iterate(O, function (e) {
    if (!otherRec.includes(e)) return false;
  }, true) !== false;
};


/***/ }),
/* 305 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var isSupersetOf = __webpack_require__(306);
var setMethodAcceptSetLike = __webpack_require__(297);

// `Set.prototype.isSupersetOf` method
// https://tc39.es/ecma262/#sec-set.prototype.issupersetof
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('isSupersetOf') }, {
  isSupersetOf: isSupersetOf
});


/***/ }),
/* 306 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(289);
var has = (__webpack_require__(290).has);
var size = __webpack_require__(294);
var getSetRecord = __webpack_require__(295);
var iterateSimple = __webpack_require__(293);
var iteratorClose = __webpack_require__(302);

// `Set.prototype.isSupersetOf` method
// https://tc39.github.io/proposal-set-methods/#Set.prototype.isSupersetOf
module.exports = function isSupersetOf(other) {
  var O = aSet(this);
  var otherRec = getSetRecord(other);
  if (size(O) < otherRec.size) return false;
  var iterator = otherRec.getIterator();
  return iterateSimple(iterator, function (e) {
    if (!has(O, e)) return iteratorClose(iterator, 'normal', false);
  }) !== false;
};


/***/ }),
/* 307 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var symmetricDifference = __webpack_require__(308);
var setMethodAcceptSetLike = __webpack_require__(297);

// `Set.prototype.symmetricDifference` method
// https://tc39.es/ecma262/#sec-set.prototype.symmetricdifference
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('symmetricDifference') }, {
  symmetricDifference: symmetricDifference
});


/***/ }),
/* 308 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(289);
var SetHelpers = __webpack_require__(290);
var clone = __webpack_require__(291);
var getSetRecord = __webpack_require__(295);
var iterateSimple = __webpack_require__(293);

var add = SetHelpers.add;
var has = SetHelpers.has;
var remove = SetHelpers.remove;

// `Set.prototype.symmetricDifference` method
// https://github.com/tc39/proposal-set-methods
module.exports = function symmetricDifference(other) {
  var O = aSet(this);
  var keysIter = getSetRecord(other).getIterator();
  var result = clone(O);
  iterateSimple(keysIter, function (e) {
    if (has(O, e)) remove(result, e);
    else add(result, e);
  });
  return result;
};


/***/ }),
/* 309 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var union = __webpack_require__(310);
var setMethodAcceptSetLike = __webpack_require__(297);

// `Set.prototype.union` method
// https://tc39.es/ecma262/#sec-set.prototype.union
$({ target: 'Set', proto: true, real: true, forced: !setMethodAcceptSetLike('union') }, {
  union: union
});


/***/ }),
/* 310 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aSet = __webpack_require__(289);
var add = (__webpack_require__(290).add);
var clone = __webpack_require__(291);
var getSetRecord = __webpack_require__(295);
var iterateSimple = __webpack_require__(293);

// `Set.prototype.union` method
// https://github.com/tc39/proposal-set-methods
module.exports = function union(other) {
  var O = aSet(this);
  var keysIter = getSetRecord(other).getIterator();
  var result = clone(O);
  iterateSimple(keysIter, function (it) {
    add(result, it);
  });
  return result;
};


/***/ }),
/* 311 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(312);


/***/ }),
/* 312 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var globalThis = __webpack_require__(203);
var anInstance = __webpack_require__(313);
var anObject = __webpack_require__(245);
var isCallable = __webpack_require__(220);
var getPrototypeOf = __webpack_require__(314);
var defineBuiltInAccessor = __webpack_require__(316);
var createProperty = __webpack_require__(317);
var fails = __webpack_require__(206);
var hasOwn = __webpack_require__(237);
var wellKnownSymbol = __webpack_require__(232);
var IteratorPrototype = (__webpack_require__(318).IteratorPrototype);
var DESCRIPTORS = __webpack_require__(205);
var IS_PURE = __webpack_require__(235);

var CONSTRUCTOR = 'constructor';
var ITERATOR = 'Iterator';
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var $TypeError = TypeError;
var NativeIterator = globalThis[ITERATOR];

// FF56- have non-standard global helper `Iterator`
var FORCED = IS_PURE
  || !isCallable(NativeIterator)
  || NativeIterator.prototype !== IteratorPrototype
  // FF44- non-standard `Iterator` passes previous tests
  || !fails(function () { NativeIterator({}); });

var IteratorConstructor = function Iterator() {
  anInstance(this, IteratorPrototype);
  if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError('Abstract class Iterator not directly constructable');
};

var defineIteratorPrototypeAccessor = function (key, value) {
  if (DESCRIPTORS) {
    defineBuiltInAccessor(IteratorPrototype, key, {
      configurable: true,
      get: function () {
        return value;
      },
      set: function (replacement) {
        anObject(this);
        if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
        if (hasOwn(this, key)) this[key] = replacement;
        else createProperty(this, key, replacement);
      }
    });
  } else IteratorPrototype[key] = value;
};

if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);

if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
  defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
}

IteratorConstructor.prototype = IteratorPrototype;

// `Iterator` constructor
// https://tc39.es/ecma262/#sec-iterator
$({ global: true, constructor: true, forced: FORCED }, {
  Iterator: IteratorConstructor
});


/***/ }),
/* 313 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(223);

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw new $TypeError('Incorrect invocation');
};


/***/ }),
/* 314 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(237);
var isCallable = __webpack_require__(220);
var toObject = __webpack_require__(238);
var sharedKey = __webpack_require__(252);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(315);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),
/* 315 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(206);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),
/* 316 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var makeBuiltIn = __webpack_require__(247);
var defineProperty = __webpack_require__(243);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),
/* 317 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var definePropertyModule = __webpack_require__(243);
var createPropertyDescriptor = __webpack_require__(210);

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ }),
/* 318 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(206);
var isCallable = __webpack_require__(220);
var isObject = __webpack_require__(219);
var create = __webpack_require__(319);
var getPrototypeOf = __webpack_require__(314);
var defineBuiltIn = __webpack_require__(246);
var wellKnownSymbol = __webpack_require__(232);
var IS_PURE = __webpack_require__(235);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),
/* 319 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(245);
var definePropertiesModule = __webpack_require__(320);
var enumBugKeys = __webpack_require__(264);
var hiddenKeys = __webpack_require__(253);
var html = __webpack_require__(322);
var documentCreateElement = __webpack_require__(241);
var sharedKey = __webpack_require__(252);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  activeXDocument = null;
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),
/* 320 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(205);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(244);
var definePropertyModule = __webpack_require__(243);
var anObject = __webpack_require__(245);
var toIndexedObject = __webpack_require__(211);
var objectKeys = __webpack_require__(321);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),
/* 321 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(257);
var enumBugKeys = __webpack_require__(264);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),
/* 322 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(222);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),
/* 323 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(324);


/***/ }),
/* 324 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var call = __webpack_require__(207);
var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var getIteratorDirect = __webpack_require__(296);
var createIteratorProxy = __webpack_require__(325);
var callWithSafeIterationClosing = __webpack_require__(328);
var IS_PURE = __webpack_require__(235);

var IteratorProxy = createIteratorProxy(function () {
  var iterator = this.iterator;
  var predicate = this.predicate;
  var next = this.next;
  var result, done, value;
  while (true) {
    result = anObject(call(next, iterator));
    done = this.done = !!result.done;
    if (done) return;
    value = result.value;
    if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
  }
});

// `Iterator.prototype.filter` method
// https://tc39.es/ecma262/#sec-iterator.prototype.filter
$({ target: 'Iterator', proto: true, real: true, forced: IS_PURE }, {
  filter: function filter(predicate) {
    anObject(this);
    aCallable(predicate);
    return new IteratorProxy(getIteratorDirect(this), {
      predicate: predicate
    });
  }
});


/***/ }),
/* 325 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(207);
var create = __webpack_require__(319);
var createNonEnumerableProperty = __webpack_require__(242);
var defineBuiltIns = __webpack_require__(326);
var wellKnownSymbol = __webpack_require__(232);
var InternalStateModule = __webpack_require__(250);
var getMethod = __webpack_require__(228);
var IteratorPrototype = (__webpack_require__(318).IteratorPrototype);
var createIterResultObject = __webpack_require__(327);
var iteratorClose = __webpack_require__(302);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ITERATOR_HELPER = 'IteratorHelper';
var WRAP_FOR_VALID_ITERATOR = 'WrapForValidIterator';
var setInternalState = InternalStateModule.set;

var createIteratorProxyPrototype = function (IS_ITERATOR) {
  var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);

  return defineBuiltIns(create(IteratorPrototype), {
    next: function next() {
      var state = getInternalState(this);
      // for simplification:
      //   for `%WrapForValidIteratorPrototype%.next` our `nextHandler` returns `IterResultObject`
      //   for `%IteratorHelperPrototype%.next` - just a value
      if (IS_ITERATOR) return state.nextHandler();
      try {
        var result = state.done ? undefined : state.nextHandler();
        return createIterResultObject(result, state.done);
      } catch (error) {
        state.done = true;
        throw error;
      }
    },
    'return': function () {
      var state = getInternalState(this);
      var iterator = state.iterator;
      state.done = true;
      if (IS_ITERATOR) {
        var returnMethod = getMethod(iterator, 'return');
        return returnMethod ? call(returnMethod, iterator) : createIterResultObject(undefined, true);
      }
      if (state.inner) try {
        iteratorClose(state.inner.iterator, 'normal');
      } catch (error) {
        return iteratorClose(iterator, 'throw', error);
      }
      if (iterator) iteratorClose(iterator, 'normal');
      return createIterResultObject(undefined, true);
    }
  });
};

var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
var IteratorHelperPrototype = createIteratorProxyPrototype(false);

createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, 'Iterator Helper');

module.exports = function (nextHandler, IS_ITERATOR) {
  var IteratorProxy = function Iterator(record, state) {
    if (state) {
      state.iterator = record.iterator;
      state.next = record.next;
    } else state = record;
    state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
    state.nextHandler = nextHandler;
    state.counter = 0;
    state.done = false;
    setInternalState(this, state);
  };

  IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;

  return IteratorProxy;
};


/***/ }),
/* 326 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineBuiltIn = __webpack_require__(246);

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),
/* 327 */
/***/ ((module) => {

"use strict";

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),
/* 328 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(245);
var iteratorClose = __webpack_require__(302);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),
/* 329 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(330);


/***/ }),
/* 330 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var iterate = __webpack_require__(331);
var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var getIteratorDirect = __webpack_require__(296);

// `Iterator.prototype.forEach` method
// https://tc39.es/ecma262/#sec-iterator.prototype.foreach
$({ target: 'Iterator', proto: true, real: true }, {
  forEach: function forEach(fn) {
    anObject(this);
    aCallable(fn);
    var record = getIteratorDirect(this);
    var counter = 0;
    iterate(record, function (value) {
      fn(value, counter++);
    }, { IS_RECORD: true });
  }
});


/***/ }),
/* 331 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(332);
var call = __webpack_require__(207);
var anObject = __webpack_require__(245);
var tryToString = __webpack_require__(230);
var isArrayIteratorMethod = __webpack_require__(334);
var lengthOfArrayLike = __webpack_require__(262);
var isPrototypeOf = __webpack_require__(223);
var getIterator = __webpack_require__(336);
var getIteratorMethod = __webpack_require__(337);
var iteratorClose = __webpack_require__(302);

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw new $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),
/* 332 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(333);
var aCallable = __webpack_require__(229);
var NATIVE_BIND = __webpack_require__(208);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 333 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classofRaw = __webpack_require__(214);
var uncurryThis = __webpack_require__(213);

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),
/* 334 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(232);
var Iterators = __webpack_require__(335);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),
/* 335 */
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),
/* 336 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(207);
var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var tryToString = __webpack_require__(230);
var getIteratorMethod = __webpack_require__(337);

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw new $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),
/* 337 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(277);
var getMethod = __webpack_require__(228);
var isNullOrUndefined = __webpack_require__(216);
var Iterators = __webpack_require__(335);
var wellKnownSymbol = __webpack_require__(232);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),
/* 338 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(339);


/***/ }),
/* 339 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var map = __webpack_require__(340);
var IS_PURE = __webpack_require__(235);

// `Iterator.prototype.map` method
// https://tc39.es/ecma262/#sec-iterator.prototype.map
$({ target: 'Iterator', proto: true, real: true, forced: IS_PURE }, {
  map: map
});


/***/ }),
/* 340 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(207);
var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var getIteratorDirect = __webpack_require__(296);
var createIteratorProxy = __webpack_require__(325);
var callWithSafeIterationClosing = __webpack_require__(328);

var IteratorProxy = createIteratorProxy(function () {
  var iterator = this.iterator;
  var result = anObject(call(this.next, iterator));
  var done = this.done = !!result.done;
  if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result.value, this.counter++], true);
});

// `Iterator.prototype.map` method
// https://github.com/tc39/proposal-iterator-helpers
module.exports = function map(mapper) {
  anObject(this);
  aCallable(mapper);
  return new IteratorProxy(getIteratorDirect(this), {
    mapper: mapper
  });
};


/***/ }),
/* 341 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(342);
__webpack_require__(349);


/***/ }),
/* 342 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var globalThis = __webpack_require__(203);
var clearImmediate = (__webpack_require__(343).clear);

// `clearImmediate` method
// http://w3c.github.io/setImmediate/#si-clearImmediate
$({ global: true, bind: true, enumerable: true, forced: globalThis.clearImmediate !== clearImmediate }, {
  clearImmediate: clearImmediate
});


/***/ }),
/* 343 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);
var apply = __webpack_require__(267);
var bind = __webpack_require__(332);
var isCallable = __webpack_require__(220);
var hasOwn = __webpack_require__(237);
var fails = __webpack_require__(206);
var html = __webpack_require__(322);
var arraySlice = __webpack_require__(344);
var createElement = __webpack_require__(241);
var validateArgumentsLength = __webpack_require__(345);
var IS_IOS = __webpack_require__(346);
var IS_NODE = __webpack_require__(347);

var set = globalThis.setImmediate;
var clear = globalThis.clearImmediate;
var process = globalThis.process;
var Dispatch = globalThis.Dispatch;
var Function = globalThis.Function;
var MessageChannel = globalThis.MessageChannel;
var String = globalThis.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var $location, defer, channel, port;

fails(function () {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  $location = globalThis.location;
});

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var eventListener = function (event) {
  run(event.data);
};

var globalPostMessageDefer = function (id) {
  // old engines have not location.origin
  globalThis.postMessage(String(id), $location.protocol + '//' + $location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    globalThis.addEventListener &&
    isCallable(globalThis.postMessage) &&
    !globalThis.importScripts &&
    $location && $location.protocol !== 'file:' &&
    !fails(globalPostMessageDefer)
  ) {
    defer = globalPostMessageDefer;
    globalThis.addEventListener('message', eventListener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),
/* 344 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);

module.exports = uncurryThis([].slice);


/***/ }),
/* 345 */
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),
/* 346 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var userAgent = __webpack_require__(227);

// eslint-disable-next-line redos/no-vulnerable -- safe
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);


/***/ }),
/* 347 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ENVIRONMENT = __webpack_require__(348);

module.exports = ENVIRONMENT === 'NODE';


/***/ }),
/* 348 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global Bun, Deno -- detection */
var globalThis = __webpack_require__(203);
var userAgent = __webpack_require__(227);
var classof = __webpack_require__(214);

var userAgentStartsWith = function (string) {
  return userAgent.slice(0, string.length) === string;
};

module.exports = (function () {
  if (userAgentStartsWith('Bun/')) return 'BUN';
  if (userAgentStartsWith('Cloudflare-Workers')) return 'CLOUDFLARE';
  if (userAgentStartsWith('Deno/')) return 'DENO';
  if (userAgentStartsWith('Node.js/')) return 'NODE';
  if (globalThis.Bun && typeof Bun.version == 'string') return 'BUN';
  if (globalThis.Deno && typeof Deno.version == 'object') return 'DENO';
  if (classof(globalThis.process) === 'process') return 'NODE';
  if (globalThis.window && globalThis.document) return 'BROWSER';
  return 'REST';
})();


/***/ }),
/* 349 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var globalThis = __webpack_require__(203);
var setTask = (__webpack_require__(343).set);
var schedulersFix = __webpack_require__(350);

// https://github.com/oven-sh/bun/issues/1633
var setImmediate = globalThis.setImmediate ? schedulersFix(setTask, false) : setTask;

// `setImmediate` method
// http://w3c.github.io/setImmediate/#si-setImmediate
$({ global: true, bind: true, enumerable: true, forced: globalThis.setImmediate !== setImmediate }, {
  setImmediate: setImmediate
});


/***/ }),
/* 350 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);
var apply = __webpack_require__(267);
var isCallable = __webpack_require__(220);
var ENVIRONMENT = __webpack_require__(348);
var USER_AGENT = __webpack_require__(227);
var arraySlice = __webpack_require__(344);
var validateArgumentsLength = __webpack_require__(345);

var Function = globalThis.Function;
// dirty IE9- and Bun 0.3.0- checks
var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === 'BUN' && (function () {
  var version = globalThis.Bun.version.split('.');
  return version.length < 3 || version[0] === '0' && (version[1] < 3 || version[1] === '3' && version[2] === '0');
})();

// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
// https://github.com/oven-sh/bun/issues/1633
module.exports = function (scheduler, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function (handler, timeout /* , ...arguments */) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
    var fn = isCallable(handler) ? handler : Function(handler);
    var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
    var callback = boundArgs ? function () {
      apply(fn, this, params);
    } : fn;
    return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
  } : scheduler;
};


/***/ }),
/* 351 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.addClass = addClass;
exports.addEvent = addEvent;
exports.clearTextSelection = clearTextSelection;
exports.closest = closest;
exports.closestDown = closestDown;
exports.empty = empty;
exports.fastInnerHTML = fastInnerHTML;
exports.fastInnerText = fastInnerText;
exports.findFirstParentWithClass = findFirstParentWithClass;
exports.getCaretPosition = getCaretPosition;
exports.getCssTransform = getCssTransform;
exports.getFrameElement = getFrameElement;
exports.getMaximumScrollLeft = getMaximumScrollLeft;
exports.getMaximumScrollTop = getMaximumScrollTop;
exports.getParent = getParent;
exports.getParentWindow = getParentWindow;
exports.getScrollLeft = getScrollLeft;
exports.getScrollTop = getScrollTop;
exports.getScrollableElement = getScrollableElement;
exports.getScrollbarWidth = getScrollbarWidth;
exports.getSelectionEndPosition = getSelectionEndPosition;
exports.getSelectionText = getSelectionText;
exports.getStyle = getStyle;
exports.getTrimmingContainer = getTrimmingContainer;
exports.getWindowScrollLeft = getWindowScrollLeft;
exports.getWindowScrollTop = getWindowScrollTop;
exports.hasAccessToParentWindow = hasAccessToParentWindow;
exports.hasClass = hasClass;
exports.hasHorizontalScrollbar = hasHorizontalScrollbar;
exports.hasVerticalScrollbar = hasVerticalScrollbar;
exports.index = index;
exports.innerHeight = innerHeight;
exports.innerWidth = innerWidth;
exports.isChildOf = isChildOf;
exports.isDetached = isDetached;
exports.isInput = isInput;
exports.isOutsideInput = isOutsideInput;
exports.isThisHotChild = isThisHotChild;
exports.isVisible = isVisible;
exports.makeElementContentEditableAndSelectItsContent = makeElementContentEditableAndSelectItsContent;
exports.matchesCSSRules = matchesCSSRules;
exports.observeVisibilityChangeOnce = observeVisibilityChangeOnce;
exports.offset = offset;
exports.outerHeight = outerHeight;
exports.outerWidth = outerWidth;
exports.overlayContainsElement = overlayContainsElement;
exports.removeAttribute = removeAttribute;
exports.removeClass = removeClass;
exports.removeContentEditableFromElementAndDeselect = removeContentEditableFromElementAndDeselect;
exports.removeEvent = removeEvent;
exports.removeTextNodes = removeTextNodes;
exports.resetCssTransform = resetCssTransform;
exports.runWithSelectedContendEditableElement = runWithSelectedContendEditableElement;
exports.selectElementIfAllowed = selectElementIfAllowed;
exports.setAttribute = setAttribute;
exports.setCaretPosition = setCaretPosition;
exports.setOverlayPosition = setOverlayPosition;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(311);
__webpack_require__(323);
__webpack_require__(329);
var _string = __webpack_require__(352);
var _a11y = __webpack_require__(496);
/**
 * Get the parent of the specified node in the DOM tree.
 *
 * @param {HTMLElement} element Element from which traversing is started.
 * @param {number} [level=0] Traversing deep level.
 * @returns {HTMLElement|null}
 */
function getParent(element) {
  let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let iteration = -1;
  let parent = null;
  let elementToCheck = element;
  while (elementToCheck !== null) {
    if (iteration === level) {
      parent = elementToCheck;
      break;
    }
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      iteration += 1;
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return parent;
}

/**
 * Check if the provided element is a child of the provided Handsontable container.
 *
 * @param {HTMLElement} element Element to be analyzed.
 * @param {HTMLElement} thisHotContainer The Handsontable container.
 * @returns {boolean}
 */
function isThisHotChild(element, thisHotContainer) {
  const closestHandsontableContainer = element.closest('.handsontable');
  return !!closestHandsontableContainer && (closestHandsontableContainer.parentNode === thisHotContainer || closestHandsontableContainer === thisHotContainer);
}

/**
 * Gets `frameElement` of the specified frame. Returns null if it is a top frame or if script has no access to read property.
 *
 * @param {Window} frame Frame from which should be get frameElement in safe way.
 * @returns {HTMLIFrameElement|null}
 */
function getFrameElement(frame) {
  return Object.getPrototypeOf(frame.parent) && frame.frameElement;
}

/**
 * Gets parent frame of the specified frame. Returns null if it is a top frame or if script has no access to read property.
 *
 * @param {Window} frame Frame from which should get frameElement in a safe way.
 * @returns {Window|null}
 */
function getParentWindow(frame) {
  return getFrameElement(frame) && frame.parent;
}

/**
 * Checks if script has access to read from parent frame of specified frame.
 *
 * @param {Window} frame Frame from which should get frameElement in a safe way.
 * @returns {boolean}
 */
function hasAccessToParentWindow(frame) {
  return !!Object.getPrototypeOf(frame.parent);
}

/**
 * Goes up the DOM tree (including given element) until it finds an parent element that matches the nodes or nodes name.
 * This method goes up through web components.
 *
 * @param {Node} element Element from which traversing is started.
 * @param {Array<string|Node>} [nodes] Array of elements or Array of elements name (in uppercase form).
 * @param {Node} [until] The element until the traversing ends.
 * @returns {Node|null}
 */
function closest(element) {
  let nodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let until = arguments.length > 2 ? arguments[2] : undefined;
  const {
    ELEMENT_NODE,
    DOCUMENT_FRAGMENT_NODE
  } = Node;
  let elementToCheck = element;
  while (elementToCheck !== null && elementToCheck !== undefined && elementToCheck !== until) {
    const {
      nodeType,
      nodeName
    } = elementToCheck;
    if (nodeType === ELEMENT_NODE && (nodes.includes(nodeName) || nodes.includes(elementToCheck))) {
      return elementToCheck;
    }
    const {
      host
    } = elementToCheck;
    if (host && nodeType === DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  return null;
}

/**
 * Goes "down" the DOM tree (including given element) until it finds an element that matches the nodes or nodes name.
 *
 * @param {HTMLElement} element Element from which traversing is started.
 * @param {Array} nodes Array of elements or Array of elements name.
 * @param {HTMLElement} [until] The list of elements until the traversing ends.
 * @returns {HTMLElement|null}
 */
function closestDown(element, nodes, until) {
  const matched = [];
  let elementToCheck = element;
  while (elementToCheck) {
    elementToCheck = closest(elementToCheck, nodes, until);
    if (!elementToCheck || until && !until.contains(elementToCheck)) {
      break;
    }
    matched.push(elementToCheck);
    if (elementToCheck.host && elementToCheck.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      elementToCheck = elementToCheck.host;
    } else {
      elementToCheck = elementToCheck.parentNode;
    }
  }
  const length = matched.length;
  return length ? matched[length - 1] : null;
}

/**
 * Traverses up the DOM tree from the given element and finds parent elements that have a specified class name
 * or match a provided class name regular expression.
 *
 * @param {HTMLElement} element - The element from which to start traversing.
 * @param {string|RegExp} className - The class name or class name regular expression to check.
 * @returns {{element: HTMLElement, classNames: string[]}} - Returns an object containing the matched parent element and an array of matched class names.
 */
function findFirstParentWithClass(element, className) {
  const matched = {
    element: undefined,
    classNames: []
  };
  let elementToCheck = element;
  while (elementToCheck !== null && elementToCheck !== element.ownerDocument.documentElement && !matched.element) {
    if (typeof className === 'string' && elementToCheck.classList.contains(className)) {
      matched.element = elementToCheck;
      matched.classNames.push(className);
    } else if (className instanceof RegExp) {
      const matchingClasses = Array.from(elementToCheck.classList).filter(cls => className.test(cls));
      if (matchingClasses.length) {
        matched.element = elementToCheck;
        matched.classNames.push(...matchingClasses);
      }
    }
    elementToCheck = elementToCheck.parentElement;
  }
  return matched;
}

/**
 * Goes up the DOM tree and checks if element is child of another element.
 *
 * @param {HTMLElement} child Child element An element to check.
 * @param {object|string} parent Parent element OR selector of the parent element.
 *                               If string provided, function returns `true` for the first occurrence of element with that class.
 * @returns {boolean}
 */
function isChildOf(child, parent) {
  let node = child.parentNode;
  let queriedParents = [];
  if (typeof parent === 'string') {
    if (child.defaultView) {
      queriedParents = Array.prototype.slice.call(child.querySelectorAll(parent), 0);
    } else {
      queriedParents = Array.prototype.slice.call(child.ownerDocument.querySelectorAll(parent), 0);
    }
  } else {
    queriedParents.push(parent);
  }
  while (node !== null) {
    if (queriedParents.indexOf(node) > -1) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}

/**
 * Counts index of element within its parent.
 * WARNING: for performance reasons, assumes there are only element nodes (no text nodes). This is true
 * for Walkotnable, otherwise would need to check for nodeType or use previousElementSibling.
 *
 * @see http://jsperf.com/sibling-index/10
 * @param {Element} element The element to check.
 * @returns {number}
 */
function index(element) {
  let i = 0;
  let elementToCheck = element;
  if (elementToCheck.previousSibling) {
    /* eslint-disable no-cond-assign */
    while (elementToCheck = elementToCheck.previousSibling) {
      i += 1;
    }
  }
  return i;
}

/**
 * Check if the provided overlay contains the provided element.
 *
 * @param {string} overlayType The type of the overlay.
 * @param {HTMLElement} element An element to check.
 * @param {HTMLElement} root The root element.
 * @returns {boolean}
 */
function overlayContainsElement(overlayType, element, root) {
  const overlayElement = root.parentElement.querySelector(`.ht_clone_${overlayType}`);
  return overlayElement ? overlayElement.contains(element) : null;
}

/**
 * @param {string[]} classNames The element "class" attribute string.
 * @returns {string[]}
 */
function filterEmptyClassNames(classNames) {
  if (!classNames || !classNames.length) {
    return [];
  }
  return classNames.filter(x => !!x);
}

/**
 * Filter out the RegExp entries from an array.
 *
 * @param {(string|RegExp)[]} list Array of either strings, Regexes or a mix of both.
 * @param {boolean} [returnBoth] If `true`, both the array without regexes and an array of regexes will be returned.
 * @returns {string[]|{regexFree: string[], regexes: RegExp[]}}
 */
function filterRegexes(list, returnBoth) {
  if (!list || !list.length) {
    return returnBoth ? {
      regexFree: [],
      regexes: []
    } : [];
  }
  const regexes = [];
  const regexFree = [];
  regexFree.push(...list.filter(entry => {
    const isRegex = entry instanceof RegExp;
    if (isRegex && returnBoth) {
      regexes.push(entry);
    }
    return !isRegex;
  }));
  return returnBoth ? {
    regexFree,
    regexes
  } : regexFree;
}

/**
 * Checks if element has class name.
 *
 * @param {HTMLElement} element An element to check.
 * @param {string} className Class name to check.
 * @returns {boolean}
 */
function hasClass(element, className) {
  if (element.classList === undefined || typeof className !== 'string' || className === '') {
    return false;
  }
  return element.classList.contains(className);
}

/**
 * Add class name to an element.
 *
 * @param {HTMLElement} element An element to process.
 * @param {string|Array} className Class name as string or array of strings.
 */
function addClass(element, className) {
  if (typeof className === 'string') {
    className = className.split(' ');
  }
  className = filterEmptyClassNames(className);
  if (className.length > 0) {
    element.classList.add(...className);
  }
}

/**
 * Remove class name from an element.
 *
 * @param {HTMLElement} element An element to process.
 * @param {string|RegExp|Array<string|RegExp>} className Class name as string or array of strings.
 */
function removeClass(element, className) {
  if (typeof className === 'string') {
    className = className.split(' ');
  } else if (className instanceof RegExp) {
    className = [className];
  }
  let {
    regexFree: stringClasses,
    // eslint-disable-next-line prefer-const
    regexes: regexClasses
  } = filterRegexes(className, true);
  stringClasses = filterEmptyClassNames(stringClasses);
  if (stringClasses.length > 0) {
    element.classList.remove(...stringClasses);
  }
  regexClasses.forEach(regexClassName => {
    element.classList.forEach(currentClassName => {
      if (regexClassName.test(currentClassName)) {
        element.classList.remove(currentClassName);
      }
    });
  });
}

/**
 * Set a single attribute or multiple attributes at once.
 *
 * @param {HTMLElement} domElement The HTML element to be modified.
 * @param {Array[]|string} attributes If setting multiple attributes at once, `attributes` holds an array containing the
 * attributes to be added. Each element of the array should be an array in a form of `[attributeName,
 * attributeValue]`. If setting a single attribute, `attributes` holds the name of the attribute.
 * @param {string|number|undefined} [attributeValue] If setting a single attribute, `attributeValue` holds the attribute
 * value.
 */
function setAttribute(domElement) {
  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let attributeValue = arguments.length > 2 ? arguments[2] : undefined;
  if (!Array.isArray(attributes)) {
    attributes = [[attributes, attributeValue]];
  }
  attributes.forEach(attributeInfo => {
    if (Array.isArray(attributeInfo) && attributeInfo[0] !== '') {
      domElement.setAttribute(...attributeInfo);
    }
  });
}

/**
 * Remove a single attribute or multiple attributes from the provided element at once.
 *
 * @param {HTMLElement} domElement The HTML element to be processed.
 * @param {Array<string|RegExp>|string} attributesToRemove If removing multiple attributes, `attributesToRemove`
 * holds an array of attribute names to be removed from the provided element. If removing a single attribute, it
 * holds the attribute name.
 */
function removeAttribute(domElement) {
  let attributesToRemove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  if (typeof attributesToRemove === 'string') {
    attributesToRemove = attributesToRemove.split(' ');
  } else if (attributesToRemove instanceof RegExp) {
    attributesToRemove = [attributesToRemove];
  }
  const {
    regexFree: stringAttributes,
    regexes: regexAttributes
  } = filterRegexes(attributesToRemove, true);
  stringAttributes.forEach(attributeNameToRemove => {
    if (attributeNameToRemove !== '') {
      domElement.removeAttribute(attributeNameToRemove);
    }
  });
  regexAttributes.forEach(attributeRegex => {
    domElement.getAttributeNames().forEach(attributeName => {
      if (attributeRegex.test(attributeName)) {
        domElement.removeAttribute(attributeName);
      }
    });
  });
}

/**
 * @param {HTMLElement} element An element from the text is removed.
 */
function removeTextNodes(element) {
  if (element.nodeType === 3) {
    element.parentNode.removeChild(element); // bye text nodes!
  } else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(element.nodeName) > -1) {
    const childs = element.childNodes;
    for (let i = childs.length - 1; i >= 0; i--) {
      removeTextNodes(childs[i]);
    }
  }
}

/**
 * Remove children function
 * WARNING - this doesn't unload events and data attached by jQuery
 * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/9
 * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/11 - no siginificant improvement with Chrome remove() method.
 *
 * @param {HTMLElement} element An element to clear.
 */
function empty(element) {
  let child;

  /* eslint-disable no-cond-assign */
  while (child = element.lastChild) {
    element.removeChild(child);
  }
}
const HTML_CHARACTERS = exports.HTML_CHARACTERS = /(<(.*)>|&(.*);)/;

/**
 * Insert content into element trying to avoid innerHTML method.
 *
 * @param {HTMLElement} element An element to write into.
 * @param {string} content The text to write.
 * @param {boolean} [sanitizeContent=true] If `true`, the content will be sanitized before writing to the element.
 */
function fastInnerHTML(element, content) {
  let sanitizeContent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (HTML_CHARACTERS.test(content)) {
    element.innerHTML = sanitizeContent ? (0, _string.sanitize)(content) : content;
  } else {
    fastInnerText(element, content);
  }
}

/**
 * Insert text content into element.
 *
 * @param {HTMLElement} element An element to write into.
 * @param {string} content The text to write.
 */
function fastInnerText(element, content) {
  const child = element.firstChild;
  if (child && child.nodeType === 3 && child.nextSibling === null) {
    // fast lane - replace existing text node
    child.textContent = content;
  } else {
    // slow lane - empty element and insert a text node
    empty(element);
    element.appendChild(element.ownerDocument.createTextNode(content));
  }
}

/**
 * Returns true if element is attached to the DOM and visible, false otherwise.
 *
 * @param {HTMLElement} element An element to check.
 * @returns {boolean}
 */
function isVisible(element) {
  const documentElement = element.ownerDocument.documentElement;
  const windowElement = element.ownerDocument.defaultView;
  let next = element;
  while (next !== documentElement) {
    // until <html> reached
    if (next === null) {
      // parent detached from DOM
      return false;
    } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      if (next.host) {
        // this is Web Components Shadow DOM
        // see: http://w3c.github.io/webcomponents/spec/shadow/#encapsulation
        // according to spec, should be if (next.ownerDocument !== window.document), but that doesn't work yet
        if (next.host.impl) {
          // Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features disabled
          return isVisible(next.host.impl);
        } else if (next.host) {
          // Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features enabled
          return isVisible(next.host);
        }
        throw new Error('Lost in Web Components world');
      } else {
        return false; // this is a node detached from document in IE8
      }
    } else if (windowElement.getComputedStyle(next).display === 'none') {
      return false;
    }
    next = next.parentNode;
  }
  return true;
}

/**
 * Returns elements top and left offset relative to the document. Function is not compatible with jQuery offset.
 *
 * @param {HTMLElement} element An element to get the offset position from.
 * @returns {object} Returns object with `top` and `left` props.
 */
function offset(element) {
  const rootDocument = element.ownerDocument;
  const rootWindow = rootDocument.defaultView;
  const documentElement = rootDocument.documentElement;
  let elementToCheck = element;
  let offsetLeft;
  let offsetTop;
  let lastElem;
  offsetLeft = elementToCheck.offsetLeft;
  offsetTop = elementToCheck.offsetTop;
  lastElem = elementToCheck;

  /* eslint-disable no-cond-assign */
  while (elementToCheck = elementToCheck.offsetParent) {
    // from my observation, document.body always has scrollLeft/scrollTop == 0
    if (elementToCheck === rootDocument.body) {
      break;
    }
    // If the element is inside an SVG context, the `offsetParent` can be
    // a <foreignObject> that does not have properties `offsetLeft` and `offsetTop` defined.
    if (!('offsetLeft' in elementToCheck)) {
      break;
    }
    offsetLeft += elementToCheck.offsetLeft;
    offsetTop += elementToCheck.offsetTop;
    lastElem = elementToCheck;
  }

  // slow - http://jsperf.com/offset-vs-getboundingclientrect/6
  if (lastElem && lastElem.style.position === 'fixed') {
    // if(lastElem !== document.body) { //faster but does gives false positive in Firefox
    offsetLeft += rootWindow.pageXOffset || documentElement.scrollLeft;
    offsetTop += rootWindow.pageYOffset || documentElement.scrollTop;
  }
  return {
    left: offsetLeft,
    top: offsetTop
  };
}

/**
 * Returns the document's scrollTop property.
 *
 * @param {Window} [rootWindow] The document window owner.
 * @returns {number}
 */
// eslint-disable-next-line no-restricted-globals
function getWindowScrollTop() {
  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  return rootWindow.scrollY;
}

/**
 * Returns the document's scrollLeft property.
 *
 * @param {Window} [rootWindow] The document window owner.
 * @returns {number}
 */
// eslint-disable-next-line no-restricted-globals
function getWindowScrollLeft() {
  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  return rootWindow.scrollX;
}

/**
 * Returns the provided element's scrollTop property.
 *
 * @param {HTMLElement} element An element to get the scroll top position from.
 * @param {Window} [rootWindow] The document window owner.
 * @returns {number}
 */
// eslint-disable-next-line no-restricted-globals
function getScrollTop(element) {
  let rootWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
  if (element === rootWindow) {
    return getWindowScrollTop(rootWindow);
  }
  return element.scrollTop;
}

/**
 * Returns the provided element's scrollLeft property.
 *
 * @param {HTMLElement} element An element to get the scroll left position from.
 * @param {Window} [rootWindow] The document window owner.
 * @returns {number}
 */
// eslint-disable-next-line no-restricted-globals
function getScrollLeft(element) {
  let rootWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;
  if (element === rootWindow) {
    return getWindowScrollLeft(rootWindow);
  }
  return element.scrollLeft;
}

/**
 * Returns a DOM element responsible for scrolling of the provided element.
 *
 * @param {HTMLElement} element An element to get the scrollable element from.
 * @returns {HTMLElement} Element's scrollable parent.
 */
function getScrollableElement(element) {
  let rootDocument = element.ownerDocument;
  let rootWindow = rootDocument ? rootDocument.defaultView : undefined;
  if (!rootDocument) {
    rootDocument = element.document ? element.document : element;
    rootWindow = rootDocument.defaultView;
  }
  const props = ['auto', 'scroll'];
  let el = element.parentNode;
  while (el && el.style && rootDocument.body !== el) {
    let {
      overflow,
      overflowX,
      overflowY
    } = el.style;
    if ([overflow, overflowX, overflowY].includes('scroll')) {
      return el;
    } else {
      ({
        overflow,
        overflowX,
        overflowY
      } = rootWindow.getComputedStyle(el));
      if (props.includes(overflow) || props.includes(overflowX) || props.includes(overflowY)) {
        return el;
      }
    }

    // The '+ 1' after the scrollHeight/scrollWidth is to prevent problems with zoomed out Chrome.
    if (el.clientHeight <= el.scrollHeight + 1 && (props.includes(overflowY) || props.includes(overflow))) {
      return el;
    }
    if (el.clientWidth <= el.scrollWidth + 1 && (props.includes(overflowX) || props.includes(overflow))) {
      return el;
    }
    el = el.parentNode;
  }
  return rootWindow;
}

/**
 * Get the maximum available `scrollTop` value for the provided element.
 *
 * @param {HTMLElement} element The element to get the maximum scroll top value from.
 * @returns {number} The maximum scroll top value.
 */
function getMaximumScrollTop(element) {
  return element.scrollHeight - element.clientHeight;
}

/**
 * Get the maximum available `scrollLeft` value for the provided element.
 *
 * @param {HTMLElement} element The element to get the maximum scroll left value from.
 * @returns {number} The maximum scroll left value.
 */
function getMaximumScrollLeft(element) {
  return element.scrollWidth - element.clientWidth;
}

/**
 * Returns a DOM element responsible for trimming the provided element.
 *
 * @param {HTMLElement} base Base element.
 * @returns {HTMLElement} Base element's trimming parent.
 */
function getTrimmingContainer(base) {
  const rootDocument = base.ownerDocument;
  const rootWindow = rootDocument.defaultView;
  let el = base.parentNode;
  while (el && el.style && rootDocument.body !== el) {
    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {
      return el;
    }
    const computedStyle = rootWindow.getComputedStyle(el);
    const allowedProperties = ['scroll', 'hidden', 'auto'];
    const property = computedStyle.getPropertyValue('overflow');
    const propertyY = computedStyle.getPropertyValue('overflow-y');
    const propertyX = computedStyle.getPropertyValue('overflow-x');
    if (allowedProperties.includes(property) || allowedProperties.includes(propertyY) || allowedProperties.includes(propertyX)) {
      return el;
    }
    el = el.parentNode;
  }
  return rootWindow;
}

/**
 * Returns a style property for the provided element. (Be it an inline or external style).
 *
 * @param {HTMLElement} element An element to get the style from.
 * @param {string} prop Wanted property.
 * @param {Window} [rootWindow] The document window owner.
 * @returns {string|undefined} Element's style property.
 */
// eslint-disable-next-line no-restricted-globals
function getStyle(element, prop) {
  let rootWindow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;
  if (!element) {
    return;
  } else if (element === rootWindow) {
    if (prop === 'width') {
      return `${rootWindow.innerWidth}px`;
    } else if (prop === 'height') {
      return `${rootWindow.innerHeight}px`;
    }
    return;
  }
  const styleProp = element.style[prop];
  if (styleProp !== '' && styleProp !== undefined) {
    return styleProp;
  }
  const computedStyle = rootWindow.getComputedStyle(element);
  if (computedStyle[prop] !== '' && computedStyle[prop] !== undefined) {
    return computedStyle[prop];
  }
}

/**
 * Verifies if element fit to provided CSSRule.
 *
 * @param {Element} element Element to verify with selector text.
 * @param {CSSRule} rule Selector text from CSSRule.
 * @returns {boolean}
 */
function matchesCSSRules(element, rule) {
  const {
    selectorText
  } = rule;
  let result = false;
  if (rule.type === CSSRule.STYLE_RULE && selectorText) {
    if (element.msMatchesSelector) {
      result = element.msMatchesSelector(selectorText);
    } else if (element.matches) {
      result = element.matches(selectorText);
    }
  }
  return result;
}

/**
 * Returns the element's outer width.
 *
 * @param {HTMLElement} element An element to get the width from.
 * @returns {number} Element's outer width.
 */
function outerWidth(element) {
  return element.offsetWidth;
}

/**
 * Returns the element's outer height.
 *
 * @param {HTMLElement} element An element to get the height from.
 * @returns {number} Element's outer height.
 */
function outerHeight(element) {
  return element.offsetHeight;
}

/**
 * Returns the element's inner height.
 *
 * @param {HTMLElement} element An element to get the height from.
 * @returns {number} Element's inner height.
 */
function innerHeight(element) {
  return element.clientHeight || element.innerHeight;
}

/**
 * Returns the element's inner width.
 *
 * @param {HTMLElement} element An element to get the width from.
 * @returns {number} Element's inner width.
 */
function innerWidth(element) {
  return element.clientWidth || element.innerWidth;
}

/**
 * @param {HTMLElement} element An element to which the event is added.
 * @param {string} event The event name.
 * @param {Function} callback The callback to add.
 */
function addEvent(element, event, callback) {
  element.addEventListener(event, callback, false);
}

/**
 * @param {HTMLElement} element An element from which the event is removed.
 * @param {string} event The event name.
 * @param {Function} callback The function reference to remove.
 */
function removeEvent(element, event, callback) {
  element.removeEventListener(event, callback, false);
}

/**
 * Returns caret position in text input.
 *
 * @author https://stackoverflow.com/questions/263743/how-to-get-caret-position-in-textarea
 * @param {HTMLElement} el An element to check.
 * @returns {number}
 */
function getCaretPosition(el) {
  if (el.selectionStart) {
    return el.selectionStart;
  }
  return 0;
}

/**
 * Returns end of the selection in text input.
 *
 * @param {HTMLElement} el An element to check.
 * @returns {number}
 */
function getSelectionEndPosition(el) {
  if (el.selectionEnd) {
    return el.selectionEnd;
  }
  return 0;
}

/**
 * Returns text under selection.
 *
 * @param {Window} [rootWindow] The document window owner.
 * @returns {string}
 */
// eslint-disable-next-line no-restricted-globals
function getSelectionText() {
  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  const rootDocument = rootWindow.document;
  let text = '';
  if (rootWindow.getSelection) {
    text = rootWindow.getSelection().toString();
  } else if (rootDocument.selection && rootDocument.selection.type !== 'Control') {
    text = rootDocument.selection.createRange().text;
  }
  return text;
}

/**
 * Cross-platform helper to clear text selection.
 *
 * @param {Window} [rootWindow] The document window owner.
 */
// eslint-disable-next-line no-restricted-globals
function clearTextSelection() {
  let rootWindow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  // http://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript
  if (rootWindow.getSelection) {
    if (rootWindow.getSelection().empty) {
      // Chrome
      rootWindow.getSelection().empty();
    } else if (rootWindow.getSelection().removeAllRanges) {
      // Firefox
      rootWindow.getSelection().removeAllRanges();
    }
  }
}

/**
 * Sets caret position in text input.
 *
 * @author http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/
 * @param {Element} element An element to process.
 * @param {number} pos The selection start position.
 * @param {number} endPos The selection end position.
 */
function setCaretPosition(element, pos, endPos) {
  if (endPos === undefined) {
    endPos = pos;
  }
  if (element.setSelectionRange) {
    element.focus();
    try {
      element.setSelectionRange(pos, endPos);
    } catch (err) {
      const elementParent = element.parentNode;
      const parentDisplayValue = elementParent.style.display;
      elementParent.style.display = 'block';
      element.setSelectionRange(pos, endPos);
      elementParent.style.display = parentDisplayValue;
    }
  }
}
let cachedScrollbarWidth;

/**
 * Helper to calculate scrollbar width.
 * Source: https://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes.
 *
 * @private
 * @param {Document} rootDocument The onwer of the document.
 * @returns {number}
 */
// eslint-disable-next-line no-restricted-globals
function walkontableCalculateScrollbarWidth() {
  let rootDocument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  const inner = rootDocument.createElement('div');
  inner.style.height = '200px';
  inner.style.width = '100%';
  const outer = rootDocument.createElement('div');
  outer.style.boxSizing = 'content-box';
  outer.style.height = '150px';
  outer.style.left = '0px';
  outer.style.overflow = 'hidden';
  outer.style.position = 'absolute';
  outer.style.top = '0px';
  outer.style.width = '200px';
  outer.style.visibility = 'hidden';
  outer.appendChild(inner);
  (rootDocument.body || rootDocument.documentElement).appendChild(outer);
  const w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  let w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  (rootDocument.body || rootDocument.documentElement).removeChild(outer);
  return w1 - w2;
}

/**
 * Returns the computed width of the native browser scroll bar.
 *
 * @param {Document} [rootDocument] The owner of the document.
 * @returns {number} Width.
 */
// eslint-disable-next-line no-restricted-globals
function getScrollbarWidth() {
  let rootDocument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  if (cachedScrollbarWidth === undefined) {
    cachedScrollbarWidth = walkontableCalculateScrollbarWidth(rootDocument);
  }
  return cachedScrollbarWidth;
}

/**
 * Checks if the provided element has a vertical scrollbar.
 *
 * @param {HTMLElement} element An element to check.
 * @returns {boolean}
 */
function hasVerticalScrollbar(element) {
  return element.offsetWidth !== element.clientWidth;
}

/**
 * Checks if the provided element has a vertical scrollbar.
 *
 * @param {HTMLElement} element An element to check.
 * @returns {boolean}
 */
function hasHorizontalScrollbar(element) {
  return element.offsetHeight !== element.clientHeight;
}

/**
 * Sets overlay position depending on it's type and used browser.
 *
 * @param {HTMLElement} overlayElem An element to process.
 * @param {number|string} left The left position of the overlay.
 * @param {number|string} top The top position of the overlay.
 */
function setOverlayPosition(overlayElem, left, top) {
  overlayElem.style.transform = `translate3d(${left},${top},0)`;
}

/**
 * @param {HTMLElement} element An element to process.
 * @returns {number|Array}
 */
function getCssTransform(element) {
  let transform;
  if (element.style.transform && (transform = element.style.transform) !== '') {
    return ['transform', transform];
  }
  return -1;
}

/**
 * @param {HTMLElement} element An element to process.
 */
function resetCssTransform(element) {
  if (element.style.transform && element.style.transform !== '') {
    element.style.transform = '';
  }
}

/**
 * Determines if the given DOM element is an input field.
 * Notice: By 'input' we mean input, textarea and select nodes.
 *
 * @param {HTMLElement} element - DOM element.
 * @returns {boolean}
 */
function isInput(element) {
  const inputs = ['INPUT', 'SELECT', 'TEXTAREA'];
  return element && (inputs.indexOf(element.nodeName) > -1 || element.contentEditable === 'true');
}

/**
 * Determines if the given DOM element is an input field placed OUTSIDE of HOT.
 * Notice: By 'input' we mean input, textarea and select nodes which have defined 'data-hot-input' attribute.
 *
 * @param {HTMLElement} element - DOM element.
 * @returns {boolean}
 */
function isOutsideInput(element) {
  return isInput(element) && element.hasAttribute('data-hot-input') === false;
}

/**
 * Check if the given DOM element can be focused (by using "select" method).
 *
 * @param {HTMLElement} element - DOM element.
 */
function selectElementIfAllowed(element) {
  const activeElement = element.ownerDocument.activeElement;
  if (!isOutsideInput(activeElement)) {
    element.select();
  }
}

/**
 * Check if the provided element is detached from DOM.
 *
 * @param {HTMLElement} element HTML element to be checked.
 * @returns {boolean} `true` if the element is detached, `false` otherwise.
 */
function isDetached(element) {
  return !element.parentNode;
}

/**
 * Set up an observer to recognize when the provided element first becomes visible and trigger a callback when it
 * happens.
 *
 * @param {HTMLElement} elementToBeObserved Element to be observed.
 * @param {Function} callback The callback function.
 */
function observeVisibilityChangeOnce(elementToBeObserved, callback) {
  const visibilityObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting && elementToBeObserved.offsetParent !== null) {
        callback();
        observer.unobserve(elementToBeObserved);
      }
    });
  }, {
    root: elementToBeObserved.ownerDocument.body
  });
  visibilityObserver.observe(elementToBeObserved);
}

/**
 * Add a `contenteditable` attribute, select the contents and optionally add the `invisibleSelection`
 * class to the provided element.
 *
 * @param {HTMLElement} element Element to be processed.
 * @param {boolean} [invisibleSelection=true] `true` if the class should be added to the element.
 * @param {boolean} [ariaHidden=true] `true` if the `aria-hidden` attribute should be added to the processed element.
 */
function makeElementContentEditableAndSelectItsContent(element) {
  let invisibleSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let ariaHidden = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const ownerDocument = element.ownerDocument;
  const range = ownerDocument.createRange();
  const sel = ownerDocument.defaultView.getSelection();
  setAttribute(element, 'contenteditable', true);
  if (ariaHidden) {
    setAttribute(element, ...(0, _a11y.A11Y_HIDDEN)());
  }
  if (invisibleSelection) {
    addClass(element, 'invisibleSelection');
  }
  range.selectNodeContents(element);
  sel.removeAllRanges();
  sel.addRange(range);
}

/**
 * Remove the `contenteditable` attribute, deselect the contents and optionally remove the `invisibleSelection`
 * class from the provided element.
 *
 * @param {HTMLElement} selectedElement The element to be deselected.
 * @param {boolean} [removeInvisibleSelectionClass=true] `true` if the class should be removed from the element.
 */
function removeContentEditableFromElementAndDeselect(selectedElement) {
  let removeInvisibleSelectionClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  const sel = selectedElement.ownerDocument.defaultView.getSelection();
  if (selectedElement.hasAttribute('aria-hidden')) {
    selectedElement.removeAttribute('aria-hidden');
  }
  sel.removeAllRanges();
  if (removeInvisibleSelectionClass) {
    removeClass(selectedElement, 'invisibleSelection');
  }
  selectedElement.removeAttribute('contenteditable');
}

/**
 * Run the provided callback while the provided element is selected and modified to have the `contenteditable`
 * attribute added. Optionally, the selection can be configured to be invisible.
 *
 * @param {HTMLElement} element Element to be selected.
 * @param {Function} callback Callback to be called.
 * @param {boolean} [invisibleSelection=true] `true` if the selection should be invisible.
 */
function runWithSelectedContendEditableElement(element, callback) {
  let invisibleSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  makeElementContentEditableAndSelectItsContent(element, invisibleSelection);
  callback();
  removeContentEditableFromElementAndDeselect(element, invisibleSelection);
}

/***/ }),
/* 352 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.equalsIgnoreCase = equalsIgnoreCase;
exports.isPercentValue = isPercentValue;
exports.randomString = randomString;
exports.sanitize = sanitize;
exports.stripTags = stripTags;
exports.substitute = substitute;
exports.toUpperCaseFirst = toUpperCaseFirst;
__webpack_require__(283);
var _dompurify = _interopRequireDefault(__webpack_require__(353));
var _mixed = __webpack_require__(354);
/**
 * Convert string to upper case first letter.
 *
 * @param {string} string String to convert.
 * @returns {string}
 */
function toUpperCaseFirst(string) {
  return string[0].toUpperCase() + string.substr(1);
}

/**
 * Compare strings case insensitively.
 *
 * @param {...string} strings Strings to compare.
 * @returns {boolean}
 */
function equalsIgnoreCase() {
  const unique = [];
  for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
    strings[_key] = arguments[_key];
  }
  let length = strings.length;
  while (length) {
    length -= 1;
    const string = (0, _mixed.stringify)(strings[length]).toLowerCase();
    if (unique.indexOf(string) === -1) {
      unique.push(string);
    }
  }
  return unique.length === 1;
}

/**
 * Generates a random hex string. Used as namespace for Handsontable instance events.
 *
 * @returns {string} Returns 16-long character random string (eq. `'92b1bfc74ec4'`).
 */
function randomString() {
  /**
   * @returns {string}
   */
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  }
  return s4() + s4() + s4() + s4();
}

/**
 * Checks if value is valid percent.
 *
 * @param {string} value The value to check.
 * @returns {boolean}
 */
function isPercentValue(value) {
  return /^([0-9][0-9]?%$)|(^100%$)/.test(value);
}

/**
 * Substitute strings placed beetwen square brackets into value defined in `variables` object. String names defined in
 * square brackets must be the same as property name of `variables` object.
 *
 * @param {string} template Template string.
 * @param {object} variables Object which contains all available values which can be injected into template.
 * @returns {string}
 */
function substitute(template) {
  let variables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return `${template}`.replace(/(?:\\)?\[([^[\]]+)]/g, (match, name) => {
    if (match.charAt(0) === '\\') {
      return match.substr(1, match.length - 1);
    }
    return variables[name] === undefined ? '' : variables[name];
  });
}

/**
 * Strip any HTML tag from the string.
 *
 * @param {string} string String to cut HTML from.
 * @returns {string}
 */
function stripTags(string) {
  return sanitize(`${string}`, {
    ALLOWED_TAGS: []
  });
}

/**
 * Sanitizes string from potential security vulnerabilities.
 *
 * @param {string} string String to sanitize.
 * @param {object} [options] DOMPurify's configuration object.
 * @returns {string}
 */
function sanitize(string, options) {
  return _dompurify.default.sanitize(string, options);
}

/***/ }),
/* 353 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*! @license DOMPurify 3.2.2 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.2/LICENSE */



const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object; // eslint-disable-line import/no-mutable-exports
let {
  apply,
  construct
} = typeof Reflect !== 'undefined' && Reflect;
if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
/**
 * Creates a new function that calls the given function with a specified thisArg and arguments.
 *
 * @param func - The function to be wrapped and called.
 * @returns A new function that calls the given function with a specified thisArg and arguments.
 */
function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
/**
 * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
 *
 * @param func - The constructor function to be wrapped and called.
 * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
 */
function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
/**
 * Add properties to a lookup table
 *
 * @param set - The set to which elements will be added.
 * @param array - The array containing elements to be added to the set.
 * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
 * @returns The modified set with added elements.
 */
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === 'string') {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
/**
 * Clean up an array to harden against CSPP
 *
 * @param array - The array to be cleaned.
 * @returns The cleaned version of the array
 */
function cleanArray(array) {
  for (let index = 0; index < array.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array, index);
    if (!isPropertyExist) {
      array[index] = null;
    }
  }
  return array;
}
/**
 * Shallow clone an object
 *
 * @param object - The object to be cloned.
 * @returns A new object that copies the original.
 */
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === 'object' && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
/**
 * This method automatically checks if the prop is function or getter and behaves accordingly.
 *
 * @param object - The object to look up the getter function in its prototype chain.
 * @param prop - The property name for which to find the getter function.
 * @returns The getter function found in the prototype chain or a fallback function.
 */
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}

const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
// SVG
const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
const text = freeze(['#text']);

const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

var EXPRESSIONS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ARIA_ATTR: ARIA_ATTR,
  ATTR_WHITESPACE: ATTR_WHITESPACE,
  CUSTOM_ELEMENT: CUSTOM_ELEMENT,
  DATA_ATTR: DATA_ATTR,
  DOCTYPE_NAME: DOCTYPE_NAME,
  ERB_EXPR: ERB_EXPR,
  IS_ALLOWED_URI: IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR: MUSTACHE_EXPR,
  TMPLIT_EXPR: TMPLIT_EXPR
});

/* eslint-disable @typescript-eslint/indent */
// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
const NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12 // Deprecated
};
const getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};
/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param trustedTypes The policy factory.
 * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
 * @return The policy created (or null, if Trusted Types
 * are not supported or creating the policy failed).
 */
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }
  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  let suffix = null;
  const ATTR_NAME = 'data-tt-policy-suffix';
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html) {
        return html;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};
const _createHooksMap = function _createHooksMap() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
  const DOMPurify = root => createDOMPurify(root);
  DOMPurify.version = '3.2.2';
  DOMPurify.removed = [];
  if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document
  } = window;
  const originalDocument = document;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element,
    NodeFilter,
    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  const remove = lookupGetter(ElementPrototype, 'remove');
  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    const template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = '';
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
  const {
    MUSTACHE_EXPR,
    ERB_EXPR,
    TMPLIT_EXPR,
    DATA_ATTR,
    ARIA_ATTR,
    IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */
  /* allowed element names */
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  /* Allowed attribute names */
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  /*
   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  let FORBID_TAGS = null;
  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  let FORBID_ATTR = null;
  /* Decide if ARIA attributes are okay */
  let ALLOW_ARIA_ATTR = true;
  /* Decide if custom data attributes are okay */
  let ALLOW_DATA_ATTR = true;
  /* Decide if unknown protocols are okay */
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  let SAFE_FOR_TEMPLATES = false;
  /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */
  let SAFE_FOR_XML = true;
  /* Decide if document with <html>... should be returned */
  let WHOLE_DOCUMENT = false;
  /* Track whether config is already set on this instance of DOMPurify. */
  let SET_CONFIG = false;
  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  let FORCE_BODY = false;
  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  let RETURN_DOM = false;
  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  let RETURN_DOM_FRAGMENT = false;
  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  let RETURN_TRUSTED_TYPE = false;
  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */
  let SANITIZE_DOM = true;
  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (§7.3.3)
   *   - DOM Tree Accessors (§3.1.5)
   *   - Form Element Parent-Child Relations (§4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
   *   - HTMLCollection (§4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
  /* Keep element content when removing element? */
  let KEEP_CONTENT = true;
  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  let IN_PLACE = false;
  /* Allow usage of profiles like html, svg and mathMl */
  let USE_PROFILES = {};
  /* Tags to ignore content of when KEEP_CONTENT is true */
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
  /* Tags that are safe for data: URIs */
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
  /* Attributes safe for values like "javascript:" */
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  /* Allowed XHTML+XML namespaces */
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
  // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
  /* Parsing of strict XHTML documents */
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  let transformCaseFunc = null;
  /* Keep a reference to config to pass to hooks */
  let CONFIG = null;
  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */
  const formElement = document.createElement('form');
  const isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  /**
   * _parseConfig
   *
   * @param cfg optional config literal
   */
  // eslint-disable-next-line complexity
  const _parseConfig = function _parseConfig() {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    /* Shield configuration object from tampering */
    if (!cfg || typeof cfg !== 'object') {
      cfg = {};
    }
    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
    /* Set configuration parameters */
    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }
    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }
    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      // Overwrite existing TrustedTypes policy.
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      // Sign local variables required by `sanitize`.
      emptyHTML = trustedTypesPolicy.createHTML('');
    } else {
      // Uninitialized policy, attempt to initialize the internal dompurify policy.
      if (trustedTypesPolicy === undefined) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      // If creating the internal policy succeeded sign internal variables.
      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
        emptyHTML = trustedTypesPolicy.createHTML('');
      }
    }
    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  /**
   * @param element a DOM element whose namespace is being checked
   * @returns Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  const _checkValidNamespace = function _checkValidNamespace(element) {
    let parent = getParentNode(element);
    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template'
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }
      // The only way to switch from MathML to SVG is via`
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }
      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }
      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    // For XHTML and XML documents that support custom namespaces
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
    // Return false just in case.
    return false;
  };
  /**
   * _forceRemove
   *
   * @param node a DOM node
   */
  const _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove(node);
    }
  };
  /**
   * _removeAttribute
   *
   * @param name an Attribute name
   * @param element a DOM node
   */
  const _removeAttribute = function _removeAttribute(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    // We void attribute values for unremovable "is" attributes
    if (name === 'is') {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {}
      } else {
        try {
          element.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };
  /**
   * _initDocument
   *
   * @param dirty - a string of dirty markup
   * @return a DOM, filled with the dirty markup
   */
  const _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }
    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  /**
   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
   *
   * @param root The root element or node to start traversing on.
   * @return The created NodeIterator
   */
  const _createNodeIterator = function _createNodeIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
  };
  /**
   * _isClobbered
   *
   * @param element element to check for clobbering attacks
   * @return true if clobbered, false if safe
   */
  const _isClobbered = function _isClobbered(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
  };
  /**
   * Checks whether the given object is a DOM node.
   *
   * @param value object to check whether it's a DOM node
   * @return true is object is a DOM node
   */
  const _isNode = function _isNode(value) {
    return typeof Node === 'function' && value instanceof Node;
  };
  function _executeHooks(hooks, currentNode, data) {
    arrayForEach(hooks, hook => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   * @param currentNode to check for permission to exist
   * @return true if node was killed, false if left alive
   */
  const _sanitizeElements = function _sanitizeElements(currentNode) {
    let content = null;
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Now let's check the element's type and name */
    const tagName = transformCaseFunc(currentNode.nodeName);
    /* Execute a hook if present */
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    /* Detect mXSS attempts abusing namespace confusion */
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any occurrence of processing instructions */
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any kind of possibly harmful comments */
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Make sure that older browsers don't get fallback-tag mXSS */
    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      /* Get the element's text content */
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        content = stringReplace(content, expr, ' ');
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  /**
   * _isValidAttribute
   *
   * @param lcTag Lowercase tag name of containing element.
   * @param lcName Lowercase attribute name.
   * @param value Attribute value.
   * @return Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }
    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
      return false;
    } else ;
    return true;
  };
  /**
   * _isBasicCustomElement
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   *
   * @param tagName name of the tag of the node to sanitize
   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
   */
  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
  };
  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param currentNode to sanitize
   */
  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    /* Check if we have attributes; if not we might have a text node */
    if (!attributes) {
      return;
    }
    const hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: undefined
    };
    let l = attributes.length;
    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      let value = name === 'value' ? attrValue : stringTrim(attrValue);
      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode);
        // Prefix the value and later re-create the attribute with the sanitized value
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      /* Work around a security issue with comments inside attributes */
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      /* Remove attribute */
      _removeAttribute(name, currentNode);
      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }
      /* Work around a security issue in jQuery 3.0 */
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          value = stringReplace(value, expr, ' ');
        });
      }
      /* Is `value` valid for this attribute? */
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      /* Handle attributes that require Trusted Types */
      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
          }
        }
      }
      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_) {}
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  /**
   * _sanitizeShadowDOM
   *
   * @param fragment to iterate over recursively
   */
  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }
      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(shadowNode);
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }
    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      if (typeof dirty.toString === 'function') {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      } else {
        throw typeErrorCreate('toString is not a function');
      }
    }
    /* Return dirty HTML if DOMPurify cannot run */
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    /* Clean up removed elements */
    DOMPurify.removed = [];
    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      /* Initialize the document to work on */
      body = _initDocument(dirty);
      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }
    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    /* Get node iterator */
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(currentNode);
    }
    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }
    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }
    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        serializedHTML = stringReplace(serializedHTML, expr, ' ');
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function () {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function (entryPoint) {
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function (entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function () {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

module.exports = purify;
//# sourceMappingURL=purify.cjs.js.map


/*** EXPORTS FROM exports-to-window-loader ***/
window['DOMPurify'] = __webpack_require__(353);

/***/ }),
/* 354 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports._injectProductInfo = _injectProductInfo;
exports.isDefined = isDefined;
exports.isEmpty = isEmpty;
exports.isRegExp = isRegExp;
exports.isUndefined = isUndefined;
exports.stringify = stringify;
var _moment = _interopRequireDefault(__webpack_require__(355));
var _templateLiteralTag = __webpack_require__(494);
/**
 * Converts any value to string.
 *
 * @param {*} value The value to stringify.
 * @returns {string}
 */
function stringify(value) {
  let result;
  switch (typeof value) {
    case 'string':
    case 'number':
      result = `${value}`;
      break;
    case 'object':
      result = value === null ? '' : value.toString();
      break;
    case 'undefined':
      result = '';
      break;
    default:
      result = value.toString();
      break;
  }
  return result;
}

/**
 * Checks if given variable is defined.
 *
 * @param {*} variable Variable to check.
 * @returns {boolean}
 */
function isDefined(variable) {
  return typeof variable !== 'undefined';
}

/**
 * Checks if given variable is undefined.
 *
 * @param {*} variable Variable to check.
 * @returns {boolean}
 */
function isUndefined(variable) {
  return typeof variable === 'undefined';
}

/**
 * Check if given variable is null, empty string or undefined.
 *
 * @param {*} variable Variable to check.
 * @returns {boolean}
 */
function isEmpty(variable) {
  return variable === null || variable === '' || isUndefined(variable);
}

/**
 * Check if given variable is a regular expression.
 *
 * @param {*} variable Variable to check.
 * @returns {boolean}
 */
function isRegExp(variable) {
  return Object.prototype.toString.call(variable) === '[object RegExp]';
}

/* eslint-disable */
const _m = '\x6C\x65\x6E\x67\x74\x68';
const _hd = v => parseInt(v, 16);
const _pi = v => parseInt(v, 10);
const _ss = (v, s, l) => v['\x73\x75\x62\x73\x74\x72'](s, l);
const _cp = v => v['\x63\x6F\x64\x65\x50\x6F\x69\x6E\x74\x41\x74'](0) - 65;
const _norm = v => `${v}`.replace(/\-/g, '');
const _extractTime = v => _hd(_ss(_norm(v), _hd('12'), _cp('\x46'))) / (_hd(_ss(_norm(v), _cp('\x42'), ~~![][_m])) || 9);
const _ignored = () => typeof location !== 'undefined' && /^([a-z0-9\-]+\.)?\x68\x61\x6E\x64\x73\x6F\x6E\x74\x61\x62\x6C\x65\x2E\x63\x6F\x6D$/i.test(location.host);
let _notified = false;
const consoleMessages = {
  invalid: () => (0, _templateLiteralTag.toSingleLine)`
    The license key for Handsontable is invalid.\x20
    If you need any help, contact us at support@handsontable.com.`,
  expired: _ref => {
    let {
      keyValidityDate,
      hotVersion
    } = _ref;
    return (0, _templateLiteralTag.toSingleLine)`
    The license key for Handsontable expired on ${keyValidityDate}, and is not valid for the installed\x20
    version ${hotVersion}. Renew your license key at handsontable.com or downgrade to a version released prior\x20
    to ${keyValidityDate}. If you need any help, contact us at sales@handsontable.com.`;
  },
  missing: () => (0, _templateLiteralTag.toSingleLine)`
    The license key for Handsontable is missing. Use your purchased key to activate the product.\x20
    Alternatively, you can activate Handsontable to use for non-commercial purposes by\x20
    passing the key: 'non-commercial-and-evaluation'. If you need any help, contact\x20
    us at support@handsontable.com.`,
  non_commercial: () => ''
};
const domMessages = {
  invalid: () => (0, _templateLiteralTag.toSingleLine)`
    The license key for Handsontable is invalid.\x20
    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> on how to\x20
    install it properly or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.`,
  expired: _ref2 => {
    let {
      keyValidityDate,
      hotVersion
    } = _ref2;
    return (0, _templateLiteralTag.toSingleLine)`
    The license key for Handsontable expired on ${keyValidityDate}, and is not valid for the installed\x20
    version ${hotVersion}. <a href="https://handsontable.com/pricing" target="_blank">Renew</a> your\x20
    license key or downgrade to a version released prior to ${keyValidityDate}. If you need any\x20
    help, contact us at <a href="mailto:sales@handsontable.com">sales@handsontable.com</a>.`;
  },
  missing: () => (0, _templateLiteralTag.toSingleLine)`
    The license key for Handsontable is missing. Use your purchased key to activate the product.\x20
    Alternatively, you can activate Handsontable to use for non-commercial purposes by\x20
    passing the key: 'non-commercial-and-evaluation'.\x20
    <a href="https://handsontable.com/docs/tutorial-license-key.html" target="_blank">Read more</a> about it in\x20
    the documentation or contact us at <a href="mailto:support@handsontable.com">support@handsontable.com</a>.`,
  non_commercial: () => ''
};
function _injectProductInfo(key, element) {
  const hasValidType = !isEmpty(key);
  const isNonCommercial = typeof key === 'string' && key.toLowerCase() === 'non-commercial-and-evaluation';
  const hotVersion = "15.0.0";
  let keyValidityDate;
  let consoleMessageState = 'invalid';
  let domMessageState = 'invalid';
  key = _norm(key || '');
  const schemaValidity = _checkKeySchema(key);
  if (hasValidType || isNonCommercial || schemaValidity) {
    if (schemaValidity) {
      const releaseDate = (0, _moment.default)("16/12/2024", 'DD/MM/YYYY');
      const releaseDays = Math.floor(releaseDate.toDate().getTime() / 8.64e7);
      const keyValidityDays = _extractTime(key);
      keyValidityDate = (0, _moment.default)((keyValidityDays + 1) * 8.64e7, 'x').format('MMMM DD, YYYY');
      if (releaseDays > keyValidityDays) {
        consoleMessageState = 'expired';
        domMessageState = 'expired';
      } else {
        consoleMessageState = 'valid';
        domMessageState = 'valid';
      }
    } else if (isNonCommercial) {
      consoleMessageState = 'non_commercial';
      domMessageState = 'valid';
    } else {
      consoleMessageState = 'invalid';
      domMessageState = 'invalid';
    }
  } else {
    consoleMessageState = 'missing';
    domMessageState = 'missing';
  }
  if (_ignored()) {
    consoleMessageState = 'valid';
    domMessageState = 'valid';
  }
  if (!_notified && consoleMessageState !== 'valid') {
    const message = consoleMessages[consoleMessageState]({
      keyValidityDate,
      hotVersion
    });
    if (message) {
      console[consoleMessageState === 'non_commercial' ? 'info' : 'warn'](consoleMessages[consoleMessageState]({
        keyValidityDate,
        hotVersion
      }));
    }
    _notified = true;
  }
  if (domMessageState !== 'valid' && element.parentNode) {
    const message = domMessages[domMessageState]({
      keyValidityDate,
      hotVersion
    });
    if (message) {
      const messageNode = document.createElement('div');
      messageNode.className = 'handsontable hot-display-license-info';
      messageNode.innerHTML = domMessages[domMessageState]({
        keyValidityDate,
        hotVersion
      });
      element.parentNode.insertBefore(messageNode, element.nextSibling);
    }
  }
}
function _checkKeySchema(v) {
  let z = [][_m];
  let p = z;
  if (v[_m] !== _cp('\x5A')) {
    return false;
  }
  for (let c = '', i = '\x42\x3C\x48\x34\x50\x2B'.split(''), j = _cp(i.shift()); j; j = _cp(i.shift() || 'A')) {
    --j < ''[_m] ? p = p | (_pi(`${_pi(_hd(c) + (_hd(_ss(v, Math.abs(j), 2)) + []).padStart(2, '0'))}`) % 97 || 2) >> 1 : c = _ss(v, j, !j ? 6 : i[_m] === 1 ? 9 : 8);
  }
  return p === z;
}
/* eslint-enable */

/***/ }),
/* 355 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
//! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    0
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i,
            arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        var flags = null,
            parsedParts = false,
            isNowValid = m._d && !isNaN(m._d.getTime());
        if (isNowValid) {
            flags = getParsingFlags(m);
            parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            isNowValid =
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidEra &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));
            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        } else {
            return isNowValid;
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i,
            prop,
            val,
            momentPropertiesLen = momentProperties.length;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentPropertiesLen > 0) {
            for (i = 0; i < momentPropertiesLen; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key,
                    argLen = arguments.length;
                for (i = 0; i < argLen; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {
        D: 'date',
        dates: 'date',
        date: 'date',
        d: 'day',
        days: 'day',
        day: 'day',
        e: 'weekday',
        weekdays: 'weekday',
        weekday: 'weekday',
        E: 'isoWeekday',
        isoweekdays: 'isoWeekday',
        isoweekday: 'isoWeekday',
        DDD: 'dayOfYear',
        dayofyears: 'dayOfYear',
        dayofyear: 'dayOfYear',
        h: 'hour',
        hours: 'hour',
        hour: 'hour',
        ms: 'millisecond',
        milliseconds: 'millisecond',
        millisecond: 'millisecond',
        m: 'minute',
        minutes: 'minute',
        minute: 'minute',
        M: 'month',
        months: 'month',
        month: 'month',
        Q: 'quarter',
        quarters: 'quarter',
        quarter: 'quarter',
        s: 'second',
        seconds: 'second',
        second: 'second',
        gg: 'weekYear',
        weekyears: 'weekYear',
        weekyear: 'weekYear',
        GG: 'isoWeekYear',
        isoweekyears: 'isoWeekYear',
        isoweekyear: 'isoWeekYear',
        w: 'week',
        weeks: 'week',
        week: 'week',
        W: 'isoWeek',
        isoweeks: 'isoWeek',
        isoweek: 'isoWeek',
        y: 'year',
        years: 'year',
        year: 'year',
    };

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {
        date: 9,
        day: 11,
        weekday: 11,
        isoWeekday: 11,
        dayOfYear: 4,
        hour: 13,
        millisecond: 16,
        minute: 14,
        month: 8,
        quarter: 7,
        second: 15,
        weekYear: 1,
        isoWeekYear: 1,
        week: 5,
        isoWeek: 5,
        year: 1,
    };

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        match1to2NoLeadingZero = /^[1-9]\d?/, //         1-99
        match1to2HasZero = /^([1-9]\d|\d)/, //           0-99
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(
                    /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                    function (matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    }
                )
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback,
            tokenLen;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        tokenLen = token.length;
        for (i = 0; i < tokenLen; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        if (!mom.isValid()) {
            return NaN;
        }

        var d = mom._d,
            isUTC = mom._isUTC;

        switch (unit) {
            case 'Milliseconds':
                return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
            case 'Seconds':
                return isUTC ? d.getUTCSeconds() : d.getSeconds();
            case 'Minutes':
                return isUTC ? d.getUTCMinutes() : d.getMinutes();
            case 'Hours':
                return isUTC ? d.getUTCHours() : d.getHours();
            case 'Date':
                return isUTC ? d.getUTCDate() : d.getDate();
            case 'Day':
                return isUTC ? d.getUTCDay() : d.getDay();
            case 'Month':
                return isUTC ? d.getUTCMonth() : d.getMonth();
            case 'FullYear':
                return isUTC ? d.getUTCFullYear() : d.getFullYear();
            default:
                return NaN; // Just in case
        }
    }

    function set$1(mom, unit, value) {
        var d, isUTC, year, month, date;

        if (!mom.isValid() || isNaN(value)) {
            return;
        }

        d = mom._d;
        isUTC = mom._isUTC;

        switch (unit) {
            case 'Milliseconds':
                return void (isUTC
                    ? d.setUTCMilliseconds(value)
                    : d.setMilliseconds(value));
            case 'Seconds':
                return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
            case 'Minutes':
                return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
            case 'Hours':
                return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
            case 'Date':
                return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
            // case 'Day': // Not real
            //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
            // case 'Month': // Not used because we need to pass two variables
            //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
            case 'FullYear':
                break; // See below ...
            default:
                return; // Just in case
        }

        year = value;
        month = mom.month();
        date = mom.date();
        date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
        void (isUTC
            ? d.setUTCFullYear(year, month, date)
            : d.setFullYear(year, month, date));
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i,
                prioritizedLen = prioritized.length;
            for (i = 0; i < prioritizedLen; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // PARSING

    addRegexToken('M', match1to2, match1to2NoLeadingZero);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
        defaultLocaleMonthsShort =
            'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        var month = value,
            date = mom.date();

        date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
        void (mom._isUTC
            ? mom._d.setUTCMonth(month, date)
            : mom._d.setMonth(month, date));
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            shortP,
            longP;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortP = regexEscape(this.monthsShort(mom, ''));
            longP = regexEscape(this.months(mom, ''));
            shortPieces.push(shortP);
            longPieces.push(longP);
            mixedPieces.push(longP);
            mixedPieces.push(shortP);
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // PARSING

    addRegexToken('w', match1to2, match1to2NoLeadingZero);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2, match1to2NoLeadingZero);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(
        ['w', 'ww', 'W', 'WW'],
        function (input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input);
        }
    );

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
              ? weekdays[m.day()]
              : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
              ? this._weekdaysShort[m.day()]
              : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
              ? this._weekdaysMin[m.day()]
              : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        var day = get(this, 'Day');
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2, match1to2HasZero);
    addRegexToken('h', match1to2, match1to2NoLeadingZero);
    addRegexToken('k', match1to2, match1to2NoLeadingZero);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function isLocaleNameSane(name) {
        // Prevent names that look like filesystem paths, i.e contain '/' or '\'
        // Ensure name is available and function returns boolean
        return !!(name && name.match('^[^/\\\\]*$'));
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            "object" !== 'undefined' &&
            module &&
            module.exports &&
            isLocaleNameSane(name)
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = undefined;
                __webpack_require__(356)("./" + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                      ? DATE
                      : a[HOUR] < 0 ||
                          a[HOUR] > 24 ||
                          (a[HOUR] === 24 &&
                              (a[MINUTE] !== 0 ||
                                  a[SECOND] !== 0 ||
                                  a[MILLISECOND] !== 0))
                        ? HOUR
                        : a[MINUTE] < 0 || a[MINUTE] > 59
                          ? MINUTE
                          : a[SECOND] < 0 || a[SECOND] > 59
                            ? SECOND
                            : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                              ? MILLISECOND
                              : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 =
            /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat,
            isoDatesLen = isoDates.length,
            isoTimesLen = isoTimes.length;

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDatesLen; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimesLen; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^()]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era,
            tokenLen;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens.length;
        for (i = 0; i < tokenLen; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false,
            configfLen = config._f.length;

        if (configfLen === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < configfLen; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i,
            orderLen = ordering.length;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < orderLen; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property,
            propertyLen = properties.length;

        for (i = 0; i < propertyLen; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
              ? 'lastWeek'
              : diff < 0
                ? 'lastDay'
                : diff < 1
                  ? 'sameDay'
                  : diff < 2
                    ? 'nextDay'
                    : diff < 7
                      ? 'nextWeek'
                      : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(
        ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
        function (input, array, config, token) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        }
    );

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            erasName,
            erasAbbr,
            erasNarrow,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            erasName = regexEscape(eras[i].name);
            erasAbbr = regexEscape(eras[i].abbr);
            erasNarrow = regexEscape(eras[i].narrow);

            namePieces.push(erasName);
            abbrPieces.push(erasAbbr);
            narrowPieces.push(erasNarrow);
            mixedPieces.push(erasName);
            mixedPieces.push(erasAbbr);
            mixedPieces.push(erasNarrow);
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(
        ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
        function (input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input);
        }
    );

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday() + this.localeData()._week.dow,
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // PARSING

    addRegexToken('D', match1to2, match1to2NoLeadingZero);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // PARSING

    addRegexToken('m', match1to2, match1to2HasZero);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // PARSING

    addRegexToken('s', match1to2, match1to2HasZero);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                          ? 'st'
                          : b === 2
                            ? 'nd'
                            : b === 3
                              ? 'rd'
                              : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y'),
        valueOf$1 = asMilliseconds;

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.30.1';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));


/*** EXPORTS FROM exports-to-window-loader ***/
window['moment'] = __webpack_require__(355);

/***/ }),
/* 356 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 357,
	"./af.js": 357,
	"./ar": 358,
	"./ar-dz": 359,
	"./ar-dz.js": 359,
	"./ar-kw": 360,
	"./ar-kw.js": 360,
	"./ar-ly": 361,
	"./ar-ly.js": 361,
	"./ar-ma": 362,
	"./ar-ma.js": 362,
	"./ar-ps": 363,
	"./ar-ps.js": 363,
	"./ar-sa": 364,
	"./ar-sa.js": 364,
	"./ar-tn": 365,
	"./ar-tn.js": 365,
	"./ar.js": 358,
	"./az": 366,
	"./az.js": 366,
	"./be": 367,
	"./be.js": 367,
	"./bg": 368,
	"./bg.js": 368,
	"./bm": 369,
	"./bm.js": 369,
	"./bn": 370,
	"./bn-bd": 371,
	"./bn-bd.js": 371,
	"./bn.js": 370,
	"./bo": 372,
	"./bo.js": 372,
	"./br": 373,
	"./br.js": 373,
	"./bs": 374,
	"./bs.js": 374,
	"./ca": 375,
	"./ca.js": 375,
	"./cs": 376,
	"./cs.js": 376,
	"./cv": 377,
	"./cv.js": 377,
	"./cy": 378,
	"./cy.js": 378,
	"./da": 379,
	"./da.js": 379,
	"./de": 380,
	"./de-at": 381,
	"./de-at.js": 381,
	"./de-ch": 382,
	"./de-ch.js": 382,
	"./de.js": 380,
	"./dv": 383,
	"./dv.js": 383,
	"./el": 384,
	"./el.js": 384,
	"./en-au": 385,
	"./en-au.js": 385,
	"./en-ca": 386,
	"./en-ca.js": 386,
	"./en-gb": 387,
	"./en-gb.js": 387,
	"./en-ie": 388,
	"./en-ie.js": 388,
	"./en-il": 389,
	"./en-il.js": 389,
	"./en-in": 390,
	"./en-in.js": 390,
	"./en-nz": 391,
	"./en-nz.js": 391,
	"./en-sg": 392,
	"./en-sg.js": 392,
	"./eo": 393,
	"./eo.js": 393,
	"./es": 394,
	"./es-do": 395,
	"./es-do.js": 395,
	"./es-mx": 396,
	"./es-mx.js": 396,
	"./es-us": 397,
	"./es-us.js": 397,
	"./es.js": 394,
	"./et": 398,
	"./et.js": 398,
	"./eu": 399,
	"./eu.js": 399,
	"./fa": 400,
	"./fa.js": 400,
	"./fi": 401,
	"./fi.js": 401,
	"./fil": 402,
	"./fil.js": 402,
	"./fo": 403,
	"./fo.js": 403,
	"./fr": 404,
	"./fr-ca": 405,
	"./fr-ca.js": 405,
	"./fr-ch": 406,
	"./fr-ch.js": 406,
	"./fr.js": 404,
	"./fy": 407,
	"./fy.js": 407,
	"./ga": 408,
	"./ga.js": 408,
	"./gd": 409,
	"./gd.js": 409,
	"./gl": 410,
	"./gl.js": 410,
	"./gom-deva": 411,
	"./gom-deva.js": 411,
	"./gom-latn": 412,
	"./gom-latn.js": 412,
	"./gu": 413,
	"./gu.js": 413,
	"./he": 414,
	"./he.js": 414,
	"./hi": 415,
	"./hi.js": 415,
	"./hr": 416,
	"./hr.js": 416,
	"./hu": 417,
	"./hu.js": 417,
	"./hy-am": 418,
	"./hy-am.js": 418,
	"./id": 419,
	"./id.js": 419,
	"./is": 420,
	"./is.js": 420,
	"./it": 421,
	"./it-ch": 422,
	"./it-ch.js": 422,
	"./it.js": 421,
	"./ja": 423,
	"./ja.js": 423,
	"./jv": 424,
	"./jv.js": 424,
	"./ka": 425,
	"./ka.js": 425,
	"./kk": 426,
	"./kk.js": 426,
	"./km": 427,
	"./km.js": 427,
	"./kn": 428,
	"./kn.js": 428,
	"./ko": 429,
	"./ko.js": 429,
	"./ku": 430,
	"./ku-kmr": 431,
	"./ku-kmr.js": 431,
	"./ku.js": 430,
	"./ky": 432,
	"./ky.js": 432,
	"./lb": 433,
	"./lb.js": 433,
	"./lo": 434,
	"./lo.js": 434,
	"./lt": 435,
	"./lt.js": 435,
	"./lv": 436,
	"./lv.js": 436,
	"./me": 437,
	"./me.js": 437,
	"./mi": 438,
	"./mi.js": 438,
	"./mk": 439,
	"./mk.js": 439,
	"./ml": 440,
	"./ml.js": 440,
	"./mn": 441,
	"./mn.js": 441,
	"./mr": 442,
	"./mr.js": 442,
	"./ms": 443,
	"./ms-my": 444,
	"./ms-my.js": 444,
	"./ms.js": 443,
	"./mt": 445,
	"./mt.js": 445,
	"./my": 446,
	"./my.js": 446,
	"./nb": 447,
	"./nb.js": 447,
	"./ne": 448,
	"./ne.js": 448,
	"./nl": 449,
	"./nl-be": 450,
	"./nl-be.js": 450,
	"./nl.js": 449,
	"./nn": 451,
	"./nn.js": 451,
	"./oc-lnc": 452,
	"./oc-lnc.js": 452,
	"./pa-in": 453,
	"./pa-in.js": 453,
	"./pl": 454,
	"./pl.js": 454,
	"./pt": 455,
	"./pt-br": 456,
	"./pt-br.js": 456,
	"./pt.js": 455,
	"./ro": 457,
	"./ro.js": 457,
	"./ru": 458,
	"./ru.js": 458,
	"./sd": 459,
	"./sd.js": 459,
	"./se": 460,
	"./se.js": 460,
	"./si": 461,
	"./si.js": 461,
	"./sk": 462,
	"./sk.js": 462,
	"./sl": 463,
	"./sl.js": 463,
	"./sq": 464,
	"./sq.js": 464,
	"./sr": 465,
	"./sr-cyrl": 466,
	"./sr-cyrl.js": 466,
	"./sr.js": 465,
	"./ss": 467,
	"./ss.js": 467,
	"./sv": 468,
	"./sv.js": 468,
	"./sw": 469,
	"./sw.js": 469,
	"./ta": 470,
	"./ta.js": 470,
	"./te": 471,
	"./te.js": 471,
	"./tet": 472,
	"./tet.js": 472,
	"./tg": 473,
	"./tg.js": 473,
	"./th": 474,
	"./th.js": 474,
	"./tk": 475,
	"./tk.js": 475,
	"./tl-ph": 476,
	"./tl-ph.js": 476,
	"./tlh": 477,
	"./tlh.js": 477,
	"./tr": 478,
	"./tr.js": 478,
	"./tzl": 479,
	"./tzl.js": 479,
	"./tzm": 480,
	"./tzm-latn": 481,
	"./tzm-latn.js": 481,
	"./tzm.js": 480,
	"./ug-cn": 482,
	"./ug-cn.js": 482,
	"./uk": 483,
	"./uk.js": 483,
	"./ur": 484,
	"./ur.js": 484,
	"./uz": 485,
	"./uz-latn": 486,
	"./uz-latn.js": 486,
	"./uz.js": 485,
	"./vi": 487,
	"./vi.js": 487,
	"./x-pseudo": 488,
	"./x-pseudo.js": 488,
	"./yo": 489,
	"./yo.js": 489,
	"./zh-cn": 490,
	"./zh-cn.js": 490,
	"./zh-hk": 491,
	"./zh-hk.js": 491,
	"./zh-mo": 492,
	"./zh-mo.js": 492,
	"./zh-tw": 493,
	"./zh-tw.js": 493
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 356;

/***/ }),
/* 357 */
/***/ (() => {



/***/ }),
/* 358 */
/***/ (() => {



/***/ }),
/* 359 */
/***/ (() => {



/***/ }),
/* 360 */
/***/ (() => {



/***/ }),
/* 361 */
/***/ (() => {



/***/ }),
/* 362 */
/***/ (() => {



/***/ }),
/* 363 */
/***/ (() => {



/***/ }),
/* 364 */
/***/ (() => {



/***/ }),
/* 365 */
/***/ (() => {



/***/ }),
/* 366 */
/***/ (() => {



/***/ }),
/* 367 */
/***/ (() => {



/***/ }),
/* 368 */
/***/ (() => {



/***/ }),
/* 369 */
/***/ (() => {



/***/ }),
/* 370 */
/***/ (() => {



/***/ }),
/* 371 */
/***/ (() => {



/***/ }),
/* 372 */
/***/ (() => {



/***/ }),
/* 373 */
/***/ (() => {



/***/ }),
/* 374 */
/***/ (() => {



/***/ }),
/* 375 */
/***/ (() => {



/***/ }),
/* 376 */
/***/ (() => {



/***/ }),
/* 377 */
/***/ (() => {



/***/ }),
/* 378 */
/***/ (() => {



/***/ }),
/* 379 */
/***/ (() => {



/***/ }),
/* 380 */
/***/ (() => {



/***/ }),
/* 381 */
/***/ (() => {



/***/ }),
/* 382 */
/***/ (() => {



/***/ }),
/* 383 */
/***/ (() => {



/***/ }),
/* 384 */
/***/ (() => {



/***/ }),
/* 385 */
/***/ (() => {



/***/ }),
/* 386 */
/***/ (() => {



/***/ }),
/* 387 */
/***/ (() => {



/***/ }),
/* 388 */
/***/ (() => {



/***/ }),
/* 389 */
/***/ (() => {



/***/ }),
/* 390 */
/***/ (() => {



/***/ }),
/* 391 */
/***/ (() => {



/***/ }),
/* 392 */
/***/ (() => {



/***/ }),
/* 393 */
/***/ (() => {



/***/ }),
/* 394 */
/***/ (() => {



/***/ }),
/* 395 */
/***/ (() => {



/***/ }),
/* 396 */
/***/ (() => {



/***/ }),
/* 397 */
/***/ (() => {



/***/ }),
/* 398 */
/***/ (() => {



/***/ }),
/* 399 */
/***/ (() => {



/***/ }),
/* 400 */
/***/ (() => {



/***/ }),
/* 401 */
/***/ (() => {



/***/ }),
/* 402 */
/***/ (() => {



/***/ }),
/* 403 */
/***/ (() => {



/***/ }),
/* 404 */
/***/ (() => {



/***/ }),
/* 405 */
/***/ (() => {



/***/ }),
/* 406 */
/***/ (() => {



/***/ }),
/* 407 */
/***/ (() => {



/***/ }),
/* 408 */
/***/ (() => {



/***/ }),
/* 409 */
/***/ (() => {



/***/ }),
/* 410 */
/***/ (() => {



/***/ }),
/* 411 */
/***/ (() => {



/***/ }),
/* 412 */
/***/ (() => {



/***/ }),
/* 413 */
/***/ (() => {



/***/ }),
/* 414 */
/***/ (() => {



/***/ }),
/* 415 */
/***/ (() => {



/***/ }),
/* 416 */
/***/ (() => {



/***/ }),
/* 417 */
/***/ (() => {



/***/ }),
/* 418 */
/***/ (() => {



/***/ }),
/* 419 */
/***/ (() => {



/***/ }),
/* 420 */
/***/ (() => {



/***/ }),
/* 421 */
/***/ (() => {



/***/ }),
/* 422 */
/***/ (() => {



/***/ }),
/* 423 */
/***/ (() => {



/***/ }),
/* 424 */
/***/ (() => {



/***/ }),
/* 425 */
/***/ (() => {



/***/ }),
/* 426 */
/***/ (() => {



/***/ }),
/* 427 */
/***/ (() => {



/***/ }),
/* 428 */
/***/ (() => {



/***/ }),
/* 429 */
/***/ (() => {



/***/ }),
/* 430 */
/***/ (() => {



/***/ }),
/* 431 */
/***/ (() => {



/***/ }),
/* 432 */
/***/ (() => {



/***/ }),
/* 433 */
/***/ (() => {



/***/ }),
/* 434 */
/***/ (() => {



/***/ }),
/* 435 */
/***/ (() => {



/***/ }),
/* 436 */
/***/ (() => {



/***/ }),
/* 437 */
/***/ (() => {



/***/ }),
/* 438 */
/***/ (() => {



/***/ }),
/* 439 */
/***/ (() => {



/***/ }),
/* 440 */
/***/ (() => {



/***/ }),
/* 441 */
/***/ (() => {



/***/ }),
/* 442 */
/***/ (() => {



/***/ }),
/* 443 */
/***/ (() => {



/***/ }),
/* 444 */
/***/ (() => {



/***/ }),
/* 445 */
/***/ (() => {



/***/ }),
/* 446 */
/***/ (() => {



/***/ }),
/* 447 */
/***/ (() => {



/***/ }),
/* 448 */
/***/ (() => {



/***/ }),
/* 449 */
/***/ (() => {



/***/ }),
/* 450 */
/***/ (() => {



/***/ }),
/* 451 */
/***/ (() => {



/***/ }),
/* 452 */
/***/ (() => {



/***/ }),
/* 453 */
/***/ (() => {



/***/ }),
/* 454 */
/***/ (() => {



/***/ }),
/* 455 */
/***/ (() => {



/***/ }),
/* 456 */
/***/ (() => {



/***/ }),
/* 457 */
/***/ (() => {



/***/ }),
/* 458 */
/***/ (() => {



/***/ }),
/* 459 */
/***/ (() => {



/***/ }),
/* 460 */
/***/ (() => {



/***/ }),
/* 461 */
/***/ (() => {



/***/ }),
/* 462 */
/***/ (() => {



/***/ }),
/* 463 */
/***/ (() => {



/***/ }),
/* 464 */
/***/ (() => {



/***/ }),
/* 465 */
/***/ (() => {



/***/ }),
/* 466 */
/***/ (() => {



/***/ }),
/* 467 */
/***/ (() => {



/***/ }),
/* 468 */
/***/ (() => {



/***/ }),
/* 469 */
/***/ (() => {



/***/ }),
/* 470 */
/***/ (() => {



/***/ }),
/* 471 */
/***/ (() => {



/***/ }),
/* 472 */
/***/ (() => {



/***/ }),
/* 473 */
/***/ (() => {



/***/ }),
/* 474 */
/***/ (() => {



/***/ }),
/* 475 */
/***/ (() => {



/***/ }),
/* 476 */
/***/ (() => {



/***/ }),
/* 477 */
/***/ (() => {



/***/ }),
/* 478 */
/***/ (() => {



/***/ }),
/* 479 */
/***/ (() => {



/***/ }),
/* 480 */
/***/ (() => {



/***/ }),
/* 481 */
/***/ (() => {



/***/ }),
/* 482 */
/***/ (() => {



/***/ }),
/* 483 */
/***/ (() => {



/***/ }),
/* 484 */
/***/ (() => {



/***/ }),
/* 485 */
/***/ (() => {



/***/ }),
/* 486 */
/***/ (() => {



/***/ }),
/* 487 */
/***/ (() => {



/***/ }),
/* 488 */
/***/ (() => {



/***/ }),
/* 489 */
/***/ (() => {



/***/ }),
/* 490 */
/***/ (() => {



/***/ }),
/* 491 */
/***/ (() => {



/***/ }),
/* 492 */
/***/ (() => {



/***/ }),
/* 493 */
/***/ (() => {



/***/ }),
/* 494 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.toSingleLine = toSingleLine;
var _array = __webpack_require__(495);
/**
 * Tags a multiline string and return new one without line break characters and following spaces.
 *
 * @param {Array} strings Parts of the entire string without expressions.
 * @param {...string} expressions Expressions converted to strings, which are added to the entire string.
 * @returns {string}
 */
function toSingleLine(strings) {
  for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    expressions[_key - 1] = arguments[_key];
  }
  const result = (0, _array.arrayReduce)(strings, (previousValue, currentValue, index) => {
    const valueWithoutWhiteSpaces = currentValue.replace(/\r?\n\s*/g, '');
    const expressionForIndex = expressions[index] ? expressions[index] : '';
    return previousValue + valueWithoutWhiteSpaces + expressionForIndex;
  }, '');
  return result.trim();
}

/***/ }),
/* 495 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.arrayAvg = arrayAvg;
exports.arrayEach = arrayEach;
exports.arrayFilter = arrayFilter;
exports.arrayFlatten = arrayFlatten;
exports.arrayMap = arrayMap;
exports.arrayMax = arrayMax;
exports.arrayMin = arrayMin;
exports.arrayReduce = arrayReduce;
exports.arraySum = arraySum;
exports.arrayUnique = arrayUnique;
exports.extendArray = extendArray;
exports.getDifferenceOfArrays = getDifferenceOfArrays;
exports.getIntersectionOfArrays = getIntersectionOfArrays;
exports.getUnionOfArrays = getUnionOfArrays;
exports.pivot = pivot;
exports.stringToArray = stringToArray;
exports.to2dArray = to2dArray;
__webpack_require__(283);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(323);
/**
 * @param {Array} arr An array to process.
 */
function to2dArray(arr) {
  const ilen = arr.length;
  let i = 0;
  while (i < ilen) {
    arr[i] = [arr[i]];
    i += 1;
  }
}

/**
 * @param {Array} arr An array to extend.
 * @param {Array} extension The data to extend from.
 */
function extendArray(arr, extension) {
  const ilen = extension.length;
  let i = 0;
  while (i < ilen) {
    arr.push(extension[i]);
    i += 1;
  }
}

/**
 * @param {Array} arr An array to pivot.
 * @returns {Array}
 */
function pivot(arr) {
  const pivotedArr = [];
  if (!arr || arr.length === 0 || !arr[0] || arr[0].length === 0) {
    return pivotedArr;
  }
  const rowCount = arr.length;
  const colCount = arr[0].length;
  for (let i = 0; i < rowCount; i++) {
    for (let j = 0; j < colCount; j++) {
      if (!pivotedArr[j]) {
        pivotedArr[j] = [];
      }
      pivotedArr[j][i] = arr[i][j];
    }
  }
  return pivotedArr;
}

/**
 * A specialized version of `.reduce` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * {@link https://github.com/lodash/lodash/blob/master/lodash.js}.
 *
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initFromArray] Specify using the first element of `array` as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initFromArray) {
  let index = -1;
  let iterable = array;
  let result = accumulator;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  const length = iterable.length;
  if (initFromArray && length) {
    index += 1;
    result = iterable[index];
  }
  index += 1;
  while (index < length) {
    result = iteratee(result, iterable[index], index, iterable);
    index += 1;
  }
  return result;
}

/**
 * A specialized version of `.filter` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * {@link https://github.com/lodash/lodash/blob/master/lodash.js}.
 *
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  let index = 0;
  let iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  const length = iterable.length;
  const result = [];
  let resIndex = -1;
  while (index < length) {
    const value = iterable[index];
    if (predicate(value, index, iterable)) {
      resIndex += 1;
      result[resIndex] = value;
    }
    index += 1;
  }
  return result;
}

/**
 * A specialized version of `.map` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayMap(array, iteratee) {
  let index = 0;
  let iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  const length = iterable.length;
  const result = [];
  let resIndex = -1;
  while (index < length) {
    const value = iterable[index];
    resIndex += 1;
    result[resIndex] = iteratee(value, index, iterable);
    index += 1;
  }
  return result;
}

/**
 * A specialized version of `.forEach` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * {@link https://github.com/lodash/lodash/blob/master/lodash.js}.
 *
 * @param {Array|*} array The array to iterate over or an any element with implemented iterator protocol.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  let index = 0;
  let iterable = array;
  if (!Array.isArray(array)) {
    iterable = Array.from(array);
  }
  const length = iterable.length;
  while (index < length) {
    if (iteratee(iterable[index], index, iterable) === false) {
      break;
    }
    index += 1;
  }
  return array;
}

/**
 * Calculate sum value for each item of the array.
 *
 * @param {Array} array The array to process.
 * @returns {number} Returns calculated sum value.
 */
function arraySum(array) {
  return arrayReduce(array, (a, b) => a + b, 0);
}

/**
 * Returns the highest value from an array. Can be array of numbers or array of strings.
 * NOTICE: Mixed values is not supported.
 *
 * @param {Array} array The array to process.
 * @returns {number} Returns the highest value from an array.
 */
function arrayMax(array) {
  return arrayReduce(array, (a, b) => a > b ? a : b, Array.isArray(array) ? array[0] : undefined);
}

/**
 * Returns the lowest value from an array. Can be array of numbers or array of strings.
 * NOTICE: Mixed values is not supported.
 *
 * @param {Array} array The array to process.
 * @returns {number} Returns the lowest value from an array.
 */
function arrayMin(array) {
  return arrayReduce(array, (a, b) => a < b ? a : b, Array.isArray(array) ? array[0] : undefined);
}

/**
 * Calculate average value for each item of the array.
 *
 * @param {Array} array The array to process.
 * @returns {number} Returns calculated average value.
 */
function arrayAvg(array) {
  if (!array.length) {
    return 0;
  }
  return arraySum(array) / array.length;
}

/**
 * Flatten multidimensional array.
 *
 * @param {Array} array Array of Arrays.
 * @returns {Array}
 */
function arrayFlatten(array) {
  return arrayReduce(array, (initial, value) => initial.concat(Array.isArray(value) ? arrayFlatten(value) : value), []);
}

/**
 * Unique values in the array.
 *
 * @param {Array} array The array to process.
 * @returns {Array}
 */
function arrayUnique(array) {
  const unique = [];
  arrayEach(array, value => {
    if (unique.indexOf(value) === -1) {
      unique.push(value);
    }
  });
  return unique;
}

/**
 * Differences from two or more arrays.
 *
 * @param {...Array} arrays Array of strings or array of numbers.
 * @returns {Array} Returns the difference between arrays.
 */
function getDifferenceOfArrays() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }
  const [first, ...rest] = [...arrays];
  let filteredFirstArray = first;
  arrayEach(rest, array => {
    filteredFirstArray = filteredFirstArray.filter(value => !array.includes(value));
  });
  return filteredFirstArray;
}

/**
 * Intersection of two or more arrays.
 *
 * @param {...Array} arrays Array of strings or array of numbers.
 * @returns {Array} Returns elements that exists in every array.
 */
function getIntersectionOfArrays() {
  for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    arrays[_key2] = arguments[_key2];
  }
  const [first, ...rest] = [...arrays];
  let filteredFirstArray = first;
  arrayEach(rest, array => {
    filteredFirstArray = filteredFirstArray.filter(value => array.includes(value));
  });
  return filteredFirstArray;
}

/**
 * Union of two or more arrays.
 *
 * @param {...Array} arrays Array of strings or array of numbers.
 * @returns {Array} Returns the elements that exist in any of the arrays, without duplicates.
 */
function getUnionOfArrays() {
  for (var _len3 = arguments.length, arrays = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    arrays[_key3] = arguments[_key3];
  }
  const [first, ...rest] = [...arrays];
  const set = new Set(first);
  arrayEach(rest, array => {
    arrayEach(array, value => {
      if (!set.has(value)) {
        set.add(value);
      }
    });
  });
  return Array.from(set);
}

/**
 * Convert a separated strings to an array of strings.
 *
 * @param {string} value A string of class name(s).
 * @param {string|RegExp} delimiter The pattern describing where each split should occur.
 * @returns {string[]} Returns array of string or empty array.
 */
function stringToArray(value) {
  let delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ' ';
  return value.split(delimiter);
}

/***/ }),
/* 496 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
const A11Y_TABINDEX = val => ['tabindex', val];
exports.A11Y_TABINDEX = A11Y_TABINDEX;
const A11Y_TREEGRID = () => ['role', 'treegrid'];
exports.A11Y_TREEGRID = A11Y_TREEGRID;
const A11Y_PRESENTATION = () => ['role', 'presentation'];
exports.A11Y_PRESENTATION = A11Y_PRESENTATION;
const A11Y_GRIDCELL = () => ['role', 'gridcell'];
exports.A11Y_GRIDCELL = A11Y_GRIDCELL;
const A11Y_ROWHEADER = () => ['role', 'rowheader'];
exports.A11Y_ROWHEADER = A11Y_ROWHEADER;
const A11Y_ROWGROUP = () => ['role', 'rowgroup'];
exports.A11Y_ROWGROUP = A11Y_ROWGROUP;
const A11Y_COLUMNHEADER = () => ['role', 'columnheader'];
exports.A11Y_COLUMNHEADER = A11Y_COLUMNHEADER;
const A11Y_ROW = () => ['role', 'row'];
exports.A11Y_ROW = A11Y_ROW;
const A11Y_MENU = () => ['role', 'menu'];
exports.A11Y_MENU = A11Y_MENU;
const A11Y_MENU_ITEM = () => ['role', 'menuitem'];
exports.A11Y_MENU_ITEM = A11Y_MENU_ITEM;
const A11Y_MENU_ITEM_CHECKBOX = () => ['role', 'menuitemcheckbox'];
exports.A11Y_MENU_ITEM_CHECKBOX = A11Y_MENU_ITEM_CHECKBOX;
const A11Y_COMBOBOX = () => ['role', 'combobox'];
exports.A11Y_COMBOBOX = A11Y_COMBOBOX;
const A11Y_LISTBOX = () => ['role', 'listbox'];
exports.A11Y_LISTBOX = A11Y_LISTBOX;
const A11Y_OPTION = () => ['role', 'option'];
exports.A11Y_OPTION = A11Y_OPTION;
const A11Y_CHECKBOX = () => ['role', 'checkbox'];
exports.A11Y_CHECKBOX = A11Y_CHECKBOX;
const A11Y_SCOPE_COL = () => ['scope', 'col'];
exports.A11Y_SCOPE_COL = A11Y_SCOPE_COL;
const A11Y_SCOPE_ROW = () => ['scope', 'row'];
exports.A11Y_SCOPE_ROW = A11Y_SCOPE_ROW;
const A11Y_TEXT = () => ['type', 'text'];
exports.A11Y_TEXT = A11Y_TEXT;
const A11Y_LABEL = val => ['aria-label', val];
exports.A11Y_LABEL = A11Y_LABEL;
const A11Y_HIDDEN = () => ['aria-hidden', 'true'];
exports.A11Y_HIDDEN = A11Y_HIDDEN;
const A11Y_DISABLED = () => ['aria-disabled', 'true'];
exports.A11Y_DISABLED = A11Y_DISABLED;
const A11Y_MULTISELECTABLE = () => ['aria-multiselectable', 'true'];
exports.A11Y_MULTISELECTABLE = A11Y_MULTISELECTABLE;
const A11Y_HASPOPUP = val => ['aria-haspopup', val];
exports.A11Y_HASPOPUP = A11Y_HASPOPUP;
const A11Y_ROWCOUNT = val => ['aria-rowcount', val];
exports.A11Y_ROWCOUNT = A11Y_ROWCOUNT;
const A11Y_COLCOUNT = val => ['aria-colcount', val];
exports.A11Y_COLCOUNT = A11Y_COLCOUNT;
const A11Y_ROWINDEX = val => ['aria-rowindex', val];
exports.A11Y_ROWINDEX = A11Y_ROWINDEX;
const A11Y_COLINDEX = val => ['aria-colindex', val];
exports.A11Y_COLINDEX = A11Y_COLINDEX;
const A11Y_EXPANDED = val => ['aria-expanded', val];
exports.A11Y_EXPANDED = A11Y_EXPANDED;
const A11Y_SORT = val => ['aria-sort', val];
exports.A11Y_SORT = A11Y_SORT;
const A11Y_READONLY = () => ['aria-readonly', 'true'];
exports.A11Y_READONLY = A11Y_READONLY;
const A11Y_INVALID = () => ['aria-invalid', 'true'];
exports.A11Y_INVALID = A11Y_INVALID;
const A11Y_CHECKED = val => ['aria-checked', val];
exports.A11Y_CHECKED = A11Y_CHECKED;
const A11Y_SELECTED = () => ['aria-selected', 'true'];
exports.A11Y_SELECTED = A11Y_SELECTED;
const A11Y_AUTOCOMPLETE = () => ['aria-autocomplete', 'list'];
exports.A11Y_AUTOCOMPLETE = A11Y_AUTOCOMPLETE;
const A11Y_CONTROLS = val => ['aria-controls', val];
exports.A11Y_CONTROLS = A11Y_CONTROLS;
const A11Y_ACTIVEDESCENDANT = val => ['aria-activedescendant', val];
exports.A11Y_ACTIVEDESCENDANT = A11Y_ACTIVEDESCENDANT;
const A11Y_LIVE = val => ['aria-live', val];
exports.A11Y_LIVE = A11Y_LIVE;
const A11Y_RELEVANT = val => ['aria-relevant', val];
exports.A11Y_RELEVANT = A11Y_RELEVANT;
const A11Y_SETSIZE = val => ['aria-setsize', val];
exports.A11Y_SETSIZE = A11Y_SETSIZE;
const A11Y_POSINSET = val => ['aria-posinset', val];
exports.A11Y_POSINSET = A11Y_POSINSET;

/***/ }),
/* 497 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.curry = curry;
exports.curryRight = curryRight;
exports.debounce = debounce;
exports.fastCall = fastCall;
exports.isFunction = isFunction;
exports.partial = partial;
exports.pipe = pipe;
exports.throttle = throttle;
exports.throttleAfterHits = throttleAfterHits;
var _array = __webpack_require__(495);
var _mixed = __webpack_require__(354);
/**
 * Checks if given variable is function.
 *
 * @param {*} func Variable to check.
 * @returns {boolean}
 */
function isFunction(func) {
  return typeof func === 'function';
}

/**
 * Creates throttle function that enforces a maximum number of times a function (`func`) can be called over time (`wait`).
 *
 * @param {Function} func Function to invoke.
 * @param {number} wait Delay in miliseconds.
 * @returns {Function}
 */
function throttle(func) {
  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
  let lastCalled = 0;
  const result = {
    lastCallThrottled: true
  };
  let lastTimer = null;

  /**
   * @param {...*} args The list of arguments passed during the function invocation.
   * @returns {object}
   */
  function _throttle() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const stamp = Date.now();
    let needCall = false;
    result.lastCallThrottled = true;
    if (!lastCalled) {
      lastCalled = stamp;
      needCall = true;
    }
    const remaining = wait - (stamp - lastCalled);
    if (needCall) {
      result.lastCallThrottled = false;
      func.apply(this, args);
    } else {
      if (lastTimer) {
        clearTimeout(lastTimer);
      }
      lastTimer = setTimeout(() => {
        result.lastCallThrottled = false;
        func.apply(this, args);
        lastCalled = 0;
        lastTimer = undefined;
      }, remaining);
    }
    return result;
  }
  return _throttle;
}

/**
 * Creates throttle function that enforces a maximum number of times a function (`func`) can be called over
 * time (`wait`) after specified hits.
 *
 * @param {Function} func Function to invoke.
 * @param {number} wait Delay in miliseconds.
 * @param {number} hits Number of hits after throttling will be applied.
 * @returns {Function}
 */
function throttleAfterHits(func) {
  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
  let hits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
  const funcThrottle = throttle(func, wait);
  let remainHits = hits;

  /**
   *
   */
  function _clearHits() {
    remainHits = hits;
  }
  /**
   * @param {*} args The list of arguments passed during the function invocation.
   * @returns {*}
   */
  function _throttleAfterHits() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (remainHits) {
      remainHits -= 1;
      return func.apply(this, args);
    }
    return funcThrottle.apply(this, args);
  }
  _throttleAfterHits.clearHits = _clearHits;
  return _throttleAfterHits;
}

/**
 * Creates debounce function that enforces a function (`func`) not be called again until a certain amount of time (`wait`)
 * has passed without it being called.
 *
 * @param {Function} func Function to invoke.
 * @param {number} wait Delay in milliseconds.
 * @returns {Function}
 */
function debounce(func) {
  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
  let lastTimer = null;
  let result;

  /**
   * @param {*} args The list of arguments passed during the function invocation.
   * @returns {*}
   */
  function _debounce() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    if (lastTimer) {
      clearTimeout(lastTimer);
    }
    lastTimer = setTimeout(() => {
      result = func.apply(this, args);
    }, wait);
    return result;
  }
  return _debounce;
}

/**
 * Creates the function that returns the result of calling the given functions. Result of the first function is passed to
 * the second as an argument and so on. Only first function in the chain can handle multiple arguments.
 *
 * @param {Function} functions Functions to compose.
 * @returns {Function}
 */
function pipe() {
  for (var _len4 = arguments.length, functions = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    functions[_key4] = arguments[_key4];
  }
  const [firstFunc, ...restFunc] = functions;
  return function _pipe() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return (0, _array.arrayReduce)(restFunc, (acc, fn) => fn(acc), firstFunc.apply(this, args));
  };
}

/**
 * Creates the function that returns the function with cached arguments.
 *
 * @param {Function} func Function to partialization.
 * @param {Array} params Function arguments to cache.
 * @returns {Function}
 */
function partial(func) {
  for (var _len6 = arguments.length, params = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    params[_key6 - 1] = arguments[_key6];
  }
  return function _partial() {
    for (var _len7 = arguments.length, restParams = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      restParams[_key7] = arguments[_key7];
    }
    return func.apply(this, params.concat(restParams));
  };
}

/**
 * Creates the functions that returns the function with cached arguments. If count if passed arguments will be matched
 * to the arguments defined in `func` then function will be invoked.
 * Arguments are added to the stack in direction from the left to the right.
 *
 * @example
 * ```
 * var replace = curry(function(find, replace, string) {
 *   return string.replace(find, replace);
 * });
 *
 * // returns function with bounded first argument
 * var replace = replace('foo')
 *
 * // returns replaced string - all arguments was passed so function was invoked
 * replace('bar', 'Some test with foo...');
 *
 * ```
 *
 * @param {Function} func Function to currying.
 * @returns {Function}
 */
function curry(func) {
  const argsLength = func.length;

  /**
   * @param {*} argsSoFar The list of arguments passed during the function invocation.
   * @returns {Function}
   */
  function given(argsSoFar) {
    return function _curry() {
      for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        params[_key8] = arguments[_key8];
      }
      const passedArgsSoFar = argsSoFar.concat(params);
      let result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}

/**
 * Creates the functions that returns the function with cached arguments. If count if passed arguments will be matched
 * to the arguments defined in `func` then function will be invoked.
 * Arguments are added to the stack in direction from the right to the left.
 *
 * @example
 * ```
 * var replace = curry(function(find, replace, string) {
 *   return string.replace(find, replace);
 * });
 *
 * // returns function with bounded first argument
 * var replace = replace('Some test with foo...')
 *
 * // returns replaced string - all arguments was passed so function was invoked
 * replace('bar', 'foo');
 *
 * ```
 *
 * @param {Function} func Function to currying.
 * @returns {Function}
 */
function curryRight(func) {
  const argsLength = func.length;

  /**
   * @param {*} argsSoFar The list of arguments passed during the function invocation.
   * @returns {Function}
   */
  function given(argsSoFar) {
    return function _curry() {
      for (var _len9 = arguments.length, params = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        params[_key9] = arguments[_key9];
      }
      const passedArgsSoFar = argsSoFar.concat(params.reverse());
      let result;
      if (passedArgsSoFar.length >= argsLength) {
        result = func.apply(this, passedArgsSoFar);
      } else {
        result = given(passedArgsSoFar);
      }
      return result;
    };
  }
  return given([]);
}

/**
 * Calls a function in the quickest way available.
 *
 * In contrast to the `apply()` method that passes arguments as an array,
 * the `call()` method passes arguments directly, to avoid garbage collection costs.
 *
 * @param {Function} func The function to call.
 * @param {*} context The value to use as `this` when calling the `func` function.
 * @param {*} [arg1] An argument passed to the `func` function.
 * @param {*} [arg2] An argument passed to `func` function.
 * @param {*} [arg3] An argument passed to `func` function.
 * @param {*} [arg4] An argument passed to `func` function.
 * @param {*} [arg5] An argument passed to `func` function.
 * @param {*} [arg6] An argument passed to `func` function.
 * @returns {*}
 */
function fastCall(func, context, arg1, arg2, arg3, arg4, arg5, arg6) {
  if ((0, _mixed.isDefined)(arg6)) {
    return func.call(context, arg1, arg2, arg3, arg4, arg5, arg6);
  } else if ((0, _mixed.isDefined)(arg5)) {
    return func.call(context, arg1, arg2, arg3, arg4, arg5);
  } else if ((0, _mixed.isDefined)(arg4)) {
    return func.call(context, arg1, arg2, arg3, arg4);
  } else if ((0, _mixed.isDefined)(arg3)) {
    return func.call(context, arg1, arg2, arg3);
  } else if ((0, _mixed.isDefined)(arg2)) {
    return func.call(context, arg1, arg2);
  } else if ((0, _mixed.isDefined)(arg1)) {
    return func.call(context, arg1);
  }
  return func.call(context);
}

/***/ }),
/* 498 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.isChrome = isChrome;
exports.isChromeWebKit = isChromeWebKit;
exports.isEdge = isEdge;
exports.isEdgeWebKit = isEdgeWebKit;
exports.isFirefox = isFirefox;
exports.isFirefoxWebKit = isFirefoxWebKit;
exports.isIOS = isIOS;
exports.isIpadOS = isIpadOS;
exports.isLinuxOS = isLinuxOS;
exports.isMacOS = isMacOS;
exports.isMobileBrowser = isMobileBrowser;
exports.isSafari = isSafari;
exports.isWindowsOS = isWindowsOS;
exports.setBrowserMeta = setBrowserMeta;
exports.setPlatformMeta = setPlatformMeta;
var _object = __webpack_require__(499);
var _feature = __webpack_require__(502);
const tester = testerFunc => {
  const result = {
    value: false
  };
  result.test = (ua, vendor) => {
    result.value = testerFunc(ua, vendor);
  };
  return result;
};
const browsers = {
  chrome: tester((ua, vendor) => /Chrome/.test(ua) && /Google/.test(vendor)),
  chromeWebKit: tester(ua => /CriOS/.test(ua)),
  edge: tester(ua => /Edge/.test(ua)),
  edgeWebKit: tester(ua => /EdgiOS/.test(ua)),
  firefox: tester(ua => /Firefox/.test(ua)),
  firefoxWebKit: tester(ua => /FxiOS/.test(ua)),
  mobile: tester(ua => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua)),
  safari: tester((ua, vendor) => /Safari/.test(ua) && /Apple Computer/.test(vendor))
};
const platforms = {
  mac: tester(platform => /^Mac/.test(platform)),
  win: tester(platform => /^Win/.test(platform)),
  linux: tester(platform => /^Linux/.test(platform)),
  ios: tester(ua => /iPhone|iPad|iPod/i.test(ua))
};

/**
 * @param {object} [metaObject] The browser identity collection.
 * @param {object} [metaObject.userAgent] The user agent reported by browser.
 * @param {object} [metaObject.vendor] The vendor name reported by browser.
 */
function setBrowserMeta() {
  let {
    userAgent = navigator.userAgent,
    vendor = navigator.vendor
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  (0, _object.objectEach)(browsers, _ref => {
    let {
      test
    } = _ref;
    return void test(userAgent, vendor);
  });
}

/**
 * @param {object} [metaObject] The platform identity collection.
 * @param {object} [metaObject.platform] The platform ID.
 */
function setPlatformMeta() {
  let {
    platform = navigator.platform
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  (0, _object.objectEach)(platforms, _ref2 => {
    let {
      test
    } = _ref2;
    return void test(platform);
  });
}
if ((0, _feature.isCSR)()) {
  setBrowserMeta();
  setPlatformMeta();
}

/**
 * @returns {boolean}
 */
function isChrome() {
  return browsers.chrome.value;
}

/**
 * @returns {boolean}
 */
function isChromeWebKit() {
  return browsers.chromeWebKit.value;
}

/**
 * @returns {boolean}
 */
function isFirefox() {
  return browsers.firefox.value;
}

/**
 * @returns {boolean}
 */
function isFirefoxWebKit() {
  return browsers.firefoxWebKit.value;
}

/**
 * @returns {boolean}
 */
function isSafari() {
  return browsers.safari.value;
}

/**
 * @returns {boolean}
 */
function isEdge() {
  return browsers.edge.value;
}

/**
 * @returns {boolean}
 */
function isEdgeWebKit() {
  return browsers.edgeWebKit.value;
}

/**
 * @returns {boolean}
 */
function isMobileBrowser() {
  return browsers.mobile.value;
}

/**
 * @returns {boolean}
 */
function isIOS() {
  return platforms.ios.value;
}

/**
 * A hacky way to recognize the iPad. Since iOS 13, the iPad on Safari mimics macOS behavior and user agent.
 *
 * @see {@https://stackoverflow.com/a/57838385}
 * @param {object} [metaObject] The browser identity collection.
 * @param {number} [metaObject.maxTouchPoints] The maximum number of simultanous touch points.
 * @returns {boolean}
 */
function isIpadOS() {
  let {
    maxTouchPoints
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : navigator;
  return maxTouchPoints > 2 && platforms.mac.value;
}

/**
 * @returns {boolean}
 */
function isWindowsOS() {
  return platforms.win.value;
}

/**
 * @returns {boolean}
 */
function isMacOS() {
  return platforms.mac.value;
}

/**
 * @returns {boolean}
 */
function isLinuxOS() {
  return platforms.linux.value;
}

/***/ }),
/* 499 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.clone = clone;
exports.createObjectPropListener = createObjectPropListener;
exports.deepClone = deepClone;
exports.deepExtend = deepExtend;
exports.deepObjectSize = deepObjectSize;
exports.defineGetter = defineGetter;
exports.duckSchema = duckSchema;
exports.extend = extend;
exports.getProperty = getProperty;
exports.hasOwnProperty = hasOwnProperty;
exports.inherit = inherit;
exports.isObject = isObject;
exports.isObjectEqual = isObjectEqual;
exports.mixin = mixin;
exports.objectEach = objectEach;
exports.setProperty = setProperty;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(500);
__webpack_require__(311);
__webpack_require__(329);
var _array = __webpack_require__(495);
/**
 * Generate schema for passed object.
 *
 * @param {Array|object} object An object to analyze.
 * @returns {Array|object}
 */
function duckSchema(object) {
  let schema;
  if (Array.isArray(object)) {
    schema = object.length ? new Array(object.length).fill(null) : [];
  } else {
    schema = {};
    objectEach(object, (value, key) => {
      if (key === '__children') {
        return;
      }
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        schema[key] = duckSchema(value);
      } else if (Array.isArray(value)) {
        if (value.length && typeof value[0] === 'object' && !Array.isArray(value[0])) {
          schema[key] = [duckSchema(value[0])];
        } else {
          schema[key] = [];
        }
      } else {
        schema[key] = null;
      }
    });
  }
  return schema;
}

/**
 * Inherit without without calling parent constructor, and setting `Child.prototype.constructor` to `Child` instead of `Parent`.
 * Creates temporary dummy function to call it as constructor.
 * Described in ticket: https://github.com/handsontable/handsontable/pull/516.
 *
 * @param {object} Child The child class.
 * @param {object} Parent The parent class.
 * @returns {object}
 */
function inherit(Child, Parent) {
  Parent.prototype.constructor = Parent;
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  return Child;
}

/**
 * Perform shallow extend of a target object with extension's own properties.
 *
 * @param {object} target An object that will receive the new properties.
 * @param {object} extension An object containing additional properties to merge into the target.
 * @param {string[]} [writableKeys] An array of keys that are writable to target object.
 * @returns {object}
 */
function extend(target, extension, writableKeys) {
  const hasWritableKeys = Array.isArray(writableKeys);
  objectEach(extension, (value, key) => {
    if (hasWritableKeys === false || writableKeys.includes(key)) {
      target[key] = value;
    }
  });
  return target;
}

/**
 * Perform deep extend of a target object with extension's own properties.
 *
 * @param {object} target An object that will receive the new properties.
 * @param {object} extension An object containing additional properties to merge into the target.
 */
function deepExtend(target, extension) {
  objectEach(extension, (value, key) => {
    if (extension[key] && typeof extension[key] === 'object') {
      if (!target[key]) {
        if (Array.isArray(extension[key])) {
          target[key] = [];
        } else if (Object.prototype.toString.call(extension[key]) === '[object Date]') {
          target[key] = extension[key];
        } else {
          target[key] = {};
        }
      }
      deepExtend(target[key], extension[key]);
    } else {
      target[key] = extension[key];
    }
  });
}

/**
 * Perform deep clone of an object.
 * WARNING! Only clones JSON properties. Will cause error when `obj` contains a function, Date, etc.
 *
 * @param {object} obj An object that will be cloned.
 * @returns {object}
 */
function deepClone(obj) {
  if (typeof obj === 'object') {
    return JSON.parse(JSON.stringify(obj));
  }
  return obj;
}

/**
 * Shallow clone object.
 *
 * @param {object} object An object to clone.
 * @returns {object}
 */
function clone(object) {
  const result = {};
  objectEach(object, (value, key) => {
    result[key] = value;
  });
  return result;
}

/**
 * Extend the Base object (usually prototype) of the functionality the `mixins` objects.
 *
 * @param {object} Base Base object which will be extended.
 * @param {object} mixins The object of the functionality will be "copied".
 * @returns {object}
 */
function mixin(Base) {
  if (!Base.MIXINS) {
    Base.MIXINS = [];
  }
  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }
  (0, _array.arrayEach)(mixins, mixinItem => {
    Base.MIXINS.push(mixinItem.MIXIN_NAME);
    objectEach(mixinItem, (value, key) => {
      if (Base.prototype[key] !== undefined) {
        throw new Error(`Mixin conflict. Property '${key}' already exist and cannot be overwritten.`);
      }
      if (typeof value === 'function') {
        Base.prototype[key] = value;
      } else {
        const getter = function _getter(property, initialValue) {
          const propertyName = `_${property}`;
          const initValue = newValue => {
            let result = newValue;
            if (Array.isArray(result) || isObject(result)) {
              result = deepClone(result);
            }
            return result;
          };
          return function () {
            if (this[propertyName] === undefined) {
              this[propertyName] = initValue(initialValue);
            }
            return this[propertyName];
          };
        };
        const setter = function _setter(property) {
          const propertyName = `_${property}`;
          return function (newValue) {
            this[propertyName] = newValue;
          };
        };
        Object.defineProperty(Base.prototype, key, {
          get: getter(key, value),
          set: setter(key),
          configurable: true
        });
      }
    });
  });
  return Base;
}

/**
 * Checks if two objects or arrays are (deep) equal.
 *
 * @param {object|Array} object1 The first object to compare.
 * @param {object|Array} object2 The second object to compare.
 * @returns {boolean}
 */
function isObjectEqual(object1, object2) {
  return JSON.stringify(object1) === JSON.stringify(object2);
}

/**
 * Determines whether given object is a plain Object.
 * Note: String and Array are not plain Objects.
 *
 * @param {*} object An object to check.
 * @returns {boolean}
 */
function isObject(object) {
  return Object.prototype.toString.call(object) === '[object Object]';
}

/**
 * @param {object} object The object on which to define the property.
 * @param {string} property The name of the property to be defined or modified.
 * @param {*} value The value associated with the property.
 * @param {object} options The descriptor for the property being defined or modified.
 */
function defineGetter(object, property, value, options) {
  options.value = value;
  options.writable = options.writable !== false;
  options.enumerable = options.enumerable !== false;
  options.configurable = options.configurable !== false;
  Object.defineProperty(object, property, options);
}

/**
 * A specialized version of `.forEach` for objects.
 *
 * @param {object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {object} Returns `object`.
 */
function objectEach(object, iteratee) {
  // eslint-disable-next-line no-restricted-syntax
  for (const key in object) {
    if (!object.hasOwnProperty || object.hasOwnProperty && Object.prototype.hasOwnProperty.call(object, key)) {
      if (iteratee(object[key], key, object) === false) {
        break;
      }
    }
  }
  return object;
}

/**
 * Get object property by its name. Access to sub properties can be achieved by dot notation (e.q. `'foo.bar.baz'`).
 *
 * @param {object} object Object which value will be exported.
 * @param {string} name Object property name.
 * @returns {*}
 */
function getProperty(object, name) {
  const names = name.split('.');
  let result = object;
  objectEach(names, nameItem => {
    result = result[nameItem];
    if (result === undefined) {
      result = undefined;
      return false;
    }
  });
  return result;
}

/**
 * Set a property value on the provided object. Works on nested object prop names as well (e.g. `first.name`).
 *
 * @param {object} object Object to work on.
 * @param {string} name Prop name.
 * @param {*} value Value to be assigned at the provided property.
 */
function setProperty(object, name, value) {
  const names = name.split('.');
  let workingObject = object;
  names.forEach((propName, index) => {
    if (index !== names.length - 1) {
      if (!hasOwnProperty(workingObject, propName)) {
        workingObject[propName] = {};
      }
      workingObject = workingObject[propName];
    } else {
      workingObject[propName] = value;
    }
  });
}

/**
 * Return object length (recursively).
 *
 * @param {*} object Object for which we want get length.
 * @returns {number}
 */
function deepObjectSize(object) {
  if (!isObject(object)) {
    return 0;
  }
  const recursObjLen = function (obj) {
    let result = 0;
    if (isObject(obj)) {
      objectEach(obj, (value, key) => {
        if (key === '__children') {
          return;
        }
        result += recursObjLen(value);
      });
    } else {
      result += 1;
    }
    return result;
  };
  return recursObjLen(object);
}

/**
 * Create object with property where its value change will be observed.
 *
 * @param {*} [defaultValue=undefined] Default value.
 * @param {string} [propertyToListen='value'] Property to listen.
 * @returns {object}
 */
function createObjectPropListener(defaultValue) {
  let propertyToListen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'value';
  const privateProperty = `_${propertyToListen}`;
  const holder = {
    _touched: false,
    [privateProperty]: defaultValue,
    isTouched() {
      return this._touched;
    }
  };
  Object.defineProperty(holder, propertyToListen, {
    get() {
      return this[privateProperty];
    },
    set(value) {
      this._touched = true;
      this[privateProperty] = value;
    },
    enumerable: true,
    configurable: true
  });
  return holder;
}

/**
 * Check if at specified `key` there is any value for `object`.
 *
 * @param {object} object Object to search value at specific key.
 * @param {string} key String key to check.
 * @returns {boolean}
 */
function hasOwnProperty(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}

/***/ }),
/* 500 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var getBuiltIn = __webpack_require__(222);
var apply = __webpack_require__(267);
var call = __webpack_require__(207);
var uncurryThis = __webpack_require__(213);
var fails = __webpack_require__(206);
var isCallable = __webpack_require__(220);
var isSymbol = __webpack_require__(221);
var arraySlice = __webpack_require__(344);
var getReplacerFunction = __webpack_require__(501);
var NATIVE_SYMBOL = __webpack_require__(225);

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')('stringify detection');
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) !== '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) !== '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) !== '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),
/* 501 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var isArray = __webpack_require__(285);
var isCallable = __webpack_require__(220);
var classof = __webpack_require__(214);
var toString = __webpack_require__(276);

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),
/* 502 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.cancelAnimationFrame = cancelAnimationFrame;
exports.getComparisonFunction = getComparisonFunction;
exports.isCSR = isCSR;
exports.isTouchSupported = isTouchSupported;
exports.requestAnimationFrame = requestAnimationFrame;
/* eslint-disable no-restricted-globals */
/**
 * Polyfill for requestAnimationFrame.
 *
 * @param {Function} callback The function to call when it's time.
 * @returns {number}
 */
function requestAnimationFrame(callback) {
  return window.requestAnimationFrame(callback);
}

/**
 * Polyfill for cancelAnimationFrame.
 *
 * @param {number} id The request Id, generated by `requestAnimationFrame`.
 */
function cancelAnimationFrame(id) {
  window.cancelAnimationFrame(id);
}

/**
 * @returns {boolean}
 */
function isTouchSupported() {
  return 'ontouchstart' in window;
}

/**
 * Checks if the environment that the code runs in is a browser.
 *
 * @returns {boolean}
 */
function isCSR() {
  return typeof window !== 'undefined';
}
let comparisonFunction;

/**
 * Get string comparison function for sorting purposes. It supports multilingual string comparison base on Internationalization API.
 *
 * @param {string} [language] The language code used for phrases sorting.
 * @param {object} [options] Additional options for sort comparator.
 * @returns {*}
 */
function getComparisonFunction(language) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (comparisonFunction) {
    return comparisonFunction;
  }
  if (typeof Intl === 'object') {
    comparisonFunction = new Intl.Collator(language, options).compare;
  } else if (typeof String.prototype.localeCompare === 'function') {
    comparisonFunction = (a, b) => `${a}`.localeCompare(b);
  } else {
    comparisonFunction = (a, b) => {
      if (a === b) {
        return 0;
      }
      return a > b ? -1 : 1;
    };
  }
  return comparisonFunction;
}

/***/ }),
/* 503 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _unicode = __webpack_require__(508);
var _event = __webpack_require__(509);
var _registry = __webpack_require__(510);
var _eventManager = _interopRequireDefault(__webpack_require__(522));
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _EditorManager_brand = /*#__PURE__*/new WeakSet();
class EditorManager {
  /**
   * @param {Core} hotInstance The Handsontable instance.
   * @param {TableMeta} tableMeta The table meta instance.
   * @param {Selection} selection The selection instance.
   */
  constructor(hotInstance, tableMeta, _selection) {
    /**
     * OnAfterDocumentKeyDown callback.
     *
     * @param {KeyboardEvent} event The keyboard event object.
     */
    _classPrivateMethodInitSpec(this, _EditorManager_brand);
    /**
     * Instance of {@link Handsontable}.
     *
     * @private
     * @type {Handsontable}
     */
    (0, _defineProperty2.default)(this, "hot", void 0);
    /**
     * Reference to an instance's private GridSettings object.
     *
     * @private
     * @type {GridSettings}
     */
    (0, _defineProperty2.default)(this, "tableMeta", void 0);
    /**
     * Instance of {@link Selection}.
     *
     * @private
     * @type {Selection}
     */
    (0, _defineProperty2.default)(this, "selection", void 0);
    /**
     * Instance of {@link EventManager}.
     *
     * @private
     * @type {EventManager}
     */
    (0, _defineProperty2.default)(this, "eventManager", void 0);
    /**
     * Determines if EditorManager is destroyed.
     *
     * @private
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "destroyed", false);
    /**
     * A reference to an instance of the activeEditor.
     *
     * @private
     * @type {BaseEditor}
     */
    (0, _defineProperty2.default)(this, "activeEditor", void 0);
    /**
     * Keeps a reference to the cell's properties object.
     *
     * @type {object}
     */
    (0, _defineProperty2.default)(this, "cellProperties", void 0);
    this.hot = hotInstance;
    this.tableMeta = tableMeta;
    this.selection = _selection;
    this.eventManager = new _eventManager.default(hotInstance);
    this.hot.addHook('afterDocumentKeyDown', event => _assertClassBrand(_EditorManager_brand, this, _onAfterDocumentKeyDown).call(this, event));

    // Open editor when text composition is started (IME editor)
    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'compositionstart', event => {
      if (!this.destroyed && this.hot.isListening()) {
        this.openEditor('', event);
      }
    });
    this.hot.view._wt.update('onCellDblClick', (event, coords, elem) => _assertClassBrand(_EditorManager_brand, this, _onCellDblClick).call(this, event, coords, elem));
  }

  /**
   * Get active editor.
   *
   * @returns {BaseEditor}
   */
  getActiveEditor() {
    return this.activeEditor;
  }

  /**
   * Prepare text input to be displayed at given grid cell.
   */
  prepareEditor() {
    var _this$hot$getSelected;
    if (this.activeEditor && this.activeEditor.isWaiting()) {
      this.closeEditor(false, false, dataSaved => {
        if (dataSaved) {
          this.prepareEditor();
        }
      });
      return;
    }
    const highlight = (_this$hot$getSelected = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected === void 0 ? void 0 : _this$hot$getSelected.highlight;
    if (!highlight || highlight.isHeader()) {
      return;
    }
    const {
      row,
      col
    } = highlight;
    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', row, col, false, 'meta');
    let visualRowToCheck = row;
    let visualColumnToCheck = col;
    if (Array.isArray(modifiedCellCoords)) {
      [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;
    }

    // Getting values using the modified coordinates.
    this.cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);
    if (!this.isCellEditable()) {
      this.clearActiveEditor();
      return;
    }
    const td = this.hot.getCell(row, col, true);

    // Skip the preparation when the cell is not rendered in the DOM. The cell is scrolled out of
    // the table's viewport.
    if (td) {
      const editorClass = this.hot.getCellEditor(this.cellProperties);
      const prop = this.hot.colToProp(visualColumnToCheck);
      const originalValue = this.hot.getSourceDataAtCell(this.hot.toPhysicalRow(visualRowToCheck), visualColumnToCheck);
      this.activeEditor = (0, _registry.getEditorInstance)(editorClass, this.hot);
      // Using not modified coordinates, as we need to get the table element using selection coordinates.
      // There is an extra translation in the editor for saving value.
      this.activeEditor.prepare(row, col, prop, td, originalValue, this.cellProperties);
    }
  }

  /**
   * Check is editor is opened/showed.
   *
   * @returns {boolean}
   */
  isEditorOpened() {
    return this.activeEditor && this.activeEditor.isOpened();
  }

  /**
   * Open editor with initial value.
   *
   * @param {null|string} newInitialValue New value from which editor will start if handled property it's not the `null`.
   * @param {Event} event The event object.
   * @param {boolean} [enableFullEditMode=false] When true, an editor works in full editing mode. Mode disallows closing an editor
   *                                             when arrow keys are pressed.
   */
  openEditor(newInitialValue, event) {
    let enableFullEditMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (!this.isCellEditable()) {
      this.clearActiveEditor();
      return;
    }
    const selection = this.hot.getSelectedRangeLast();
    let allowOpening = this.hot.runHooks('beforeBeginEditing', selection.highlight.row, selection.highlight.col, newInitialValue, event, enableFullEditMode);

    // If the above hook does not return boolean then the default behavior is applied which disallows opening
    // an editor after double mouse click for non-contiguous selection (while pressing Ctrl/Cmd) and
    // for multiple selected cells (while pressing SHIFT).
    if (event instanceof MouseEvent && typeof allowOpening !== 'boolean') {
      allowOpening = this.hot.selection.getLayerLevel() === 0 && selection.isSingle();
    }
    if (allowOpening === false) {
      this.clearActiveEditor();
      return;
    }
    if (!this.activeEditor) {
      this.hot.scrollToFocusedCell();
      this.prepareEditor();
    }
    if (this.activeEditor) {
      if (enableFullEditMode) {
        this.activeEditor.enableFullEditMode();
      }
      this.activeEditor.beginEditing(newInitialValue, event);
    }
  }

  /**
   * Close editor, finish editing cell.
   *
   * @param {boolean} restoreOriginalValue If `true`, then closes editor without saving value from the editor into a cell.
   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.
   * @param {Function} callback The callback function, fired after editor closing.
   */
  closeEditor(restoreOriginalValue, isCtrlPressed, callback) {
    if (this.activeEditor) {
      this.activeEditor.finishEditing(restoreOriginalValue, isCtrlPressed, callback);
    } else if (callback) {
      callback(false);
    }
  }

  /**
   * Close editor and save changes.
   *
   * @param {boolean} isCtrlPressed If `true`, then editor will save value to each cell in the last selected range.
   */
  closeEditorAndSaveChanges(isCtrlPressed) {
    this.closeEditor(false, isCtrlPressed);
  }

  /**
   * Close editor and restore original value.
   *
   * @param {boolean} isCtrlPressed Indication of whether the CTRL button is pressed.
   */
  closeEditorAndRestoreOriginalValue(isCtrlPressed) {
    this.closeEditor(true, isCtrlPressed);
  }

  /**
   * Clears reference to an instance of the active editor.
   *
   * @private
   */
  clearActiveEditor() {
    this.activeEditor = undefined;
  }

  /**
   * Checks if the currently selected cell (pointed by selection highlight coords) is editable.
   * Editable cell is when:
   *   - the cell has defined an editor type;
   *   - the cell is not marked as read-only;
   *   - the cell is not hidden.
   *
   * @private
   * @returns {boolean}
   */
  isCellEditable() {
    const selection = this.hot.getSelectedRangeLast();
    if (!selection) {
      return false;
    }
    const editorClass = this.hot.getCellEditor(this.cellProperties);
    const {
      row,
      col
    } = selection.highlight;
    const {
      rowIndexMapper,
      columnIndexMapper
    } = this.hot;
    const isCellHidden = rowIndexMapper.isHidden(this.hot.toPhysicalRow(row)) || columnIndexMapper.isHidden(this.hot.toPhysicalColumn(col));
    if (this.cellProperties.readOnly || !editorClass || isCellHidden) {
      return false;
    }
    return true;
  }

  /**
   * Controls selection's behavior after clicking `Enter`.
   *
   * @private
   * @param {KeyboardEvent} event The keyboard event object.
   */
  moveSelectionAfterEnter(event) {
    const enterMoves = {
      ...(typeof this.tableMeta.enterMoves === 'function' ? this.tableMeta.enterMoves(event) : this.tableMeta.enterMoves)
    };
    if (event.shiftKey) {
      enterMoves.row = -enterMoves.row;
      enterMoves.col = -enterMoves.col;
    }
    if (this.hot.selection.isMultiple()) {
      this.selection.transformFocus(enterMoves.row, enterMoves.col);
    } else {
      this.selection.transformStart(enterMoves.row, enterMoves.col, true);
    }
  }
  /**
   * Destroy the instance.
   */
  destroy() {
    this.destroyed = true;
    this.eventManager.destroy();
  }
}
function _onAfterDocumentKeyDown(event) {
  const selection = this.hot.getSelectedRangeLast();
  if (!this.hot.isListening() || !selection || selection.highlight.isHeader() || (0, _event.isImmediatePropagationStopped)(event)) {
    return;
  }
  const {
    keyCode
  } = event;

  // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
  const isCtrlPressed = (event.ctrlKey || event.metaKey) && !event.altKey;
  if (!this.activeEditor || this.activeEditor && !this.activeEditor.isWaiting()) {
    if (!(0, _unicode.isFunctionKey)(keyCode) && !(0, _unicode.isCtrlMetaKey)(keyCode) && !isCtrlPressed && !this.isEditorOpened()) {
      this.openEditor('', event);
    }
  }
}
/**
 * OnCellDblClick callback.
 *
 * @param {MouseEvent} event The mouse event object.
 * @param {object} coords The cell coordinates.
 */
function _onCellDblClick(event, coords) {
  if (coords.isCell()) {
    this.openEditor(null, event, true);
  }
}
const instances = new WeakMap();

/**
 * @param {Core} hotInstance The Handsontable instance.
 * @param {TableMeta} tableMeta The table meta class instance.
 * @param {Selection} selection The selection instance.
 * @returns {EditorManager}
 */
EditorManager.getInstance = function (hotInstance, tableMeta, selection) {
  let editorManager = instances.get(hotInstance);
  if (!editorManager) {
    editorManager = new EditorManager(hotInstance, tableMeta, selection);
    instances.set(hotInstance, editorManager);
  }
  return editorManager;
};
var _default = exports["default"] = EditorManager;

/***/ }),
/* 504 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPropertyKey = __webpack_require__(505);
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 505 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(506)["default"]);
var toPrimitive = __webpack_require__(507);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 506 */
/***/ ((module) => {

function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 507 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(506)["default"]);
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 508 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.isCtrlKey = isCtrlKey;
exports.isCtrlMetaKey = isCtrlMetaKey;
exports.isFunctionKey = isFunctionKey;
exports.isKey = isKey;
exports.isPrintableChar = isPrintableChar;
__webpack_require__(283);
var _array = __webpack_require__(495);
var _browser = __webpack_require__(498);
const KEY_CODES = exports.KEY_CODES = {
  ALT: 18,
  ARROW_DOWN: 40,
  ARROW_LEFT: 37,
  ARROW_RIGHT: 39,
  ARROW_UP: 38,
  AUDIO_DOWN: (0, _browser.isFirefox)() ? 182 : 174,
  AUDIO_MUTE: (0, _browser.isFirefox)() ? 181 : 173,
  AUDIO_UP: (0, _browser.isFirefox)() ? 183 : 175,
  BACKSPACE: 8,
  CAPS_LOCK: 20,
  COMMA: 188,
  COMMAND_LEFT: 91,
  COMMAND_RIGHT: 93,
  COMMAND_FIREFOX: 224,
  CONTROL: 17,
  DELETE: 46,
  END: 35,
  ENTER: 13,
  ESCAPE: 27,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  F13: 124,
  F14: 125,
  F15: 126,
  F16: 127,
  F17: 128,
  F18: 129,
  F19: 130,
  HOME: 36,
  INSERT: 45,
  MEDIA_NEXT: 176,
  MEDIA_PLAY_PAUSE: 179,
  MEDIA_PREV: 177,
  MEDIA_STOP: 178,
  NULL: 0,
  NUM_LOCK: 144,
  PAGE_DOWN: 34,
  PAGE_UP: 33,
  PAUSE: 19,
  PERIOD: 190,
  SCROLL_LOCK: 145,
  SHIFT: 16,
  SPACE: 32,
  TAB: 9,
  A: 65,
  C: 67,
  D: 68,
  F: 70,
  L: 76,
  O: 79,
  P: 80,
  S: 83,
  V: 86,
  X: 88,
  Y: 89,
  Z: 90
};
const FUNCTION_KEYS = [KEY_CODES.ALT, KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_UP, KEY_CODES.AUDIO_DOWN, KEY_CODES.AUDIO_MUTE, KEY_CODES.AUDIO_UP, KEY_CODES.BACKSPACE, KEY_CODES.CAPS_LOCK, KEY_CODES.DELETE, KEY_CODES.END, KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.F13, KEY_CODES.F14, KEY_CODES.F15, KEY_CODES.F16, KEY_CODES.F17, KEY_CODES.F18, KEY_CODES.F19, KEY_CODES.HOME, KEY_CODES.INSERT, KEY_CODES.MEDIA_NEXT, KEY_CODES.MEDIA_PLAY_PAUSE, KEY_CODES.MEDIA_PREV, KEY_CODES.MEDIA_STOP, KEY_CODES.NULL, KEY_CODES.NUM_LOCK, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, KEY_CODES.PAUSE, KEY_CODES.SCROLL_LOCK, KEY_CODES.SHIFT, KEY_CODES.TAB];

/**
 * Returns true if keyCode represents a printable character.
 *
 * @param {number} keyCode The keyboard key code.
 * @returns {boolean}
 */
function isPrintableChar(keyCode) {
  return keyCode === 32 ||
  // space
  keyCode >= 48 && keyCode <= 57 ||
  // 0-9
  keyCode >= 96 && keyCode <= 111 ||
  // numpad
  keyCode >= 186 && keyCode <= 192 ||
  // ;=,-./`
  keyCode >= 219 && keyCode <= 222 ||
  // []{}\|"'
  keyCode >= 226 ||
  // special chars (229 for Asian chars)
  keyCode >= 65 && keyCode <= 90; // a-z
}

/**
 * @param {number} keyCode The keyboard key code.
 * @returns {boolean}
 */
function isFunctionKey(keyCode) {
  return FUNCTION_KEYS.includes(keyCode);
}

/**
 * Checks if passed key code is ctrl or cmd key. Depends on what OS the code runs it check key code based on
 * different meta key codes.
 *
 * @param {number} keyCode The keyboard key code.
 * @returns {boolean}
 */
function isCtrlKey(keyCode) {
  const keys = [];
  if ((0, _browser.isMacOS)()) {
    keys.push(KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX);
  } else {
    keys.push(KEY_CODES.CONTROL);
  }
  return keys.includes(keyCode);
}

/**
 * Checks if passed key code is ctrl or cmd key. This helper checks if the key code matches to meta keys
 * regardless of the OS on which it is running.
 *
 * @param {number} keyCode The keyboard key code.
 * @returns {boolean}
 */
function isCtrlMetaKey(keyCode) {
  return [KEY_CODES.CONTROL, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT, KEY_CODES.COMMAND_FIREFOX].includes(keyCode);
}

/**
 * @param {number} keyCode The keyboard key code.
 * @param {string} baseCode The list of the key codes to compare with.
 * @returns {boolean}
 */
function isKey(keyCode, baseCode) {
  const keys = baseCode.split('|');
  let result = false;
  (0, _array.arrayEach)(keys, key => {
    if (keyCode === KEY_CODES[key]) {
      result = true;
      return false;
    }
  });
  return result;
}

/***/ }),
/* 509 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.isImmediatePropagationStopped = isImmediatePropagationStopped;
exports.isLeftClick = isLeftClick;
exports.isRightClick = isRightClick;
exports.isTouchEvent = isTouchEvent;
exports.offsetRelativeTo = offsetRelativeTo;
exports.stopImmediatePropagation = stopImmediatePropagation;
/**
 * Prevent other listeners of the same event from being called.
 *
 * @param {Event} event The mouse event object.
 */
function stopImmediatePropagation(event) {
  event.isImmediatePropagationEnabled = false;
  event.cancelBubble = true;
}

/**
 * Check if event was stopped by `stopImmediatePropagation`.
 *
 * @param {Event} event The mouse event object.
 * @returns {boolean}
 */
function isImmediatePropagationStopped(event) {
  return event.isImmediatePropagationEnabled === false;
}

/**
 * Check if provided event was triggered by clicking the right mouse button.
 *
 * @param {Event} event The mouse event object.
 * @returns {boolean}
 */
function isRightClick(event) {
  return event.button === 2;
}

/**
 * Check if provided event was triggered by clicking the left mouse button.
 *
 * @param {Event} event The mouse event object.
 * @returns {boolean}
 */
function isLeftClick(event) {
  return event.button === 0;
}

/**
 * Check if the provided event is a touch event.
 *
 * @param {Event} event The event object.
 * @returns {boolean}
 */
function isTouchEvent(event) {
  return event instanceof TouchEvent;
}

/**
 * Calculates the event offset until reaching the element defined by `relativeElement` argument.
 *
 * @param {Event} event The mouse event object.
 * @param {HTMLElement|undefined} [untilElement] The element to which the offset will be calculated.
 * @returns {{ x: number, y: number }}
 */
function offsetRelativeTo(event, untilElement) {
  const offset = {
    x: event.offsetX,
    y: event.offsetY
  };
  let element = event.target;
  if (!(untilElement instanceof HTMLElement) || element !== untilElement && element.contains(untilElement)) {
    return offset;
  }
  while (element !== untilElement) {
    offset.x += element.offsetLeft;
    offset.y += element.offsetTop;
    element = element.offsetParent;
  }
  return offset;
}

/***/ }),
/* 510 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.RegisteredEditor = RegisteredEditor;
exports.getEditorInstance = exports._getEditorInstance = _getEditorInstance;
exports.getEditor = _getItem;
exports.registerEditor = _register;
__webpack_require__(201);
var _hooks = __webpack_require__(511);
var _staticRegister = _interopRequireDefault(__webpack_require__(521));
/**
 * Utility to register editors and common namespace for keeping reference to all editor classes.
 */

const registeredEditorClasses = new WeakMap();
const {
  register,
  getItem,
  hasItem,
  getNames,
  getValues
} = (0, _staticRegister.default)('editors');

/**
 * @param {BaseEditor} editorClass The editor constructor.
 */
exports.getRegisteredEditors = getValues;
exports.getRegisteredEditorNames = getNames;
exports.hasEditor = hasItem;
function RegisteredEditor(editorClass) {
  const instances = {};
  const Clazz = editorClass;
  this.getConstructor = function () {
    return editorClass;
  };
  this.getInstance = function (hotInstance) {
    if (!(hotInstance.guid in instances)) {
      instances[hotInstance.guid] = new Clazz(hotInstance);
    }
    return instances[hotInstance.guid];
  };
  _hooks.Hooks.getSingleton().add('afterDestroy', function () {
    instances[this.guid] = null;
  });
}

/**
 * Returns instance (singleton) of editor class.
 *
 * @param {string} name Name of an editor under which it has been stored.
 * @param {object} hotInstance Instance of Handsontable.
 * @returns {Function} Returns instance of editor.
 */
function _getEditorInstance(name, hotInstance) {
  let editor;
  if (typeof name === 'function') {
    if (!registeredEditorClasses.get(name)) {
      _register(null, name);
    }
    editor = registeredEditorClasses.get(name);
  } else if (typeof name === 'string') {
    editor = getItem(name);
  } else {
    throw Error('Only strings and functions can be passed as "editor" parameter');
  }
  if (!editor) {
    throw Error(`No editor registered under name "${name}"`);
  }
  return editor.getInstance(hotInstance);
}

/**
 * Retrieve editor class.
 *
 * @param {string} name Editor identification.
 * @returns {Function} Returns editor class.
 */
function _getItem(name) {
  if (typeof name === 'function') {
    return name;
  }
  if (!hasItem(name)) {
    throw Error(`No registered editor found under "${name}" name`);
  }
  return getItem(name).getConstructor();
}

/**
 * Register editor class under specified name.
 *
 * @param {string} name Editor identification.
 * @param {Function} editorClass Editor class.
 */
function _register(name, editorClass) {
  if (name && typeof name !== 'string') {
    editorClass = name;
    name = editorClass.EDITOR_TYPE;
  }
  const editorWrapper = new RegisteredEditor(editorClass);
  if (typeof name === 'string') {
    register(name, editorWrapper);
  }
  registeredEditorClasses.set(editorClass, editorWrapper);
}

/***/ }),
/* 511 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _array = __webpack_require__(495);
var _string = __webpack_require__(352);
var _console = __webpack_require__(512);
var _templateLiteralTag = __webpack_require__(494);
var _function = __webpack_require__(497);
var _constants = __webpack_require__(513);
var _bucket = __webpack_require__(514);
/**
 * Template warning message for removed hooks.
 *
 * @type {string}
 */
const REMOVED_MESSAGE = (0, _templateLiteralTag.toSingleLine)`The plugin hook "[hookName]" was removed in Handsontable [removedInVersion].\x20
  Please consult release notes https://github.com/handsontable/handsontable/releases/tag/[removedInVersion] to\x20
  learn about the migration path.`;
class Hooks {
  constructor() {
    /**
     * @type {HooksBucket}
     */
    (0, _defineProperty2.default)(this, "globalBucket", new _bucket.HooksBucket());
  }
  static getSingleton() {
    return getGlobalSingleton();
  }
  /**
   * Get hook bucket based on the context of the object or if argument is missing, get the global hook bucket.
   *
   * @param {object} [context=null] A Handsontable instance.
   * @returns {HooksBucket} Returns a global or Handsontable instance bucket.
   */
  getBucket() {
    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    if (context) {
      if (!context.pluginHookBucket) {
        context.pluginHookBucket = new _bucket.HooksBucket();
      }
      return context.pluginHookBucket;
    }
    return this.globalBucket;
  }

  /**
   * Adds a listener (globally or locally) to a specified hook name.
   * If the `context` parameter is provided, the hook will be added only to the instance it references.
   * Otherwise, the callback will be used every time the hook fires on any Handsontable instance.
   * You can provide an array of callback functions as the `callback` argument, this way they will all be fired
   * once the hook is triggered.
   *
   * @param {string} key Hook name.
   * @param {Function|Function[]} callback Callback function or an array of functions.
   * @param {object} [context=null] The context for the hook callback to be added - a Handsontable instance or leave empty.
   * @param {number} [orderIndex] Order index of the callback.
   *                              If > 0, the callback will be added after the others, for example, with an index of 1, the callback will be added before the ones with an index of 2, 3, etc., but after the ones with an index of 0 and lower.
   *                              If < 0, the callback will be added before the others, for example, with an index of -1, the callback will be added after the ones with an index of -2, -3, etc., but before the ones with an index of 0 and higher.
   *                              If 0 or no order index is provided, the callback will be added between the "negative" and "positive" indexes.
   * @returns {Hooks} Instance of Hooks.
   *
   * @example
   * ```js
   * // single callback, added locally
   * Handsontable.hooks.add('beforeInit', myCallback, hotInstance);
   *
   * // single callback, added globally
   * Handsontable.hooks.add('beforeInit', myCallback);
   *
   * // multiple callbacks, added locally
   * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback], hotInstance);
   *
   * // multiple callbacks, added globally
   * Handsontable.hooks.add('beforeInit', [myCallback, anotherCallback]);
   * ```
   */
  add(key, callback) {
    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let orderIndex = arguments.length > 3 ? arguments[3] : undefined;
    if (Array.isArray(callback)) {
      (0, _array.arrayEach)(callback, c => this.add(key, c, context));
    } else {
      if (_constants.REMOVED_HOOKS.has(key)) {
        (0, _console.warn)((0, _string.substitute)(REMOVED_MESSAGE, {
          hookName: key,
          removedInVersion: _constants.REMOVED_HOOKS.get(key)
        }));
      }
      if (_constants.DEPRECATED_HOOKS.has(key)) {
        (0, _console.warn)(_constants.DEPRECATED_HOOKS.get(key));
      }
      this.getBucket(context).add(key, callback, {
        orderIndex,
        runOnce: false
      });
    }
    return this;
  }

  /**
   * Adds a listener to a specified hook. After the hook runs this listener will be automatically removed from the bucket.
   *
   * @param {string} key Hook/Event name.
   * @param {Function|Function[]} callback Callback function.
   * @param {object} [context=null] A Handsontable instance.
   * @param {number} [orderIndex] Order index of the callback.
   *                              If > 0, the callback will be added after the others, for example, with an index of 1, the callback will be added before the ones with an index of 2, 3, etc., but after the ones with an index of 0 and lower.
   *                              If < 0, the callback will be added before the others, for example, with an index of -1, the callback will be added after the ones with an index of -2, -3, etc., but before the ones with an index of 0 and higher.
   *                              If 0 or no order index is provided, the callback will be added between the "negative" and "positive" indexes.
   * @returns {Hooks} Instance of Hooks.
   *
   * @example
   * ```js
   * Handsontable.hooks.once('beforeInit', myCallback, hotInstance);
   * ```
   */
  once(key, callback) {
    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let orderIndex = arguments.length > 3 ? arguments[3] : undefined;
    if (Array.isArray(callback)) {
      (0, _array.arrayEach)(callback, c => this.once(key, c, context));
    } else {
      this.getBucket(context).add(key, callback, {
        orderIndex,
        runOnce: true
      });
    }
    return this;
  }

  /**
   * Adds a listener to a specified hook. The added hook stays in the bucket at specified index position even after
   * adding another one with the same hook name.
   *
   * @param {string} key Hook/Event name.
   * @param {Function|Function[]} callback Callback function.
   * @param {object} [context=null] A Handsontable instance.
   * @returns {Hooks} Instance of Hooks.
   *
   * @example
   * ```js
   * Handsontable.hooks.addAsFixed('beforeInit', myCallback, hotInstance);
   * ```
   */
  addAsFixed(key, callback) {
    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (Array.isArray(callback)) {
      (0, _array.arrayEach)(callback, c => this.addAsFixed(key, c, context));
    } else {
      this.getBucket(context).add(key, callback, {
        initialHook: true
      });
    }
    return this;
  }

  /**
   * Removes a listener from a hook with a given name. If the `context` argument is provided, it removes a listener from a local hook assigned to the given Handsontable instance.
   *
   * @param {string} key Hook/Event name.
   * @param {Function} callback Callback function (needs the be the function that was previously added to the hook).
   * @param {object} [context=null] Handsontable instance.
   * @returns {boolean} Returns `true` if hook was removed, `false` otherwise.
   *
   * @example
   * ```js
   * Handsontable.hooks.remove('beforeInit', myCallback);
   * ```
   */
  remove(key, callback) {
    let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return this.getBucket(context).remove(key, callback);
  }

  /**
   * Checks whether there are any registered listeners for the provided hook name.
   * If the `context` parameter is provided, it only checks for listeners assigned to the given Handsontable instance.
   *
   * @param {string} key Hook name.
   * @param {object} [context=null] A Handsontable instance.
   * @returns {boolean} `true` for success, `false` otherwise.
   */
  has(key) {
    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return this.getBucket(context).has(key);
  }

  /**
   * Runs all local and global callbacks assigned to the hook identified by the `key` parameter.
   * It returns either a return value from the last called callback or the first parameter (`p1`) passed to the `run` function.
   *
   * @param {object} context Handsontable instance.
   * @param {string} key Hook/Event name.
   * @param {*} [p1] Parameter to be passed as an argument to the callback function.
   * @param {*} [p2] Parameter to be passed as an argument to the callback function.
   * @param {*} [p3] Parameter to be passed as an argument to the callback function.
   * @param {*} [p4] Parameter to be passed as an argument to the callback function.
   * @param {*} [p5] Parameter to be passed as an argument to the callback function.
   * @param {*} [p6] Parameter to be passed as an argument to the callback function.
   * @returns {*} Either a return value from the last called callback or `p1`.
   *
   * @example
   * ```js
   * Handsontable.hooks.run(hot, 'beforeInit');
   * ```
   */
  run(context, key, p1, p2, p3, p4, p5, p6) {
    {
      const globalHandlers = this.getBucket().getHooks(key);
      const length = globalHandlers ? globalHandlers.length : 0;
      let index = 0;
      if (length) {
        // Do not optimize this loop with arrayEach or arrow function! If you do You'll decrease perf because of GC.
        while (index < length) {
          if (!globalHandlers[index] || globalHandlers[index].skip) {
            index += 1;
            /* eslint-disable no-continue */
            continue;
          }
          const res = (0, _function.fastCall)(globalHandlers[index].callback, context, p1, p2, p3, p4, p5, p6);
          if (res !== undefined) {
            // eslint-disable-next-line no-param-reassign
            p1 = res;
          }
          if (globalHandlers[index] && globalHandlers[index].runOnce) {
            this.remove(key, globalHandlers[index].callback);
          }
          index += 1;
        }
      }
    }
    {
      const localHandlers = this.getBucket(context).getHooks(key);
      const length = localHandlers ? localHandlers.length : 0;
      let index = 0;
      if (length) {
        // Do not optimize this loop with arrayEach or arrow function! If you do You'll decrease perf because of GC.
        while (index < length) {
          if (!localHandlers[index] || localHandlers[index].skip) {
            index += 1;
            /* eslint-disable no-continue */
            continue;
          }
          const res = (0, _function.fastCall)(localHandlers[index].callback, context, p1, p2, p3, p4, p5, p6);
          if (res !== undefined) {
            // eslint-disable-next-line no-param-reassign
            p1 = res;
          }
          if (localHandlers[index] && localHandlers[index].runOnce) {
            this.remove(key, localHandlers[index].callback, context);
          }
          index += 1;
        }
      }
    }
    return p1;
  }

  /**
   * Destroy all listeners connected to the context. If no context is provided, the global listeners will be destroyed.
   *
   * @param {object} [context=null] A Handsontable instance.
   * @example
   * ```js
   * // destroy the global listeners
   * Handsontable.hooks.destroy();
   *
   * // destroy the local listeners
   * Handsontable.hooks.destroy(hotInstance);
   * ```
   */
  destroy() {
    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    this.getBucket(context).destroy();
  }

  /**
   * Registers a hook name (adds it to the list of the known hook names). Used by plugins.
   * It is not necessary to call register, but if you use it, your plugin hook will be used returned by
   * the `getRegistered` method. (which itself is used in the [demo](@/guides/getting-started/events-and-hooks/events-and-hooks.md)).
   *
   * @param {string} key The hook name.
   *
   * @example
   * ```js
   * Handsontable.hooks.register('myHook');
   * ```
   */
  register(key) {
    if (!this.isRegistered(key)) {
      _constants.REGISTERED_HOOKS.push(key);
    }
  }

  /**
   * Deregisters a hook name (removes it from the list of known hook names).
   *
   * @param {string} key The hook name.
   *
   * @example
   * ```js
   * Handsontable.hooks.deregister('myHook');
   * ```
   */
  deregister(key) {
    if (this.isRegistered(key)) {
      _constants.REGISTERED_HOOKS.splice(_constants.REGISTERED_HOOKS.indexOf(key), 1);
    }
  }

  /**
   * Returns a boolean value depending on if a hook by such name has been removed or deprecated.
   *
   * @param {string} hookName The hook name to check.
   * @returns {boolean} Returns `true` if the provided hook name was marked as deprecated or
   * removed from API, `false` otherwise.
   * @example
   * ```js
   * Handsontable.hooks.isDeprecated('skipLengthCache');
   *
   * // Results:
   * true
   * ```
   */
  isDeprecated(hookName) {
    return _constants.DEPRECATED_HOOKS.has(hookName) || _constants.REMOVED_HOOKS.has(hookName);
  }

  /**
   * Returns a boolean depending on if a hook by such name has been registered.
   *
   * @param {string} hookName The hook name to check.
   * @returns {boolean} `true` for success, `false` otherwise.
   * @example
   * ```js
   * Handsontable.hooks.isRegistered('beforeInit');
   *
   * // Results:
   * true
   * ```
   */
  isRegistered(hookName) {
    return _constants.REGISTERED_HOOKS.indexOf(hookName) >= 0;
  }

  /**
   * Returns an array of registered hooks.
   *
   * @returns {Array} An array of registered hooks.
   *
   * @example
   * ```js
   * Handsontable.hooks.getRegistered();
   *
   * // Results:
   * [
   * ...
   *   'beforeInit',
   *   'beforeRender',
   *   'beforeSetRangeEnd',
   *   'beforeDrawBorders',
   *   'beforeChange',
   * ...
   * ]
   * ```
   */
  getRegistered() {
    return _constants.REGISTERED_HOOKS;
  }
}
exports.Hooks = Hooks;
const globalSingleton = new Hooks();

/**
 * @returns {Hooks}
 */
function getGlobalSingleton() {
  return globalSingleton;
}
var _default = exports["default"] = Hooks;

/***/ }),
/* 512 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.error = error;
exports.info = info;
exports.log = log;
exports.warn = warn;
var _mixed = __webpack_require__(354);
/* eslint-disable no-console */
/* eslint-disable no-restricted-globals */

/**
 * "In Internet Explorer 9 (and 8), the console object is only exposed when the developer tools are opened
 * for a particular tab.".
 *
 * Source: https://stackoverflow.com/a/5473193.
 */

/**
 * Logs message to the console if the `console` object is exposed.
 *
 * @param {...*} args Values which will be logged.
 */
function log() {
  if ((0, _mixed.isDefined)(console)) {
    console.log(...arguments);
  }
}

/**
 * Logs warn to the console if the `console` object is exposed.
 *
 * @param {...*} args Values which will be logged.
 */
function warn() {
  if ((0, _mixed.isDefined)(console)) {
    console.warn(...arguments);
  }
}

/**
 * Logs info to the console if the `console` object is exposed.
 *
 * @param {...*} args Values which will be logged.
 */
function info() {
  if ((0, _mixed.isDefined)(console)) {
    console.info(...arguments);
  }
}

/**
 * Logs error to the console if the `console` object is exposed.
 *
 * @param {...*} args Values which will be logged.
 */
function error() {
  if ((0, _mixed.isDefined)(console)) {
    console.error(...arguments);
  }
}

/***/ }),
/* 513 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * @description
 *
 * ::: only-for javascript
 * Handsontable events are the common interface that function in 2 ways: as __callbacks__ and as __hooks__.
 * :::
 *
 * ::: only-for react
 * This page lists all the **Handsontable hooks** – callbacks that let you react before or after an action occurs.
 *
 * Read more on the [Events and hooks](@/guides/getting-started/events-and-hooks/events-and-hooks.md) page.
 * :::
 *
 * @example
 *
 * ::: only-for javascript
 * ```js
 * // using events as callbacks
 * ...
 * const hot1 = new Handsontable(document.getElementById('example1'), {
 *   afterChange: function(changes, source) {
 *     $.ajax({
 *       url: "save.php',
 *       data: change
 *     });
 *   }
 * });
 * ...
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * <HotTable
 *   afterChange={(changes, source) => {
 *     fetch('save.php', {
 *       method: 'POST',
 *       headers: {
 *         'Accept': 'application/json',
 *         'Content-Type': 'application/json'
 *       },
 *       body: JSON.stringify(changes)
 *     });
 *   }}
 * />
 * :::
 *
 * ::: only-for javascript
 * ```js
 * // using events as plugin hooks
 * ...
 * const hot1 = new Handsontable(document.getElementById('example1'), {
 *   myPlugin: true
 * });
 *
 * const hot2 = new Handsontable(document.getElementById('example2'), {
 *   myPlugin: false
 * });
 *
 * // global hook
 * Handsontable.hooks.add('afterChange', function() {
 *   // Fired twice - for hot1 and hot2
 *   if (this.getSettings().myPlugin) {
 *     // function body - will only run for hot1
 *   }
 * });
 *
 * // local hook (has same effect as a callback)
 * hot2.addHook('afterChange', function() {
 *   // function body - will only run in #example2
 * });
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * const hotRef1 = useRef(null);
 * const hotRef2 = useRef(null);
 *
 * // Using events as plugin hooks:
 * ...
 *
 * <HotTable
 *   ref={hotRef1}
 *   myPlugin={true}
 * });
 *
 * <HotTable
 *   ref={hotRef2}
 *   myPlugin={false}
 * });
 *
 * ...
 *
 * const hot2 = hotRef2.current.hotInstance;
 * // local hook (has same effect as a callback)
 * hot2.addHook('afterChange', function() {
 *   // function body - will only run in #example2
 * });
 *
 * // global hook
 * Handsontable.hooks.add('afterChange', function() {
 *   // Fired twice - for hot1 and hot2
 *   if (this.getSettings().myPlugin) {
 *     // function body - will only run for first instance
 *   }
 * });
 * :::
 * ...
 */

const REGISTERED_HOOKS = exports.REGISTERED_HOOKS = [/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * Fired after resetting a cell's meta. This happens when the {@link Core#updateSettings} method is called.
 *
 * @event Hooks#afterCellMetaReset
 */
'afterCellMetaReset',
/**
 * Fired after one or more cells has been changed. The changes are triggered in any situation when the
 * value is entered using an editor or changed using API (e.q [`setDataAtCell`](@/api/core.md#setdataatcell) method).
 *
 * __Note:__ For performance reasons, the `changes` array is null for `"loadData"` source.
 *
 * @event Hooks#afterChange
 * @param {Array[]} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row index.
 * @param {string} [source] String that identifies source of hook call ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 * @example
 * ::: only-for javascript
 * ```js
 * new Handsontable(element, {
 *   afterChange: (changes) => {
 *     changes?.forEach(([row, prop, oldValue, newValue]) => {
 *       // Some logic...
 *     });
 *   }
 * })
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * <HotTable
 *   afterChange={(changes, source) => {
 *     changes?.forEach(([row, prop, oldValue, newValue]) => {
 *       // Some logic...
 *     });
 *   }}
 * />
 * ```
 * :::
 */
'afterChange',
/**
 * Fired each time user opens {@link ContextMenu} and after setting up the Context Menu's default options. These options are a collection
 * which user can select by setting an array of keys or an array of objects in {@link Options#contextMenu} option.
 *
 * @event Hooks#afterContextMenuDefaultOptions
 * @param {Array} predefinedItems An array of objects containing information about the pre-defined Context Menu items.
 */
'afterContextMenuDefaultOptions',
/**
 * Fired each time user opens {@link ContextMenu} plugin before setting up the Context Menu's items but after filtering these options by
 * user ([`contextMenu`](@/api/options.md#contextmenu) option). This hook can by helpful to determine if user use specified menu item or to set up
 * one of the menu item to by always visible.
 *
 * @event Hooks#beforeContextMenuSetItems
 * @param {object[]} menuItems An array of objects containing information about to generated Context Menu items.
 */
'beforeContextMenuSetItems',
/**
 * Fired by {@link DropdownMenu} plugin after setting up the Dropdown Menu's default options. These options are a
 * collection which user can select by setting an array of keys or an array of objects in {@link Options#dropdownMenu}
 * option.
 *
 * @event Hooks#afterDropdownMenuDefaultOptions
 * @param {object[]} predefinedItems An array of objects containing information about the pre-defined Context Menu items.
 */
'afterDropdownMenuDefaultOptions',
/**
 * Fired by {@link DropdownMenu} plugin before setting up the Dropdown Menu's items but after filtering these options
 * by user ([`dropdownMenu`](@/api/options.md#dropdownmenu) option). This hook can by helpful to determine if user use specified menu item or to set
 * up one of the menu item to by always visible.
 *
 * @event Hooks#beforeDropdownMenuSetItems
 * @param {object[]} menuItems An array of objects containing information about to generated Dropdown Menu items.
 */
'beforeDropdownMenuSetItems',
/**
 * Fired by {@link ContextMenu} plugin after hiding the Context Menu. This hook is fired when {@link Options#contextMenu}
 * option is enabled.
 *
 * @event Hooks#afterContextMenuHide
 * @param {object} context The Context Menu plugin instance.
 */
'afterContextMenuHide',
/**
 * Fired by {@link ContextMenu} plugin before opening the Context Menu. This hook is fired when {@link Options#contextMenu}
 * option is enabled.
 *
 * @event Hooks#beforeContextMenuShow
 * @param {object} context The Context Menu instance.
 */
'beforeContextMenuShow',
/**
 * Fired by {@link ContextMenu} plugin after opening the Context Menu. This hook is fired when {@link Options#contextMenu}
 * option is enabled.
 *
 * @event Hooks#afterContextMenuShow
 * @param {object} context The Context Menu plugin instance.
 */
'afterContextMenuShow',
/**
 * Fired by {@link CopyPaste} plugin after reaching the copy limit while copying data. This hook is fired when
 * {@link Options#copyPaste} option is enabled.
 *
 * @event Hooks#afterCopyLimit
 * @param {number} selectedRows Count of selected copyable rows.
 * @param {number} selectedColumns Count of selected copyable columns.
 * @param {number} copyRowsLimit Current copy rows limit.
 * @param {number} copyColumnsLimit Current copy columns limit.
 */
'afterCopyLimit',
/**
 * Fired before created a new column.
 *
 * @event Hooks#beforeCreateCol
 * @param {number} index Represents the visual index of first newly created column in the data source array.
 * @param {number} amount Number of newly created columns in the data source array.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 * @returns {*} If `false` then creating columns is cancelled.
 * @example
 * ::: only-for javascript
 * ```js
 * // Return `false` to cancel column inserting.
 * new Handsontable(element, {
 *   beforeCreateCol: function(data, coords) {
 *     return false;
 *   }
 * });
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * // Return `false` to cancel column inserting.
 * <HotTable
 *   beforeCreateCol={(data, coords) => {
 *     return false;
 *   }}
 * />
 * ```
 * :::
 */
'beforeCreateCol',
/**
 * Fired after the order of columns has changed.
 * This hook is fired by changing column indexes of any type supported by the {@link IndexMapper}.
 *
 * @event Hooks#afterColumnSequenceChange
 * @param {'init'|'remove'|'insert'|'move'|'update'} [source] A string that indicates what caused the change to the order of columns.
 */
'afterColumnSequenceChange',
/**
 * Fired after created a new column.
 *
 * @event Hooks#afterCreateCol
 * @param {number} index Represents the visual index of first newly created column in the data source.
 * @param {number} amount Number of newly created columns in the data source.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 */
'afterCreateCol',
/**
 * Fired before created a new row.
 *
 * @event Hooks#beforeCreateRow
 * @param {number} index Represents the visual index of first newly created row in the data source array.
 * @param {number} amount Number of newly created rows in the data source array.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 * @returns {*|boolean} If false is returned the action is canceled.
 */
'beforeCreateRow',
/**
 * Fired after created a new row.
 *
 * @event Hooks#afterCreateRow
 * @param {number} index Represents the visual index of first newly created row in the data source array.
 * @param {number} amount Number of newly created rows in the data source array.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 */
'afterCreateRow',
/**
 * Fired after all selected cells are deselected.
 *
 * @event Hooks#afterDeselect
 */
'afterDeselect',
/**
 * Fired after destroying the Handsontable instance.
 *
 * @event Hooks#afterDestroy
 */
'afterDestroy',
/**
 * Hook fired after `keydown` event is handled.
 *
 * @event Hooks#afterDocumentKeyDown
 * @param {Event} event A native `keydown` event object.
 */
'afterDocumentKeyDown',
/**
 * Fired inside the Walkontable's selection `draw` method. Can be used to add additional class names to cells, depending on the current selection.
 *
 * @event Hooks#afterDrawSelection
 * @param {number} currentRow Row index of the currently processed cell.
 * @param {number} currentColumn Column index of the currently cell.
 * @param {number[]} cornersOfSelection Array of the current selection in a form of `[startRow, startColumn, endRow, endColumn]`.
 * @param {number|undefined} layerLevel Number indicating which layer of selection is currently processed.
 * @since 0.38.1
 * @returns {string|undefined} Can return a `String`, which will act as an additional `className` to be added to the currently processed cell.
 */
'afterDrawSelection',
/**
 * Fired inside the Walkontable's `refreshSelections` method. Can be used to remove additional class names from all cells in the table.
 *
 * @event Hooks#beforeRemoveCellClassNames
 * @since 0.38.1
 * @returns {string[]|undefined} Can return an `Array` of `String`s. Each of these strings will act like class names to be removed from all the cells in the table.
 */
'beforeRemoveCellClassNames',
/**
 * Fired after getting the cell settings.
 *
 * @event Hooks#afterGetCellMeta
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {object} cellProperties Object containing the cell properties.
 */
'afterGetCellMeta',
/**
 * Fired after retrieving information about a column header and appending it to the table header.
 *
 * @event Hooks#afterGetColHeader
 * @param {number} column Visual column index.
 * @param {HTMLTableCellElement} TH Header's TH element.
 * @param {number} [headerLevel=0] (Since 12.2.0) Header level index. Accepts positive (0 to n)
 *                                 and negative (-1 to -n) values. For positive values, 0 points to the
 *                                 topmost header. For negative values, -1 points to the bottom-most
 *                                 header (the header closest to the cells).
 */
'afterGetColHeader',
/**
 * Fired after retrieving information about a row header and appending it to the table header.
 *
 * @event Hooks#afterGetRowHeader
 * @param {number} row Visual row index.
 * @param {HTMLTableCellElement} TH Header's TH element.
 */
'afterGetRowHeader',
/**
 * Fired after the Handsontable instance is initiated.
 *
 * @event Hooks#afterInit
 */
'afterInit',
/**
 * Fired after Handsontable's [`data`](@/api/options.md#data)
 * gets modified by the [`loadData()`](@/api/core.md#loaddata) method
 * or the [`updateSettings()`](@/api/core.md#updatesettings) method.
 *
 * Read more:
 * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)
 * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)
 *
 * @event Hooks#afterLoadData
 * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data
 * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
 * @param {string} source The source of the call
 */
'afterLoadData',
/**
 * Fired after the [`updateData()`](@/api/core.md#updatedata) method
 * modifies Handsontable's [`data`](@/api/options.md#data).
 *
 * Read more:
 * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)
 * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)
 *
 * @event Hooks#afterUpdateData
 * @since 11.1.0
 * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data
 * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
 * @param {string} source The source of the call
 */
'afterUpdateData',
/**
 * Fired after a scroll event, which is identified as a momentum scroll (e.g. on an iPad).
 *
 * @event Hooks#afterMomentumScroll
 */
'afterMomentumScroll',
/**
 * Fired after a `mousedown` event is triggered on the cell corner (the drag handle).
 *
 * @event Hooks#afterOnCellCornerMouseDown
 * @param {Event} event `mousedown` event object.
 */
'afterOnCellCornerMouseDown',
/**
 * Fired after a `dblclick` event is triggered on the cell corner (the drag handle).
 *
 * @event Hooks#afterOnCellCornerDblClick
 * @param {Event} event `dblclick` event object.
 */
'afterOnCellCornerDblClick',
/**
 * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate
 * indexes are negative.
 *
 * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseDown` called
 * with coordinates `{row: 0, col: -1}`.
 *
 * @event Hooks#afterOnCellMouseDown
 * @param {Event} event `mousedown` event object.
 * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
 * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
 */
'afterOnCellMouseDown',
/**
 * Fired after clicking on a cell or row/column header. In case the row/column header was clicked, the coordinate
 * indexes are negative.
 *
 * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseUp` called
 * with coordinates `{row: 0, col: -1}`.
 *
 * @event Hooks#afterOnCellMouseUp
 * @param {Event} event `mouseup` event object.
 * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
 * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
 */
'afterOnCellMouseUp',
/**
 * Fired after clicking right mouse button on a cell or row/column header.
 *
 * For example clicking on the row header of cell (0, 0) results with `afterOnCellContextMenu` called
 * with coordinates `{row: 0, col: -1}`.
 *
 * @event Hooks#afterOnCellContextMenu
 * @since 4.1.0
 * @param {Event} event `contextmenu` event object.
 * @param {CellCoords} coords Coordinates object containing the visual row and visual column indexes of the clicked cell.
 * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
 */
'afterOnCellContextMenu',
/**
 * Fired after hovering a cell or row/column header with the mouse cursor. In case the row/column header was
 * hovered, the index is negative.
 *
 * For example, hovering over the row header of cell (0, 0) results with `afterOnCellMouseOver` called
 * with coords `{row: 0, col: -1}`.
 *
 * @event Hooks#afterOnCellMouseOver
 * @param {Event} event `mouseover` event object.
 * @param {CellCoords} coords Hovered cell's visual coordinate object.
 * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
 */
'afterOnCellMouseOver',
/**
 * Fired after leaving a cell or row/column header with the mouse cursor.
 *
 * @event Hooks#afterOnCellMouseOut
 * @param {Event} event `mouseout` event object.
 * @param {CellCoords} coords Leaved cell's visual coordinate object.
 * @param {HTMLTableCellElement} TD Cell's TD (or TH) element.
 */
'afterOnCellMouseOut',
/**
 * Fired after one or more columns are removed.
 *
 * @event Hooks#afterRemoveCol
 * @param {number} index Visual index of starter column.
 * @param {number} amount An amount of removed columns.
 * @param {number[]} physicalColumns An array of physical columns removed from the data source.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 */
'afterRemoveCol',
/**
 * Fired after one or more rows are removed.
 *
 * @event Hooks#afterRemoveRow
 * @param {number} index Visual index of starter row.
 * @param {number} amount An amount of removed rows.
 * @param {number[]} physicalRows An array of physical rows removed from the data source.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 */
'afterRemoveRow',
/**
 * Fired before starting rendering the cell.
 *
 * @event Hooks#beforeRenderer
 * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.
 * @param {*} value Value of the rendered cell.
 * @param {object} cellProperties Object containing the cell's properties.
 */
'beforeRenderer',
/**
 * Fired after finishing rendering the cell (after the renderer finishes).
 *
 * @event Hooks#afterRenderer
 * @param {HTMLTableCellElement} TD Currently rendered cell's TD element.
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {string|number} prop Column property name or a column index, if datasource is an array of arrays.
 * @param {*} value Value of the rendered cell.
 * @param {object} cellProperties Object containing the cell's properties.
 */
'afterRenderer',
/**
 * Fired after the order of rows has changed.
 * This hook is fired by changing row indexes of any type supported by the {@link IndexMapper}.
 *
 * @event Hooks#afterRowSequenceChange
 * @param {'init'|'remove'|'insert'|'move'|'update'} [source] A string that indicates what caused the change to the order of rows.
 */
'afterRowSequenceChange',
/**
 * Fired before the vertical viewport scroll. Triggered by the [`scrollViewportTo()`](@/api/core.md#scrollviewportto)
 * method or table internals.
 *
 * @since 14.0.0
 * @event Hooks#beforeViewportScrollVertically
 * @param {number} visualRow Visual row index.
 * @param {'auto' | 'top' | 'bottom'} [snapping='auto'] If `'top'`, viewport is scrolled to show
 * the cell on the top of the table. If `'bottom'`, viewport is scrolled to show the cell on
 * the bottom of the table. When `'auto'`, the viewport is scrolled only when the row is outside of
 * the viewport.
 * @returns {number | boolean} Returns modified row index (or the same as passed in the method argument) to which
 * the viewport will be scrolled. If the returned value is `false`, the scrolling will be canceled.
 */
'beforeViewportScrollVertically',
/**
 * Fired before the horizontal viewport scroll. Triggered by the [`scrollViewportTo()`](@/api/core.md#scrollviewportto)
 * method or table internals.
 *
 * @since 14.0.0
 * @event Hooks#beforeViewportScrollHorizontally
 * @param {number} visualColumn Visual column index.
 * @param {'auto' | 'start' | 'end'} [snapping='auto'] If `'start'`, viewport is scrolled to show
 * the cell on the left of the table. If `'end'`, viewport is scrolled to show the cell on the right of
 * the table. When `'auto'`, the viewport is scrolled only when the column is outside of the viewport.
 * @returns {number | boolean} Returns modified column index (or the same as passed in the method argument) to which
 * the viewport will be scrolled. If the returned value is `false`, the scrolling will be canceled.
 */
'beforeViewportScrollHorizontally',
/**
 * Fired before the vertical or horizontal viewport scroll. Triggered by the [`scrollViewportTo()`](@/api/core.md#scrollviewportto)
 * method or table internals.
 *
 * @since 14.0.0
 * @event Hooks#beforeViewportScroll
 */
'beforeViewportScroll',
/**
 * Fired after the horizontal scroll event.
 *
 * @event Hooks#afterScrollHorizontally
 */
'afterScrollHorizontally',
/**
 * Fired after the vertical scroll event.
 *
 * @event Hooks#afterScrollVertically
 */
'afterScrollVertically',
/**
 * Fired after the vertical or horizontal scroll event.
 *
 * @since 14.0.0
 * @event Hooks#afterScroll
 */
'afterScroll',
/**
 * Fired after one or more cells are selected (e.g. during mouse move).
 *
 * @event Hooks#afterSelection
 * @param {number} row Selection start visual row index.
 * @param {number} column Selection start visual column index.
 * @param {number} row2 Selection end visual row index.
 * @param {number} column2 Selection end visual column index.
 * @param {object} preventScrolling A reference to the observable object with the `value` property.
 *                                  Property `preventScrolling.value` expects a boolean value that
 *                                  Handsontable uses to control scroll behavior after selection.
 * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
 * @example
 * ::: only-for javascript
 * ```js
 * new Handsontable(element, {
 *   afterSelection: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
 *     // If set to `false` (default): when cell selection is outside the viewport,
 *     // Handsontable scrolls the viewport to cell selection's end corner.
 *     // If set to `true`: when cell selection is outside the viewport,
 *     // Handsontable doesn't scroll to cell selection's end corner.
 *     preventScrolling.value = true;
 *   }
 * })
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * <HotTable
 *   afterSelection={(row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
 *     // If set to `false` (default): when cell selection is outside the viewport,
 *     // Handsontable scrolls the viewport to cell selection's end corner.
 *     // If set to `true`: when cell selection is outside the viewport,
 *     // Handsontable doesn't scroll to cell selection's end corner.
 *     preventScrolling.value = true;
 *   }}
 * />
 * ```
 * :::
 */
'afterSelection',
/**
 * Fired after one or more cells are selected.
 *
 * The `prop` and `prop2` arguments represent the source object property name instead of the column number.
 *
 * @event Hooks#afterSelectionByProp
 * @param {number} row Selection start visual row index.
 * @param {string} prop Selection start data source object property name.
 * @param {number} row2 Selection end visual row index.
 * @param {string} prop2 Selection end data source object property name.
 * @param {object} preventScrolling A reference to the observable object with the `value` property.
 *                                  Property `preventScrolling.value` expects a boolean value that
 *                                  Handsontable uses to control scroll behavior after selection.
 * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
 * @example
 * ```js
 * ::: only-for javascript
 * new Handsontable(element, {
 *   afterSelectionByProp: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
 *     // setting if prevent scrolling after selection
 *     preventScrolling.value = true;
 *   }
 * })
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * <HotTable
 *   afterSelectionByProp={(row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
 *     // setting if prevent scrolling after selection
 *     preventScrolling.value = true;
 *   }}
 * />
 * ```
 * :::
 */
'afterSelectionByProp',
/**
 * Fired after one or more cells are selected (e.g. on mouse up).
 *
 * @event Hooks#afterSelectionEnd
 * @param {number} row Selection start visual row index.
 * @param {number} column Selection start visual column index.
 * @param {number} row2 Selection end visual row index.
 * @param {number} column2 Selection end visual column index.
 * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
 */
'afterSelectionEnd',
/**
 * Fired after one or more cells are selected (e.g. on mouse up).
 *
 * The `prop` and `prop2` arguments represent the source object property name instead of the column number.
 *
 * @event Hooks#afterSelectionEndByProp
 * @param {number} row Selection start visual row index.
 * @param {string} prop Selection start data source object property index.
 * @param {number} row2 Selection end visual row index.
 * @param {string} prop2 Selection end data source object property index.
 * @param {number} selectionLayerLevel The number which indicates what selection layer is currently modified.
 */
'afterSelectionEndByProp',
/**
 * Fired after the focus position within a selected range is changed.
 *
 * @since 14.3.0
 * @event Hooks#afterSelectionFocusSet
 * @param {number} row The focus visual row index position.
 * @param {number} column The focus visual column index position.
 * @param {object} preventScrolling A reference to the observable object with the `value` property.
 *                                  Property `preventScrolling.value` expects a boolean value that
 *                                  Handsontable uses to control scroll behavior after selection.
 * @example
 * ```js
 * ::: only-for javascript
 * new Handsontable(element, {
 *   afterSelectionFocusSet: (row, column, preventScrolling) => {
 *     // If set to `false` (default): when focused cell selection is outside the viewport,
 *     // Handsontable scrolls the viewport to that cell.
 *     // If set to `true`: when focused cell selection is outside the viewport,
 *     // Handsontable doesn't scroll the viewport.
 *     preventScrolling.value = true;
 *   }
 * })
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * <HotTable
 *   afterSelectionFocusSet={(row, column, preventScrolling) => {
 *     // If set to `false` (default): when focused cell selection is outside the viewport,
 *     // Handsontable scrolls the viewport to that cell.
 *     // If set to `true`: when focused cell selection is outside the viewport,
 *     // Handsontable doesn't scroll the viewport.
 *     preventScrolling.value = true;
 *   }}
 * />
 * ```
 * :::
 */
'afterSelectionFocusSet',
/**
 * Fired before one or more columns are selected (e.g. During mouse header click or {@link Core#selectColumns} API call).
 *
 * @since 14.0.0
 * @event Hooks#beforeSelectColumns
 * @param {CellCoords} from Selection start coords object.
 * @param {CellCoords} to Selection end coords object.
 * @param {CellCoords} highlight Selection cell focus coords object.
 * @example
 * ::: only-for javascript
 * ```js
 * new Handsontable(element, {
 *   beforeSelectColumns: (from, to, highlight) => {
 *     // Extend the column selection by one column left and one column right.
 *     from.col = Math.max(from.col - 1, 0);
 *     to.col = Math.min(to.col + 1, this.countCols() - 1);
 *   }
 * })
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * <HotTable
 *   beforeSelectColumns={(from, to, highlight) => {
 *     // Extend the column selection by one column left and one column right.
 *     from.col = Math.max(from.col - 1, 0);
 *     to.col = Math.min(to.col + 1, this.countCols() - 1);
 *   }}
 * />
 * ```
 * :::
 */
'beforeSelectColumns',
/**
 * Fired after one or more columns are selected (e.g. during mouse header click or {@link Core#selectColumns} API call).
 *
 * @since 14.0.0
 * @event Hooks#afterSelectColumns
 * @param {CellCoords} from Selection start coords object.
 * @param {CellCoords} to Selection end coords object.
 * @param {CellCoords} highlight Selection cell focus coords object.
 */
'afterSelectColumns',
/**
 * Fired before one or more rows are selected (e.g. during mouse header click or {@link Core#selectRows} API call).
 *
 * @since 14.0.0
 * @event Hooks#beforeSelectRows
 * @param {CellCoords} from Selection start coords object.
 * @param {CellCoords} to Selection end coords object.
 * @param {CellCoords} highlight Selection cell focus coords object.
 * @example
 * ::: only-for javascript
 * ```js
 * new Handsontable(element, {
 *   beforeSelectRows: (from, to, highlight) => {
 *     // Extend the row selection by one row up and one row bottom more.
 *     from.row = Math.max(from.row - 1, 0);
 *     to.row = Math.min(to.row + 1, this.countRows() - 1);
 *   }
 * })
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * <HotTable
 *   beforeSelectRows={(from, to, highlight) => {
 *     // Extend the row selection by one row up and one row bottom more.
 *     from.row = Math.max(from.row - 1, 0);
 *     to.row = Math.min(to.row + 1, this.countRows() - 1);
 *   }}
 * />
 * ```
 * :::
 */
'beforeSelectRows',
/**
 * Fired after one or more rows are selected (e.g. during mouse header click or {@link Core#selectRows} API call).
 *
 * @since 14.0.0
 * @event Hooks#afterSelectRows
 * @param {CellCoords} from Selection start coords object.
 * @param {CellCoords} to Selection end coords object.
 * @param {CellCoords} highlight Selection cell focus coords object.
 */
'afterSelectRows',
/**
 * Fired after cell meta is changed.
 *
 * @event Hooks#afterSetCellMeta
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {string} key The updated meta key.
 * @param {*} value The updated meta value.
 */
'afterSetCellMeta',
/**
 * Fired after cell meta is removed.
 *
 * @event Hooks#afterRemoveCellMeta
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {string} key The removed meta key.
 * @param {*} value Value which was under removed key of cell meta.
 */
'afterRemoveCellMeta',
/**
 * Fired after cell data was changed.
 *
 * @event Hooks#afterSetDataAtCell
 * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 */
'afterSetDataAtCell',
/**
 * Fired after cell data was changed.
 * Called only when [`setDataAtRowProp`](@/api/core.md#setdataatrowprop) was executed.
 *
 * @event Hooks#afterSetDataAtRowProp
 * @param {Array} changes An array of changes in format `[[row, prop, oldValue, value], ...]`.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 */
'afterSetDataAtRowProp',
/**
 * Fired after cell source data was changed.
 *
 * @event Hooks#afterSetSourceDataAtCell
 * @since 8.0.0
 * @param {Array} changes An array of changes in format `[[row, column, oldValue, value], ...]`.
 * @param {string} [source] String that identifies source of hook call.
 */
'afterSetSourceDataAtCell',
/**
 * Fired after a theme is enabled, changed, or disabled.
 *
 * @since 15.0.0
 * @event Hooks#afterSetTheme
 * @param {string|boolean|undefined} themeName The theme name.
 * @param {boolean} firstRun `true` if it's the initial setting of the theme, `false` otherwise.
 */
'afterSetTheme',
/**
 * Fired after calling the [`updateSettings`](@/api/core.md#updatesettings) method.
 *
 * @event Hooks#afterUpdateSettings
 * @param {object} newSettings New settings object.
 */
'afterUpdateSettings',
/**
 * @description
 * A plugin hook executed after validator function, only if validator function is defined.
 * Validation result is the first parameter. This can be used to determinate if validation passed successfully or not.
 *
 * __Returning false from the callback will mark the cell as invalid__.
 *
 * @event Hooks#afterValidate
 * @param {boolean} isValid `true` if valid, `false` if not.
 * @param {*} value The value in question.
 * @param {number} row Visual row index.
 * @param {string|number} prop Property name / visual column index.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 * @returns {undefined | boolean} If `false` the cell will be marked as invalid, `true` otherwise.
 */
'afterValidate',
/**
 * Fired before successful change of language (when proper language code was set).
 *
 * @event Hooks#beforeLanguageChange
 * @since 0.35.0
 * @param {string} languageCode New language code.
 */
'beforeLanguageChange',
/**
 * Fired after successful change of language (when proper language code was set).
 *
 * @event Hooks#afterLanguageChange
 * @since 0.35.0
 * @param {string} languageCode New language code.
 */
'afterLanguageChange',
/**
 * Fired by {@link Autofill} plugin before populating the data in the autofill feature. This hook is fired when
 * {@link Options#fillHandle} option is enabled.
 *
 * @event Hooks#beforeAutofill
 * @param {Array[]} selectionData Data the autofill operation will start from.
 * @param {CellRange} sourceRange The range values will be filled from.
 * @param {CellRange} targetRange The range new values will be filled into.
 * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.
 *
 * @returns {boolean|Array[]} If false, the operation is cancelled. If array of arrays, the returned data
 *                              will be passed into [`populateFromArray`](@/api/core.md#populatefromarray) instead of the default autofill
 *                              algorithm's result.
 */
'beforeAutofill',
/**
 * Fired by {@link Autofill} plugin after populating the data in the autofill feature. This hook is fired when
 * {@link Options#fillHandle} option is enabled.
 *
 * @event Hooks#afterAutofill
 * @since 8.0.0
 * @param {Array[]} fillData The data that was used to fill the `targetRange`. If `beforeAutofill` was used
 *                            and returned `[[]]`, this will be the same object that was returned from `beforeAutofill`.
 * @param {CellRange} sourceRange The range values will be filled from.
 * @param {CellRange} targetRange The range new values will be filled into.
 * @param {string} direction Declares the direction of the autofill. Possible values: `up`, `down`, `left`, `right`.
 */
'afterAutofill',
/**
 * Fired before aligning the cell contents.
 *
 * @event Hooks#beforeCellAlignment
 * @param {object} stateBefore An object with class names defining the cell alignment.
 * @param {CellRange[]} range An array of `CellRange` coordinates where the alignment will be applied.
 * @param {string} type Type of the alignment - either `horizontal` or `vertical`.
 * @param {string} alignmentClass String defining the alignment class added to the cell.
 * Possible values: `htLeft` , `htCenter`, `htRight`, `htJustify`, `htTop`, `htMiddle`, `htBottom`.
 */
'beforeCellAlignment',
/**
 * Fired before one or more cells are changed.
 *
 * Use this hook to silently alter the user's changes before Handsontable re-renders.
 *
 * To ignore the user's changes, use a nullified array or return `false`.
 *
 * @event Hooks#beforeChange
 * @param {Array[]} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`. `row` is a visual row index.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 * @returns {undefined | boolean} If `false` all changes were cancelled, `true` otherwise.
 * @example
 * ::: only-for javascript
 * ```js
 * // to alter a single change, overwrite the value with `changes[i][3]`
 * new Handsontable(element, {
 *   beforeChange: (changes, source) => {
 *     // [[row, prop, oldVal, newVal], ...]
 *     changes[0][3] = 10;
 *   }
 * });
 *
 * // to ignore a single change, set `changes[i]` to `null`
 * // or remove `changes[i]` from the array, by using `changes.splice(i, 1)`
 * new Handsontable(element, {
 *   beforeChange: (changes, source) => {
 *     // [[row, prop, oldVal, newVal], ...]
 *     changes[0] = null;
 *   }
 * });
 *
 * // to ignore all changes, return `false`
 * // or set the array's length to 0, by using `changes.length = 0`
 * new Handsontable(element, {
 *   beforeChange: (changes, source) => {
 *     // [[row, prop, oldVal, newVal], ...]
 *     return false;
 *   }
 * });
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * // to alter a single change, overwrite the desired value with `changes[i][3]`
 * <HotTable
 *   beforeChange={(changes, source) => {
 *     // [[row, prop, oldVal, newVal], ...]
 *     changes[0][3] = 10;
 *   }}
 * />
 *
 * // to ignore a single change, set `changes[i]` to `null`
 * // or remove `changes[i]` from the array, by using changes.splice(i, 1).
 * <HotTable
 *   beforeChange={(changes, source) => {
 *     // [[row, prop, oldVal, newVal], ...]
 *     changes[0] = null;
 *   }}
 * />
 *
 * // to ignore all changes, return `false`
 * // or set the array's length to 0 (`changes.length = 0`)
 * <HotTable
 *   beforeChange={(changes, source) => {
 *     // [[row, prop, oldVal, newVal], ...]
 *     return false;
 *   }}
 * />
 * ```
 * :::
 */
'beforeChange',
/**
 * Fired right before rendering the changes.
 *
 * @event Hooks#beforeChangeRender
 * @param {Array[]} changes Array in form of `[row, prop, oldValue, newValue]`.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 */
'beforeChangeRender',
/**
 * Fired before drawing the borders.
 *
 * @event Hooks#beforeDrawBorders
 * @param {Array} corners Array specifying the current selection borders.
 * @param {string} borderClassName Specifies the border class name.
 */
'beforeDrawBorders',
/**
 * Fired before getting cell settings.
 *
 * @event Hooks#beforeGetCellMeta
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {object} cellProperties Object containing the cell's properties.
 */
'beforeGetCellMeta',
/**
 * Fired before cell meta is removed.
 *
 * @event Hooks#beforeRemoveCellMeta
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {string} key The removed meta key.
 * @param {*} value Value which is under removed key of cell meta.
 * @returns {*|boolean} If false is returned the action is canceled.
 */
'beforeRemoveCellMeta',
/**
 * Fired before the Handsontable instance is initiated.
 *
 * @event Hooks#beforeInit
 */
'beforeInit',
/**
 * Fired before the Walkontable instance is initiated.
 *
 * @event Hooks#beforeInitWalkontable
 * @param {object} walkontableConfig Walkontable configuration object.
 */
'beforeInitWalkontable',
/**
 * Fired before Handsontable's [`data`](@/api/options.md#data)
 * gets modified by the [`loadData()`](@/api/core.md#loaddata) method
 * or the [`updateSettings()`](@/api/core.md#updatesettings) method.
 *
 * Read more:
 * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)
 * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)
 *
 * @event Hooks#beforeLoadData
 * @since 8.0.0
 * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data
 * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
 * @param {string} source The source of the call
 * @returns {Array} The returned array will be used as Handsontable's new dataset.
 */
'beforeLoadData',
/**
 * Fired before the [`updateData()`](@/api/core.md#updatedata) method
 * modifies Handsontable's [`data`](@/api/options.md#data).
 *
 * Read more:
 * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)
 * - [Saving data](@/guides/getting-started/saving-data/saving-data.md)
 *
 * @event Hooks#beforeUpdateData
 * @since 11.1.0
 * @param {Array} sourceData An [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), or an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), that contains Handsontable's data
 * @param {boolean} initialLoad A flag that indicates whether the data was loaded at Handsontable's initialization (`true`) or later (`false`)
 * @param {string} source The source of the call
 * @returns {Array} The returned array will be used as Handsontable's new dataset.
 */
'beforeUpdateData',
/**
 * Hook fired before `keydown` event is handled. It can be used to stop default key bindings.
 *
 * __Note__: To prevent default behavior you need to call `false` in your `beforeKeyDown` handler.
 *
 * @event Hooks#beforeKeyDown
 * @param {Event} event Original DOM event.
 */
'beforeKeyDown',
/**
 * Fired after the user clicked a cell, but before all the calculations related with it.
 *
 * @event Hooks#beforeOnCellMouseDown
 * @param {Event} event The `mousedown` event object.
 * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
 * @param {HTMLTableCellElement} TD TD element.
 * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
 *                            a boolean value that allows or disallows changing the selection for that particular area.
 */
'beforeOnCellMouseDown',
/**
 * Fired after the user clicked a cell.
 *
 * @event Hooks#beforeOnCellMouseUp
 * @param {Event} event The `mouseup` event object.
 * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
 * @param {HTMLTableCellElement} TD TD element.
 */
'beforeOnCellMouseUp',
/**
 * Fired after the user clicked a cell, but before all the calculations related with it.
 *
 * @event Hooks#beforeOnCellContextMenu
 * @since 4.1.0
 * @param {Event} event The `contextmenu` event object.
 * @param {CellCoords} coords Cell coords object containing the visual coordinates of the clicked cell.
 * @param {HTMLTableCellElement} TD TD element.
 */
'beforeOnCellContextMenu',
/**
 * Fired after the user moved cursor over a cell, but before all the calculations related with it.
 *
 * @event Hooks#beforeOnCellMouseOver
 * @param {Event} event The `mouseover` event object.
 * @param {CellCoords} coords CellCoords object containing the visual coordinates of the clicked cell.
 * @param {HTMLTableCellElement} TD TD element.
 * @param {object} controller An object with properties `row`, `column` and `cell`. Each property contains
 *                            a boolean value that allows or disallows changing the selection for that particular area.
 */
'beforeOnCellMouseOver',
/**
 * Fired after the user moved cursor out from a cell, but before all the calculations related with it.
 *
 * @event Hooks#beforeOnCellMouseOut
 * @param {Event} event The `mouseout` event object.
 * @param {CellCoords} coords CellCoords object containing the visual coordinates of the leaved cell.
 * @param {HTMLTableCellElement} TD TD element.
 */
'beforeOnCellMouseOut',
/**
 * Fired before one or more columns are about to be removed.
 *
 * @event Hooks#beforeRemoveCol
 * @param {number} index Visual index of starter column.
 * @param {number} amount Amount of columns to be removed.
 * @param {number[]} physicalColumns An array of physical columns removed from the data source.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 * @returns {*|boolean} If false is returned the action is canceled.
 */
'beforeRemoveCol',
/**
 * Fired when one or more rows are about to be removed.
 *
 * @event Hooks#beforeRemoveRow
 * @param {number} index Visual index of starter row.
 * @param {number} amount Amount of rows to be removed.
 * @param {number[]} physicalRows An array of physical rows removed from the data source.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 * @returns {*|boolean} If false is returned the action is canceled.
 */
'beforeRemoveRow',
/**
 * Fired before Handsontable's view-rendering engine is rendered.
 *
 * __Note:__ In Handsontable 9.x and earlier, the `beforeViewRender` hook was named `beforeRender`.
 *
 * @event Hooks#beforeViewRender
 * @since 10.0.0
 * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
 *                           data, or a logic that needs a full Handsontable render cycle.
 *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
 * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering cycle will be skipped.
 */
'beforeViewRender',
/**
 * Fired after Handsontable's view-rendering engine is rendered,
 * but before redrawing the selection borders and before scroll syncing.
 *
 * __Note:__ In Handsontable 9.x and earlier, the `afterViewRender` hook was named `afterRender`.
 *
 * @event Hooks#afterViewRender
 * @since 10.0.0
 * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
 *                           data, or a logic that needs a full Handsontable render cycle.
 *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
 */
'afterViewRender',
/**
 * Fired before Handsontable's view-rendering engine updates the view.
 *
 * The `beforeRender` event is fired right after the Handsontable
 * business logic is executed and right before the rendering engine starts calling
 * the Core logic, renderers, cell meta objects etc. to update the view.
 *
 * @event Hooks#beforeRender
 * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
 *                           data, or a logic that needs a full Handsontable render cycle.
 *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
 */
'beforeRender',
/**
 * Fired after Handsontable's view-rendering engine updates the view.
 *
 * @event Hooks#afterRender
 * @param {boolean} isForced If set to `true`, the rendering gets triggered by a change of settings, a change of
 *                           data, or a logic that needs a full Handsontable render cycle.
 *                           If set to `false`, the rendering gets triggered by scrolling or moving the selection.
 */
'afterRender',
/**
 * When the focus position is moved to the next or previous row caused by the {@link Options#autoWrapRow} option
 * the hook is triggered.
 *
 * @since 14.0.0
 * @event Hooks#beforeRowWrap
 * @param {boolean} isWrapEnabled Tells whether the row wrapping is going to happen.
 * There may be situations where the option does not work even though it is enabled.
 * This is due to the priority of other options that may block the feature.
 * For example, when the {@link Options#minSpareCols} is defined, the {@link Options#autoWrapRow} option is not checked.
 * Thus, row wrapping is off.
 * @param {CellCoords} newCoords The new focus position. It is an object with keys `row` and `col`, where a value of `-1` indicates a header.
 * @param {boolean} isFlipped `true` if the row index was flipped, `false` otherwise.
 * Flipped index means that the user reached the last row and the focus is moved to the first row or vice versa.
 */
'beforeRowWrap',
/**
 * When the focus position is moved to the next or previous column caused by the {@link Options#autoWrapCol} option
 * the hook is triggered.
 *
 * @since 14.0.0
 * @event Hooks#beforeColumnWrap
 * @param {boolean} isWrapEnabled Tells whether the column wrapping is going to happen.
 * There may be situations where the option does not work even though it is enabled.
 * This is due to the priority of other options that may block the feature.
 * For example, when the {@link Options#minSpareRows} is defined, the {@link Options#autoWrapCol} option is not checked.
 * Thus, column wrapping is off.
 * @param {CellCoords} newCoords The new focus position. It is an object with keys `row` and `col`, where a value of `-1` indicates a header.
 * @param {boolean} isFlipped `true` if the column index was flipped, `false` otherwise.
 * Flipped index means that the user reached the last column and the focus is moved to the first column or vice versa.
 */
'beforeColumnWrap',
/**
 * Fired before cell meta is changed.
 *
 * @event Hooks#beforeSetCellMeta
 * @since 8.0.0
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {string} key The updated meta key.
 * @param {*} value The updated meta value.
 * @returns {boolean|undefined} If false is returned the action is canceled.
 */
'beforeSetCellMeta',
/**
 * Fired before setting focus selection.
 *
 * @since 14.3.0
 * @event Hooks#beforeSelectionFocusSet
 * @param {CellCoords} coords CellCoords instance.
 */
'beforeSelectionFocusSet',
/**
 * Fired before setting range is started but not finished yet.
 *
 * @event Hooks#beforeSetRangeStartOnly
 * @param {CellCoords} coords `CellCoords` instance.
 */
'beforeSetRangeStartOnly',
/**
 * Fired before setting range is started.
 *
 * @event Hooks#beforeSetRangeStart
 * @param {CellCoords} coords `CellCoords` instance.
 */
'beforeSetRangeStart',
/**
 * Fired before setting range is ended.
 *
 * @event Hooks#beforeSetRangeEnd
 * @param {CellCoords} coords `CellCoords` instance.
 */
'beforeSetRangeEnd',
/**
 * Fired before applying selection coordinates to the renderable coordinates for Walkontable (rendering engine).
 * It occurs even when cell coordinates remain unchanged and activates during cell selection and drag selection.
 * The behavior of Shift+Tab differs from Arrow Left when there's no further movement possible.
 *
 * @since 14.0.0
 * @event Hooks#beforeSelectionHighlightSet
 */
'beforeSelectionHighlightSet',
/**
 * Fired before the logic of handling a touch scroll, when user started scrolling on a touch-enabled device.
 *
 * @event Hooks#beforeTouchScroll
 */
'beforeTouchScroll',
/**
 * Fired before cell validation, only if validator function is defined. This can be used to manipulate the value
 * of changed cell before it is applied to the validator function.
 *
 * __Note:__ this will not affect values of changes. This will change value *ONLY* for validation.
 *
 * @event Hooks#beforeValidate
 * @param {*} value Value of the cell.
 * @param {number} row Visual row index.
 * @param {string|number} prop Property name / column index.
 * @param {string} [source] String that identifies source of hook call
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 */
'beforeValidate',
/**
 * Fired before cell value is rendered into the DOM (through renderer function). This can be used to manipulate the
 * value which is passed to the renderer without modifying the renderer itself.
 *
 * @event Hooks#beforeValueRender
 * @param {*} value Cell value to render.
 * @param {object} cellProperties An object containing the cell properties.
 */
'beforeValueRender',
/**
 * Fired after Handsontable instance is constructed (using `new` operator).
 *
 * @event Hooks#construct
 */
'construct',
/**
 * Fired after Handsontable instance is initiated but before table is rendered.
 *
 * @event Hooks#init
 */
'init',
/**
 * Fired when a column header index is about to be modified by a callback function.
 *
 * @event Hooks#modifyColHeader
 * @param {number} column Visual column header index.
 */
'modifyColHeader',
/**
 * Fired when a column width is about to be modified by a callback function.
 *
 * @event Hooks#modifyColWidth
 * @param {number} width Current column width.
 * @param {number} column Visual column index.
 * @param {string} [source] String that identifies source of hook call.
 */
'modifyColWidth',
/**
 * Fired when rendering the list of values in the multiple-selection component of the Filters dropdown.
 * The hook allows modifying the displayed values in that component.
 *
 * @since 14.2.0
 * @event Hooks#modifyFiltersMultiSelectValue
 * @param {object} item The item in the list of values.
 * @param {object} meta The cell properties object.
 */
'modifyFiltersMultiSelectValue',
/**
 * Fired when focusing a cell or a header element. Allows replacing the element to be focused by returning a
 * different HTML element.
 *
 * @since 14.0.0
 * @event Hooks#modifyFocusedElement
 * @param {number} row Row index.
 * @param {number} column Column index.
 * @param {HTMLElement|undefined} focusedElement The element to be focused. `null` for focusedElement is intended when focused cell is hidden.
 */
'modifyFocusedElement',
/**
 * Fired when a row header index is about to be modified by a callback function.
 *
 * @event Hooks#modifyRowHeader
 * @param {number} row Visual row header index.
 */
'modifyRowHeader',
/**
 * Fired when a row height is about to be modified by a callback function.
 *
 * @event Hooks#modifyRowHeight
 * @param {number} height Row height.
 * @param {number} row Visual row index.
 * @param {string} [source] String that identifies source of hook call.
 */
'modifyRowHeight',
/**
 * Fired when a row height is about to be modified by a callback function. The hook allows to change the row height
 * for the specified overlay type.
 *
 * @since 14.5.0
 * @event Hooks#modifyRowHeightByOverlayName
 * @param {number} height Row height.
 * @param {number} row Visual row index.
 * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'|'master'} overlayName Overlay name.
 */
'modifyRowHeightByOverlayName',
/**
 * Fired when a data was retrieved or modified.
 *
 * @event Hooks#modifyData
 * @param {number} row Physical row index.
 * @param {number} column Visual column index.
 * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.
 * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
 */
'modifyData',
/**
 * Fired when a data was retrieved or modified from the source data set.
 *
 * @event Hooks#modifySourceData
 * @since 8.0.0
 * @param {number} row Physical row index.
 * @param {number} column Physical column index or property name.
 * @param {object} valueHolder Object which contains original value which can be modified by overwriting `.value` property.
 * @param {string} ioMode String which indicates for what operation hook is fired (`get` or `set`).
 */
'modifySourceData',
/**
 * Fired when a data was retrieved or modified.
 *
 * @event Hooks#modifyRowData
 * @param {number} row Physical row index.
 */
'modifyRowData',
/**
 * Used to modify the cell coordinates when using the [`getCell`](@/api/core.md#getcell) method, opening editor, getting value from the editor
 * and saving values from the closed editor.
 *
 * @event Hooks#modifyGetCellCoords
 * @since 0.36.0
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @param {boolean} topmost If set to `true`, it returns the TD element from the topmost overlay. For example,
 *                          if the wanted cell is in the range of fixed rows, it will return a TD element
 *                          from the `top` overlay.
 * @param {string} source String that identifies how this coords change will be processed. Possible values:
 *                        `meta` the change will affect the cell meta and data; `render` the change will affect the
 *                        DOM element that will be returned by the `getCell` method.
 * @returns {undefined|number[]}
 */
'modifyGetCellCoords',
/**
 * Used to modify the returned cell coordinates of clicked cells (TD or TH elements).
 *
 * @event Hooks#modifyGetCoordsElement
 * @since 14.6.0
 * @param {number} row Visual row index.
 * @param {number} column Visual column index.
 * @returns {undefined|number[]}
 */
'modifyGetCoordsElement',
/**
 * Used to modify the cell coordinates when the table is activated (going into the listen mode).
 *
 * @event Hooks#modifyFocusOnTabNavigation
 * @since 14.0.0
 * @param {'from_above' | 'from_below'} tabActivationDir The browsers Tab navigation direction. Depending on
 * whether the user activated the table from the element above or below, another cell can be selected.
 * @param {CellCoords} visualCoords The coords that will be used to select a cell.
 */
'modifyFocusOnTabNavigation',
/**
 * Allows modify the visual row index that is used to retrieve the row header element (TH) before it's
 * highlighted (proper CSS class names are added). Modifying the visual row index allows building a custom
 * implementation of the nested headers feature or other features that require highlighting other DOM
 * elements than that the rendering engine, by default, would have highlighted.
 *
 * @event Hooks#beforeHighlightingRowHeader
 * @since 8.4.0
 * @param {number} row Visual row index.
 * @param {number} headerLevel Column header level (0 = most distant to the table).
 * @param {object} highlightMeta An object that contains additional information about processed selection.
 * @returns {number|undefined}
 */
'beforeHighlightingRowHeader',
/**
 * Allows modify the visual column index that is used to retrieve the column header element (TH) before it's
 * highlighted (proper CSS class names are added). Modifying the visual column index allows building a custom
 * implementation of the nested headers feature or other features that require highlighting other DOM
 * elements than that the rendering engine, by default, would have highlighted.
 *
 * @event Hooks#beforeHighlightingColumnHeader
 * @since 8.4.0
 * @param {number} column Visual column index.
 * @param {number} headerLevel Row header level (0 = most distant to the table).
 * @param {object} highlightMeta An object that contains additional information about processed selection.
 * @returns {number|undefined}
 */
'beforeHighlightingColumnHeader',
/**
 * Fired by {@link PersistentState} plugin, after loading value, saved under given key, from browser local storage.
 *
 * The `persistentStateLoad` hook is fired even when the {@link Options#persistentState} option is disabled.
 *
 * @event Hooks#persistentStateLoad
 * @param {string} key Key.
 * @param {object} valuePlaceholder Object containing the loaded value under `valuePlaceholder.value` (if no value have been saved, `value` key will be undefined).
 */
'persistentStateLoad',
/**
 * Fired by {@link PersistentState} plugin after resetting data from local storage. If no key is given, all values associated with table will be cleared.
 * This hook is fired when {@link Options#persistentState} option is enabled.
 *
 * @event Hooks#persistentStateReset
 * @param {string} [key] Key.
 */
'persistentStateReset',
/**
 * Fired by {@link PersistentState} plugin, after saving value under given key in browser local storage.
 *
 * The `persistentStateSave` hook is fired even when the {@link Options#persistentState} option is disabled.
 *
 * @event Hooks#persistentStateSave
 * @param {string} key Key.
 * @param {Mixed} value Value to save.
 */
'persistentStateSave',
/**
 * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins before sorting the column. If you return `false` value inside callback for hook, then sorting
 * will be not applied by the Handsontable (useful for server-side sorting).
 *
 * This hook is fired when {@link Options#columnSorting} or {@link Options#multiColumnSorting} option is enabled.
 *
 * @event Hooks#beforeColumnSort
 * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).
 * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).
 * @returns {boolean | undefined} If `false` the column will not be sorted, `true` otherwise.
 */
'beforeColumnSort',
/**
 * Fired by {@link ColumnSorting} and {@link MultiColumnSorting} plugins after sorting the column. This hook is fired when {@link Options#columnSorting}
 * or {@link Options#multiColumnSorting} option is enabled.
 *
 * @event Hooks#afterColumnSort
 * @param {Array} currentSortConfig Current sort configuration (for all sorted columns).
 * @param {Array} destinationSortConfigs Destination sort configuration (for all sorted columns).
 */
'afterColumnSort',
/**
 * Fired by {@link Autofill} plugin after setting range of autofill. This hook is fired when {@link Options#fillHandle}
 * option is enabled.
 *
 * @event Hooks#modifyAutofillRange
 * @param {Array} startArea Array of visual coordinates of the starting point for the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).
 * @param {Array} entireArea Array of visual coordinates of the entire area of the drag-down operation (`[startRow, startColumn, endRow, endColumn]`).
 */
'modifyAutofillRange',
/**
 * Fired to allow modifying the copyable range with a callback function.
 *
 * @event Hooks#modifyCopyableRange
 * @param {Array[]} copyableRanges Array of objects defining copyable cells.
 */
'modifyCopyableRange',
/**
 * Fired by {@link CopyPaste} plugin before copying the values to the clipboard and before clearing values of
 * the selected cells. This hook is fired when {@link Options#copyPaste} option is enabled.
 *
 * @event Hooks#beforeCut
 * @param {Array[]} data An array of arrays which contains data to cut.
 * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
 *                       which will be cut out.
 * @returns {*} If returns `false` then operation of the cutting out is canceled.
 * @example
 * ::: only-for javascript
 * ```js
 * // To disregard a single row, remove it from the array using data.splice(i, 1).
 * new Handsontable(element, {
 *   beforeCut: function(data, coords) {
 *     // data -> [[1, 2, 3], [4, 5, 6]]
 *     data.splice(0, 1);
 *     // data -> [[4, 5, 6]]
 *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
 *   }
 * });
 * // To cancel a cutting action, just return `false`.
 * new Handsontable(element, {
 *   beforeCut: function(data, coords) {
 *     return false;
 *   }
 * });
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * // To disregard a single row, remove it from the array using data.splice(i, 1).
 * <HotTable
 *   beforeCut={(data, coords) => {
 *     // data -> [[1, 2, 3], [4, 5, 6]]
 *     data.splice(0, 1);
 *     // data -> [[4, 5, 6]]
 *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
 *   }}
 * />
 * // To cancel a cutting action, just return `false`.
 * <HotTable
 *   beforeCut={(data, coords) => {
 *     return false;
 *   }}
 * />
 * ```
 * :::
 */
'beforeCut',
/**
 * Fired by {@link CopyPaste} plugin after data was cut out from the table. This hook is fired when
 * {@link Options#copyPaste} option is enabled.
 *
 * @event Hooks#afterCut
 * @param {Array[]} data An array of arrays with the cut data.
 * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
 *                       which was cut out.
 */
'afterCut',
/**
 * Fired before values are copied to the clipboard.
 *
 * @event Hooks#beforeCopy
 * @param {Array[]} data An array of arrays which contains data to copied.
 * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
 *                         which will copied.
 * @param {{ columnHeadersCount: number }} copiedHeadersCount (Since 12.3.0) The number of copied column headers.
 * @returns {*} If returns `false` then copying is canceled.
 *
 * @example
 * ::: only-for javascript
 * ```js
 * // To disregard a single row, remove it from array using data.splice(i, 1).
 * ...
 * new Handsontable(document.getElementById('example'), {
 *   beforeCopy: (data, coords) => {
 *     // data -> [[1, 2, 3], [4, 5, 6]]
 *     data.splice(0, 1);
 *     // data -> [[4, 5, 6]]
 *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
 *   }
 * });
 * ...
 *
 * // To cancel copying, return false from the callback.
 * ...
 * new Handsontable(document.getElementById('example'), {
 *   beforeCopy: (data, coords) => {
 *     return false;
 *   }
 * });
 * ...
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * // To disregard a single row, remove it from array using data.splice(i, 1).
 * ...
 * <HotTable
 *   beforeCopy={(data, coords) => {
 *     // data -> [[1, 2, 3], [4, 5, 6]]
 *     data.splice(0, 1);
 *     // data -> [[4, 5, 6]]
 *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
 *   }}
 * />
 * ...
 *
 * // To cancel copying, return false from the callback.
 * ...
 * <HotTable
 *   beforeCopy={(data, coords) => {
 *     return false;
 *   }}
 * />
 * ...
 * ```
 * :::
 */
'beforeCopy',
/**
 * Fired by {@link CopyPaste} plugin after data are pasted into table. This hook is fired when {@link Options#copyPaste}
 * option is enabled.
 *
 * @event Hooks#afterCopy
 * @param {Array[]} data An array of arrays which contains the copied data.
 * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
 *                         which was copied.
 * @param {{ columnHeadersCount: number }} copiedHeadersCount (Since 12.3.0) The number of copied column headers.
 */
'afterCopy',
/**
 * Fired by {@link CopyPaste} plugin before values are pasted into table. This hook is fired when
 * {@link Options#copyPaste} option is enabled.
 *
 * @event Hooks#beforePaste
 * @param {Array[]} data An array of arrays which contains data to paste.
 * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
 *                       that correspond to the previously selected area.
 * @returns {*} If returns `false` then pasting is canceled.
 * @example
 * ```js
 * ::: only-for javascript
 * // To disregard a single row, remove it from array using data.splice(i, 1).
 * new Handsontable(example, {
 *   beforePaste: (data, coords) => {
 *     // data -> [[1, 2, 3], [4, 5, 6]]
 *     data.splice(0, 1);
 *     // data -> [[4, 5, 6]]
 *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
 *   }
 * });
 * // To cancel pasting, return false from the callback.
 * new Handsontable(example, {
 *   beforePaste: (data, coords) => {
 *     return false;
 *   }
 * });
 * ```
 * :::
 *
 * ::: only-for react
 * ```jsx
 * // To disregard a single row, remove it from array using data.splice(i, 1).
 * <HotTable
 *   beforePaste={(data, coords) => {
 *     // data -> [[1, 2, 3], [4, 5, 6]]
 *     data.splice(0, 1);
 *     // data -> [[4, 5, 6]]
 *     // coords -> [{startRow: 0, startCol: 0, endRow: 1, endCol: 2}]
 *   }}
 * />
 * // To cancel pasting, return false from the callback.
 * <HotTable
 *   beforePaste={(data, coords) => {
 *     return false;
 *   }}
 * />
 * ```
 * :::
 */
'beforePaste',
/**
 * Fired by {@link CopyPaste} plugin after values are pasted into table. This hook is fired when
 * {@link Options#copyPaste} option is enabled.
 *
 * @event Hooks#afterPaste
 * @param {Array[]} data An array of arrays with the pasted data.
 * @param {object[]} coords An array of objects with ranges of the visual indexes (`startRow`, `startCol`, `endRow`, `endCol`)
 *                       that correspond to the previously selected area.
 */
'afterPaste',
/**
 * Fired by the {@link ManualColumnFreeze} plugin, before freezing a column.
 *
 * @event Hooks#beforeColumnFreeze
 * @since 12.1.0
 * @param {number} column The visual index of the column that is going to freeze.
 * @param {boolean} freezePerformed If `true`: the column is going to freeze. If `false`: the column is not going to freeze (which might happen if the column is already frozen).
 * @returns {boolean|undefined} If `false`: the column is not going to freeze, and the `afterColumnFreeze` hook won't fire.
 */
'beforeColumnFreeze',
/**
 * Fired by the {@link ManualColumnFreeze} plugin, right after freezing a column.
 *
 * @event Hooks#afterColumnFreeze
 * @since 12.1.0
 * @param {number} column The visual index of the frozen column.
 * @param {boolean} freezePerformed If `true`: the column got successfully frozen. If `false`: the column didn't get frozen.
 */
'afterColumnFreeze',
/**
 * Fired by {@link ManualColumnMove} plugin before change order of the visual indexes. This hook is fired when
 * {@link Options#manualColumnMove} option is enabled.
 *
 * @event Hooks#beforeColumnMove
 * @param {Array} movedColumns Array of visual column indexes to be moved.
 * @param {number} finalIndex Visual column index, being a start index for the moved columns.
 *                            Points to where the elements will be placed after the moving action.
 *                            To check visualization of final index please take a look at
 *                            [documentation](@/guides/columns/column-moving/column-moving.md).
 * @param {number|undefined} dropIndex Visual column index, being a drop index for the moved columns.
 *                                     Points to where we are going to drop the moved elements. To check
 *                                     visualization of drop index please take a look at
 *                                     [documentation](@/guides/columns/column-moving/column-moving.md).
 *                                     It's `undefined` when `dragColumns` function wasn't called.
 * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
 * @returns {undefined | boolean} If `false` the column will not be moved, `true` otherwise.
 */
'beforeColumnMove',
/**
 * Fired by {@link ManualColumnMove} plugin after changing order of the visual indexes.
 * This hook is fired when {@link Options#manualColumnMove} option is enabled.
 *
 * @event Hooks#afterColumnMove
 * @param {Array} movedColumns Array of visual column indexes to be moved.
 * @param {number} finalIndex Visual column index, being a start index for the moved columns.
 *                            Points to where the elements will be placed after the moving action.
 *                            To check visualization of final index please take a look at
 *                            [documentation](@/guides/columns/column-moving/column-moving.md).
 * @param {number|undefined} dropIndex Visual column index, being a drop index for the moved columns.
 *                                     Points to where we are going to drop the moved elements.
 *                                     To check visualization of drop index please take a look at
 *                                     [documentation](@/guides/columns/column-moving/column-moving.md).
 *                                     It's `undefined` when `dragColumns` function wasn't called.
 * @param {boolean} movePossible Indicates if it was possible to move columns to the desired position.
 * @param {boolean} orderChanged Indicates if order of columns was changed by move.
 */
'afterColumnMove',
/**
 * Fired by the {@link ManualColumnFreeze} plugin, before unfreezing a column.
 *
 * @event Hooks#beforeColumnUnfreeze
 * @since 12.1.0
 * @param {number} column The visual index of the column that is going to unfreeze.
 * @param {boolean} unfreezePerformed If `true`: the column is going to unfreeze. If `false`: the column is not going to unfreeze (which might happen if the column is already unfrozen).
 * @returns {boolean|undefined} If `false`: the column is not going to unfreeze, and the `afterColumnUnfreeze` hook won't fire.
 */
'beforeColumnUnfreeze',
/**
 * Fired by the {@link ManualColumnFreeze} plugin, right after unfreezing a column.
 *
 * @event Hooks#afterColumnUnfreeze
 * @since 12.1.0
 * @param {number} column The visual index of the unfrozen column.
 * @param {boolean} unfreezePerformed If `true`: the column got successfully unfrozen. If `false`: the column didn't get unfrozen.
 */
'afterColumnUnfreeze',
/**
 * Fired by {@link ManualRowMove} plugin before changing the order of the visual indexes. This hook is fired when
 * {@link Options#manualRowMove} option is enabled.
 *
 * @event Hooks#beforeRowMove
 * @param {Array} movedRows Array of visual row indexes to be moved.
 * @param {number} finalIndex Visual row index, being a start index for the moved rows.
 *                            Points to where the elements will be placed after the moving action.
 *                            To check visualization of final index please take a look at
 *                            [documentation](@/guides/rows/row-moving/row-moving.md).
 * @param {number|undefined} dropIndex Visual row index, being a drop index for the moved rows.
 *                                     Points to where we are going to drop the moved elements.
 *                                     To check visualization of drop index please take a look at
 *                                     [documentation](@/guides/rows/row-moving/row-moving.md).
 *                                     It's `undefined` when `dragRows` function wasn't called.
 * @param {boolean} movePossible Indicates if it's possible to move rows to the desired position.
 * @returns {*|boolean} If false is returned the action is canceled.
 */
'beforeRowMove',
/**
 * Fired by {@link ManualRowMove} plugin after changing the order of the visual indexes.
 * This hook is fired when {@link Options#manualRowMove} option is enabled.
 *
 * @event Hooks#afterRowMove
 * @param {Array} movedRows Array of visual row indexes to be moved.
 * @param {number} finalIndex Visual row index, being a start index for the moved rows.
 *                            Points to where the elements will be placed after the moving action.
 *                            To check visualization of final index please take a look at
 *                            [documentation](@/guides/rows/row-moving/row-moving.md).
 * @param {number|undefined} dropIndex Visual row index, being a drop index for the moved rows.
 *                                     Points to where we are going to drop the moved elements.
 *                                     To check visualization of drop index please take a look at
 *                                     [documentation](@/guides/rows/row-moving/row-moving.md).
 *                                     It's `undefined` when `dragRows` function wasn't called.
 * @param {boolean} movePossible Indicates if it was possible to move rows to the desired position.
 * @param {boolean} orderChanged Indicates if order of rows was changed by move.
 */
'afterRowMove',
/**
 * Fired by {@link ManualColumnResize} plugin before rendering the table with modified column sizes. This hook is
 * fired when {@link Options#manualColumnResize} option is enabled.
 *
 * @event Hooks#beforeColumnResize
 * @param {number} newSize Calculated new column width.
 * @param {number} column Visual index of the resized column.
 * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
 * @returns {number} Returns a new column size or `undefined`, if column size should be calculated automatically.
 */
'beforeColumnResize',
/**
 * Fired by {@link ManualColumnResize} plugin after rendering the table with modified column sizes. This hook is
 * fired when {@link Options#manualColumnResize} option is enabled.
 *
 * @event Hooks#afterColumnResize
 * @param {number} newSize Calculated new column width.
 * @param {number} column Visual index of the resized column.
 * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
 */
'afterColumnResize',
/**
 * Fired by {@link ManualRowResize} plugin before rendering the table with modified row sizes. This hook is
 * fired when {@link Options#manualRowResize} option is enabled.
 *
 * @event Hooks#beforeRowResize
 * @param {number} newSize Calculated new row height.
 * @param {number} row Visual index of the resized row.
 * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
 * @returns {number|undefined} Returns the new row size or `undefined` if row size should be calculated automatically.
 */
'beforeRowResize',
/**
 * Fired by {@link ManualRowResize} plugin after rendering the table with modified row sizes. This hook is
 * fired when {@link Options#manualRowResize} option is enabled.
 *
 * @event Hooks#afterRowResize
 * @param {number} newSize Calculated new row height.
 * @param {number} row Visual index of the resized row.
 * @param {boolean} isDoubleClick Flag that determines whether there was a double-click.
 */
'afterRowResize',
/**
 * Fired after getting the column header renderers.
 *
 * @event Hooks#afterGetColumnHeaderRenderers
 * @param {Function[]} renderers An array of the column header renderers.
 */
'afterGetColumnHeaderRenderers',
/**
 * Fired after getting the row header renderers.
 *
 * @event Hooks#afterGetRowHeaderRenderers
 * @param {Function[]} renderers An array of the row header renderers.
 */
'afterGetRowHeaderRenderers',
/**
 * Fired before applying stretched column width to column.
 *
 * @event Hooks#beforeStretchingColumnWidth
 * @param {number} stretchedWidth Calculated width.
 * @param {number} column Visual column index.
 * @returns {number|undefined} Returns new width which will be applied to the column element.
 */
'beforeStretchingColumnWidth',
/**
 * Fired by the [`Filters`](@/api/filters.md) plugin,
 * before a [column filter](@/guides/columns/column-filter/column-filter.md) gets applied.
 *
 * [`beforeFilter`](#beforefilter) takes two arguments: `conditionsStack` and `previousConditionsStack`, both are
 * arrays of objects.
 *
 * Each object represents one of your [column filters](@/api/filters.md#addcondition),
 * and consists of the following properties:
 *
 * | Property     | Possible values                                                         | Description                                                                                                              |
 * | ------------ | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
 * | `column`     | Number                                                                  | A visual index of the column to which the filter will be applied.                                                        |
 * | `conditions` | Array of objects                                                        | Each object represents one condition. For details, see [`addCondition()`](@/api/filters.md#addcondition).                |
 * | `operation`  | `'conjunction'` \| `'disjunction'` \| `'disjunctionWithExtraCondition'` | An operation to perform on your set of `conditions`. For details, see [`addCondition()`](@/api/filters.md#addcondition). |
 *
 * An example of the format of the `conditionsStack` argument:
 *
 * ```js
 * [
 *   {
 *     column: 2,
 *     conditions: [
 *       {name: 'begins_with', args: [['S']]}
 *     ],
 *     operation: 'conjunction'
 *   },
 *   {
 *     column: 4,
 *     conditions: [
 *       {name: 'not_empty', args: []}
 *     ],
 *     operation: 'conjunction'
 *   },
 * ]
 * ```
 *
 * To perform server-side filtering (i.e., to not apply filtering to Handsontable's UI),
 * set [`beforeFilter`](#beforefilter) to return `false`:
 *
 * ```js
 * new Handsontable(document.getElementById('example'), {
 *   beforeFilter: (conditionsStack) => {
 *     return false;
 *   }
 * });
 *```
 *
 * Read more:
 * - [Guides: Column filter](@/guides/columns/column-filter/column-filter.md)
 * - [Hooks: `afterFilter`](#afterfilter)
 * - [Options: `filters`](@/api/options.md#filters)
 * - [Plugins: `Filters`](@/api/filters.md)
 * – [Plugin methods: `addCondition()`](@/api/filters.md#addcondition)
 *
 * @event Hooks#beforeFilter
 * @param {object[]} conditionsStack An array of objects with your [column filters](@/api/filters.md#addcondition).
 * @param {object[]|null} previousConditionsStack An array of objects with your previous [column filters](@/api/filters.md#addcondition). It can also be `null` if there was no previous filters applied or the conditions did not change between performing the `filter` action.
 * @returns {boolean} To perform server-side filtering (i.e., to not apply filtering to Handsontable's UI), return `false`.
 */
'beforeFilter',
/**
 * Fired by the [`Filters`](@/api/filters.md) plugin,
 * after a [column filter](@/guides/columns/column-filter/column-filter.md) gets applied.
 *
 * [`afterFilter`](#afterfilter) takes one argument (`conditionsStack`), which is an array of objects.
 * Each object represents one of your [column filters](@/api/filters.md#addcondition),
 * and consists of the following properties:
 *
 * | Property     | Possible values                                                         | Description                                                                                                              |
 * | ------------ | ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
 * | `column`     | Number                                                                  | A visual index of the column to which the filter was applied.                                                            |
 * | `conditions` | Array of objects                                                        | Each object represents one condition. For details, see [`addCondition()`](@/api/filters.md#addcondition).                |
 * | `operation`  | `'conjunction'` \| `'disjunction'` \| `'disjunctionWithExtraCondition'` | An operation to perform on your set of `conditions`. For details, see [`addCondition()`](@/api/filters.md#addcondition). |
 *
 * An example of the format of the `conditionsStack` argument:
 *
 * ```js
 * [
 *   {
 *     column: 2,
 *     conditions: [
 *       {name: 'begins_with', args: [['S']]}
 *     ],
 *     operation: 'conjunction'
 *   },
 *   {
 *     column: 4,
 *     conditions: [
 *       {name: 'not_empty', args: []}
 *     ],
 *     operation: 'conjunction'
 *   },
 * ]
 * ```
 *
 * Read more:
 * - [Guides: Column filter](@/guides/columns/column-filter/column-filter.md)
 * - [Hooks: `beforeFilter`](#beforefilter)
 * - [Options: `filters`](@/api/options.md#filters)
 * - [Plugins: `Filters`](@/api/filters.md)
 * – [Plugin methods: `addCondition()`](@/api/filters.md#addcondition)
 *
 * @event Hooks#afterFilter
 * @param {object[]} conditionsStack An array of objects with your [column filters](@/api/filters.md#addcondition).
 */
'afterFilter',
/**
 * Fired by the {@link Formulas} plugin, when any cell value changes.
 *
 * Returns an array of objects that contains:
 * - The addresses (`sheet`, `row`, `col`) and new values (`newValue`) of the changed cells.
 * - The addresses and new values of any cells that had to be recalculated (because their formulas depend on the cells that changed).
 *
 * This hook gets also fired on Handsontable's initialization, returning the addresses and values of all cells.
 *
 * Read more:
 * - [Guides: Formula calculation](@/guides/formulas/formula-calculation/formula-calculation.md)
 * - [HyperFormula documentation: `valuesUpdated`](https://hyperformula.handsontable.com/api/interfaces/listeners.html#valuesupdated)
 *
 * @since 9.0.0
 * @event Hooks#afterFormulasValuesUpdate
 * @param {Array} changes The addresses and new values of all the changed and recalculated cells.
 */
'afterFormulasValuesUpdate',
/**
 * Fired when a named expression is added to the Formulas' engine instance.
 *
 * @since 9.0.0
 * @event Hooks#afterNamedExpressionAdded
 * @param {string} namedExpressionName The name of the added expression.
 * @param {Array} changes The values and location of applied changes.
 */
'afterNamedExpressionAdded',
/**
 * Fired when a named expression is removed from the Formulas' engine instance.
 *
 * @since 9.0.0
 * @event Hooks#afterNamedExpressionRemoved
 * @param {string} namedExpressionName The name of the removed expression.
 * @param {Array} changes The values and location of applied changes.
 */
'afterNamedExpressionRemoved',
/**
 * Fired when a new sheet is added to the Formulas' engine instance.
 *
 * @since 9.0.0
 * @event Hooks#afterSheetAdded
 * @param {string} addedSheetDisplayName The name of the added sheet.
 */
'afterSheetAdded',
/**
 * Fired when a sheet in the Formulas' engine instance is renamed.
 *
 * @since 9.0.0
 * @event Hooks#afterSheetRenamed
 * @param {string} oldDisplayName The old name of the sheet.
 * @param {string} newDisplayName The new name of the sheet.
 */
'afterSheetRenamed',
/**
 * Fired when a sheet is removed from the Formulas' engine instance.
 *
 * @since 9.0.0
 * @event Hooks#afterSheetRemoved
 * @param {string} removedSheetDisplayName The removed sheet name.
 * @param {Array} changes The values and location of applied changes.
 */
'afterSheetRemoved',
/**
 * Fired while retrieving the column header height.
 *
 * @event Hooks#modifyColumnHeaderHeight
 */
'modifyColumnHeaderHeight',
/**
 * Fired while retrieving a column header's value.
 *
 * @since 12.3.0
 * @event Hooks#modifyColumnHeaderValue
 * @param {string} value A column header value.
 * @param {number} visualColumnIndex A visual column index.
 * @param {number} [headerLevel=0] Header level index. Accepts positive (`0` to `n`)
 *                                 and negative (`-1` to `-n`) values. For positive values, `0` points to the
 *                                 topmost header. For negative values, `-1` points to the bottom-most
 *                                 header (the header closest to the cells).
 * @returns {string} The column header value to be updated.
 */
'modifyColumnHeaderValue',
/**
 * Fired by {@link UndoRedo} plugin before the undo action. Contains information about the action that is being undone.
 * This hook is fired when {@link Options#undo} option is enabled.
 *
 * @event Hooks#beforeUndo
 * @param {object} action The action object. Contains information about the action being undone. The `actionType`
 *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).
 * @returns {*|boolean} If false is returned the action is canceled.
 */
'beforeUndo',
/**
 * Fired by {@link UndoRedo} plugin before changing undo stack.
 *
 * @event Hooks#beforeUndoStackChange
 * @since 8.4.0
 * @param {Array} doneActions Stack of actions which may be undone.
 * @param {string} [source] String that identifies source of action
 *                          ([list of all available sources](@/guides/getting-started/events-and-hooks/events-and-hooks.md#definition-for-source-argument)).
 * @returns {*|boolean} If false is returned the action of changing undo stack is canceled.
 */
'beforeUndoStackChange',
/**
 * Fired by {@link UndoRedo} plugin after the undo action. Contains information about the action that is being undone.
 * This hook is fired when {@link Options#undo} option is enabled.
 *
 * @event Hooks#afterUndo
 * @param {object} action The action object. Contains information about the action being undone. The `actionType`
 *                        property of the object specifies the type of the action in a String format. (e.g. `'remove_row'`).
 */
'afterUndo',
/**
 * Fired by {@link UndoRedo} plugin after changing undo stack.
 *
 * @event Hooks#afterUndoStackChange
 * @since 8.4.0
 * @param {Array} doneActionsBefore Stack of actions which could be undone before performing new action.
 * @param {Array} doneActionsAfter Stack of actions which can be undone after performing new action.
 */
'afterUndoStackChange',
/**
 * Fired by {@link UndoRedo} plugin before the redo action. Contains information about the action that is being redone.
 * This hook is fired when {@link Options#undo} option is enabled.
 *
 * @event Hooks#beforeRedo
 * @param {object} action The action object. Contains information about the action being redone. The `actionType`
 *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).
 * @returns {*|boolean} If false is returned the action is canceled.
 */
'beforeRedo',
/**
 * Fired by {@link UndoRedo} plugin before changing redo stack.
 *
 * @event Hooks#beforeRedoStackChange
 * @since 8.4.0
 * @param {Array} undoneActions Stack of actions which may be redone.
 */
'beforeRedoStackChange',
/**
 * Fired by {@link UndoRedo} plugin after the redo action. Contains information about the action that is being redone.
 * This hook is fired when {@link Options#undo} option is enabled.
 *
 * @event Hooks#afterRedo
 * @param {object} action The action object. Contains information about the action being redone. The `actionType`
 *                        property of the object specifies the type of the action in a String format (e.g. `'remove_row'`).
 */
'afterRedo',
/**
 * Fired by {@link UndoRedo} plugin after changing redo stack.
 *
 * @event Hooks#afterRedoStackChange
 * @since 8.4.0
 * @param {Array} undoneActionsBefore Stack of actions which could be redone before performing new action.
 * @param {Array} undoneActionsAfter Stack of actions which can be redone after performing new action.
 */
'afterRedoStackChange',
/**
 * Fired while retrieving the row header width.
 *
 * @event Hooks#modifyRowHeaderWidth
 * @param {number} rowHeaderWidth Row header width.
 */
'modifyRowHeaderWidth',
/**
 * Fired when the focus of the selection is being modified (e.g. Moving the focus with the enter/tab keys).
 *
 * @since 14.3.0
 * @event Hooks#modifyTransformFocus
 * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
 */
'modifyTransformFocus',
/**
 * Fired when the start of the selection is being modified (e.g. Moving the selection with the arrow keys).
 *
 * @event Hooks#modifyTransformStart
 * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
 */
'modifyTransformStart',
/**
 * Fired when the end of the selection is being modified (e.g. Moving the selection with the arrow keys).
 *
 * @event Hooks#modifyTransformEnd
 * @param {CellCoords} delta Cell coords object declaring the delta of the new selection relative to the previous one.
 */
'modifyTransformEnd',
/**
 * Fired after the focus of the selection is being modified (e.g. Moving the focus with the enter/tab keys).
 *
 * @since 14.3.0
 * @event Hooks#afterModifyTransformFocus
 * @param {CellCoords} coords Coords of the freshly focused cell.
 * @param {number} rowTransformDir `-1` if trying to focus a cell with a negative row index. `0` otherwise.
 * @param {number} colTransformDir `-1` if trying to focus a cell with a negative column index. `0` otherwise.
 */
'afterModifyTransformFocus',
/**
 * Fired after the start of the selection is being modified (e.g. Moving the selection with the arrow keys).
 *
 * @event Hooks#afterModifyTransformStart
 * @param {CellCoords} coords Coords of the freshly selected cell.
 * @param {number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.
 * @param {number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.
 */
'afterModifyTransformStart',
/**
 * Fired after the end of the selection is being modified (e.g. Moving the selection with the arrow keys).
 *
 * @event Hooks#afterModifyTransformEnd
 * @param {CellCoords} coords Visual coords of the freshly selected cell.
 * @param {number} rowTransformDir `-1` if trying to select a cell with a negative row index. `0` otherwise.
 * @param {number} colTransformDir `-1` if trying to select a cell with a negative column index. `0` otherwise.
 */
'afterModifyTransformEnd',
/**
 * Fired inside the `viewportRowCalculatorOverride` method. Allows modifying the row calculator parameters.
 *
 * @event Hooks#afterViewportRowCalculatorOverride
 * @param {object} calc The row calculator.
 */
'afterViewportRowCalculatorOverride',
/**
 * Fired inside the `viewportColumnCalculatorOverride` method. Allows modifying the row calculator parameters.
 *
 * @event Hooks#afterViewportColumnCalculatorOverride
 * @param {object} calc The row calculator.
 */
'afterViewportColumnCalculatorOverride',
/**
 * Fired after initializing all the plugins.
 * This hook should be added before Handsontable is initialized.
 *
 * @event Hooks#afterPluginsInitialized
 *
 * @example
 * ```js
 * Handsontable.hooks.add('afterPluginsInitialized', myCallback);
 * ```
 */
'afterPluginsInitialized',
/**
 * Fired by {@link HiddenRows} plugin before marking the rows as hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
 * Returning `false` in the callback will prevent the hiding action from completing.
 *
 * @event Hooks#beforeHideRows
 * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
 * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
 * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
 */
'beforeHideRows',
/**
 * Fired by {@link HiddenRows} plugin after marking the rows as hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
 *
 * @event Hooks#afterHideRows
 * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
 * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
 * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
 * @param {boolean} stateChanged `true`, if the action affected any non-hidden rows, `false` otherwise.
 */
'afterHideRows',
/**
 * Fired by {@link HiddenRows} plugin before marking the rows as not hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
 * Returning `false` in the callback will prevent the row revealing action from completing.
 *
 * @event Hooks#beforeUnhideRows
 * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
 * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
 * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the revealing action will not be completed.
 */
'beforeUnhideRows',
/**
 * Fired by {@link HiddenRows} plugin after marking the rows as not hidden. Fired only if the {@link Options#hiddenRows} option is enabled.
 *
 * @event Hooks#afterUnhideRows
 * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical row indexes.
 * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical row indexes.
 * @param {boolean} actionPossible `true`, if provided row indexes are valid, `false` otherwise.
 * @param {boolean} stateChanged `true`, if the action affected any hidden rows, `false` otherwise.
 */
'afterUnhideRows',
/**
 * Fired by {@link HiddenColumns} plugin before marking the columns as hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
 * Returning `false` in the callback will prevent the hiding action from completing.
 *
 * @event Hooks#beforeHideColumns
 * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
 * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
 * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
 */
'beforeHideColumns',
/**
 * Fired by {@link HiddenColumns} plugin after marking the columns as hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
 *
 * @event Hooks#afterHideColumns
 * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
 * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
 * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
 * @param {boolean} stateChanged `true`, if the action affected any non-hidden columns, `false` otherwise.
 */
'afterHideColumns',
/**
 * Fired by {@link HiddenColumns} plugin before marking the columns as not hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
 * Returning `false` in the callback will prevent the column revealing action from completing.
 *
 * @event Hooks#beforeUnhideColumns
 * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
 * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
 * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the hiding action will not be completed.
 */
'beforeUnhideColumns',
/**
 * Fired by {@link HiddenColumns} plugin after marking the columns as not hidden. Fired only if the {@link Options#hiddenColumns} option is enabled.
 *
 * @event Hooks#afterUnhideColumns
 * @param {Array} currentHideConfig Current hide configuration - a list of hidden physical column indexes.
 * @param {Array} destinationHideConfig Destination hide configuration - a list of hidden physical column indexes.
 * @param {boolean} actionPossible `true`, if the provided column indexes are valid, `false` otherwise.
 * @param {boolean} stateChanged `true`, if the action affected any hidden columns, `false` otherwise.
 */
'afterUnhideColumns',
/**
 * Fired by {@link TrimRows} plugin before trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
 *
 * @event Hooks#beforeTrimRow
 * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
 * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
 * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the trimming action will not be completed.
 */
'beforeTrimRow',
/**
 * Fired by {@link TrimRows} plugin after trimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
 *
 * @event Hooks#afterTrimRow
 * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
 * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
 * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
 * @param {boolean} stateChanged `true`, if the action affected any non-trimmed rows, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the trimming action will not be completed.
 */
'afterTrimRow',
/**
 * Fired by {@link TrimRows} plugin before untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
 *
 * @event Hooks#beforeUntrimRow
 * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
 * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
 * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the untrimming action will not be completed.
 */
'beforeUntrimRow',
/**
 * Fired by {@link TrimRows} plugin after untrimming rows. This hook is fired when {@link Options#trimRows} option is enabled.
 *
 * @event Hooks#afterUntrimRow
 * @param {Array} currentTrimConfig Current trim configuration - a list of trimmed physical row indexes.
 * @param {Array} destinationTrimConfig Destination trim configuration - a list of trimmed physical row indexes.
 * @param {boolean} actionPossible `true`, if all of the row indexes are withing the bounds of the table, `false` otherwise.
 * @param {boolean} stateChanged `true`, if the action affected any trimmed rows, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the untrimming action will not be completed.
 */
'afterUntrimRow',
/**
 * Fired by {@link DropdownMenu} plugin before opening the dropdown menu. This hook is fired when {@link Options#dropdownMenu}
 * option is enabled.
 *
 * @event Hooks#beforeDropdownMenuShow
 * @param {DropdownMenu} dropdownMenu The `DropdownMenu` instance.
 */
'beforeDropdownMenuShow',
/**
 * Fired by {@link DropdownMenu} plugin after opening the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}
 * option is enabled.
 *
 * @event Hooks#afterDropdownMenuShow
 * @param {DropdownMenu} dropdownMenu The `DropdownMenu` instance.
 */
'afterDropdownMenuShow',
/**
 * Fired by {@link DropdownMenu} plugin after hiding the Dropdown Menu. This hook is fired when {@link Options#dropdownMenu}
 * option is enabled.
 *
 * @event Hooks#afterDropdownMenuHide
 * @param {DropdownMenu} instance The `DropdownMenu` instance.
 */
'afterDropdownMenuHide',
/**
 * Fired by {@link NestedRows} plugin before adding a children to the `NestedRows` structure. This hook is fired when
 * {@link Options#nestedRows} option is enabled.
 *
 * @event Hooks#beforeAddChild
 * @param {object} parent The parent object.
 * @param {object|undefined} element The element added as a child. If `undefined`, a blank child was added.
 * @param {number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.
 */
'beforeAddChild',
/**
 * Fired by {@link NestedRows} plugin after adding a children to the `NestedRows` structure. This hook is fired when
 * {@link Options#nestedRows} option is enabled.
 *
 * @event Hooks#afterAddChild
 * @param {object} parent The parent object.
 * @param {object|undefined} element The element added as a child. If `undefined`, a blank child was added.
 * @param {number|undefined} index The index within the parent where the new child was added. If `undefined`, the element was added as the last child.
 */
'afterAddChild',
/**
 * Fired by {@link NestedRows} plugin before detaching a child from its parent. This hook is fired when
 * {@link Options#nestedRows} option is enabled.
 *
 * @event Hooks#beforeDetachChild
 * @param {object} parent An object representing the parent from which the element is to be detached.
 * @param {object} element The detached element.
 */
'beforeDetachChild',
/**
 * Fired by {@link NestedRows} plugin after detaching a child from its parent. This hook is fired when
 * {@link Options#nestedRows} option is enabled.
 *
 * @event Hooks#afterDetachChild
 * @param {object} parent An object representing the parent from which the element was detached.
 * @param {object} element The detached element.
 * @param {number} finalElementPosition The final row index of the detached element.
 */
'afterDetachChild',
/**
 * Fired before the editor is opened and rendered.
 *
 * @since 14.2.0
 * @event Hooks#beforeBeginEditing
 * @param {number} row Visual row index of the edited cell.
 * @param {number} column Visual column index of the edited cell.
 * @param {*} initialValue The initial editor value.
 * @param {MouseEvent | KeyboardEvent} event The event which was responsible for opening the editor.
 * @param {boolean} fullEditMode `true` if the editor is opened in full edit mode, `false` otherwise.
 * Editor opened in full edit mode does not close after pressing Arrow keys.
 * @returns {boolean | undefined} If the callback returns `false,` the editor won't be opened after
 * the mouse double click or after pressing the Enter key. Returning `undefined` (or other value
 * than boolean) will result in default behavior, which disallows opening an editor for non-contiguous
 * selection (while pressing Ctrl/Cmd) and for multiple selected cells (while pressing SHIFT).
 * Returning `true` removes those restrictions.
 */
'beforeBeginEditing',
/**
 * Fired after the editor is opened and rendered.
 *
 * @event Hooks#afterBeginEditing
 * @param {number} row Visual row index of the edited cell.
 * @param {number} column Visual column index of the edited cell.
 */
'afterBeginEditing',
/**
 * Fired by {@link MergeCells} plugin before cell merging. This hook is fired when {@link Options#mergeCells}
 * option is enabled.
 *
 * @event Hooks#beforeMergeCells
 * @param {CellRange} cellRange Selection cell range.
 * @param {boolean} [auto=false] `true` if called automatically by the plugin.
 */
'beforeMergeCells',
/**
 * Fired by {@link MergeCells} plugin after cell merging. This hook is fired when {@link Options#mergeCells}
 * option is enabled.
 *
 * @event Hooks#afterMergeCells
 * @param {CellRange} cellRange Selection cell range.
 * @param {object} mergeParent The parent collection of the provided cell range.
 * @param {boolean} [auto=false] `true` if called automatically by the plugin.
 */
'afterMergeCells',
/**
 * Fired by {@link MergeCells} plugin before unmerging the cells. This hook is fired when {@link Options#mergeCells}
 * option is enabled.
 *
 * @event Hooks#beforeUnmergeCells
 * @param {CellRange} cellRange Selection cell range.
 * @param {boolean} [auto=false] `true` if called automatically by the plugin.
 */
'beforeUnmergeCells',
/**
 * Fired by {@link MergeCells} plugin after unmerging the cells. This hook is fired when {@link Options#mergeCells}
 * option is enabled.
 *
 * @event Hooks#afterUnmergeCells
 * @param {CellRange} cellRange Selection cell range.
 * @param {boolean} [auto=false] `true` if called automatically by the plugin.
 */
'afterUnmergeCells',
/**
 * Fired after the table was switched into listening mode. This allows Handsontable to capture keyboard events and
 * respond in the right way.
 *
 * @event Hooks#afterListen
 */
'afterListen',
/**
 * Fired after the table was switched off from the listening mode. This makes the Handsontable inert for any
 * keyboard events.
 *
 * @event Hooks#afterUnlisten
 */
'afterUnlisten',
/**
 * Fired after the window was resized or the size of the Handsontable root element was changed.
 *
 * @event Hooks#afterRefreshDimensions
 * @param {{ width: number, height: number }} previousDimensions Previous dimensions of the container.
 * @param {{ width: number, height: number }} currentDimensions Current dimensions of the container.
 * @param {boolean} stateChanged `true`, if the container was re-render, `false` otherwise.
 */
'afterRefreshDimensions',
/**
 * Cancellable hook, called after resizing a window or after detecting size change of the
 * Handsontable root element, but before redrawing a table.
 *
 * @event Hooks#beforeRefreshDimensions
 * @param {{ width: number, height: number }} previousDimensions Previous dimensions of the container.
 * @param {{ width: number, height: number }} currentDimensions Current dimensions of the container.
 * @param {boolean} actionPossible `true`, if current and previous dimensions are different, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the refresh action will not be completed.
 */
'beforeRefreshDimensions',
/**
 * Fired by {@link CollapsibleColumns} plugin before columns collapse. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
 *
 * @event Hooks#beforeColumnCollapse
 * @since 8.0.0
 * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
 * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
 * @param {boolean} collapsePossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the collapsing action will not be completed.
 */
'beforeColumnCollapse',
/**
 * Fired by {@link CollapsibleColumns} plugin before columns collapse. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
 *
 * @event Hooks#afterColumnCollapse
 * @since 8.0.0
 * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
 * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
 * @param {boolean} collapsePossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
 * @param {boolean} successfullyCollapsed `true`, if the action affected any non-collapsible column, `false` otherwise.
 */
'afterColumnCollapse',
/**
 * Fired by {@link CollapsibleColumns} plugin before columns expand. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
 *
 * @event Hooks#beforeColumnExpand
 * @since 8.0.0
 * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
 * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
 * @param {boolean} expandPossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
 * @returns {undefined|boolean} If the callback returns `false`, the expanding action will not be completed.
 */
'beforeColumnExpand',
/**
 * Fired by {@link CollapsibleColumns} plugin before columns expand. This hook is fired when {@link Options#collapsibleColumns} option is enabled.
 *
 * @event Hooks#afterColumnExpand
 * @since 8.0.0
 * @param {Array} currentCollapsedColumns Current collapsible configuration - a list of collapsible physical column indexes.
 * @param {Array} destinationCollapsedColumns Destination collapsible configuration - a list of collapsible physical column indexes.
 * @param {boolean} expandPossible `true`, if all of the column indexes are withing the bounds of the collapsed sections, `false` otherwise.
 * @param {boolean} successfullyExpanded `true`, if the action affected any non-collapsible column, `false` otherwise.
 */
'afterColumnExpand',
/**
 * Fired by {@link AutoColumnSize} plugin within SampleGenerator utility.
 *
 * @event Hooks#modifyAutoColumnSizeSeed
 * @since 8.4.0
 * @param {string|undefined} seed Seed ID, unique name to categorize samples.
 * @param {object} cellProperties Object containing the cell properties.
 * @param {*} cellValue Value of the cell.
 */
'modifyAutoColumnSizeSeed'];

/**
 * The list of the hooks which are removed from the API. The warning message is printed out in
 * the developer console when the hook is used.
 *
 * The Map key is represented by hook name and its value points to the Handsontable version
 * in which it was removed.
 *
 * @type {Map<string, string>}
 */
const REMOVED_HOOKS = exports.REMOVED_HOOKS = new Map([['modifyRow', '8.0.0'], ['modifyCol', '8.0.0'], ['unmodifyRow', '8.0.0'], ['unmodifyCol', '8.0.0'], ['skipLengthCache', '8.0.0'], ['hiddenColumn', '8.0.0'], ['hiddenRow', '8.0.0']]);

/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * The list of the hooks which are deprecated. The warning message is printed out in
 * the developer console when the hook is used.
 *
 * The Map key is represented by hook name and its value keeps message which whould be
 * printed out when the hook is used.
 *
 * Usage:
 * ```js
 * ...
 * New Map([
 *   ['beforeColumnExpand', 'The plugin hook "beforeColumnExpand" is deprecated. Use "beforeColumnExpand2" instead.'],
 * ])
 * ...
 * ```
 *
 *
 * @type {Map<string, string>}
 */
/* eslint-enable jsdoc/require-description-complete-sentence */
const DEPRECATED_HOOKS = exports.DEPRECATED_HOOKS = new Map([[]]);

/***/ }),
/* 514 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(515);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(323);
__webpack_require__(519);
__webpack_require__(329);
var _constants = __webpack_require__(513);
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @typedef {object} HookEntry
 * @property {Function} callback The callback function.
 * @property {number} orderIndex The order index.
 * @property {boolean} runOnce Indicates if the hook should run only once.
 * @property {boolean} initialHook Indicates if it is an initial hook - which means that the hook
 * always stays at the same index position even after update.
 * @property {boolean} skip Indicates if the hook was removed.
 */
/**
 * The maximum number of hooks that can be skipped before the bucket is cleaned up.
 */
const MAX_SKIPPED_HOOKS_COUNT = 100;

/**
 * The class represents a collection that allows to manage hooks (add, remove).
 *
 * @class HooksBucket
 */
var _hooks = /*#__PURE__*/new WeakMap();
var _skippedHooksCount = /*#__PURE__*/new WeakMap();
var _needsSort = /*#__PURE__*/new WeakMap();
var _HooksBucket_brand = /*#__PURE__*/new WeakSet();
class HooksBucket {
  constructor() {
    /**
     * Creates a initial collection for the provided hook name.
     *
     * @param {string} hookName The name of the hook.
     */
    _classPrivateMethodInitSpec(this, _HooksBucket_brand);
    /**
     * A map that stores hooks.
     *
     * @type {Map<string, HookEntry>}
     */
    _classPrivateFieldInitSpec(this, _hooks, new Map());
    /**
     * A map that stores the number of skipped hooks.
     */
    _classPrivateFieldInitSpec(this, _skippedHooksCount, new Map());
    /**
     * A set that stores hook names that need to be re-sorted.
     */
    _classPrivateFieldInitSpec(this, _needsSort, new Set());
    _constants.REGISTERED_HOOKS.forEach(hookName => _assertClassBrand(_HooksBucket_brand, this, _createHooksCollection).call(this, hookName));
  }

  /**
   * Gets all hooks for the provided hook name.
   *
   * @param {string} hookName The name of the hook.
   * @returns {HookEntry[]}
   */
  getHooks(hookName) {
    var _classPrivateFieldGet2;
    return (_classPrivateFieldGet2 = _classPrivateFieldGet(_hooks, this).get(hookName)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : [];
  }

  /**
   * Adds a new hook to the collection.
   *
   * @param {string} hookName The name of the hook.
   * @param {Function} callback The callback function to add.
   * @param {{ orderIndex?: number, runOnce?: boolean, initialHook?: boolean }} options The options object.
   */
  add(hookName, callback) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!_classPrivateFieldGet(_hooks, this).has(hookName)) {
      _assertClassBrand(_HooksBucket_brand, this, _createHooksCollection).call(this, hookName);
      _constants.REGISTERED_HOOKS.push(hookName);
    }
    const hooks = _classPrivateFieldGet(_hooks, this).get(hookName);
    if (hooks.find(hook => hook.callback === callback)) {
      // adding the same hook twice is now silently ignored
      return;
    }
    const orderIndex = Number.isInteger(options.orderIndex) ? options.orderIndex : 0;
    const runOnce = !!options.runOnce;
    const initialHook = !!options.initialHook;
    let foundInitialHook = false;
    if (initialHook) {
      const initialHookEntry = hooks.find(hook => hook.initialHook);
      if (initialHookEntry) {
        initialHookEntry.callback = callback;
        foundInitialHook = true;
      }
    }
    if (!foundInitialHook) {
      hooks.push({
        callback,
        orderIndex,
        runOnce,
        initialHook,
        skip: false
      });
      let needsSort = _classPrivateFieldGet(_needsSort, this).has(hookName);
      if (!needsSort && orderIndex !== 0) {
        needsSort = true;
        _classPrivateFieldGet(_needsSort, this).add(hookName);
      }
      if (needsSort && hooks.length > 1) {
        _classPrivateFieldGet(_hooks, this).set(hookName, hooks.toSorted((a, b) => a.orderIndex - b.orderIndex));
      }
    }
  }

  /**
   * Checks if there are any hooks for the provided hook name.
   *
   * @param {string} hookName The name of the hook.
   * @returns {boolean}
   */
  has(hookName) {
    return _classPrivateFieldGet(_hooks, this).has(hookName) && _classPrivateFieldGet(_hooks, this).get(hookName).length > 0;
  }

  /**
   * Removes a hook from the collection. If the hook was found and removed,
   * the method returns `true`, otherwise `false`.
   *
   * @param {string} hookName The name of the hook.
   * @param {*} callback The callback function to remove.
   * @returns {boolean}
   */
  remove(hookName, callback) {
    if (!_classPrivateFieldGet(_hooks, this).has(hookName)) {
      return false;
    }
    const hooks = _classPrivateFieldGet(_hooks, this).get(hookName);
    const hookEntry = hooks.find(hook => hook.callback === callback);
    if (hookEntry) {
      let skippedHooksCount = _classPrivateFieldGet(_skippedHooksCount, this).get(hookName);
      hookEntry.skip = true;
      skippedHooksCount += 1;
      if (skippedHooksCount > MAX_SKIPPED_HOOKS_COUNT) {
        _classPrivateFieldGet(_hooks, this).set(hookName, hooks.filter(hook => !hook.skip));
        skippedHooksCount = 0;
      }
      _classPrivateFieldGet(_skippedHooksCount, this).set(hookName, skippedHooksCount);
      return true;
    }
    return false;
  }

  /**
   * Destroys the bucket.
   */
  destroy() {
    _classPrivateFieldGet(_hooks, this).clear();
    _classPrivateFieldGet(_skippedHooksCount, this).clear();
    _classPrivateFieldSet(_hooks, this, null);
    _classPrivateFieldSet(_skippedHooksCount, this, null);
  }
}
exports.HooksBucket = HooksBucket;
function _createHooksCollection(hookName) {
  _classPrivateFieldGet(_hooks, this).set(hookName, []);
  _classPrivateFieldGet(_skippedHooksCount, this).set(hookName, 0);
}

/***/ }),
/* 515 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var uncurryThis = __webpack_require__(213);
var aCallable = __webpack_require__(229);
var toIndexedObject = __webpack_require__(211);
var arrayFromConstructorAndList = __webpack_require__(516);
var getBuiltInPrototypeMethod = __webpack_require__(517);
var addToUnscopables = __webpack_require__(518);

var $Array = Array;
var sort = uncurryThis(getBuiltInPrototypeMethod('Array', 'sort'));

// `Array.prototype.toSorted` method
// https://tc39.es/ecma262/#sec-array.prototype.tosorted
$({ target: 'Array', proto: true }, {
  toSorted: function toSorted(compareFn) {
    if (compareFn !== undefined) aCallable(compareFn);
    var O = toIndexedObject(this);
    var A = arrayFromConstructorAndList($Array, O);
    return sort(A, compareFn);
  }
});

addToUnscopables('toSorted');


/***/ }),
/* 516 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var lengthOfArrayLike = __webpack_require__(262);

module.exports = function (Constructor, list, $length) {
  var index = 0;
  var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
  var result = new Constructor(length);
  while (length > index) result[index] = list[index++];
  return result;
};


/***/ }),
/* 517 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(203);

module.exports = function (CONSTRUCTOR, METHOD) {
  var Constructor = globalThis[CONSTRUCTOR];
  var Prototype = Constructor && Constructor.prototype;
  return Prototype && Prototype[METHOD];
};


/***/ }),
/* 518 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(232);
var create = __webpack_require__(319);
var defineProperty = (__webpack_require__(243).f);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] === undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),
/* 519 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(520);


/***/ }),
/* 520 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var iterate = __webpack_require__(331);
var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var getIteratorDirect = __webpack_require__(296);

// `Iterator.prototype.find` method
// https://tc39.es/ecma262/#sec-iterator.prototype.find
$({ target: 'Iterator', proto: true, real: true }, {
  find: function find(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return iterate(record, function (value, stop) {
      if (predicate(value, counter++)) return stop(value);
    }, { IS_RECORD: true, INTERRUPTED: true }).result;
  }
});


/***/ }),
/* 521 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = staticRegister;
const collection = exports.collection = new Map();

/**
 * @param {string} namespace The namespace for the storage.
 * @returns {object}
 */
function staticRegister() {
  let namespace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'common';
  if (!collection.has(namespace)) {
    collection.set(namespace, new Map());
  }
  const subCollection = collection.get(namespace);

  /**
   * Register an item to the collection. If the item under the same was exist earlier then this item will be replaced with new one.
   *
   * @param {string} name Identification of the item.
   * @param {*} item Item to save in the collection.
   */
  function register(name, item) {
    subCollection.set(name, item);
  }

  /**
   * Retrieve the item from the collection.
   *
   * @param {string} name Identification of the item.
   * @returns {*} Returns item which was saved in the collection.
   */
  function getItem(name) {
    return subCollection.get(name);
  }

  /**
   * Check if item under specified name is exists.
   *
   * @param {string} name Identification of the item.
   * @returns {boolean} Returns `true` or `false` depends on if element exists in the collection.
   */
  function hasItem(name) {
    return subCollection.has(name);
  }

  /**
   * Retrieve list of names registered from the collection.
   *
   * @returns {Array} Returns an array of strings with all names under which objects are stored.
   */
  function getNames() {
    return [...subCollection.keys()];
  }

  /**
   * Retrieve all registered values from the collection.
   *
   * @returns {Array} Returns an array with all values stored in the collection.
   */
  function getValues() {
    return [...subCollection.values()];
  }
  return {
    register,
    getItem,
    hasItem,
    getNames,
    getValues
  };
}

/***/ }),
/* 522 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.getListenersCounter = getListenersCounter;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _event = __webpack_require__(509);
/**
 * Counter which tracks unregistered listeners (useful for detecting memory leaks).
 *
 * @type {number}
 */
let listenersCounter = 0;

/**
 * Event DOM manager for internal use in Handsontable.
 *
 * @class EventManager
 */
class EventManager {
  /**
   * @param {object} [context=null] An object to which event listeners will be stored.
   * @private
   */
  constructor() {
    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    /**
     * @type {object}
     */
    (0, _defineProperty2.default)(this, "context", void 0);
    this.context = context || this;

    // TODO it modify external object. Rethink that.
    if (!this.context.eventListeners) {
      this.context.eventListeners = []; // TODO perf It would be more performant if every instance of EventManager tracked its own listeners only
    }
  }

  /**
   * Register specified listener (`eventName`) to the element.
   *
   * @param {Element} element Target element.
   * @param {string} eventName Event name.
   * @param {Function} callback Function which will be called after event occur.
   * @param {AddEventListenerOptions|boolean} [options] Listener options if object or useCapture if boolean.
   * @returns {Function} Returns function which you can easily call to remove that event.
   */
  addEventListener(element, eventName, callback) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    /**
     * @private
     * @param {Event} event The event object.
     */
    function callbackProxy(event) {
      callback.call(this, extendEvent(event));
    }
    this.context.eventListeners.push({
      element,
      event: eventName,
      callback,
      callbackProxy,
      options,
      eventManager: this
    });
    element.addEventListener(eventName, callbackProxy, options);
    listenersCounter += 1;
    return () => {
      this.removeEventListener(element, eventName, callback);
    };
  }

  /**
   * Remove the event listener previously registered.
   *
   * @param {Element} element Target element.
   * @param {string} eventName Event name.
   * @param {Function} callback Function to remove from the event target. It must be the same as during registration listener.
   * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.
   */
  removeEventListener(element, eventName, callback) {
    let onlyOwnEvents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    let len = this.context.eventListeners.length;
    let tmpEvent;
    while (len) {
      len -= 1;
      tmpEvent = this.context.eventListeners[len];
      if (tmpEvent.event === eventName && tmpEvent.element === element) {
        if (callback && callback !== tmpEvent.callback) {
          /* eslint-disable no-continue */
          continue;
        }
        // TODO rethink that, main bulk is that it needs multi instances to handle same context, but with a different scopes.
        // TODO I suppose much more efficient way will be comparing string with scope id, or any similar approach.
        if (onlyOwnEvents && tmpEvent.eventManager !== this) {
          continue;
        }
        this.context.eventListeners.splice(len, 1);
        tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, tmpEvent.options);
        listenersCounter -= 1;
      }
    }
  }

  /**
   * Clear all previously registered events.
   *
   * @private
   * @since 0.15.0-beta3
   * @param {boolean} [onlyOwnEvents] Whether whould remove only events registered using this instance of EventManager.
   */
  clearEvents() {
    let onlyOwnEvents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!this.context) {
      return;
    }
    let len = this.context.eventListeners.length;
    while (len) {
      len -= 1;
      const event = this.context.eventListeners[len];
      if (onlyOwnEvents && event.eventManager !== this) {
        continue;
      }
      this.context.eventListeners.splice(len, 1);
      event.element.removeEventListener(event.event, event.callbackProxy, event.options);
      listenersCounter -= 1;
    }
  }

  /**
   * Clear all previously registered events.
   */
  clear() {
    this.clearEvents();
  }

  /**
   * Destroy instance of EventManager, clearing all events of the context.
   */
  destroy() {
    this.clearEvents();
    this.context = null;
  }

  /**
   * Destroy instance of EventManager, clearing only the own events.
   */
  destroyWithOwnEventsOnly() {
    this.clearEvents(true);
    this.context = null;
  }

  /**
   * Trigger event at the specified target element.
   *
   * @param {Element} element Target element.
   * @param {string} eventName Event name.
   */
  fireEvent(element, eventName) {
    let rootDocument = element.document;
    let rootWindow = element;
    if (!rootDocument) {
      rootDocument = element.ownerDocument ? element.ownerDocument : element;
      rootWindow = rootDocument.defaultView;
    }
    const options = {
      bubbles: true,
      cancelable: eventName !== 'mousemove',
      view: rootWindow,
      detail: 0,
      screenX: 0,
      screenY: 0,
      clientX: 1,
      clientY: 1,
      ctrlKey: false,
      altKey: false,
      shiftKey: false,
      metaKey: false,
      button: 0,
      relatedTarget: undefined
    };
    let event;
    if (rootDocument.createEvent) {
      event = rootDocument.createEvent('MouseEvents');
      event.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget || rootDocument.body.parentNode);
    } else {
      event = rootDocument.createEventObject();
    }
    if (element.dispatchEvent) {
      element.dispatchEvent(event);
    } else {
      element.fireEvent(`on${eventName}`, event);
    }
  }
}

/**
 * @private
 * @param {Event} event The event object.
 * @returns {Event}
 */
function extendEvent(event) {
  const nativeStopImmediatePropagation = event.stopImmediatePropagation;
  event.stopImmediatePropagation = function () {
    nativeStopImmediatePropagation.apply(this);
    (0, _event.stopImmediatePropagation)(this);
  };
  return event;
}
var _default = exports["default"] = EventManager;
/**
 * @private
 * @returns {number}
 */
function getListenersCounter() {
  return listenersCounter;
}

/***/ }),
/* 523 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(201);
var _console = __webpack_require__(512);
var _element = __webpack_require__(351);
var _function = __webpack_require__(497);
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Possible focus modes.
 * - CELL - The browser's focus stays on the lastly selected cell element.
 * - MIXED - The browser's focus switches from the lastly selected cell element to the currently active editor's
 * `TEXTAREA` element after a delay defined in the manager.
 *
 * @type {{CELL: string, MIXED: string}}
 */
const FOCUS_MODES = Object.freeze({
  CELL: 'cell',
  MIXED: 'mixed'
});

/**
 * Manages the browser's focus in the table.
 */
var _hot = /*#__PURE__*/new WeakMap();
var _focusMode = /*#__PURE__*/new WeakMap();
var _refocusDelay = /*#__PURE__*/new WeakMap();
var _refocusElementGetter = /*#__PURE__*/new WeakMap();
var _debouncedSelect = /*#__PURE__*/new WeakMap();
var _FocusManager_brand = /*#__PURE__*/new WeakSet();
class FocusManager {
  constructor(hotInstance) {
    var _this = this;
    /**
     * Get and return the currently selected and highlighted cell/header element.
     *
     * @param {Function} callback Callback function to be called after the cell element is retrieved.
     */
    _classPrivateMethodInitSpec(this, _FocusManager_brand);
    /**
     * The Handsontable instance.
     */
    _classPrivateFieldInitSpec(this, _hot, void 0);
    /**
     * The currently enabled focus mode.
     * Can be either:
     *
     * - 'cell' - The browser's focus stays on the lastly selected cell element.
     * - 'mixed' - The browser's focus switches from the lastly selected cell element to the currently active editor's
     * `TEXTAREA` element after a delay defined in the manager.
     *
     * @type {'cell' | 'mixed'}
     */
    _classPrivateFieldInitSpec(this, _focusMode, void 0);
    /**
     * The delay after which the focus switches from the lastly selected cell to the active editor's `TEXTAREA`
     * element if the focus mode is set to 'mixed'.
     *
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _refocusDelay, 1);
    /**
     * Getter function for the element to be used when refocusing the browser after a delay. If `null`, the active
     * editor's `TEXTAREA` element will be used.
     *
     * @type {null|Function}
     */
    _classPrivateFieldInitSpec(this, _refocusElementGetter, null);
    /**
     * Map of the debounced `select` functions.
     *
     * @type {Map<number, Function>}
     */
    _classPrivateFieldInitSpec(this, _debouncedSelect, new Map());
    const hotSettings = hotInstance.getSettings();
    _classPrivateFieldSet(_hot, this, hotInstance);
    _classPrivateFieldSet(_focusMode, this, hotSettings.imeFastEdit ? FOCUS_MODES.MIXED : FOCUS_MODES.CELL);
    _classPrivateFieldGet(_hot, this).addHook('afterUpdateSettings', function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _assertClassBrand(_FocusManager_brand, _this, _onUpdateSettings).call(_this, ...args);
    });
    _classPrivateFieldGet(_hot, this).addHook('afterSelection', function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _assertClassBrand(_FocusManager_brand, _this, _focusCell).call(_this, ...args);
    });
    _classPrivateFieldGet(_hot, this).addHook('afterSelectionFocusSet', function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _assertClassBrand(_FocusManager_brand, _this, _focusCell).call(_this, ...args);
    });
    _classPrivateFieldGet(_hot, this).addHook('afterSelectionEnd', function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _assertClassBrand(_FocusManager_brand, _this, _focusEditorElement).call(_this, ...args);
    });
  }

  /**
   * Get the current focus mode.
   *
   * @returns {'cell' | 'mixed'}
   */
  getFocusMode() {
    return _classPrivateFieldGet(_focusMode, this);
  }

  /**
   * Set the focus mode.
   *
   * @param {'cell' | 'mixed'} focusMode The new focus mode.
   */
  setFocusMode(focusMode) {
    if (Object.values(FOCUS_MODES).includes(focusMode)) {
      _classPrivateFieldSet(_focusMode, this, focusMode);
    } else {
      (0, _console.warn)(`"${focusMode}" is not a valid focus mode.`);
    }
  }

  /**
   * Get the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`
   * element if the focus mode is set to 'mixed'.
   *
   * @returns {number} Delay in milliseconds.
   */
  getRefocusDelay() {
    return _classPrivateFieldGet(_refocusDelay, this);
  }

  /**
   * Set the delay after which the focus will change from the cell elements to the active editor's `TEXTAREA`
   * element if the focus mode is set to 'mixed'.
   *
   * @param {number} delay Delay in milliseconds.
   */
  setRefocusDelay(delay) {
    _classPrivateFieldSet(_refocusDelay, this, delay);
  }

  /**
   * Set the function to be used as the "refocus element" getter. It should return a focusable HTML element.
   *
   * @param {Function} getRefocusElementFunction The refocus element getter.
   */
  setRefocusElementGetter(getRefocusElementFunction) {
    _classPrivateFieldSet(_refocusElementGetter, this, getRefocusElementFunction);
  }

  /**
   * Get the element to be used when refocusing the browser after a delay in case of the focus mode being 'mixed'.
   *
   * @returns {HTMLTextAreaElement|HTMLElement|undefined}
   */
  getRefocusElement() {
    var _classPrivateFieldGet2;
    if (typeof _classPrivateFieldGet(_refocusElementGetter, this) === 'function') {
      return _classPrivateFieldGet(_refocusElementGetter, this).call(this);
    }
    return (_classPrivateFieldGet2 = _classPrivateFieldGet(_hot, this).getActiveEditor()) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.TEXTAREA;
  }

  /**
   * Set the browser's focus to the highlighted cell of the last selection.
   *
   * @param {HTMLTableCellElement} [selectedCell] The highlighted cell/header element.
   */
  focusOnHighlightedCell(selectedCell) {
    const focusElement = element => {
      var _classPrivateFieldGet3, _classPrivateFieldGet4;
      const currentHighlightCoords = (_classPrivateFieldGet3 = _classPrivateFieldGet(_hot, this).getSelectedRangeLast()) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.highlight;
      if (!currentHighlightCoords) {
        return;
      }
      let elementToBeFocused = _classPrivateFieldGet(_hot, this).runHooks('modifyFocusedElement', currentHighlightCoords.row, currentHighlightCoords.col, element);
      if (!(elementToBeFocused instanceof HTMLElement)) {
        elementToBeFocused = element;
      }
      if (elementToBeFocused && !((_classPrivateFieldGet4 = _classPrivateFieldGet(_hot, this).getActiveEditor()) !== null && _classPrivateFieldGet4 !== void 0 && _classPrivateFieldGet4.isOpened())) {
        elementToBeFocused.focus({
          preventScroll: true
        });
      }
    };
    if (selectedCell) {
      focusElement(selectedCell);
    } else {
      _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, element => focusElement(element));
    }
  }

  /**
   * Set the focus to the active editor's `TEXTAREA` element after the provided delay. If no delay is provided, it
   * will be taken from the manager's configuration.
   *
   * @param {number} [delay] Delay in milliseconds.
   */
  refocusToEditorTextarea() {
    var _classPrivateFieldGet5;
    let delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _classPrivateFieldGet(_refocusDelay, this);
    // Re-focus on the editor's `TEXTAREA` element (or a predefined element) if the `imeFastEdit` option is enabled.
    if (_classPrivateFieldGet(_hot, this).getSettings().imeFastEdit && !((_classPrivateFieldGet5 = _classPrivateFieldGet(_hot, this).getActiveEditor()) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.isOpened())) {
      if (!_classPrivateFieldGet(_debouncedSelect, this).has(delay)) {
        _classPrivateFieldGet(_debouncedSelect, this).set(delay, (0, _function.debounce)(() => {
          var _this$getRefocusEleme;
          (_this$getRefocusEleme = this.getRefocusElement()) === null || _this$getRefocusEleme === void 0 || _this$getRefocusEleme.select();
        }, delay));
      }
      _classPrivateFieldGet(_debouncedSelect, this).get(delay)();
    }
  }
}
exports.FocusManager = FocusManager;
function _getSelectedCell(callback) {
  var _classPrivateFieldGet6;
  const highlight = (_classPrivateFieldGet6 = _classPrivateFieldGet(_hot, this).getSelectedRangeLast()) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.highlight;
  if (!highlight || !_classPrivateFieldGet(_hot, this).selection.isCellVisible(highlight)) {
    callback(null);
    return;
  }
  const cell = _classPrivateFieldGet(_hot, this).getCell(highlight.row, highlight.col, true);
  if (cell === null) {
    _classPrivateFieldGet(_hot, this).addHookOnce('afterScroll', () => {
      callback(_classPrivateFieldGet(_hot, this).getCell(highlight.row, highlight.col, true));
    });
  } else {
    callback(cell);
  }
}
/**
 * Manage the browser's focus after each cell selection change.
 */
function _focusCell() {
  _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, selectedCell => {
    const {
      activeElement
    } = _classPrivateFieldGet(_hot, this).rootDocument;

    // Blurring the `activeElement` removes the unwanted border around the focusable element (#6877)
    // and resets the `document.activeElement` property. The blurring should happen only when the
    // previously selected input element has not belonged to the Handsontable editor. If blurring is
    // triggered for all elements, there is a problem with the disappearing IME editor (#9672).
    if (activeElement && (0, _element.isOutsideInput)(activeElement)) {
      activeElement.blur();
    }
    this.focusOnHighlightedCell(selectedCell);
  });
}
/**
 * Manage the browser's focus after cell selection end.
 */
function _focusEditorElement() {
  _assertClassBrand(_FocusManager_brand, this, _getSelectedCell).call(this, selectedCell => {
    if (this.getFocusMode() === FOCUS_MODES.MIXED && selectedCell.nodeName === 'TD') {
      this.refocusToEditorTextarea();
    }
  });
}
/**
 * Update the manager configuration after calling `updateSettings`.
 *
 * @param {object} newSettings The new settings passed to the `updateSettings` method.
 */
function _onUpdateSettings(newSettings) {
  if (typeof newSettings.imeFastEdit === 'boolean') {
    this.setFocusMode(newSettings.imeFastEdit ? FOCUS_MODES.MIXED : FOCUS_MODES.CELL);
  }
}

/***/ }),
/* 524 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports._dataToHTML = _dataToHTML;
exports.htmlToGridSettings = htmlToGridSettings;
exports.instanceToHTML = instanceToHTML;
__webpack_require__(283);
__webpack_require__(525);
__webpack_require__(311);
__webpack_require__(323);
__webpack_require__(338);
__webpack_require__(530);
var _mixed = __webpack_require__(354);
const ESCAPED_HTML_CHARS = {
  '&nbsp;': '\x20',
  '&amp;': '&',
  '&lt;': '<',
  '&gt;': '>'
};
const regEscapedChars = new RegExp(Object.keys(ESCAPED_HTML_CHARS).map(key => `(${key})`).join('|'), 'gi');

/**
 * Verifies if node is an HTMLTable element.
 *
 * @param {Node} element Node to verify if it's an HTMLTable.
 * @returns {boolean}
 */
function isHTMLTable(element) {
  return (element && element.nodeName || '') === 'TABLE';
}

/**
 * Converts Handsontable into HTMLTableElement.
 *
 * @param {Core} instance The Handsontable instance.
 * @returns {string} OuterHTML of the HTMLTableElement.
 */
function instanceToHTML(instance) {
  const hasColumnHeaders = instance.hasColHeaders();
  const hasRowHeaders = instance.hasRowHeaders();
  const coords = [hasColumnHeaders ? -1 : 0, hasRowHeaders ? -1 : 0, instance.countRows() - 1, instance.countCols() - 1];
  const data = instance.getData(...coords);
  const countRows = data.length;
  const countCols = countRows > 0 ? data[0].length : 0;
  const TABLE = ['<table>', '</table>'];
  const THEAD = hasColumnHeaders ? ['<thead>', '</thead>'] : [];
  const TBODY = ['<tbody>', '</tbody>'];
  const rowModifier = hasRowHeaders ? 1 : 0;
  const columnModifier = hasColumnHeaders ? 1 : 0;
  for (let row = 0; row < countRows; row += 1) {
    const isColumnHeadersRow = hasColumnHeaders && row === 0;
    const CELLS = [];
    for (let column = 0; column < countCols; column += 1) {
      const isRowHeadersColumn = !isColumnHeadersRow && hasRowHeaders && column === 0;
      let cell = '';
      if (isColumnHeadersRow) {
        cell = `<th>${instance.getColHeader(column - rowModifier)}</th>`;
      } else if (isRowHeadersColumn) {
        cell = `<th>${instance.getRowHeader(row - columnModifier)}</th>`;
      } else {
        const cellData = data[row][column];
        const {
          hidden,
          rowspan,
          colspan
        } = instance.getCellMeta(row - columnModifier, column - rowModifier);
        if (!hidden) {
          const attrs = [];
          if (rowspan) {
            attrs.push(`rowspan="${rowspan}"`);
          }
          if (colspan) {
            attrs.push(`colspan="${colspan}"`);
          }
          if ((0, _mixed.isEmpty)(cellData)) {
            cell = `<td ${attrs.join(' ')}></td>`;
          } else {
            const value = cellData.toString().replace('<', '&lt;').replace('>', '&gt;').replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, '<br>\r\n').replace(/\x20/gi, '&nbsp;').replace(/\t/gi, '&#9;');
            cell = `<td ${attrs.join(' ')}>${value}</td>`;
          }
        }
      }
      CELLS.push(cell);
    }
    const TR = ['<tr>', ...CELLS, '</tr>'].join('');
    if (isColumnHeadersRow) {
      THEAD.splice(1, 0, TR);
    } else {
      TBODY.splice(-1, 0, TR);
    }
  }
  TABLE.splice(1, 0, THEAD.join(''), TBODY.join(''));
  return TABLE.join('');
}

/**
 * Converts 2D array into HTMLTableElement.
 *
 * @param {Array} input Input array which will be converted to HTMLTable.
 * @returns {string} OuterHTML of the HTMLTableElement.
 */
// eslint-disable-next-line no-restricted-globals
function _dataToHTML(input) {
  const inputLen = input.length;
  const result = ['<table>'];
  for (let row = 0; row < inputLen; row += 1) {
    const rowData = input[row];
    const columnsLen = rowData.length;
    const columnsResult = [];
    if (row === 0) {
      result.push('<tbody>');
    }
    for (let column = 0; column < columnsLen; column += 1) {
      const cellData = rowData[column];
      const parsedCellData = (0, _mixed.isEmpty)(cellData) ? '' : cellData.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/(<br(\s*|\/)>(\r\n|\n)?|\r\n|\n)/g, '<br>\r\n').replace(/\x20{2,}/gi, substring => {
        // The way how Excel serializes data with at least two spaces.
        return `<span style="mso-spacerun: yes">${'&nbsp;'.repeat(substring.length - 1)} </span>`;
      }).replace(/\t/gi, '&#9;');
      columnsResult.push(`<td>${parsedCellData}</td>`);
    }
    result.push('<tr>', ...columnsResult, '</tr>');
    if (row + 1 === inputLen) {
      result.push('</tbody>');
    }
  }
  result.push('</table>');
  return result.join('');
}

/**
 * Converts HTMLTable or string into Handsontable configuration object.
 *
 * @param {Element|string} element Node element which should contain `<table>...</table>`.
 * @param {Document} [rootDocument] The document window owner.
 * @returns {object} Return configuration object. Contains keys as DefaultSettings.
 */
// eslint-disable-next-line no-restricted-globals
function htmlToGridSettings(element) {
  let rootDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  const settingsObj = {};
  const fragment = rootDocument.createDocumentFragment();
  const tempElem = rootDocument.createElement('div');
  fragment.appendChild(tempElem);
  let checkElement = element;
  if (typeof checkElement === 'string') {
    const escapedAdjacentHTML = checkElement.replace(/<td\b[^>]*?>([\s\S]*?)<\/\s*td>/g, cellFragment => {
      const openingTag = cellFragment.match(/<td\b[^>]*?>/g)[0];
      const paragraphRegexp = /<p.*?>/g;
      const cellValue = cellFragment.substring(openingTag.length, cellFragment.lastIndexOf('<')).trim() // Removing whitespaces from the start and the end of HTML fragment
      .replaceAll(/\n\s+/g, ' ') // HTML tags may be split using multiple new lines and whitespaces
      .replaceAll(paragraphRegexp, '\n') // Only paragraphs should split text using new line characters
      .replace('\n', '') // First paragraph shouldn't start with new line characters
      .replaceAll(/<\/(.*)>\s+$/mg, '</$1>') // HTML tags may end with whitespace.
      .replace(/(<(?!br)([^>]+)>)/gi, '') // Removing HTML tags
      .replaceAll(/^&nbsp;$/mg, ''); // Removing single &nbsp; characters separating new lines
      const closingTag = '</td>';
      return `${openingTag}${cellValue}${closingTag}`;
    });
    tempElem.insertAdjacentHTML('afterbegin', `${escapedAdjacentHTML}`);
    checkElement = tempElem.querySelector('table');
  }
  if (!checkElement || !isHTMLTable(checkElement)) {
    return;
  }
  const generator = tempElem.querySelector('meta[name$="enerator"]');
  const hasRowHeaders = checkElement.querySelector('tbody th') !== null;
  const trElement = checkElement.querySelector('tr');
  const countCols = !trElement ? 0 : Array.from(trElement.cells).reduce((cols, cell) => cols + cell.colSpan, 0) - (hasRowHeaders ? 1 : 0);
  const fixedRowsBottom = checkElement.tFoot && Array.from(checkElement.tFoot.rows) || [];
  const fixedRowsTop = [];
  let hasColHeaders = false;
  let thRowsLen = 0;
  let countRows = 0;
  if (checkElement.tHead) {
    const thRows = Array.from(checkElement.tHead.rows).filter(tr => {
      const isDataRow = tr.querySelector('td') !== null;
      if (isDataRow) {
        fixedRowsTop.push(tr);
      }
      return !isDataRow;
    });
    thRowsLen = thRows.length;
    hasColHeaders = thRowsLen > 0;
    if (thRowsLen > 1) {
      settingsObj.nestedHeaders = Array.from(thRows).reduce((rows, row) => {
        const headersRow = Array.from(row.cells).reduce((headers, header, currentIndex) => {
          if (hasRowHeaders && currentIndex === 0) {
            return headers;
          }
          const {
            colSpan: colspan,
            innerHTML
          } = header;
          const nextHeader = colspan > 1 ? {
            label: innerHTML,
            colspan
          } : innerHTML;
          headers.push(nextHeader);
          return headers;
        }, []);
        rows.push(headersRow);
        return rows;
      }, []);
    } else if (hasColHeaders) {
      settingsObj.colHeaders = Array.from(thRows[0].children).reduce((headers, header, index) => {
        if (hasRowHeaders && index === 0) {
          return headers;
        }
        headers.push(header.innerHTML);
        return headers;
      }, []);
    }
  }
  if (fixedRowsTop.length) {
    settingsObj.fixedRowsTop = fixedRowsTop.length;
  }
  if (fixedRowsBottom.length) {
    settingsObj.fixedRowsBottom = fixedRowsBottom.length;
  }
  const dataRows = [...fixedRowsTop, ...Array.from(checkElement.tBodies).reduce((sections, section) => {
    sections.push(...Array.from(section.rows));
    return sections;
  }, []), ...fixedRowsBottom];
  countRows = dataRows.length;
  const dataArr = new Array(countRows);
  for (let r = 0; r < countRows; r++) {
    dataArr[r] = new Array(countCols);
  }
  const mergeCells = [];
  const rowHeaders = [];
  for (let row = 0; row < countRows; row++) {
    const tr = dataRows[row];
    const cells = Array.from(tr.cells);
    const cellsLen = cells.length;
    for (let cellId = 0; cellId < cellsLen; cellId++) {
      const cell = cells[cellId];
      const {
        nodeName,
        innerHTML,
        rowSpan: rowspan,
        colSpan: colspan
      } = cell;
      const col = dataArr[row].findIndex(value => value === undefined);
      if (nodeName === 'TD') {
        if (rowspan > 1 || colspan > 1) {
          for (let rstart = row; rstart < row + rowspan; rstart++) {
            if (rstart < countRows) {
              for (let cstart = col; cstart < col + colspan; cstart++) {
                dataArr[rstart][cstart] = null;
              }
            }
          }
          const styleAttr = cell.getAttribute('style');
          const ignoreMerge = styleAttr && styleAttr.includes('mso-ignore:colspan');
          if (!ignoreMerge) {
            mergeCells.push({
              col,
              row,
              rowspan,
              colspan
            });
          }
        }
        let cellValue = '';
        if (generator && /excel/gi.test(generator.content)) {
          cellValue = innerHTML.replace(/[\r\n][\x20]{0,2}/g, '\x20').replace(/<br(\s*|\/)>[\r\n]?[\x20]{0,3}/gim, '\r\n');
        } else {
          cellValue = innerHTML.replace(/<br(\s*|\/)>[\r\n]?/gim, '\r\n');
        }
        dataArr[row][col] = cellValue.replace(regEscapedChars, match => ESCAPED_HTML_CHARS[match]);
      } else {
        rowHeaders.push(innerHTML);
      }
    }
  }
  if (mergeCells.length) {
    settingsObj.mergeCells = mergeCells;
  }
  if (rowHeaders.length) {
    settingsObj.rowHeaders = rowHeaders;
  }
  if (dataArr.length) {
    settingsObj.data = dataArr;
  }
  return settingsObj;
}

/***/ }),
/* 525 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var call = __webpack_require__(207);
var uncurryThis = __webpack_require__(213);
var requireObjectCoercible = __webpack_require__(215);
var isCallable = __webpack_require__(220);
var isNullOrUndefined = __webpack_require__(216);
var isRegExp = __webpack_require__(526);
var toString = __webpack_require__(276);
var getMethod = __webpack_require__(228);
var getRegExpFlags = __webpack_require__(527);
var getSubstitution = __webpack_require__(529);
var wellKnownSymbol = __webpack_require__(232);
var IS_PURE = __webpack_require__(235);

var REPLACE = wellKnownSymbol('replace');
var $TypeError = TypeError;
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
var max = Math.max;

// `String.prototype.replaceAll` method
// https://tc39.es/ecma262/#sec-string.prototype.replaceall
$({ target: 'String', proto: true }, {
  replaceAll: function replaceAll(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, position, replacement;
    var endOfLastMatch = 0;
    var result = '';
    if (!isNullOrUndefined(searchValue)) {
      IS_REG_EXP = isRegExp(searchValue);
      if (IS_REG_EXP) {
        flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)));
        if (!~indexOf(flags, 'g')) throw new $TypeError('`.replaceAll` does not allow non-global regexes');
      }
      replacer = getMethod(searchValue, REPLACE);
      if (replacer) return call(replacer, searchValue, O, replaceValue);
      if (IS_PURE && IS_REG_EXP) return replace(toString(O), searchValue, replaceValue);
    }
    string = toString(O);
    searchString = toString(searchValue);
    functionalReplace = isCallable(replaceValue);
    if (!functionalReplace) replaceValue = toString(replaceValue);
    searchLength = searchString.length;
    advanceBy = max(1, searchLength);
    position = indexOf(string, searchString);
    while (position !== -1) {
      replacement = functionalReplace
        ? toString(replaceValue(searchString, position, string))
        : getSubstitution(searchString, string, position, [], undefined, replaceValue);
      result += stringSlice(string, endOfLastMatch, position) + replacement;
      endOfLastMatch = position + searchLength;
      position = position + advanceBy > string.length ? -1 : indexOf(string, searchString, position + advanceBy);
    }
    if (endOfLastMatch < string.length) {
      result += stringSlice(string, endOfLastMatch);
    }
    return result;
  }
});


/***/ }),
/* 526 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(219);
var classof = __webpack_require__(214);
var wellKnownSymbol = __webpack_require__(232);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) === 'RegExp');
};


/***/ }),
/* 527 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(207);
var hasOwn = __webpack_require__(237);
var isPrototypeOf = __webpack_require__(223);
var regExpFlags = __webpack_require__(528);

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),
/* 528 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(245);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 529 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(213);
var toObject = __webpack_require__(238);

var floor = Math.floor;
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
// eslint-disable-next-line redos/no-vulnerable -- safe
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice(str, 0, position);
      case "'": return stringSlice(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),
/* 530 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(531);


/***/ }),
/* 531 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var iterate = __webpack_require__(331);
var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var getIteratorDirect = __webpack_require__(296);

var $TypeError = TypeError;

// `Iterator.prototype.reduce` method
// https://tc39.es/ecma262/#sec-iterator.prototype.reduce
$({ target: 'Iterator', proto: true, real: true }, {
  reduce: function reduce(reducer /* , initialValue */) {
    anObject(this);
    aCallable(reducer);
    var record = getIteratorDirect(this);
    var noInitial = arguments.length < 2;
    var accumulator = noInitial ? undefined : arguments[1];
    var counter = 0;
    iterate(record, function (value) {
      if (noInitial) {
        noInitial = false;
        accumulator = value;
      } else {
        accumulator = reducer(accumulator, value, counter);
      }
      counter++;
    }, { IS_RECORD: true });
    if (noInitial) throw new $TypeError('Reduce of empty iterator with no initial value');
    return accumulator;
  }
});


/***/ }),
/* 532 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.getPlugin = getPlugin;
exports.getPluginsNames = getPluginsNames;
exports.hasPlugin = hasPlugin;
exports.registerPlugin = registerPlugin;
__webpack_require__(201);
var _string = __webpack_require__(352);
var _priorityMap = __webpack_require__(533);
var _uniqueMap = __webpack_require__(535);
var _uniqueSet = __webpack_require__(536);
/**
 * Utility to register plugins and common namespace for keeping the reference to all plugins classes.
 */

const ERROR_PLUGIN_REGISTERED = pluginName => `There is already registered "${pluginName}" plugin.`;
const ERROR_PRIORITY_REGISTERED = priority => `There is already registered plugin on priority "${priority}".`;
const ERROR_PRIORITY_NAN = priority => `The priority "${priority}" is not a number.`;

/**
 * Stores plugins' names' queue with their priorities.
 */
const priorityPluginsQueue = (0, _priorityMap.createPriorityMap)({
  errorPriorityExists: ERROR_PRIORITY_REGISTERED,
  errorPriorityNaN: ERROR_PRIORITY_NAN
});
/**
 * Stores plugins names' queue by registration order.
 */
const uniquePluginsQueue = (0, _uniqueSet.createUniqueSet)({
  errorItemExists: ERROR_PLUGIN_REGISTERED
});
/**
 * Stores plugins references between their name and class.
 */
const uniquePluginsList = (0, _uniqueMap.createUniqueMap)({
  errorIdExists: ERROR_PLUGIN_REGISTERED
});

/**
 * Gets registered plugins' names in the following order:
 * 1) Plugins registered with a defined priority attribute, in the ascending order of priority.
 * 2) Plugins registered without a defined priority attribute, in the registration order.
 *
 * @returns {string[]}
 */
function getPluginsNames() {
  return [...priorityPluginsQueue.getItems(), ...uniquePluginsQueue.getItems()];
}

/**
 * Gets registered plugin's class based on the given name.
 *
 * @param {string} pluginName Plugin's name.
 * @returns {BasePlugin}
 */
function getPlugin(pluginName) {
  const unifiedPluginName = (0, _string.toUpperCaseFirst)(pluginName);
  return uniquePluginsList.getItem(unifiedPluginName);
}

/**
 * Checks if the plugin under the name is already registered.
 *
 * @param {string} pluginName Plugin's name.
 * @returns {boolean}
 */
function hasPlugin(pluginName) {
  /* eslint-disable no-unneeded-ternary */
  return getPlugin(pluginName) ? true : false;
}

/**
 * Registers plugin under the given name only once.
 *
 * @param {string|Function} pluginName The plugin name or plugin class.
 * @param {Function} [pluginClass] The plugin class.
 * @param {number} [priority] The plugin priority.
 */
function registerPlugin(pluginName, pluginClass, priority) {
  [pluginName, pluginClass, priority] = unifyPluginArguments(pluginName, pluginClass, priority);
  if (getPlugin(pluginName) === undefined) {
    _registerPlugin(pluginName, pluginClass, priority);
  }
}

/**
 * Registers plugin under the given name.
 *
 * @param {string|Function} pluginName The plugin name or plugin class.
 * @param {Function} [pluginClass] The plugin class.
 * @param {number} [priority] The plugin priority.
 */
function _registerPlugin(pluginName, pluginClass, priority) {
  const unifiedPluginName = (0, _string.toUpperCaseFirst)(pluginName);
  if (uniquePluginsList.hasItem(unifiedPluginName)) {
    throw new Error(ERROR_PLUGIN_REGISTERED(unifiedPluginName));
  }
  if (priority === undefined) {
    uniquePluginsQueue.addItem(unifiedPluginName);
  } else {
    priorityPluginsQueue.addItem(priority, unifiedPluginName);
  }
  uniquePluginsList.addItem(unifiedPluginName, pluginClass);
}

/**
 * Unifies arguments to register the plugin.
 *
 * @param {string|Function} pluginName The plugin name or plugin class.
 * @param {Function} [pluginClass] The plugin class.
 * @param {number} [priority] The plugin priority.
 * @returns {Array}
 */
function unifyPluginArguments(pluginName, pluginClass, priority) {
  if (typeof pluginName === 'function') {
    pluginClass = pluginName;
    pluginName = pluginClass.PLUGIN_KEY;
    priority = pluginClass.PLUGIN_PRIORITY;
  }
  return [pluginName, pluginClass, priority];
}

/***/ }),
/* 533 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createPriorityMap = createPriorityMap;
__webpack_require__(201);
__webpack_require__(338);
var _number = __webpack_require__(534);
var _function = __webpack_require__(497);
const ASC = exports.ASC = 'asc';
const DESC = exports.DESC = 'desc';
const ORDER_MAP = new Map([[ASC, [-1, 1]], [DESC, [1, -1]]]);
const DEFAULT_ERROR_PRIORITY_EXISTS = priority => `The priority '${priority}' is already declared in a map.`;
const DEFAULT_ERROR_PRIORITY_NAN = priority => `The priority '${priority}' is not a number.`;

/**
 * @typedef {object} PriorityMap
 * @property {Function} addItem Adds items to the priority map.
 * @property {Function} getItems Gets items from the passed map in a ASC or DESC order of priorities.
 */
/**
 * Creates a new priority map.
 *
 * @param {object} config The config for priority map.
 * @param {Function} config.errorPriorityExists The function to generate a custom error message if priority is already taken.
 * @param {Function} config.errorPriorityNaN The function to generate a custom error message if priority is not a number.
 * @returns {PriorityMap}
 */
function createPriorityMap() {
  let {
    errorPriorityExists,
    errorPriorityNaN
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const priorityMap = new Map();
  errorPriorityExists = (0, _function.isFunction)(errorPriorityExists) ? errorPriorityExists : DEFAULT_ERROR_PRIORITY_EXISTS;
  errorPriorityNaN = (0, _function.isFunction)(errorPriorityNaN) ? errorPriorityNaN : DEFAULT_ERROR_PRIORITY_NAN;

  /**
   * Adds items to priority map. Throws an error if `priority` is not a number or if is already added.
   *
   * @param {number} priority The priority for adding item.
   * @param {*} item The adding item.
   */
  function addItem(priority, item) {
    if (!(0, _number.isNumeric)(priority)) {
      throw new Error(errorPriorityNaN(priority));
    }
    if (priorityMap.has(priority)) {
      throw new Error(errorPriorityExists(priority));
    }
    priorityMap.set(priority, item);
  }

  /**
   * Gets items from the passed map in a ASC or DESC order of priorities.
   *
   * @param {string} [order] The order for getting items. ASC is an default.
   * @returns {*}
   */
  function getItems() {
    let order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ASC;
    const [left, right] = ORDER_MAP.get(order) || ORDER_MAP.get(ASC);
    return [...priorityMap]
    // we want to be sure we sort over a priority key
    // if we are sure we can remove custom compare function
    // then we should replace next line with a default `.sort()`
    .sort((a, b) => a[0] < b[0] ? left : right).map(item => item[1]);
  }
  return {
    addItem,
    getItems
  };
}

/***/ }),
/* 534 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.clamp = clamp;
exports.isNumeric = isNumeric;
exports.isNumericLike = isNumericLike;
exports.rangeEach = rangeEach;
exports.rangeEachReverse = rangeEachReverse;
exports.valueAccordingPercent = valueAccordingPercent;
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(338);
/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * Checks if the passed value is numeric one. For example these values (passed as string or number)
 * are considered as numeric values:
 *  - 0.001
 *  - .001
 *  - 10000
 *  - 1e+26
 *  - 22e-26
 *  - .45e+26
 *  - 0xabcdef (hex)
 *  - 0x1 (hex)
 *
 * these values are not considered as numeric:
 *  - - 1000
 *  - 100 000
 *
 * @param {*} value The value to check.
 * @param {string[]} additionalDelimiters An additional delimiters to be used while checking the numeric value.
 * @returns {boolean}
 */
function isNumeric(value) {
  let additionalDelimiters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const type = typeof value;
  if (type === 'number') {
    return !isNaN(value) && isFinite(value);
  } else if (type === 'string') {
    if (value.length === 0) {
      return false;
    } else if (value.length === 1) {
      return /\d/.test(value);
    }
    const delimiter = Array.from(new Set(['.', ...additionalDelimiters])).map(d => `\\${d}`).join('|');
    return new RegExp(`^[+-]?(((${delimiter})?\\d+((${delimiter})\\d+)?(e[+-]?\\d+)?)|(0x[a-f\\d]+))$`, 'i').test(value.trim());
  } else if (type === 'object') {
    return !!value && typeof value.valueOf() === 'number' && !(value instanceof Date);
  }
  return false;
}
/* eslint-enable jsdoc/require-description-complete-sentence */

/**
 * Checks if the passed value is numeric-like value. The helper returns `true` for the same
 * values as for the `isNumeric` function plus `true` for numbers delimited by comma.
 *
 * @param {*} value The value to check.
 * @returns {boolean}
 */
function isNumericLike(value) {
  return isNumeric(value, [',']);
}

/**
 * A specialized version of `.forEach` defined by ranges.
 *
 * @param {number} rangeFrom The number from start iterate.
 * @param {number|Function} rangeTo The number where finish iterate or function as a iteratee.
 * @param {Function} [iteratee] The function invoked per iteration.
 */
function rangeEach(rangeFrom, rangeTo, iteratee) {
  let index = -1;
  if (typeof rangeTo === 'function') {
    iteratee = rangeTo;
    rangeTo = rangeFrom;
  } else {
    index = rangeFrom - 1;
  }

  /* eslint-disable-next-line no-plusplus */
  while (++index <= rangeTo) {
    if (iteratee(index) === false) {
      break;
    }
  }
}

/**
 * A specialized version of `.forEach` defined by ranges iterable in reverse order.
 *
 * @param {number} rangeFrom The number from start iterate.
 * @param {number|Function} rangeTo The number where finish iterate or function as a iteratee.
 * @param {Function} [iteratee] The function invoked per iteration.
 */
function rangeEachReverse(rangeFrom, rangeTo, iteratee) {
  let index = rangeFrom + 1;
  if (typeof rangeTo === 'function') {
    iteratee = rangeTo;
    rangeTo = 0;
  }
  /* eslint-disable-next-line no-plusplus */
  while (--index >= rangeTo) {
    if (iteratee(index) === false) {
      break;
    }
  }
}

/**
 * Calculate value from percent.
 *
 * @param {number} value Base value from percent will be calculated.
 * @param {string|number} percent Can be number or string (eq. `'33%'`).
 * @returns {number}
 */
function valueAccordingPercent(value, percent) {
  percent = parseInt(percent.toString().replace('%', ''), 10);
  percent = isNaN(percent) ? 0 : percent;
  return parseInt(value * percent / 100, 10);
}

/**
 * Clamps the value between min and max.
 *
 * @param {number} value The base number value.
 * @param {number} minValue The max number value.
 * @param {number} maxValue The min number value.
 * @returns {number}
 */
function clamp(value, minValue, maxValue) {
  if (Math.min(value, minValue) === value) {
    return minValue;
  } else if (Math.max(value, maxValue) === value) {
    return maxValue;
  }
  return value;
}

/***/ }),
/* 535 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createUniqueMap = createUniqueMap;
__webpack_require__(201);
__webpack_require__(311);
__webpack_require__(519);
var _function = __webpack_require__(497);
const DEFAULT_ERROR_ID_EXISTS = id => `The id '${id}' is already declared in a map.`;

/**
 * @typedef {object} UniqueMap
 * @property {Function} addItem Adds a new item to the unique map.
 * @property {Function} clear Clears the map.
 * @property {Function} getId Returns ID for the passed item.
 * @property {Function} getItem Gets item from the passed ID.
 * @property {Function} getItems Gets all items from the map.
 * @property {Function} hasItem Verifies if the passed ID exists in a map.
 * @property {Function} removeItem Removes item from the passed id if exists.
 */
/**
 * Creates a new unique map.
 *
 * @param {object} config The config for priority queue.
 * @param {Function} config.errorIdExists The function to generate custom message if ID is already taken.
 * @returns {UniqueMap}
 */
function createUniqueMap() {
  let {
    errorIdExists
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const uniqueMap = new Map();
  errorIdExists = (0, _function.isFunction)(errorIdExists) ? errorIdExists : DEFAULT_ERROR_ID_EXISTS;

  /**
   * Adds a new item to the unique map. Throws error if `id` is already added.
   *
   * @param {*} id The ID of the adding item.
   * @param {*} item The adding item.
   */
  function addItem(id, item) {
    if (hasItem(id)) {
      throw new Error(errorIdExists(id));
    }
    uniqueMap.set(id, item);
  }

  /**
   * Removes item from the passed id if exists.
   *
   * @param {*} id The ID to remove.
   * @returns {boolean}
   */
  function removeItem(id) {
    return uniqueMap.delete(id);
  }

  /**
   * Clears the map.
   */
  function clear() {
    uniqueMap.clear();
  }

  /**
   * Returns ID for the passed item.
   *
   * @param {*} item The item of the getting ID.
   * @returns {*}
   */
  function getId(item) {
    const [itemId] = getItems().find(_ref => {
      let [id, element] = _ref;
      if (item === element) {
        return id;
      }
      return false;
    }) || [null];
    return itemId;
  }

  /**
   * Returns item from the passed ID.
   *
   * @param {*} id The ID of the getting item.
   * @returns {*}
   */
  function getItem(id) {
    return uniqueMap.get(id);
  }

  /**
   * Gets all items from the map.
   *
   * @returns {Array}
   */
  function getItems() {
    return [...uniqueMap];
  }

  /**
   * Verifies if the passed ID exists in a map.
   *
   * @param {*} id The ID to check if registered.
   * @returns {boolean}
   */
  function hasItem(id) {
    return uniqueMap.has(id);
  }
  return {
    addItem,
    clear,
    getId,
    getItem,
    getItems,
    hasItem,
    removeItem
  };
}

/***/ }),
/* 536 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createUniqueSet = createUniqueSet;
__webpack_require__(201);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
var _function = __webpack_require__(497);
const DEFAULT_ERROR_ITEM_EXISTS = item => `'${item}' value is already declared in a unique set.`;

/**
 * @typedef {object} UniqueSet
 * @property {Function} addItem Adds items to the priority set.
 * @property {Function} getItems Gets items from the set in order of addition.
 */
/**
 * Creates a new unique set.
 *
 * @param {object} config The config for priority set.
 * @param {Function} config.errorItemExists The function to generate custom error message if item is already in the set.
 * @returns {UniqueSet}
 */
function createUniqueSet() {
  let {
    errorItemExists
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const uniqueSet = new Set();
  errorItemExists = (0, _function.isFunction)(errorItemExists) ? errorItemExists : DEFAULT_ERROR_ITEM_EXISTS;

  /**
   * Adds items to the unique set. Throws an error if `item` is already added.
   *
   * @param {*} item The adding item.
   */
  function addItem(item) {
    if (uniqueSet.has(item)) {
      throw new Error(errorItemExists(item));
    }
    uniqueSet.add(item);
  }

  /**
   * Gets items from the set in order of addition.
   *
   * @returns {*}
   */
  function getItems() {
    return [...uniqueSet];
  }

  /**
   * Clears the unique set.
   */
  function clear() {
    uniqueSet.clear();
  }
  return {
    addItem,
    clear,
    getItems
  };
}

/***/ }),
/* 537 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.getRenderer = _getItem;
exports.registerRenderer = _register;
__webpack_require__(201);
var _staticRegister = _interopRequireDefault(__webpack_require__(521));
const {
  register,
  getItem,
  hasItem,
  getNames,
  getValues
} = (0, _staticRegister.default)('renderers');

/**
 * Retrieve renderer function.
 *
 * @param {string} name Renderer identification.
 * @returns {Function} Returns renderer function.
 */
exports.getRegisteredRenderers = getValues;
exports.getRegisteredRendererNames = getNames;
exports.hasRenderer = hasItem;
function _getItem(name) {
  if (typeof name === 'function') {
    return name;
  }
  if (!hasItem(name)) {
    throw Error(`No registered renderer found under "${name}" name`);
  }
  return getItem(name);
}

/**
 * Register renderer under its alias.
 *
 * @param {string|Function} name Renderer's alias or renderer function with its descriptor.
 * @param {Function} [renderer] Renderer function.
 */
function _register(name, renderer) {
  if (typeof name !== 'string') {
    renderer = name;
    name = renderer.RENDERER_TYPE;
  }
  register(name, renderer);
}

/***/ }),
/* 538 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.getValidator = _getItem;
exports.registerValidator = _register;
__webpack_require__(201);
var _staticRegister = _interopRequireDefault(__webpack_require__(521));
const {
  register,
  getItem,
  hasItem,
  getNames,
  getValues
} = (0, _staticRegister.default)('validators');

/**
 * Retrieve validator function.
 *
 * @param {string} name Validator identification.
 * @returns {Function} Returns validator function.
 */
exports.getRegisteredValidators = getValues;
exports.getRegisteredValidatorNames = getNames;
exports.hasValidator = hasItem;
function _getItem(name) {
  if (typeof name === 'function') {
    return name;
  }
  if (!hasItem(name)) {
    throw Error(`No registered validator found under "${name}" name`);
  }
  return getItem(name);
}

/**
 * Register validator under its alias.
 *
 * @param {string|Function} name Validator's alias or validator function with its descriptor.
 * @param {Function} [validator] Validator function.
 */
function _register(name, validator) {
  if (typeof name !== 'string') {
    validator = name;
    name = validator.VALIDATOR_TYPE;
  }
  register(name, validator);
}

/***/ }),
/* 539 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _eventManager = _interopRequireDefault(__webpack_require__(522));
var _event = __webpack_require__(509);
var _src = _interopRequireDefault(__webpack_require__(540));
var _mouseEventHandler = __webpack_require__(615);
var _rootInstance = __webpack_require__(616);
var _a11y = __webpack_require__(496);
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @class TableView
 * @private
 */
var _columnHeadersCount = /*#__PURE__*/new WeakMap();
var _rowHeadersCount = /*#__PURE__*/new WeakMap();
var _selectionMouseDown = /*#__PURE__*/new WeakMap();
var _mouseDown = /*#__PURE__*/new WeakMap();
var _table = /*#__PURE__*/new WeakMap();
var _lastWidth = /*#__PURE__*/new WeakMap();
var _lastHeight = /*#__PURE__*/new WeakMap();
var _TableView_brand = /*#__PURE__*/new WeakSet();
class TableView {
  /**
   * @param {Hanstontable} hotInstance Instance of {@link Handsontable}.
   */
  constructor(hotInstance) {
    /**
     * Return the value of the `aria-colcount` attribute.
     *
     * @returns {number} The value of the `aria-colcount` attribute.
     */
    _classPrivateMethodInitSpec(this, _TableView_brand);
    /**
     * Instance of {@link Handsontable}.
     *
     * @private
     * @type {Handsontable}
     */
    (0, _defineProperty2.default)(this, "hot", void 0);
    /**
     * Instance of {@link EventManager}.
     *
     * @private
     * @type {EventManager}
     */
    (0, _defineProperty2.default)(this, "eventManager", void 0);
    /**
     * Current Handsontable's GridSettings object.
     *
     * @private
     * @type {GridSettings}
     */
    (0, _defineProperty2.default)(this, "settings", void 0);
    /**
     * Main <THEAD> element.
     *
     * @private
     * @type {HTMLTableSectionElement}
     */
    (0, _defineProperty2.default)(this, "THEAD", void 0);
    /**
     * Main <TBODY> element.
     *
     * @private
     * @type {HTMLTableSectionElement}
     */
    (0, _defineProperty2.default)(this, "TBODY", void 0);
    /**
     * Main Walkontable instance.
     *
     * @private
     * @type {Walkontable}
     */
    (0, _defineProperty2.default)(this, "_wt", void 0);
    /**
     * Main Walkontable instance.
     *
     * @type {Walkontable}
     */
    (0, _defineProperty2.default)(this, "activeWt", void 0);
    /**
     * The total number of the column header renderers applied to the table through the
     * `afterGetColumnHeaderRenderers` hook.
     *
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _columnHeadersCount, 0);
    /**
     * The total number of the row header renderers applied to the table through the
     * `afterGetRowHeaderRenderers` hook.
     *
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _rowHeadersCount, 0);
    /**
     * The flag determines if the `adjustElementsSize` method call was made during
     * the render suspending. If true, the method has to be triggered once after render
     * resuming.
     *
     * @private
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "postponedAdjustElementsSize", false);
    /**
     * Defines if the text should be selected during mousemove.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _selectionMouseDown, false);
    /**
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _mouseDown, void 0);
    /**
     * Main <TABLE> element.
     *
     * @type {HTMLTableElement}
     */
    _classPrivateFieldInitSpec(this, _table, void 0);
    /**
     * Cached width of the rootElement.
     *
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _lastWidth, 0);
    /**
     * Cached height of the rootElement.
     *
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _lastHeight, 0);
    this.hot = hotInstance;
    this.eventManager = new _eventManager.default(this.hot);
    this.settings = this.hot.getSettings();
    this.createElements();
    this.registerEvents();
    this.initializeWalkontable();
  }

  /**
   * Renders WalkontableUI.
   */
  render() {
    if (!this.hot.isRenderSuspended()) {
      this.hot.runHooks('beforeRender', this.hot.forceFullRender);
      if (this.postponedAdjustElementsSize) {
        this.postponedAdjustElementsSize = false;
        this.adjustElementsSize();
      }
      this._wt.draw(!this.hot.forceFullRender);
      _assertClassBrand(_TableView_brand, this, _updateScrollbarClassNames).call(this);
      this.hot.runHooks('afterRender', this.hot.forceFullRender);
      this.hot.forceFullRender = false;
      this.hot.renderCall = false;
    }
  }

  /**
   * Adjust overlays elements size and master table size.
   */
  adjustElementsSize() {
    if (this.hot.isRenderSuspended()) {
      this.postponedAdjustElementsSize = true;
    } else {
      this._wt.wtOverlays.adjustElementsSize();
    }
  }

  /**
   * Returns td object given coordinates.
   *
   * @param {CellCoords} coords Renderable cell coordinates.
   * @param {boolean} topmost Indicates whether the cell should be calculated from the topmost.
   * @returns {HTMLTableCellElement|null}
   */
  getCellAtCoords(coords, topmost) {
    const td = this._wt.getCell(coords, topmost);
    if (td < 0) {
      // there was an exit code (cell is out of bounds)
      return null;
    }
    return td;
  }

  /**
   * Scroll viewport to a cell.
   *
   * @param {CellCoords} coords Renderable cell coordinates.
   * @param {'auto' | 'start' | 'end'} [horizontalSnap] If `'start'`, viewport is scrolled to show
   * the cell on the left of the table. If `'end'`, viewport is scrolled to show the cell on the right of
   * the table. When `'auto'`, the viewport is scrolled only when the column is outside of the viewport.
   * @param {'auto' | 'top' | 'bottom'} [verticalSnap] If `'top'`, viewport is scrolled to show
   * the cell on the top of the table. If `'bottom'`, viewport is scrolled to show the cell on the bottom of
   * the table. When `'auto'`, the viewport is scrolled only when the row is outside of the viewport.
   * @returns {boolean}
   */
  scrollViewport(coords, horizontalSnap, verticalSnap) {
    return this._wt.scrollViewport(coords, horizontalSnap, verticalSnap);
  }

  /**
   * Scroll viewport to a column.
   *
   * @param {number} column Renderable column index.
   * @param {'auto' | 'start' | 'end'} [snap] If `'start'`, viewport is scrolled to show
   * the cell on the left of the table. If `'end'`, viewport is scrolled to show the cell on the right of
   * the table. When `'auto'`, the viewport is scrolled only when the column is outside of the viewport.
   * @returns {boolean}
   */
  scrollViewportHorizontally(column, snap) {
    return this._wt.scrollViewportHorizontally(column, snap);
  }

  /**
   * Scroll viewport to a row.
   *
   * @param {number} row Renderable row index.
   * @param {'auto' | 'top' | 'bottom'} [snap] If `'top'`, viewport is scrolled to show
   * the cell on the top of the table. If `'bottom'`, viewport is scrolled to show the cell on
   * the bottom of the table. When `'auto'`, the viewport is scrolled only when the row is outside of
   * the viewport.
   * @returns {boolean}
   */
  scrollViewportVertically(row, snap) {
    return this._wt.scrollViewportVertically(row, snap);
  }

  /**
   * Prepares DOMElements and adds correct className to the root element.
   *
   * @private
   */
  createElements() {
    const {
      rootElement,
      rootDocument
    } = this.hot;
    const originalStyle = rootElement.getAttribute('style');
    if (originalStyle) {
      rootElement.setAttribute('data-originalstyle', originalStyle); // needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions
    }
    (0, _element.addClass)(rootElement, 'handsontable');
    _classPrivateFieldSet(_table, this, rootDocument.createElement('TABLE'));
    (0, _element.addClass)(_classPrivateFieldGet(_table, this), 'htCore');
    if (this.hot.getSettings().tableClassName) {
      (0, _element.addClass)(_classPrivateFieldGet(_table, this), this.hot.getSettings().tableClassName);
    }
    if (this.settings.ariaTags) {
      (0, _element.setAttribute)(_classPrivateFieldGet(_table, this), [(0, _a11y.A11Y_PRESENTATION)()]);
      (0, _element.setAttribute)(rootElement, [(0, _a11y.A11Y_TREEGRID)(), (0, _a11y.A11Y_ROWCOUNT)(-1), (0, _a11y.A11Y_COLCOUNT)(this.hot.countCols()), (0, _a11y.A11Y_MULTISELECTABLE)()]);
    }
    this.THEAD = rootDocument.createElement('THEAD');
    _classPrivateFieldGet(_table, this).appendChild(this.THEAD);
    this.TBODY = rootDocument.createElement('TBODY');
    _classPrivateFieldGet(_table, this).appendChild(this.TBODY);
    this.hot.table = _classPrivateFieldGet(_table, this);
    this.hot.container.insertBefore(_classPrivateFieldGet(_table, this), this.hot.container.firstChild);
  }

  /**
   * Attaches necessary listeners.
   *
   * @private
   */
  registerEvents() {
    const {
      rootElement,
      rootDocument,
      selection,
      rootWindow
    } = this.hot;
    const documentElement = rootDocument.documentElement;
    this.eventManager.addEventListener(rootElement, 'mousedown', event => {
      _classPrivateFieldSet(_selectionMouseDown, this, true);
      if (!this.isTextSelectionAllowed(event.target)) {
        (0, _element.clearTextSelection)(rootWindow);
        event.preventDefault();
        rootWindow.focus(); // make sure that window that contains HOT is active. Important when HOT is in iframe.
      }
    });
    this.eventManager.addEventListener(rootElement, 'mouseup', () => {
      _classPrivateFieldSet(_selectionMouseDown, this, false);
    });
    this.eventManager.addEventListener(rootElement, 'mousemove', event => {
      if (_classPrivateFieldGet(_selectionMouseDown, this) && !this.isTextSelectionAllowed(event.target)) {
        // Clear selection only when fragmentSelection is enabled, otherwise clearing selection breaks the IME editor.
        if (this.settings.fragmentSelection) {
          (0, _element.clearTextSelection)(rootWindow);
        }
        event.preventDefault();
      }
    });
    this.eventManager.addEventListener(documentElement, 'keyup', event => {
      // TODO: is it the best place and way to finish cell selection?
      if (selection.isInProgress() && !event.shiftKey) {
        selection.finish();
      }
    });
    this.eventManager.addEventListener(documentElement, 'mouseup', event => {
      if (selection.isInProgress() && (0, _event.isLeftClick)(event)) {
        selection.finish();
      }
      _classPrivateFieldSet(_mouseDown, this, false);
      const isOutsideInputElement = (0, _element.isOutsideInput)(rootDocument.activeElement);
      if ((0, _element.isInput)(rootDocument.activeElement) && !isOutsideInputElement) {
        return;
      }
      if (isOutsideInputElement || !selection.isSelected() && !selection.isSelectedByAnyHeader() && !rootElement.contains(event.target) && !(0, _event.isRightClick)(event)) {
        this.hot.unlisten();
      }
    });
    this.eventManager.addEventListener(documentElement, 'contextmenu', event => {
      if (selection.isInProgress() && (0, _event.isRightClick)(event)) {
        selection.finish();
        _classPrivateFieldSet(_mouseDown, this, false);
      }
    });
    this.eventManager.addEventListener(documentElement, 'touchend', () => {
      if (selection.isInProgress()) {
        selection.finish();
      }
      _classPrivateFieldSet(_mouseDown, this, false);
    });
    this.eventManager.addEventListener(documentElement, 'mousedown', event => {
      const originalTarget = event.target;
      const eventX = event.x || event.clientX;
      const eventY = event.y || event.clientY;
      let next = event.target;
      if (_classPrivateFieldGet(_mouseDown, this) || !rootElement || !this.hot.view) {
        return; // it must have been started in a cell
      }

      // immediate click on "holder" means click on the right side of vertical scrollbar
      const {
        holder
      } = this._wt.wtTable;
      if (next === holder) {
        const scrollbarWidth = (0, _element.getScrollbarWidth)(rootDocument);
        if (rootDocument.elementFromPoint(eventX + scrollbarWidth, eventY) !== holder || rootDocument.elementFromPoint(eventX, eventY + scrollbarWidth) !== holder) {
          return;
        }
      } else {
        while (next !== documentElement) {
          if (next === null) {
            if (event.isTargetWebComponent) {
              break;
            }

            // click on something that was a row but now is detached (possibly because your click triggered a rerender)
            return;
          }
          if (next === rootElement) {
            // click inside container
            return;
          }
          next = next.parentNode;
        }
      }

      // function did not return until here, we have an outside click!
      const outsideClickDeselects = typeof this.settings.outsideClickDeselects === 'function' ? this.settings.outsideClickDeselects(originalTarget) : this.settings.outsideClickDeselects;
      if (outsideClickDeselects) {
        this.hot.deselectCell();
      } else {
        this.hot.destroyEditor(false, false);
      }
    });
    let parentWindow = (0, _element.getParentWindow)(rootWindow);
    while (parentWindow !== null) {
      this.eventManager.addEventListener(parentWindow.document.documentElement, 'click', () => {
        this.hot.unlisten();
      });
      parentWindow = (0, _element.getParentWindow)(parentWindow);
    }
    this.eventManager.addEventListener(_classPrivateFieldGet(_table, this), 'selectstart', event => {
      if (this.settings.fragmentSelection || (0, _element.isInput)(event.target)) {
        return;
      }
      // https://github.com/handsontable/handsontable/issues/160
      // Prevent text from being selected when performing drag down.
      event.preventDefault();
    });
  }

  /**
   * Translate renderable cell coordinates to visual coordinates.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @returns {CellCoords}
   */
  translateFromRenderableToVisualCoords(_ref) {
    let {
      row,
      col
    } = _ref;
    // TODO: To consider an idea to reusing the CellCoords instance instead creating new one.
    return this.hot._createCellCoords(...this.translateFromRenderableToVisualIndex(row, col));
  }

  /**
   * Translate renderable row and column indexes to visual row and column indexes.
   *
   * @param {number} renderableRow Renderable row index.
   * @param {number} renderableColumn Renderable columnIndex.
   * @returns {number[]}
   */
  translateFromRenderableToVisualIndex(renderableRow, renderableColumn) {
    // TODO: Some helper may be needed.
    // We perform translation for indexes (without headers).
    let visualRow = renderableRow >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRow) : renderableRow;
    let visualColumn = renderableColumn >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderableColumn) : renderableColumn;
    if (visualRow === null) {
      visualRow = renderableRow;
    }
    if (visualColumn === null) {
      visualColumn = renderableColumn;
    }
    return [visualRow, visualColumn];
  }

  /**
   * Returns the number of renderable indexes.
   *
   * @private
   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
   * @param {number} maxElements Maximum number of elements (rows or columns).
   *
   * @returns {number|*}
   */
  countRenderableIndexes(indexMapper, maxElements) {
    const consideredElements = Math.min(indexMapper.getNotTrimmedIndexesLength(), maxElements);
    // Don't take hidden indexes into account. We are looking just for renderable indexes.
    const firstNotHiddenIndex = indexMapper.getNearestNotHiddenIndex(consideredElements - 1, -1);

    // There are no renderable indexes.
    if (firstNotHiddenIndex === null) {
      return 0;
    }
    return indexMapper.getRenderableFromVisualIndex(firstNotHiddenIndex) + 1;
  }

  /**
   * Returns the number of renderable columns.
   *
   * @returns {number}
   */
  countRenderableColumns() {
    return this.countRenderableIndexes(this.hot.columnIndexMapper, this.settings.maxCols);
  }

  /**
   * Returns the number of renderable rows.
   *
   * @returns {number}
   */
  countRenderableRows() {
    return this.countRenderableIndexes(this.hot.rowIndexMapper, this.settings.maxRows);
  }

  /**
   * Returns number of not hidden row indexes counting from the passed starting index.
   * The counting direction can be controlled by `incrementBy` argument.
   *
   * @param {number} visualIndex The visual index from which the counting begins.
   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
   * @returns {number}
   */
  countNotHiddenRowIndexes(visualIndex, incrementBy) {
    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.rowIndexMapper, this.countRenderableRows());
  }

  /**
   * Returns number of not hidden column indexes counting from the passed starting index.
   * The counting direction can be controlled by `incrementBy` argument.
   *
   * @param {number} visualIndex The visual index from which the counting begins.
   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
   * @returns {number}
   */
  countNotHiddenColumnIndexes(visualIndex, incrementBy) {
    return this.countNotHiddenIndexes(visualIndex, incrementBy, this.hot.columnIndexMapper, this.countRenderableColumns());
  }

  /**
   * Returns number of not hidden indexes counting from the passed starting index.
   * The counting direction can be controlled by `incrementBy` argument.
   *
   * @param {number} visualIndex The visual index from which the counting begins.
   * @param {number} incrementBy If `-1` then counting is backwards or forward when `1`.
   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
   * @param {number} renderableIndexesCount Total count of renderable indexes for specific axis.
   * @returns {number}
   */
  countNotHiddenIndexes(visualIndex, incrementBy, indexMapper, renderableIndexesCount) {
    if (isNaN(visualIndex) || visualIndex < 0) {
      return 0;
    }
    const firstVisibleIndex = indexMapper.getNearestNotHiddenIndex(visualIndex, incrementBy);
    const renderableIndex = indexMapper.getRenderableFromVisualIndex(firstVisibleIndex);
    if (!Number.isInteger(renderableIndex)) {
      return 0;
    }
    let notHiddenIndexes = 0;
    if (incrementBy < 0) {
      // Zero-based numbering for renderable indexes corresponds to a number of not hidden indexes.
      notHiddenIndexes = renderableIndex + 1;
    } else if (incrementBy > 0) {
      notHiddenIndexes = renderableIndexesCount - renderableIndex;
    }
    return notHiddenIndexes;
  }

  /**
   * The function returns the number of not hidden column indexes that fit between the first and
   * last fixed column in the left (or right in RTL mode) overlay.
   *
   * @returns {number}
   */
  countNotHiddenFixedColumnsStart() {
    const countCols = this.hot.countCols();
    const visualFixedColumnsStart = Math.min(parseInt(this.settings.fixedColumnsStart, 10), countCols) - 1;
    return this.countNotHiddenColumnIndexes(visualFixedColumnsStart, -1);
  }

  /**
   * The function returns the number of not hidden row indexes that fit between the first and
   * last fixed row in the top overlay.
   *
   * @returns {number}
   */
  countNotHiddenFixedRowsTop() {
    const countRows = this.hot.countRows();
    const visualFixedRowsTop = Math.min(parseInt(this.settings.fixedRowsTop, 10), countRows) - 1;
    return this.countNotHiddenRowIndexes(visualFixedRowsTop, -1);
  }

  /**
   * The function returns the number of not hidden row indexes that fit between the first and
   * last fixed row in the bottom overlay.
   *
   * @returns {number}
   */
  countNotHiddenFixedRowsBottom() {
    const countRows = this.hot.countRows();
    const visualFixedRowsBottom = Math.max(countRows - parseInt(this.settings.fixedRowsBottom, 10), 0);
    return this.countNotHiddenRowIndexes(visualFixedRowsBottom, 1);
  }

  /**
   * The function returns the number of renderable column indexes within the passed range of the visual indexes.
   *
   * @param {number} columnStart The column visual start index.
   * @param {number} columnEnd The column visual end index.
   * @returns {number}
   */
  countRenderableColumnsInRange(columnStart, columnEnd) {
    let count = 0;
    for (let column = columnStart; column <= columnEnd; column++) {
      if (this.hot.columnIndexMapper.getRenderableFromVisualIndex(column) !== null) {
        count += 1;
      }
    }
    return count;
  }

  /**
   * The function returns the number of renderable row indexes within the passed range of the visual indexes.
   *
   * @param {number} rowStart The row visual start index.
   * @param {number} rowEnd The row visual end index.
   * @returns {number}
   */
  countRenderableRowsInRange(rowStart, rowEnd) {
    let count = 0;
    for (let row = rowStart; row <= rowEnd; row++) {
      if (this.hot.rowIndexMapper.getRenderableFromVisualIndex(row) !== null) {
        count += 1;
      }
    }
    return count;
  }

  /**
   * Retrieves the styles handler from the Walkontable instance.
   *
   * @returns {StylesHandler} The styles handler instance.
   */
  getStylesHandler() {
    return this._wt.stylesHandler;
  }

  /**
   * Returns the default row height.
   *
   * This method retrieves the default row height from the Walkontable styles handler.
   *
   * @returns {number} The default row height.
   */
  getDefaultRowHeight() {
    return this._wt.stylesHandler.getDefaultRowHeight();
  }

  /**
   * Add a class name to the license information element.
   *
   * @param {string} className The class name to add.
   */
  addClassNameToLicenseElement(className) {
    var _this$hot$rootElement;
    const licenseInfoElement = (_this$hot$rootElement = this.hot.rootElement.parentNode) === null || _this$hot$rootElement === void 0 ? void 0 : _this$hot$rootElement.querySelector('.hot-display-license-info');
    if (licenseInfoElement) {
      (0, _element.addClass)(licenseInfoElement, className);
    }
  }

  /**
   * Remove a class name from the license information element.
   *
   * @param {string} className The class name to remove.
   */
  removeClassNameFromLicenseElement(className) {
    var _this$hot$rootElement2;
    const licenseInfoElement = (_this$hot$rootElement2 = this.hot.rootElement.parentNode) === null || _this$hot$rootElement2 === void 0 ? void 0 : _this$hot$rootElement2.querySelector('.hot-display-license-info');
    if (licenseInfoElement) {
      (0, _element.removeClass)(licenseInfoElement, className);
    }
  }

  /**
   * Checks if at least one cell than belongs to the main table is not covered by the top, left or
   * bottom overlay.
   *
   * @returns {boolean}
   */
  isMainTableNotFullyCoveredByOverlays() {
    const fixedAllRows = this.countNotHiddenFixedRowsTop() + this.countNotHiddenFixedRowsBottom();
    const fixedAllColumns = this.countNotHiddenFixedColumnsStart();
    return this.hot.countRenderedRows() > fixedAllRows && this.hot.countRenderedCols() > fixedAllColumns;
  }

  /**
   * Defines default configuration and initializes WalkOnTable instance.
   *
   * @private
   */
  initializeWalkontable() {
    const walkontableConfig = {
      ariaTags: this.settings.ariaTags,
      rtlMode: this.hot.isRtl(),
      externalRowCalculator: this.hot.getPlugin('autoRowSize') && this.hot.getPlugin('autoRowSize').isEnabled(),
      table: _classPrivateFieldGet(_table, this),
      isDataViewInstance: () => (0, _rootInstance.isRootInstance)(this.hot),
      preventOverflow: () => this.settings.preventOverflow,
      preventWheel: () => this.settings.preventWheel,
      viewportColumnRenderingThreshold: () => this.settings.viewportColumnRenderingThreshold,
      viewportRowRenderingThreshold: () => this.settings.viewportRowRenderingThreshold,
      data: (renderableRow, renderableColumn) => {
        return this.hot.getDataAtCell(...this.translateFromRenderableToVisualIndex(renderableRow, renderableColumn));
      },
      totalRows: () => this.countRenderableRows(),
      totalColumns: () => this.countRenderableColumns(),
      // Number of renderable columns for the left overlay.
      fixedColumnsStart: () => this.countNotHiddenFixedColumnsStart(),
      // Number of renderable rows for the top overlay.
      fixedRowsTop: () => this.countNotHiddenFixedRowsTop(),
      // Number of renderable rows for the bottom overlay.
      fixedRowsBottom: () => this.countNotHiddenFixedRowsBottom(),
      // Enable the inline start overlay when conditions are met.
      shouldRenderInlineStartOverlay: () => {
        return this.settings.fixedColumnsStart > 0 || walkontableConfig.rowHeaders().length > 0;
      },
      // Enable the top overlay when conditions are met.
      shouldRenderTopOverlay: () => {
        return this.settings.fixedRowsTop > 0 || walkontableConfig.columnHeaders().length > 0;
      },
      // Enable the bottom overlay when conditions are met.
      shouldRenderBottomOverlay: () => {
        return this.settings.fixedRowsBottom > 0;
      },
      minSpareRows: () => this.settings.minSpareRows,
      renderAllRows: this.settings.renderAllRows,
      renderAllColumns: this.settings.renderAllColumns,
      rowHeaders: () => {
        const headerRenderers = [];
        if (this.hot.hasRowHeaders()) {
          headerRenderers.push((renderableRowIndex, TH) => {
            // TODO: Some helper may be needed.
            // We perform translation for row indexes (without row headers).
            const visualRowIndex = renderableRowIndex >= 0 ? this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
            this.appendRowHeader(visualRowIndex, TH);
          });
        }
        this.hot.runHooks('afterGetRowHeaderRenderers', headerRenderers);
        _classPrivateFieldSet(_rowHeadersCount, this, headerRenderers.length);
        if (this.hot.getSettings().ariaTags) {
          // Update the aria-colcount attribute.
          // Only needs to be done once after initialization/data update.
          if (_assertClassBrand(_TableView_brand, this, _getAriaColcount).call(this) === this.hot.countCols()) {
            _assertClassBrand(_TableView_brand, this, _updateAriaColcount).call(this, _classPrivateFieldGet(_rowHeadersCount, this));
          }
        }
        return headerRenderers;
      },
      columnHeaders: () => {
        const headerRenderers = [];
        if (this.hot.hasColHeaders()) {
          headerRenderers.push((renderedColumnIndex, TH) => {
            // TODO: Some helper may be needed.
            // We perform translation for columns indexes (without column headers).
            const visualColumnsIndex = renderedColumnIndex >= 0 ? this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex) : renderedColumnIndex;
            this.appendColHeader(visualColumnsIndex, TH);
          });
        }
        this.hot.runHooks('afterGetColumnHeaderRenderers', headerRenderers);
        _classPrivateFieldSet(_columnHeadersCount, this, headerRenderers.length);
        return headerRenderers;
      },
      columnWidth: renderedColumnIndex => {
        const visualIndex = this.hot.columnIndexMapper.getVisualFromRenderableIndex(renderedColumnIndex);

        // It's not a bug that we can't find visual index for some handled by method indexes. The function is called also
        // for indexes that are not displayed (indexes that are beyond the grid's boundaries), i.e. when `fixedColumnsStart` > `startCols` (wrong config?) or
        // scrolling and dataset is empty (scroll should handle that?).
        return this.hot.getColWidth(visualIndex === null ? renderedColumnIndex : visualIndex);
      },
      rowHeight: renderedRowIndex => {
        const visualIndex = this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);
        return this.hot.getRowHeight(visualIndex === null ? renderedRowIndex : visualIndex);
      },
      rowHeightByOverlayName: (renderedRowIndex, overlayType) => {
        const visualIndex = this.hot.rowIndexMapper.getVisualFromRenderableIndex(renderedRowIndex);
        const visualRowIndex = visualIndex === null ? renderedRowIndex : visualIndex;
        return this.hot.runHooks('modifyRowHeightByOverlayName', this.hot.getRowHeight(visualRowIndex), visualRowIndex, overlayType);
      },
      cellRenderer: (renderedRowIndex, renderedColumnIndex, TD) => {
        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(renderedRowIndex, renderedColumnIndex);

        // Coords may be modified. For example, by the `MergeCells` plugin. It should affect cell value and cell meta.
        const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex, false, 'meta');
        let visualRowToCheck = visualRowIndex;
        let visualColumnToCheck = visualColumnIndex;
        if (Array.isArray(modifiedCellCoords)) {
          [visualRowToCheck, visualColumnToCheck] = modifiedCellCoords;
        }
        const cellProperties = this.hot.getCellMeta(visualRowToCheck, visualColumnToCheck);
        const prop = this.hot.colToProp(visualColumnToCheck);
        let value = this.hot.getDataAtRowProp(visualRowToCheck, prop);
        if (this.hot.hasHook('beforeValueRender')) {
          value = this.hot.runHooks('beforeValueRender', value, cellProperties);
        }
        this.hot.runHooks('beforeRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
        this.hot.getCellRenderer(cellProperties)(this.hot, TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
        this.hot.runHooks('afterRenderer', TD, visualRowIndex, visualColumnIndex, prop, value, cellProperties);
      },
      selections: this.hot.selection.highlight,
      hideBorderOnMouseDownOver: () => this.settings.fragmentSelection,
      onWindowResize: () => {
        if (this.hot && !this.hot.isDestroyed) {
          this.hot.refreshDimensions();
        }
      },
      onContainerElementResize: () => {
        if (this.hot && !this.hot.isDestroyed && (0, _element.isVisible)(this.hot.rootElement)) {
          this.hot.refreshDimensions();
        }
      },
      onCellMouseDown: (event, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        const controller = {
          row: false,
          column: false,
          cell: false
        };
        this.hot.listen();
        this.activeWt = wt;
        _classPrivateFieldSet(_mouseDown, this, true);
        this.hot.runHooks('beforeOnCellMouseDown', event, visualCoords, TD, controller);
        if ((0, _event.isImmediatePropagationStopped)(event)) {
          return;
        }
        (0, _mouseEventHandler.handleMouseEvent)(event, {
          coords: visualCoords,
          selection: this.hot.selection,
          controller,
          cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)
        });
        this.hot.runHooks('afterOnCellMouseDown', event, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellContextMenu: (event, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        this.activeWt = wt;
        _classPrivateFieldSet(_mouseDown, this, false);
        if (this.hot.selection.isInProgress()) {
          this.hot.selection.finish();
        }
        this.hot.runHooks('beforeOnCellContextMenu', event, visualCoords, TD);
        if ((0, _event.isImmediatePropagationStopped)(event)) {
          return;
        }
        this.hot.runHooks('afterOnCellContextMenu', event, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellMouseOut: (event, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        this.activeWt = wt;
        this.hot.runHooks('beforeOnCellMouseOut', event, visualCoords, TD);
        if ((0, _event.isImmediatePropagationStopped)(event)) {
          return;
        }
        this.hot.runHooks('afterOnCellMouseOut', event, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellMouseOver: (event, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        const controller = {
          row: false,
          column: false,
          cell: false
        };
        this.activeWt = wt;
        this.hot.runHooks('beforeOnCellMouseOver', event, visualCoords, TD, controller);
        if ((0, _event.isImmediatePropagationStopped)(event)) {
          return;
        }
        if (_classPrivateFieldGet(_mouseDown, this)) {
          (0, _mouseEventHandler.handleMouseEvent)(event, {
            coords: visualCoords,
            selection: this.hot.selection,
            controller,
            cellCoordsFactory: (row, column) => this.hot._createCellCoords(row, column)
          });
        }
        this.hot.runHooks('afterOnCellMouseOver', event, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellMouseUp: (event, coords, TD, wt) => {
        const visualCoords = this.translateFromRenderableToVisualCoords(coords);
        this.activeWt = wt;
        this.hot.runHooks('beforeOnCellMouseUp', event, visualCoords, TD);

        // TODO: The second condition check is a workaround. Callback corresponding the method `updateSettings`
        // disable plugin and enable it again. Disabling plugin closes the menu. Thus, calling the
        // `updateSettings` in a body of any callback executed right after some context-menu action
        // breaks the table (#7231).
        if ((0, _event.isImmediatePropagationStopped)(event) || this.hot.isDestroyed) {
          return;
        }
        this.hot.runHooks('afterOnCellMouseUp', event, visualCoords, TD);
        this.activeWt = this._wt;
      },
      onCellCornerMouseDown: event => {
        event.preventDefault();
        this.hot.runHooks('afterOnCellCornerMouseDown', event);
      },
      onCellCornerDblClick: event => {
        event.preventDefault();
        this.hot.runHooks('afterOnCellCornerDblClick', event);
      },
      beforeDraw: (force, skipRender) => this.beforeRender(force, skipRender),
      onDraw: force => this.afterRender(force),
      onBeforeViewportScrollVertically: (renderableRow, snapping) => {
        const rowMapper = this.hot.rowIndexMapper;
        const areColumnHeadersSelected = renderableRow < 0;
        let visualRow = renderableRow;
        if (!areColumnHeadersSelected) {
          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);

          // for an empty data return index as is
          if (visualRow === null) {
            return renderableRow;
          }
        }
        visualRow = this.hot.runHooks('beforeViewportScrollVertically', visualRow, snapping);
        this.hot.runHooks('beforeViewportScroll');
        if (!areColumnHeadersSelected) {
          return rowMapper.getRenderableFromVisualIndex(visualRow);
        }
        return visualRow;
      },
      onBeforeViewportScrollHorizontally: (renderableColumn, snapping) => {
        const columnMapper = this.hot.columnIndexMapper;
        const areRowHeadersSelected = renderableColumn < 0;
        let visualColumn = renderableColumn;
        if (!areRowHeadersSelected) {
          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);

          // for an empty data return index as is
          if (visualColumn === null) {
            return renderableColumn;
          }
        }
        visualColumn = this.hot.runHooks('beforeViewportScrollHorizontally', visualColumn, snapping);
        this.hot.runHooks('beforeViewportScroll');
        if (!areRowHeadersSelected) {
          return columnMapper.getRenderableFromVisualIndex(visualColumn);
        }
        return visualColumn;
      },
      onScrollVertically: () => {
        this.hot.runHooks('afterScrollVertically');
        this.hot.runHooks('afterScroll');
      },
      onScrollHorizontally: () => {
        this.hot.runHooks('afterScrollHorizontally');
        this.hot.runHooks('afterScroll');
      },
      onBeforeRemoveCellClassNames: () => this.hot.runHooks('beforeRemoveCellClassNames'),
      onBeforeHighlightingRowHeader: (renderableRow, headerLevel, highlightMeta) => {
        const rowMapper = this.hot.rowIndexMapper;
        const areColumnHeadersSelected = renderableRow < 0;
        let visualRow = renderableRow;
        if (!areColumnHeadersSelected) {
          visualRow = rowMapper.getVisualFromRenderableIndex(renderableRow);
        }
        const newVisualRow = this.hot.runHooks('beforeHighlightingRowHeader', visualRow, headerLevel, highlightMeta);
        if (!areColumnHeadersSelected) {
          return rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(newVisualRow, 1));
        }
        return newVisualRow;
      },
      onBeforeHighlightingColumnHeader: (renderableColumn, headerLevel, highlightMeta) => {
        const columnMapper = this.hot.columnIndexMapper;
        const areRowHeadersSelected = renderableColumn < 0;
        let visualColumn = renderableColumn;
        if (!areRowHeadersSelected) {
          visualColumn = columnMapper.getVisualFromRenderableIndex(renderableColumn);
        }
        const newVisualColumn = this.hot.runHooks('beforeHighlightingColumnHeader', visualColumn, headerLevel, highlightMeta);
        if (!areRowHeadersSelected) {
          return columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(newVisualColumn, 1));
        }
        return newVisualColumn;
      },
      onAfterDrawSelection: (currentRow, currentColumn, layerLevel) => {
        let cornersOfSelection;
        const [visualRowIndex, visualColumnIndex] = this.translateFromRenderableToVisualIndex(currentRow, currentColumn);
        const selectedRange = this.hot.selection.getSelectedRange();
        const selectionRangeSize = selectedRange.size();
        if (selectionRangeSize > 0) {
          const selectionForLayer = selectedRange.peekByIndex(layerLevel !== null && layerLevel !== void 0 ? layerLevel : 0);
          cornersOfSelection = [selectionForLayer.from.row, selectionForLayer.from.col, selectionForLayer.to.row, selectionForLayer.to.col];
        }
        return this.hot.runHooks('afterDrawSelection', visualRowIndex, visualColumnIndex, cornersOfSelection, layerLevel);
      },
      onBeforeDrawBorders: (corners, borderClassName) => {
        const [startRenderableRow, startRenderableColumn, endRenderableRow, endRenderableColumn] = corners;
        const visualCorners = [this.hot.rowIndexMapper.getVisualFromRenderableIndex(startRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(startRenderableColumn), this.hot.rowIndexMapper.getVisualFromRenderableIndex(endRenderableRow), this.hot.columnIndexMapper.getVisualFromRenderableIndex(endRenderableColumn)];
        return this.hot.runHooks('beforeDrawBorders', visualCorners, borderClassName);
      },
      onBeforeTouchScroll: () => this.hot.runHooks('beforeTouchScroll'),
      onAfterMomentumScroll: () => this.hot.runHooks('afterMomentumScroll'),
      onModifyRowHeaderWidth: rowHeaderWidth => this.hot.runHooks('modifyRowHeaderWidth', rowHeaderWidth),
      onModifyGetCellCoords: (renderableRowIndex, renderableColumnIndex, topmost, source) => {
        const rowMapper = this.hot.rowIndexMapper;
        const columnMapper = this.hot.columnIndexMapper;

        // Callback handle also headers. We shouldn't translate them.
        const visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;
        const visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
        const visualIndexes = this.hot.runHooks('modifyGetCellCoords', visualRowIndex, visualColumnIndex, topmost, source);
        if (Array.isArray(visualIndexes)) {
          const [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = visualIndexes;

          // Result of the hook is handled by the Walkontable (renderable indexes).
          return [visualRowFrom >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowFrom, 1)) : visualRowFrom, visualColumnFrom >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnFrom, 1)) : visualColumnFrom, visualRowTo >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRowTo, -1)) : visualRowTo, visualColumnTo >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumnTo, -1)) : visualColumnTo];
        }
      },
      onModifyGetCoordsElement: (renderableRowIndex, renderableColumnIndex) => {
        const rowMapper = this.hot.rowIndexMapper;
        const columnMapper = this.hot.columnIndexMapper;
        const visualColumnIndex = renderableColumnIndex >= 0 ? columnMapper.getVisualFromRenderableIndex(renderableColumnIndex) : renderableColumnIndex;
        const visualRowIndex = renderableRowIndex >= 0 ? rowMapper.getVisualFromRenderableIndex(renderableRowIndex) : renderableRowIndex;
        const visualIndexes = this.hot.runHooks('modifyGetCoordsElement', visualRowIndex, visualColumnIndex);
        if (Array.isArray(visualIndexes)) {
          const [visualRow, visualColumn] = visualIndexes;
          return [visualRow >= 0 ? rowMapper.getRenderableFromVisualIndex(rowMapper.getNearestNotHiddenIndex(visualRow, 1)) : visualRow, visualColumn >= 0 ? columnMapper.getRenderableFromVisualIndex(columnMapper.getNearestNotHiddenIndex(visualColumn, 1)) : visualColumn];
        }
      },
      viewportRowCalculatorOverride: calc => {
        let viewportOffset = this.settings.viewportRowRenderingOffset;
        if (viewportOffset === 'auto' && this.settings.fixedRowsTop) {
          viewportOffset = 10;
        }
        if (viewportOffset > 0 || viewportOffset === 'auto') {
          const renderableRows = this.countRenderableRows();
          const firstRenderedRow = calc.startRow;
          const lastRenderedRow = calc.endRow;
          if (typeof viewportOffset === 'number') {
            calc.startRow = Math.max(firstRenderedRow - viewportOffset, 0);
            calc.endRow = Math.min(lastRenderedRow + viewportOffset, renderableRows - 1);
          } else if (viewportOffset === 'auto') {
            const offset = Math.max(1, Math.ceil(lastRenderedRow / renderableRows * 12));
            calc.startRow = Math.max(firstRenderedRow - offset, 0);
            calc.endRow = Math.min(lastRenderedRow + offset, renderableRows - 1);
          }
        }
        this.hot.runHooks('afterViewportRowCalculatorOverride', calc);
      },
      viewportColumnCalculatorOverride: calc => {
        let viewportOffset = this.settings.viewportColumnRenderingOffset;
        if (viewportOffset === 'auto' && this.settings.fixedColumnsStart) {
          viewportOffset = 10;
        }
        if (viewportOffset > 0 || viewportOffset === 'auto') {
          const renderableColumns = this.countRenderableColumns();
          const firstRenderedColumn = calc.startColumn;
          const lastRenderedColumn = calc.endColumn;
          if (typeof viewportOffset === 'number') {
            calc.startColumn = Math.max(firstRenderedColumn - viewportOffset, 0);
            calc.endColumn = Math.min(lastRenderedColumn + viewportOffset, renderableColumns - 1);
          }
          if (viewportOffset === 'auto') {
            const offset = Math.max(1, Math.ceil(lastRenderedColumn / renderableColumns * 6));
            calc.startColumn = Math.max(firstRenderedColumn - offset, 0);
            calc.endColumn = Math.min(lastRenderedColumn + offset, renderableColumns - 1);
          }
        }
        this.hot.runHooks('afterViewportColumnCalculatorOverride', calc);
      },
      rowHeaderWidth: () => this.settings.rowHeaderWidth,
      columnHeaderHeight: () => {
        const columnHeaderHeight = this.hot.runHooks('modifyColumnHeaderHeight');
        return this.settings.columnHeaderHeight || columnHeaderHeight;
      }
    };
    this.hot.runHooks('beforeInitWalkontable', walkontableConfig);
    this._wt = new _src.default(walkontableConfig);
    this.activeWt = this._wt;
    const spreader = this._wt.wtTable.spreader;
    // We have to cache width and height after Walkontable initialization.
    const {
      width,
      height
    } = this.hot.rootElement.getBoundingClientRect();
    this.setLastSize(width, height);
    this.eventManager.addEventListener(spreader, 'mousedown', event => {
      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar
      if (event.target === spreader && event.which === 3) {
        event.stopPropagation();
      }
    });
    this.eventManager.addEventListener(spreader, 'contextmenu', event => {
      // right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar
      if (event.target === spreader && event.which === 3) {
        event.stopPropagation();
      }
    });
    this.eventManager.addEventListener(this.hot.rootDocument.documentElement, 'click', () => {
      if (this.settings.observeDOMVisibility) {
        if (this._wt.drawInterrupted) {
          this.hot.forceFullRender = true;
          this.render();
        }
      }
    });
  }

  /**
   * Checks if it's possible to create text selection in element.
   *
   * @private
   * @param {HTMLElement} el The element to check.
   * @returns {boolean}
   */
  isTextSelectionAllowed(el) {
    if ((0, _element.isInput)(el)) {
      return true;
    }
    const isChildOfTableBody = (0, _element.isChildOf)(el, this._wt.wtTable.spreader);
    if (this.settings.fragmentSelection === true && isChildOfTableBody) {
      return true;
    }
    if (this.settings.fragmentSelection === 'cell' && this.isSelectedOnlyCell() && isChildOfTableBody) {
      return true;
    }
    if (!this.settings.fragmentSelection && this.isCellEdited() && this.isSelectedOnlyCell()) {
      return true;
    }
    return false;
  }

  /**
   * Checks if user's been called mousedown.
   *
   * @private
   * @returns {boolean}
   */
  isMouseDown() {
    return _classPrivateFieldGet(_mouseDown, this);
  }

  /**
   * Check if selected only one cell.
   *
   * @private
   * @returns {boolean}
   */
  isSelectedOnlyCell() {
    var _this$hot$getSelected, _this$hot$getSelected2;
    return (_this$hot$getSelected = (_this$hot$getSelected2 = this.hot.getSelectedRangeLast()) === null || _this$hot$getSelected2 === void 0 ? void 0 : _this$hot$getSelected2.isSingleCell()) !== null && _this$hot$getSelected !== void 0 ? _this$hot$getSelected : false;
  }

  /**
   * Checks if active cell is editing.
   *
   * @private
   * @returns {boolean}
   */
  isCellEdited() {
    const activeEditor = this.hot.getActiveEditor();
    return activeEditor && activeEditor.isOpened();
  }

  /**
   * `beforeDraw` callback.
   *
   * @private
   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if
   *                        rendering was triggered by scrolling or moving selection.
   * @param {object} skipRender Object with `skipRender` property, if it is set to `true ` the next rendering
   *                            cycle will be skipped.
   */
  beforeRender(force, skipRender) {
    if (force) {
      // this.hot.forceFullRender = did Handsontable request full render?
      this.hot.runHooks('beforeViewRender', this.hot.forceFullRender, skipRender);
    }
  }

  /**
   * `afterRender` callback.
   *
   * @private
   * @param {boolean} force If `true` rendering was triggered by a change of settings or data or `false` if
   *                        rendering was triggered by scrolling or moving selection.
   */
  afterRender(force) {
    if (force) {
      // this.hot.forceFullRender = did Handsontable request full render?
      this.hot.runHooks('afterViewRender', this.hot.forceFullRender);
    }
  }

  /**
   * Append row header to a TH element.
   *
   * @private
   * @param {number} visualRowIndex The visual row index.
   * @param {HTMLTableHeaderCellElement} TH The table header element.
   */
  appendRowHeader(visualRowIndex, TH) {
    if (TH.firstChild) {
      const container = TH.firstChild;
      if (!(0, _element.hasClass)(container, 'relative')) {
        (0, _element.empty)(TH);
        this.appendRowHeader(visualRowIndex, TH);
        return;
      }
      this.updateCellHeader(container.querySelector('.rowHeader'), visualRowIndex, this.hot.getRowHeader);
    } else {
      const {
        rootDocument,
        getRowHeader
      } = this.hot;
      const div = rootDocument.createElement('div');
      const span = rootDocument.createElement('span');
      div.className = 'relative';
      span.className = 'rowHeader';
      this.updateCellHeader(span, visualRowIndex, getRowHeader);
      div.appendChild(span);
      TH.appendChild(div);
    }
    this.hot.runHooks('afterGetRowHeader', visualRowIndex, TH);
  }

  /**
   * Append column header to a TH element.
   *
   * @private
   * @param {number} visualColumnIndex Visual column index.
   * @param {HTMLTableCellElement} TH The table header element.
   * @param {Function} [label] The function that returns the header label.
   * @param {number} [headerLevel=0] The index of header level counting from the top (positive
   *                                 values counting from 0 to N).
   */
  appendColHeader(visualColumnIndex, TH) {
    let label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hot.getColHeader;
    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    const getColumnHeaderClassNames = () => {
      const metaHeaderClassNames = visualColumnIndex >= 0 ? this.hot.getColumnMeta(visualColumnIndex).headerClassName : null;
      return metaHeaderClassNames ? metaHeaderClassNames.split(' ') : [];
    };
    if (TH.firstChild) {
      const container = TH.firstChild;
      if ((0, _element.hasClass)(container, 'relative')) {
        this.updateCellHeader(container.querySelector('.colHeader'), visualColumnIndex, label, headerLevel);
        container.className = '';
        (0, _element.addClass)(container, ['relative', ...getColumnHeaderClassNames()]);
      } else {
        (0, _element.empty)(TH);
        this.appendColHeader(visualColumnIndex, TH, label, headerLevel);
      }
    } else {
      const {
        rootDocument
      } = this.hot;
      const div = rootDocument.createElement('div');
      const span = rootDocument.createElement('span');
      const classNames = getColumnHeaderClassNames();
      div.classList.add('relative', ...classNames);
      span.className = 'colHeader';
      if (this.settings.ariaTags) {
        (0, _element.setAttribute)(div, ...(0, _a11y.A11Y_PRESENTATION)());
        (0, _element.setAttribute)(span, ...(0, _a11y.A11Y_PRESENTATION)());
      }
      this.updateCellHeader(span, visualColumnIndex, label, headerLevel);
      div.appendChild(span);
      TH.appendChild(div);
    }
    this.hot.runHooks('afterGetColHeader', visualColumnIndex, TH, headerLevel);
  }

  /**
   * Updates header cell content.
   *
   * @private
   * @param {HTMLElement} element Element to update.
   * @param {number} index Row index or column index.
   * @param {Function} content Function which should be returns content for this cell.
   * @param {number} [headerLevel=0] The index of header level counting from the top (positive
   *                                 values counting from 0 to N).
   */
  updateCellHeader(element, index, content) {
    let headerLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let renderedIndex = index;
    const parentOverlay = this._wt.wtOverlays.getParentOverlay(element) || this._wt;

    // prevent wrong calculations from SampleGenerator
    if (element.parentNode) {
      if ((0, _element.hasClass)(element, 'colHeader')) {
        renderedIndex = parentOverlay.wtTable.columnFilter.sourceToRendered(index);
      } else if ((0, _element.hasClass)(element, 'rowHeader')) {
        renderedIndex = parentOverlay.wtTable.rowFilter.sourceToRendered(index);
      }
    }
    if (renderedIndex > -1) {
      (0, _element.fastInnerHTML)(element, content(index, headerLevel));
    } else {
      // workaround for https://github.com/handsontable/handsontable/issues/1946
      (0, _element.fastInnerText)(element, String.fromCharCode(160));
      (0, _element.addClass)(element, 'cornerHeader');
    }
  }

  /**
   * Given a element's left (or right in RTL mode) position relative to the viewport, returns maximum
   * element width until the right (or left) edge of the viewport (before scrollbar).
   *
   * @private
   * @param {number} inlineOffset The left (or right in RTL mode) offset.
   * @returns {number}
   */
  maximumVisibleElementWidth(inlineOffset) {
    const workspaceWidth = this._wt.wtViewport.getWorkspaceWidth();
    const maxWidth = workspaceWidth - inlineOffset;
    return maxWidth > 0 ? maxWidth : 0;
  }

  /**
   * Given a element's top position relative to the viewport, returns maximum element height until the bottom
   * edge of the viewport (before scrollbar).
   *
   * @private
   * @param {number} topOffset The top offset.
   * @returns {number}
   */
  maximumVisibleElementHeight(topOffset) {
    const workspaceHeight = this._wt.wtViewport.getWorkspaceHeight();
    const maxHeight = workspaceHeight - topOffset;
    return maxHeight > 0 ? maxHeight : 0;
  }

  /**
   * Sets new dimensions of the container.
   *
   * @param {number} width The table width.
   * @param {number} height The table height.
   */
  setLastSize(width, height) {
    _classPrivateFieldSet(_lastWidth, this, width);
    _classPrivateFieldSet(_lastHeight, this, height);
  }

  /**
   * Returns cached dimensions.
   *
   * @returns {object}
   */
  getLastSize() {
    return {
      width: _classPrivateFieldGet(_lastWidth, this),
      height: _classPrivateFieldGet(_lastHeight, this)
    };
  }

  /**
   * Returns the first rendered row in the DOM (usually is not visible in the table's viewport).
   *
   * @returns {number | null}
   */
  getFirstRenderedVisibleRow() {
    if (!this._wt.wtViewport.rowsRenderCalculator) {
      return null;
    }
    const indexMapper = this.hot.rowIndexMapper;
    const visualRowIndex = indexMapper.getVisualFromRenderableIndex(this._wt.wtTable.getFirstRenderedRow());
    return indexMapper.getNearestNotHiddenIndex(visualRowIndex !== null && visualRowIndex !== void 0 ? visualRowIndex : 0, 1);
  }

  /**
   * Returns the last rendered row in the DOM (usually is not visible in the table's viewport).
   *
   * @returns {number | null}
   */
  getLastRenderedVisibleRow() {
    if (!this._wt.wtViewport.rowsRenderCalculator) {
      return null;
    }
    const indexMapper = this.hot.rowIndexMapper;
    const visualRowIndex = indexMapper.getVisualFromRenderableIndex(this._wt.wtTable.getLastRenderedRow());
    return indexMapper.getNearestNotHiddenIndex(visualRowIndex !== null && visualRowIndex !== void 0 ? visualRowIndex : this.hot.countRows() - 1, -1);
  }

  /**
   * Returns the first rendered column in the DOM (usually is not visible in the table's viewport).
   *
   * @returns {number | null}
   */
  getFirstRenderedVisibleColumn() {
    if (!this._wt.wtViewport.columnsRenderCalculator) {
      return null;
    }
    const indexMapper = this.hot.columnIndexMapper;
    const visualColumnIndex = indexMapper.getVisualFromRenderableIndex(this._wt.wtTable.getFirstRenderedColumn());
    return indexMapper.getNearestNotHiddenIndex(visualColumnIndex !== null && visualColumnIndex !== void 0 ? visualColumnIndex : 0, 1);
  }

  /**
   * Returns the last rendered column in the DOM (usually is not visible in the table's viewport).
   *
   * @returns {number | null}
   */
  getLastRenderedVisibleColumn() {
    if (!this._wt.wtViewport.columnsRenderCalculator) {
      return null;
    }
    const indexMapper = this.hot.columnIndexMapper;
    const visualColumnIndex = indexMapper.getVisualFromRenderableIndex(this._wt.wtTable.getLastRenderedColumn());
    return indexMapper.getNearestNotHiddenIndex(visualColumnIndex !== null && visualColumnIndex !== void 0 ? visualColumnIndex : this.hot.countCols() - 1, -1);
  }

  /**
   * Returns the first fully visible row in the table viewport. When the table has overlays the method returns
   * the first row of the master table that is not overlapped by overlay.
   *
   * @returns {number}
   */
  getFirstFullyVisibleRow() {
    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstVisibleRow());
  }

  /**
   * Returns the last fully visible row in the table viewport. When the table has overlays the method returns
   * the first row of the master table that is not overlapped by overlay.
   *
   * @returns {number}
   */
  getLastFullyVisibleRow() {
    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastVisibleRow());
  }

  /**
   * Returns the first fully visible column in the table viewport. When the table has overlays the method returns
   * the first row of the master table that is not overlapped by overlay.
   *
   * @returns {number}
   */
  getFirstFullyVisibleColumn() {
    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstVisibleColumn());
  }

  /**
   * Returns the last fully visible column in the table viewport. When the table has overlays the method returns
   * the first row of the master table that is not overlapped by overlay.
   *
   * @returns {number}
   */
  getLastFullyVisibleColumn() {
    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastVisibleColumn());
  }

  /**
   * Returns the first partially visible row in the table viewport. When the table has overlays the method returns
   * the first row of the master table that is not overlapped by overlay.
   *
   * @returns {number}
   */
  getFirstPartiallyVisibleRow() {
    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstPartiallyVisibleRow());
  }

  /**
   * Returns the last partially visible row in the table viewport. When the table has overlays the method returns
   * the first row of the master table that is not overlapped by overlay.
   *
   * @returns {number}
   */
  getLastPartiallyVisibleRow() {
    return this.hot.rowIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastPartiallyVisibleRow());
  }

  /**
   * Returns the first partially visible column in the table viewport. When the table has overlays the method returns
   * the first row of the master table that is not overlapped by overlay.
   *
   * @returns {number}
   */
  getFirstPartiallyVisibleColumn() {
    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getFirstPartiallyVisibleColumn());
  }

  /**
   * Returns the last partially visible column in the table viewport. When the table has overlays the method returns
   * the first row of the master table that is not overlapped by overlay.
   *
   * @returns {number}
   */
  getLastPartiallyVisibleColumn() {
    return this.hot.columnIndexMapper.getVisualFromRenderableIndex(this._wt.wtScroll.getLastPartiallyVisibleColumn());
  }

  /**
   * Returns the total count of the rendered column headers.
   *
   * @returns {number}
   */
  getColumnHeadersCount() {
    return _classPrivateFieldGet(_columnHeadersCount, this);
  }

  /**
   * Returns the total count of the rendered row headers.
   *
   * @returns {number}
   */
  getRowHeadersCount() {
    return _classPrivateFieldGet(_rowHeadersCount, this);
  }

  /**
   * Returns the table's viewport width. When the table has defined the size of the container,
   * and the columns do not fill the entire viewport, the viewport width is equal to the sum of
   * the columns' widths.
   *
   * @returns {number}
   */
  getViewportWidth() {
    return this._wt.wtViewport.getViewportWidth();
  }

  /**
   * Returns the table's total width including the scrollbar width.
   *
   * @returns {number}
   */
  getWorkspaceWidth() {
    return this._wt.wtViewport.getWorkspaceWidth();
  }

  /**
   * Returns the table's viewport height. When the table has defined the size of the container,
   * and the rows do not fill the entire viewport, the viewport height is equal to the sum of
   * the rows' heights.
   *
   * @returns {number}
   */
  getViewportHeight() {
    return this._wt.wtViewport.getViewportHeight();
  }

  /**
   * Returns the table's total height including the scrollbar height.
   *
   * @returns {number}
   */
  getWorkspaceHeight() {
    return this._wt.wtViewport.getWorkspaceHeight();
  }

  /**
   * Checks to what overlay the provided element belongs.
   *
   * @param {HTMLElement} element The DOM element to check.
   * @returns {'master'|'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'}
   */
  getElementOverlayName(element) {
    var _this$_wt$wtOverlays$;
    return ((_this$_wt$wtOverlays$ = this._wt.wtOverlays.getParentOverlay(element)) !== null && _this$_wt$wtOverlays$ !== void 0 ? _this$_wt$wtOverlays$ : this._wt).wtTable.name;
  }

  /**
   * Gets the overlay instance by its name.
   *
   * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'} overlayName The overlay name.
   * @returns {Overlay | null}
   */
  getOverlayByName(overlayName) {
    return this._wt.getOverlayByName(overlayName);
  }

  /**
   * Gets the name of the overlay that currently renders the table. If the method is called out of the render cycle
   * the 'master' name is returned.
   *
   * @returns {string}
   */
  getActiveOverlayName() {
    return this._wt.activeOverlayName;
  }

  /**
   * Checks if the table is visible or not.
   *
   * @returns {boolean}
   */
  isVisible() {
    return this._wt.wtTable.isVisible();
  }

  /**
   * Checks if the table has a horizontal scrollbar.
   *
   * @returns {boolean}
   */
  hasVerticalScroll() {
    return this._wt.wtViewport.hasVerticalScroll();
  }

  /**
   * Checks if the table has a vertical scrollbar.
   *
   * @returns {boolean}
   */
  hasHorizontalScroll() {
    return this._wt.wtViewport.hasHorizontalScroll();
  }

  /**
   * Gets the table's width.
   *
   * @returns {boolean}
   */
  getTableWidth() {
    return this._wt.wtTable.getWidth();
  }

  /**
   * Gets the table's height.
   *
   * @returns {boolean}
   */
  getTableHeight() {
    return this._wt.wtTable.getHeight();
  }

  /**
   * Gets the row header width. If there are multiple row headers, the width of
   * the sum of all of them is returned.
   *
   * @returns {number}
   */
  getRowHeaderWidth() {
    return this._wt.wtViewport.getRowHeaderWidth();
  }

  /**
   * Gets the column header height. If there are multiple column headers, the height
   * of the sum of all of them is returned.
   *
   * @returns {number}
   */
  getColumnHeaderHeight() {
    return this._wt.wtViewport.getColumnHeaderHeight();
  }

  /**
   * Checks if the table uses the window as a viewport and if there is a vertical scrollbar.
   *
   * @returns {boolean}
   */
  isVerticallyScrollableByWindow() {
    return this._wt.wtViewport.isVerticallyScrollableByWindow();
  }

  /**
   * Checks if the table uses the window as a viewport and if there is a horizontal scrollbar.
   *
   * @returns {boolean}
   */
  isHorizontallyScrollableByWindow() {
    return this._wt.wtViewport.isHorizontallyScrollableByWindow();
  }
  /**
   * Destroys internal WalkOnTable's instance. Detaches all of the bonded listeners.
   *
   * @private
   */
  destroy() {
    this._wt.destroy();
    this.eventManager.destroy();
  }
}
function _getAriaColcount() {
  return parseInt(this.hot.rootElement.getAttribute((0, _a11y.A11Y_COLCOUNT)()[0]), 10);
}
/**
 * Update the `aria-colcount` attribute by the provided value.
 *
 * @param {number} delta The number of columns to add or remove to the aria tag.
 */
function _updateAriaColcount(delta) {
  const colCount = _assertClassBrand(_TableView_brand, this, _getAriaColcount).call(this) + delta;
  (0, _element.setAttribute)(this.hot.rootElement, ...(0, _a11y.A11Y_COLCOUNT)(colCount));
}
/**
 * Updates the class names on the root element based on the presence of scrollbars.
 *
 * This method checks if the table has vertical and/or horizontal scrollbars and
 * adds or removes the corresponding class names (`htHasScrollY` and `htHasScrollX`)
 * to/from the root element.
 */
function _updateScrollbarClassNames() {
  const rootElement = this.hot.rootElement;
  if (this.hasVerticalScroll()) {
    (0, _element.addClass)(rootElement, 'htHasScrollY');
  } else {
    (0, _element.removeClass)(rootElement, 'htHasScrollY');
  }
  if (this.hasHorizontalScroll()) {
    (0, _element.addClass)(rootElement, 'htHasScrollX');
  } else {
    (0, _element.removeClass)(rootElement, 'htHasScrollX');
  }
}
var _default = exports["default"] = TableView;

/***/ }),
/* 540 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _calculator = __webpack_require__(541);
exports.ViewportColumnsCalculator = _calculator.ViewportColumnsCalculator;
exports.ViewportRowsCalculator = _calculator.ViewportRowsCalculator;
exports.DEFAULT_COLUMN_WIDTH = _calculator.DEFAULT_COLUMN_WIDTH;
var _coords = _interopRequireDefault(__webpack_require__(555));
exports.CellCoords = _coords.default;
var _range = _interopRequireDefault(__webpack_require__(556));
exports.CellRange = _range.default;
var _core = _interopRequireDefault(__webpack_require__(557));
exports["default"] = _core.default;
exports.Core = _core.default;
var _selection = __webpack_require__(597);
exports.Selection = _selection.Selection;
exports.HIGHLIGHT_ACTIVE_HEADER_TYPE = _selection.ACTIVE_HEADER_TYPE;
exports.HIGHLIGHT_AREA_TYPE = _selection.AREA_TYPE;
exports.HIGHLIGHT_FOCUS_TYPE = _selection.FOCUS_TYPE;
exports.HIGHLIGHT_FILL_TYPE = _selection.FILL_TYPE;
exports.HIGHLIGHT_HEADER_TYPE = _selection.HEADER_TYPE;
exports.HIGHLIGHT_ROW_TYPE = _selection.ROW_TYPE;
exports.HIGHLIGHT_COLUMN_TYPE = _selection.COLUMN_TYPE;
exports.HIGHLIGHT_CUSTOM_SELECTION_TYPE = _selection.CUSTOM_SELECTION_TYPE;
var Renderer = _interopRequireWildcard(__webpack_require__(567));
exports.Renderer = Renderer;
var _orderView = __webpack_require__(569);
exports.OrderView = _orderView.OrderView;
exports.SharedOrderView = _orderView.SharedOrderView;
var _eventManager = __webpack_require__(522);
exports.getListenersCounter = _eventManager.getListenersCounter;
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }

/***/ }),
/* 541 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _fullyVisibleColumns = __webpack_require__(542);
exports.FullyVisibleColumnsCalculationType = _fullyVisibleColumns.FullyVisibleColumnsCalculationType;
var _fullyVisibleRows = __webpack_require__(545);
exports.FullyVisibleRowsCalculationType = _fullyVisibleRows.FullyVisibleRowsCalculationType;
var _partiallyVisibleColumns = __webpack_require__(546);
exports.PartiallyVisibleColumnsCalculationType = _partiallyVisibleColumns.PartiallyVisibleColumnsCalculationType;
var _partiallyVisibleRows = __webpack_require__(547);
exports.PartiallyVisibleRowsCalculationType = _partiallyVisibleRows.PartiallyVisibleRowsCalculationType;
var _renderedAllColumns = __webpack_require__(548);
exports.RenderedAllColumnsCalculationType = _renderedAllColumns.RenderedAllColumnsCalculationType;
var _renderedAllRows = __webpack_require__(549);
exports.RenderedAllRowsCalculationType = _renderedAllRows.RenderedAllRowsCalculationType;
var _renderedColumns = __webpack_require__(550);
exports.RenderedColumnsCalculationType = _renderedColumns.RenderedColumnsCalculationType;
var _renderedRows = __webpack_require__(551);
exports.RenderedRowsCalculationType = _renderedRows.RenderedRowsCalculationType;
var _viewportColumns = __webpack_require__(552);
exports.ViewportColumnsCalculator = _viewportColumns.ViewportColumnsCalculator;
exports.DEFAULT_COLUMN_WIDTH = _viewportColumns.DEFAULT_WIDTH;
var _viewportRows = __webpack_require__(554);
exports.ViewportRowsCalculator = _viewportRows.ViewportRowsCalculator;

/***/ }),
/* 542 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(543);
__webpack_require__(544);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @class FullyVisibleColumnsCalculationType
 */
class FullyVisibleColumnsCalculationType {
  constructor() {
    /**
     * Total number of fully visible columns in the viewport.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "count", 0);
    /**
     * The column index of the first fully visible column in the viewport.
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "startColumn", null);
    /**
     * The column index of the last fully visible column in the viewport.
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "endColumn", null);
    /**
     * Position of the first fully visible column (in px).
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "startPosition", null);
    /**
     * Determines if the viewport is visible in the trimming container.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "isVisibleInTrimmingContainer", false);
  }
  /**
   * Initializes the calculation.
   */
  initialize() {}

  /**
   * Processes the column.
   *
   * @param {number} column The column index.
   * @param {ViewportColumnsCalculator} viewportCalculator The viewport calculator object.
   */
  process(column, viewportCalculator) {
    const {
      totalCalculatedWidth,
      zeroBasedScrollOffset,
      viewportWidth,
      columnWidth
    } = viewportCalculator;
    const compensatedViewportWidth = zeroBasedScrollOffset > 0 ? viewportWidth + 1 : viewportWidth;
    if (totalCalculatedWidth >= zeroBasedScrollOffset && totalCalculatedWidth + columnWidth <= zeroBasedScrollOffset + compensatedViewportWidth) {
      if (this.startColumn === null || this.startColumn === undefined) {
        this.startColumn = column;
      }
      this.endColumn = column;
    }
  }

  /**
   * Finalizes the calculation.
   *
   * @param {ViewportColumnsCalculator} viewportCalculator The viewport calculator object.
   */
  finalize(viewportCalculator) {
    var _startPositions$this$;
    const {
      scrollOffset,
      viewportWidth,
      inlineStartOffset,
      zeroBasedScrollOffset,
      totalColumns,
      needReverse,
      startPositions,
      columnWidth
    } = viewportCalculator;

    // If the estimation has reached the last column and there is still some space available in the viewport,
    // we need to render in reverse in order to fill the whole viewport with columns
    if (this.endColumn === totalColumns - 1 && needReverse) {
      this.startColumn = this.endColumn;
      while (this.startColumn > 0) {
        const calculatedViewportHeight = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];
        if (calculatedViewportHeight <= viewportWidth) {
          this.startColumn -= 1;
        }
        if (calculatedViewportHeight >= viewportWidth) {
          break;
        }
      }
    }
    this.startPosition = (_startPositions$this$ = startPositions[this.startColumn]) !== null && _startPositions$this$ !== void 0 ? _startPositions$this$ : null;
    const compensatedViewportWidth = zeroBasedScrollOffset > 0 ? viewportWidth + 1 : viewportWidth;
    const mostRightScrollOffset = scrollOffset + viewportWidth - compensatedViewportWidth;
    const inlineStartColumnOffset = this.startColumn === null ? 0 : viewportCalculator.getColumnWidth(this.startColumn);
    if (
    // the table is to the left of the viewport
    mostRightScrollOffset < -1 * inlineStartOffset || scrollOffset > startPositions.at(-1) ||
    // the table is to the right of the viewport
    -1 * scrollOffset - viewportWidth > -1 * inlineStartColumnOffset) {
      this.isVisibleInTrimmingContainer = false;
    } else {
      this.isVisibleInTrimmingContainer = true;
    }
    if (totalColumns < this.endColumn) {
      this.endColumn = totalColumns - 1;
    }
    if (this.startColumn !== null) {
      this.count = this.endColumn - this.startColumn + 1;
    }
  }
}
exports.FullyVisibleColumnsCalculationType = FullyVisibleColumnsCalculationType;

/***/ }),
/* 543 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var toObject = __webpack_require__(238);
var lengthOfArrayLike = __webpack_require__(262);
var toIntegerOrInfinity = __webpack_require__(260);
var addToUnscopables = __webpack_require__(518);

// `Array.prototype.at` method
// https://tc39.es/ecma262/#sec-array.prototype.at
$({ target: 'Array', proto: true }, {
  at: function at(index) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var relativeIndex = toIntegerOrInfinity(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return (k < 0 || k >= len) ? undefined : O[k];
  }
});

addToUnscopables('at');


/***/ }),
/* 544 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var uncurryThis = __webpack_require__(213);
var requireObjectCoercible = __webpack_require__(215);
var toIntegerOrInfinity = __webpack_require__(260);
var toString = __webpack_require__(276);
var fails = __webpack_require__(206);

var charAt = uncurryThis(''.charAt);

var FORCED = fails(function () {
  // eslint-disable-next-line es/no-string-prototype-at -- safe
  return '𠮷'.at(-2) !== '\uD842';
});

// `String.prototype.at` method
// https://tc39.es/ecma262/#sec-string.prototype.at
$({ target: 'String', proto: true, forced: FORCED }, {
  at: function at(index) {
    var S = toString(requireObjectCoercible(this));
    var len = S.length;
    var relativeIndex = toIntegerOrInfinity(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return (k < 0 || k >= len) ? undefined : charAt(S, k);
  }
});


/***/ }),
/* 545 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(543);
__webpack_require__(544);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @class FullyVisibleRowsCalculationType
 */
class FullyVisibleRowsCalculationType {
  constructor() {
    /**
     * Total number of fully visible rows in the viewport.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "count", 0);
    /**
     * The row index of the first fully visible row in the viewport.
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "startRow", null);
    /**
     * The row index of the last fully visible row in the viewport.
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "endRow", null);
    /**
     * Position of the first fully visible row (in px).
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "startPosition", null);
    /**
     * Determines if the viewport is visible in the trimming container.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "isVisibleInTrimmingContainer", false);
  }
  /**
   * Initializes the calculation.
   */
  initialize() {}

  /**
   * Processes the row.
   *
   * @param {number} row The row index.
   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.
   */
  process(row, viewportCalculator) {
    const {
      totalCalculatedHeight,
      zeroBasedScrollOffset,
      innerViewportHeight,
      rowHeight
    } = viewportCalculator;
    if (totalCalculatedHeight >= zeroBasedScrollOffset && totalCalculatedHeight + rowHeight <= innerViewportHeight) {
      if (this.startRow === null) {
        this.startRow = row;
      }
      this.endRow = row;
    }
  }

  /**
   * Finalizes the calculation.
   *
   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.
   */
  finalize(viewportCalculator) {
    var _startPositions$this$;
    const {
      scrollOffset,
      viewportHeight,
      horizontalScrollbarHeight,
      totalRows,
      needReverse,
      startPositions,
      rowHeight
    } = viewportCalculator;

    // If the estimation has reached the last row and there is still some space available in the viewport,
    // we need to render in reverse in order to fill the whole viewport with rows
    if (this.endRow === totalRows - 1 && needReverse) {
      this.startRow = this.endRow;
      while (this.startRow > 0) {
        const calculatedViewportHeight = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];
        if (calculatedViewportHeight <= viewportHeight - horizontalScrollbarHeight) {
          this.startRow -= 1;
        }
        if (calculatedViewportHeight >= viewportHeight - horizontalScrollbarHeight) {
          break;
        }
      }
    }
    this.startPosition = (_startPositions$this$ = startPositions[this.startRow]) !== null && _startPositions$this$ !== void 0 ? _startPositions$this$ : null;
    const mostBottomScrollOffset = scrollOffset + viewportHeight - horizontalScrollbarHeight;
    const topRowOffset = this.startRow === null ? 0 : viewportCalculator.getRowHeight(this.startRow);
    if (mostBottomScrollOffset < topRowOffset || scrollOffset > startPositions.at(-1)) {
      this.isVisibleInTrimmingContainer = false;
    } else {
      this.isVisibleInTrimmingContainer = true;
    }
    if (totalRows < this.endRow) {
      this.endRow = totalRows - 1;
    }
    if (this.startRow !== null) {
      this.count = this.endRow - this.startRow + 1;
    }
  }
}
exports.FullyVisibleRowsCalculationType = FullyVisibleRowsCalculationType;

/***/ }),
/* 546 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(543);
__webpack_require__(544);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @class PartiallyVisibleColumnsCalculationType
 */
class PartiallyVisibleColumnsCalculationType {
  constructor() {
    /**
     * Total number of partially visible columns in the viewport.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "count", 0);
    /**
     * The column index of the first partially visible column in the viewport.
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "startColumn", null);
    /**
     * The column index of the last partially visible column in the viewport.
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "endColumn", null);
    /**
     * Position of the first partially visible column (in px).
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "startPosition", null);
    /**
     * Determines if the viewport is visible in the trimming container.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "isVisibleInTrimmingContainer", false);
  }
  /**
   * Initializes the calculation.
   */
  initialize() {}

  /**
   * Processes the column.
   *
   * @param {number} column The column index.
   * @param {ViewportColumnsCalculator} viewportCalculator The viewport calculator object.
   */
  process(column, viewportCalculator) {
    const {
      totalCalculatedWidth,
      zeroBasedScrollOffset,
      viewportWidth
    } = viewportCalculator;
    if (totalCalculatedWidth <= zeroBasedScrollOffset) {
      this.startColumn = column;
    }
    const compensatedViewportWidth = zeroBasedScrollOffset > 0 ? viewportWidth + 1 : viewportWidth;
    if (totalCalculatedWidth >= zeroBasedScrollOffset && totalCalculatedWidth <= zeroBasedScrollOffset + compensatedViewportWidth) {
      if (this.startColumn === null || this.startColumn === undefined) {
        this.startColumn = column;
      }
    }
    this.endColumn = column;
  }

  /**
   * Finalizes the calculation.
   *
   * @param {ViewportColumnsCalculator} viewportCalculator The viewport calculator object.
   */
  finalize(viewportCalculator) {
    var _startPositions$this$;
    const {
      scrollOffset,
      viewportWidth,
      inlineStartOffset,
      zeroBasedScrollOffset,
      totalColumns,
      needReverse,
      startPositions,
      columnWidth
    } = viewportCalculator;

    // If the estimation has reached the last column and there is still some space available in the viewport,
    // we need to render in reverse in order to fill the whole viewport with columns
    if (this.endColumn === totalColumns - 1 && needReverse) {
      this.startColumn = this.endColumn;
      while (this.startColumn > 0) {
        const calculatedViewportWidth = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];
        this.startColumn -= 1;
        if (calculatedViewportWidth > viewportWidth) {
          break;
        }
      }
    }
    this.startPosition = (_startPositions$this$ = startPositions[this.startColumn]) !== null && _startPositions$this$ !== void 0 ? _startPositions$this$ : null;
    const compensatedViewportWidth = zeroBasedScrollOffset > 0 ? viewportWidth + 1 : viewportWidth;
    const mostRightScrollOffset = scrollOffset + viewportWidth - compensatedViewportWidth;
    if (
    // the table is to the left of the viewport
    mostRightScrollOffset < -1 * inlineStartOffset || scrollOffset > startPositions.at(-1) + columnWidth ||
    // the table is to the right of the viewport
    -1 * scrollOffset - viewportWidth > 0) {
      this.isVisibleInTrimmingContainer = false;
    } else {
      this.isVisibleInTrimmingContainer = true;
    }
    if (totalColumns < this.endColumn) {
      this.endColumn = totalColumns - 1;
    }
    if (this.startColumn !== null) {
      this.count = this.endColumn - this.startColumn + 1;
    }
  }
}
exports.PartiallyVisibleColumnsCalculationType = PartiallyVisibleColumnsCalculationType;

/***/ }),
/* 547 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(543);
__webpack_require__(544);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @class PartiallyVisibleRowsCalculationType
 */
class PartiallyVisibleRowsCalculationType {
  constructor() {
    /**
     * Total number of partially visible rows in the viewport.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "count", 0);
    /**
     * The row index of the first partially visible row in the viewport.
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "startRow", null);
    /**
     * The row index of the last partially visible row in the viewport.
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "endRow", null);
    /**
     * Position of the first partially visible row (in px).
     *
     * @type {number|null}
     */
    (0, _defineProperty2.default)(this, "startPosition", null);
    /**
     * Determines if the viewport is visible in the trimming container.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "isVisibleInTrimmingContainer", false);
  }
  /**
   * Initializes the calculation.
   */
  initialize() {}

  /**
   * Processes the row.
   *
   * @param {number} row The row index.
   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.
   */
  process(row, viewportCalculator) {
    const {
      totalCalculatedHeight,
      zeroBasedScrollOffset,
      innerViewportHeight
    } = viewportCalculator;
    if (totalCalculatedHeight <= zeroBasedScrollOffset) {
      this.startRow = row;
    }
    if (totalCalculatedHeight >= zeroBasedScrollOffset && totalCalculatedHeight <= innerViewportHeight) {
      if (this.startRow === null) {
        this.startRow = row;
      }
    }
    this.endRow = row;
  }

  /**
   * Finalizes the calculation.
   *
   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.
   */
  finalize(viewportCalculator) {
    var _startPositions$this$;
    const {
      scrollOffset,
      viewportHeight,
      horizontalScrollbarHeight,
      totalRows,
      needReverse,
      startPositions,
      rowHeight
    } = viewportCalculator;

    // If the estimation has reached the last row and there is still some space available in the viewport,
    // we need to render in reverse in order to fill the whole viewport with rows
    if (this.endRow === totalRows - 1 && needReverse) {
      this.startRow = this.endRow;
      while (this.startRow > 0) {
        const calculatedViewportHeight = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];
        this.startRow -= 1;
        if (calculatedViewportHeight >= viewportHeight - horizontalScrollbarHeight) {
          break;
        }
      }
    }
    this.startPosition = (_startPositions$this$ = startPositions[this.startRow]) !== null && _startPositions$this$ !== void 0 ? _startPositions$this$ : null;
    const mostBottomScrollOffset = scrollOffset + viewportHeight - horizontalScrollbarHeight;
    if (mostBottomScrollOffset < 0 || scrollOffset > startPositions.at(-1) + rowHeight) {
      this.isVisibleInTrimmingContainer = false;
    } else {
      this.isVisibleInTrimmingContainer = true;
    }
    if (totalRows < this.endRow) {
      this.endRow = totalRows - 1;
    }
    if (this.startRow !== null) {
      this.count = this.endRow - this.startRow + 1;
    }
  }
}
exports.PartiallyVisibleRowsCalculationType = PartiallyVisibleRowsCalculationType;

/***/ }),
/* 548 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @typedef {object} RenderedAllColumnsCalculatorOptions
 * @property {number} totalColumns Total number of columns.
 */
/**
 * Holds all calculations needed to perform the rendering of all columns.
 *
 * @class RenderedAllColumnsCalculationType
 */
class RenderedAllColumnsCalculationType {
  constructor() {
    /**
     * Number of rendered/visible columns.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "count", 0);
    /**
     * Index of the first rendered/visible column.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "startColumn", 0);
    /**
     * Index of the last rendered/visible column.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "endColumn", 0);
    /**
     * Position of the first rendered/visible column (in px).
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "startPosition", 0);
    /**
     * Determines if the viewport is visible in the trimming container.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "isVisibleInTrimmingContainer", true);
  }
  /**
   * Initializes the calculation.
   *
   * @param {ViewportColumnsCalculator} viewportCalculator The viewport calculator object.
   */
  initialize(_ref) {
    let {
      totalColumns
    } = _ref;
    this.count = totalColumns;
    this.endColumn = this.count - 1;
  }

  /**
   * Processes the column.
   */
  process() {}

  /**
   * Finalizes the calculation.
   */
  finalize() {}
}
exports.RenderedAllColumnsCalculationType = RenderedAllColumnsCalculationType;

/***/ }),
/* 549 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @typedef {object} RenderedAllRowsCalculatorOptions
 * @property {number} totalRows Total number of rows.
 */
/**
 * Holds all calculations needed to perform the rendering of all rows.
 *
 * @class RenderedAllRowsCalculationType
 */
class RenderedAllRowsCalculationType {
  constructor() {
    /**
     * Number of rendered/visible rows.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "count", 0);
    /**
     * Index of the first rendered/visible row.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "startRow", 0);
    /**
     * Index of the last rendered/visible row.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "endRow", 0);
    /**
     * Position of the first rendered/visible row (in px).
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "startPosition", 0);
    /**
     * Determines if the viewport is visible in the trimming container.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "isVisibleInTrimmingContainer", true);
  }
  /**
   * Initializes the calculation.
   *
   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.
   */
  initialize(_ref) {
    let {
      totalRows
    } = _ref;
    this.count = totalRows;
    this.endRow = this.count - 1;
  }

  /**
   * Processes the row.
   */
  process() {}

  /**
   * Finalizes the calculation.
   */
  finalize() {}
}
exports.RenderedAllRowsCalculationType = RenderedAllRowsCalculationType;

/***/ }),
/* 550 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _partiallyVisibleColumns = __webpack_require__(546);
/**
 * @class RenderedColumnsCalculationType
 */
class RenderedColumnsCalculationType extends _partiallyVisibleColumns.PartiallyVisibleColumnsCalculationType {
  constructor() {
    super(...arguments);
    /**
     * The property holds the offset applied in the `overrideFn` function to the `startColumn` value.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "columnStartOffset", 0);
    /**
     * The property holds the offset applied in the `overrideFn` function to the `endColumn` value.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "columnEndOffset", 0);
  }
  /**
   * Finalizes the calculation.
   *
   * @param {ViewportColumnsCalculator} viewportCalculator The viewport calculator object.
   */
  finalize(viewportCalculator) {
    var _startPositions$this$;
    super.finalize(viewportCalculator);
    const {
      overrideFn,
      totalColumns,
      startPositions
    } = viewportCalculator;
    if (this.startColumn !== null && typeof overrideFn === 'function') {
      const startColumn = this.startColumn;
      const endColumn = this.endColumn;
      overrideFn(this);
      this.columnStartOffset = startColumn - this.startColumn;
      this.columnEndOffset = this.endColumn - endColumn;
    }
    if (this.startColumn < 0) {
      this.startColumn = 0;
    }
    this.startPosition = (_startPositions$this$ = startPositions[this.startColumn]) !== null && _startPositions$this$ !== void 0 ? _startPositions$this$ : null;
    if (totalColumns < this.endColumn) {
      this.endColumn = totalColumns - 1;
    }
    if (this.startColumn !== null) {
      this.count = this.endColumn - this.startColumn + 1;
    }
  }
}
exports.RenderedColumnsCalculationType = RenderedColumnsCalculationType;

/***/ }),
/* 551 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _partiallyVisibleRows = __webpack_require__(547);
/**
 * @class RenderedRowsCalculationType
 */
class RenderedRowsCalculationType extends _partiallyVisibleRows.PartiallyVisibleRowsCalculationType {
  constructor() {
    super(...arguments);
    /**
     * The property holds the offset applied in the `overrideFn` function to the `startColumn` value.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "rowStartOffset", 0);
    /**
     * The property holds the offset applied in the `overrideFn` function to the `endColumn` value.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "rowEndOffset", 0);
  }
  /**
   * Finalizes the calculation.
   *
   * @param {ViewportRowsCalculator} viewportCalculator The viewport calculator object.
   */
  finalize(viewportCalculator) {
    var _startPositions$this$;
    super.finalize(viewportCalculator);
    const {
      overrideFn,
      totalRows,
      startPositions
    } = viewportCalculator;
    if (this.startRow !== null && typeof overrideFn === 'function') {
      const startRow = this.startRow;
      const endRow = this.endRow;
      overrideFn(this);
      this.rowStartOffset = startRow - this.startRow;
      this.rowEndOffset = this.endRow - endRow;
    }
    if (this.startRow < 0) {
      this.startRow = 0;
    }
    this.startPosition = (_startPositions$this$ = startPositions[this.startRow]) !== null && _startPositions$this$ !== void 0 ? _startPositions$this$ : null;
    if (totalRows < this.endRow) {
      this.endRow = totalRows - 1;
    }
    if (this.startRow !== null) {
      this.count = this.endRow - this.startRow + 1;
    }
  }
}
exports.RenderedRowsCalculationType = RenderedRowsCalculationType;

/***/ }),
/* 552 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _viewportBase = __webpack_require__(553);
const DEFAULT_WIDTH = exports.DEFAULT_WIDTH = 50;

/**
 * @typedef {object} ViewportColumnsCalculatorOptions
 * @property {Map<string, ViewportBaseCalculator>} calculationTypes The calculation types to be performed.
 * @property {number} viewportWidth Width of the viewport.
 * @property {number} scrollOffset Current horizontal scroll position of the viewport.
 * @property {number} totalColumns Total number of columns.
 * @property {Function} columnWidthFn Function that returns the width of the column at a given index (in px).
 * @property {Function} overrideFn Function that allows to adjust the `startRow` and `endRow` parameters.
 * @property {string} inlineStartOffset Inline-start offset of the parent container.
 */
/**
 * Calculates indexes of columns to render OR columns that are visible OR partially visible in the viewport.
 *
 * @class ViewportColumnsCalculator
 */
class ViewportColumnsCalculator extends _viewportBase.ViewportBaseCalculator {
  /**
   * @param {ViewportColumnsCalculatorOptions} options Object with all options specified for column viewport calculation.
   */
  constructor(_ref) {
    let {
      calculationTypes,
      viewportWidth,
      scrollOffset,
      totalColumns,
      columnWidthFn,
      overrideFn,
      inlineStartOffset
    } = _ref;
    super(calculationTypes);
    (0, _defineProperty2.default)(this, "viewportWidth", 0);
    (0, _defineProperty2.default)(this, "scrollOffset", 0);
    (0, _defineProperty2.default)(this, "zeroBasedScrollOffset", 0);
    (0, _defineProperty2.default)(this, "totalColumns", 0);
    (0, _defineProperty2.default)(this, "columnWidthFn", null);
    (0, _defineProperty2.default)(this, "columnWidth", 0);
    (0, _defineProperty2.default)(this, "overrideFn", null);
    (0, _defineProperty2.default)(this, "inlineStartOffset", 0);
    (0, _defineProperty2.default)(this, "totalCalculatedWidth", 0);
    (0, _defineProperty2.default)(this, "startPositions", []);
    (0, _defineProperty2.default)(this, "needReverse", true);
    this.viewportWidth = viewportWidth;
    this.scrollOffset = scrollOffset;
    this.zeroBasedScrollOffset = Math.max(scrollOffset, 0);
    this.totalColumns = totalColumns;
    this.columnWidthFn = columnWidthFn;
    this.overrideFn = overrideFn;
    this.inlineStartOffset = inlineStartOffset;
    this.calculate();
  }

  /**
   * Calculates viewport.
   */
  calculate() {
    this._initialize(this);
    for (let column = 0; column < this.totalColumns; column++) {
      this.columnWidth = this.getColumnWidth(column);
      this._process(column, this);
      this.startPositions.push(this.totalCalculatedWidth);
      this.totalCalculatedWidth += this.columnWidth;
      if (this.totalCalculatedWidth >= this.zeroBasedScrollOffset + this.viewportWidth) {
        this.needReverse = false;
        break;
      }
    }
    this._finalize(this);
  }

  /**
   * Gets the column width at the specified column index.
   *
   * @param {number} column Column index.
   * @returns {number}
   */
  getColumnWidth(column) {
    const width = this.columnWidthFn(column);
    if (isNaN(width)) {
      return DEFAULT_WIDTH;
    }
    return width;
  }
}
exports.ViewportColumnsCalculator = ViewportColumnsCalculator;

/***/ }),
/* 553 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(311);
__webpack_require__(329);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @typedef {object} ColumnsCalculationType
 * @property {number | null} startColumn The column index of the first column in the viewport.
 * @property {number | null} endColumn The column index of the last column in the viewport.
 * @property {number} count Total number of columns.
 * @property {number | null} startPosition Position of the first fully column (in px).
 * @property {boolean} isVisibleInTrimmingContainer Determines if the viewport is visible in the trimming container.
 */
/**
 * @typedef {object} RowsCalculationType
 * @property {number | null} startRow The row index of the first row in the viewport.
 * @property {number | null} endRow The row index of the last row in the viewport.
 * @property {number} count Total number of rows.
 * @property {number | null} startPosition Position of the first fully row (in px).
 * @property {boolean} isVisibleInTrimmingContainer Determines if the viewport is visible in the trimming container.
 */
/**
 * @class ViewportBaseCalculator
 */
class ViewportBaseCalculator {
  constructor(calculationTypes) {
    /**
     * The calculation types to be performed.
     *
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "calculationTypes", []);
    /**
     * The calculation results.
     *
     * @type {Map<string, ColumnsCalculationType | RowsCalculationType>}
     */
    (0, _defineProperty2.default)(this, "calculationResults", new Map());
    this.calculationTypes = calculationTypes;
  }

  /**
   * Initializes all calculators (triggers all calculators before calculating the rows/columns sizes).
   *
   * @param {*} context The context object (rows or columns viewport calculator).
   */
  _initialize(context) {
    this.calculationTypes.forEach(_ref => {
      let [id, calculator] = _ref;
      this.calculationResults.set(id, calculator);
      calculator.initialize(context);
    });
  }

  /**
   * Processes the row/column at the given index.
   *
   * @param {number} index The index of the row/column.
   * @param {*} context The context object (rows or columns viewport calculator).
   */
  _process(index, context) {
    this.calculationTypes.forEach(_ref2 => {
      let [, calculator] = _ref2;
      return calculator.process(index, context);
    });
  }

  /**
   * Finalizes all calculators (triggers all calculators after calculating the rows/columns sizes).
   *
   * @param {*} context The context object (rows or columns viewport calculator).
   */
  _finalize(context) {
    this.calculationTypes.forEach(_ref3 => {
      let [, calculator] = _ref3;
      return calculator.finalize(context);
    });
  }

  /**
   * Gets the results for the given calculator.
   *
   * @param {string} calculatorId The id of the calculator.
   * @returns {ColumnsCalculationType | RowsCalculationType}
   */
  getResultsFor(calculatorId) {
    return this.calculationResults.get(calculatorId);
  }
}
exports.ViewportBaseCalculator = ViewportBaseCalculator;

/***/ }),
/* 554 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _viewportBase = __webpack_require__(553);
/**
 * @typedef {object} ViewportRowsCalculatorOptions
 * @property {Map<string, ViewportBaseCalculator>} calculationTypes The calculation types to be performed.
 * @property {number} viewportHeight Height of the viewport.
 * @property {number} scrollOffset Current vertical scroll position of the viewport.
 * @property {number} totalRows Total number of rows.
 * @property {Function} rowHeightFn Function that returns the height of the row at a given index (in px).
 * @property {Function} overrideFn Function that allows to adjust the `startRow` and `endRow` parameters.
 * @property {number} horizontalScrollbarHeight The scrollbar height.
 */
/**
 * Calculates indexes of rows to render OR rows that are visible OR partially visible in the viewport.
 *
 * @class ViewportRowsCalculator
 */
class ViewportRowsCalculator extends _viewportBase.ViewportBaseCalculator {
  /**
   * @param {ViewportRowsCalculatorOptions} options Object with all options specified for row viewport calculation.
   */
  constructor(_ref) {
    let {
      calculationTypes,
      viewportHeight,
      scrollOffset,
      totalRows,
      defaultRowHeight,
      rowHeightFn,
      overrideFn,
      horizontalScrollbarHeight
    } = _ref;
    super(calculationTypes);
    (0, _defineProperty2.default)(this, "viewportHeight", 0);
    (0, _defineProperty2.default)(this, "scrollOffset", 0);
    (0, _defineProperty2.default)(this, "zeroBasedScrollOffset", 0);
    (0, _defineProperty2.default)(this, "totalRows", 0);
    (0, _defineProperty2.default)(this, "rowHeightFn", null);
    (0, _defineProperty2.default)(this, "rowHeight", 0);
    (0, _defineProperty2.default)(this, "overrideFn", null);
    (0, _defineProperty2.default)(this, "horizontalScrollbarHeight", 0);
    (0, _defineProperty2.default)(this, "innerViewportHeight", 0);
    (0, _defineProperty2.default)(this, "totalCalculatedHeight", 0);
    (0, _defineProperty2.default)(this, "startPositions", []);
    (0, _defineProperty2.default)(this, "needReverse", true);
    this.defaultHeight = defaultRowHeight;
    this.viewportHeight = viewportHeight;
    this.scrollOffset = scrollOffset;
    this.zeroBasedScrollOffset = Math.max(scrollOffset, 0);
    this.totalRows = totalRows;
    this.rowHeightFn = rowHeightFn;
    this.overrideFn = overrideFn;
    this.horizontalScrollbarHeight = horizontalScrollbarHeight !== null && horizontalScrollbarHeight !== void 0 ? horizontalScrollbarHeight : 0;
    this.innerViewportHeight = this.zeroBasedScrollOffset + this.viewportHeight - this.horizontalScrollbarHeight;
    this.calculate();
  }

  /**
   * Calculates viewport.
   */
  calculate() {
    this._initialize(this);
    for (let row = 0; row < this.totalRows; row++) {
      this.rowHeight = this.getRowHeight(row);
      this._process(row, this);
      this.startPositions.push(this.totalCalculatedHeight);
      this.totalCalculatedHeight += this.rowHeight;
      if (this.totalCalculatedHeight >= this.innerViewportHeight) {
        this.needReverse = false;
        break;
      }
    }
    this._finalize(this);
  }

  /**
   * Gets the row height at the specified row index.
   *
   * @param {number} row Row index.
   * @returns {number}
   */
  getRowHeight(row) {
    const rowHeight = this.rowHeightFn(row);
    if (isNaN(rowHeight)) {
      return this.defaultHeight;
    }
    return rowHeight;
  }
}
exports.ViewportRowsCalculator = ViewportRowsCalculator;

/***/ }),
/* 555 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _isRtl = /*#__PURE__*/new WeakMap();
/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * @description
 *
 * The `CellCoords` class holds the coordinates (`row`, `col`) of a single cell.
 *
 * It also contains methods for validating the coordinates
 * and retrieving them as an object.
 *
 * To import the `CellCoords` class:
 *
 * ```js
 * import Handsontable, { CellCoords } from '/handsontable';
 *
 * // or, using modules
 * import Handsontable, { CellCoords } from '/handsontable/base';
 * ```
 */
class CellCoords {
  constructor(row, column) {
    let isRtl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    /**
     * A visual row index.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "row", null);
    /**
     * A visual column index.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "col", null);
    /**
     * A flag which determines if the coordinates run in RTL mode.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _isRtl, false);
    _classPrivateFieldSet(_isRtl, this, isRtl);
    if (typeof row !== 'undefined' && typeof column !== 'undefined') {
      this.row = row;
      this.col = column;
    }
  }

  /**
   * Checks if the coordinates in your `CellCoords` instance are valid
   * in the context of given table parameters.
   *
   * The `row` index:
   * - Must be an integer.
   * - Must be higher than the number of column headers in the table.
   * - Must be lower than the total number of rows in the table.
   *
   * The `col` index:
   * - Must be an integer.
   * - Must be higher than the number of row headers in the table.
   * - Must be lower than the total number of columns in the table.
   *
   * @param {object} [tableParams] An object with a defined table size.
   * @param {number} [tableParams.countRows=0] The total number of rows.
   * @param {number} [tableParams.countCols=0] The total number of columns.
   * @param {number} [tableParams.countRowHeaders=0] A number of row headers.
   * @param {number} [tableParams.countColHeaders=0] A number of column headers.
   * @returns {boolean} `true`: The coordinates are valid.
   */
  isValid(tableParams) {
    const {
      countRows,
      countCols,
      countRowHeaders,
      countColHeaders
    } = {
      countRows: 0,
      countCols: 0,
      countRowHeaders: 0,
      countColHeaders: 0,
      ...tableParams
    };
    if (!Number.isInteger(this.row) || !Number.isInteger(this.col)) {
      return false;
    }
    if (this.row < -countColHeaders || this.col < -countRowHeaders) {
      return false;
    }
    if (this.row >= countRows || this.col >= countCols) {
      return false;
    }
    return true;
  }

  /**
   * Checks if another set of coordinates (`coords`)
   * is equal to the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} coords Coordinates to check.
   * @returns {boolean}
   */
  isEqual(coords) {
    if (coords === this) {
      return true;
    }
    return this.row === coords.row && this.col === coords.col;
  }

  /**
   * Checks if the coordinates point to the headers range. If one of the axis (row or col) point to
   * the header (negative value) then method returns `true`.
   *
   * @returns {boolean}
   */
  isHeader() {
    return !this.isCell();
  }

  /**
   * Checks if the coordinates point to the cells range. If all axis (row and col) point to
   * the cell (positive value) then method returns `true`.
   *
   * @returns {boolean}
   */
  isCell() {
    return this.row >= 0 && this.col >= 0;
  }

  /**
   * Checks if the coordinates runs in RTL mode.
   *
   * @returns {boolean}
   */
  isRtl() {
    return _classPrivateFieldGet(_isRtl, this);
  }

  /**
   * Checks if another set of coordinates (`testedCoords`)
   * is south-east of the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} testedCoords Coordinates to check.
   * @returns {boolean}
   */
  isSouthEastOf(testedCoords) {
    return this.row >= testedCoords.row && (_classPrivateFieldGet(_isRtl, this) ? this.col <= testedCoords.col : this.col >= testedCoords.col);
  }

  /**
   * Checks if another set of coordinates (`testedCoords`)
   * is north-west of the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} testedCoords Coordinates to check.
   * @returns {boolean}
   */
  isNorthWestOf(testedCoords) {
    return this.row <= testedCoords.row && (_classPrivateFieldGet(_isRtl, this) ? this.col >= testedCoords.col : this.col <= testedCoords.col);
  }

  /**
   * Checks if another set of coordinates (`testedCoords`)
   * is south-west of the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} testedCoords Coordinates to check.
   * @returns {boolean}
   */
  isSouthWestOf(testedCoords) {
    return this.row >= testedCoords.row && (_classPrivateFieldGet(_isRtl, this) ? this.col >= testedCoords.col : this.col <= testedCoords.col);
  }

  /**
   * Checks if another set of coordinates (`testedCoords`)
   * is north-east of the coordinates in your `CellCoords` instance.
   *
   * @param {CellCoords} testedCoords Coordinates to check.
   * @returns {boolean}
   */
  isNorthEastOf(testedCoords) {
    return this.row <= testedCoords.row && (_classPrivateFieldGet(_isRtl, this) ? this.col <= testedCoords.col : this.col >= testedCoords.col);
  }

  /**
   * Normalizes the coordinates in your `CellCoords` instance to the nearest valid position.
   *
   * Coordinates that point to headers (negative values) are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  normalize() {
    this.row = this.row === null ? this.row : Math.max(this.row, 0);
    this.col = this.col === null ? this.col : Math.max(this.col, 0);
    return this;
  }

  /**
   * Assigns the coordinates from another `CellCoords` instance (or compatible literal object)
   * to your `CellCoords` instance.
   *
   * @param {CellCoords | { row: number | undefined, col: number | undefined }} coords The CellCoords
   * instance or compatible literal object.
   * @returns {CellCoords}
   */
  assign(coords) {
    if (Number.isInteger(coords === null || coords === void 0 ? void 0 : coords.row)) {
      this.row = coords.row;
    }
    if (Number.isInteger(coords === null || coords === void 0 ? void 0 : coords.col)) {
      this.col = coords.col;
    }
    if (coords instanceof CellCoords) {
      _classPrivateFieldSet(_isRtl, this, coords.isRtl());
    }
    return this;
  }

  /**
   * Clones your `CellCoords` instance.
   *
   * @returns {CellCoords}
   */
  clone() {
    return new CellCoords(this.row, this.col, _classPrivateFieldGet(_isRtl, this));
  }

  /**
   * Converts your `CellCoords` instance into an object literal with `row` and `col` properties.
   *
   * @returns {{row: number, col: number}} An object literal with `row` and `col` properties.
   */
  toObject() {
    return {
      row: this.row,
      col: this.col
    };
  }
}
var _default = exports["default"] = CellCoords;

/***/ }),
/* 556 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _coords = _interopRequireDefault(__webpack_require__(555));
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * @description
 *
 * The `CellRange` class holds a set of cell coordinates ([`CellCoords`](@/api/cellCoords.md) instances)
 * that form a [selection range](@/guides/cell-features/selection/selection.md#select-ranges).
 *
 * A single `CellRange` instance represents a single unit of selection
 * that contains either a single cell or multiple adjacent cells.
 *
 * To import the `CellRange` class:
 *
 * ```js
 * import Handsontable, { CellRange } from '/handsontable';
 *
 * // or, using modules
 * import Handsontable, { CellRange } from '/handsontable/base';
 * ```
 */
var _isRtl = /*#__PURE__*/new WeakMap();
class CellRange {
  constructor(highlight) {
    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : highlight;
    let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : highlight;
    let isRtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    /**
     * Used to draw bold border around a cell where selection was started and to edit the cell
     * when you press Enter. The highlight cannot point to headers (negative values) so its
     * coordinates object is normalized while assigning.
     *
     * @private
     * @type {CellCoords}
     */
    (0, _defineProperty2.default)(this, "highlight", null);
    /**
     * Usually the same as highlight, but in Excel there is distinction - one can change
     * highlight within a selection.
     *
     * @private
     * @type {CellCoords}
     */
    (0, _defineProperty2.default)(this, "from", null);
    /**
     * End selection.
     *
     * @private
     * @type {CellCoords}
     */
    (0, _defineProperty2.default)(this, "to", null);
    /**
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _isRtl, false);
    this.highlight = highlight.clone();
    this.from = from.clone();
    this.to = to.clone();
    _classPrivateFieldSet(_isRtl, this, isRtl);
  }

  /**
   * Highlights cell selection at the `coords` coordinates.
   *
   * @param {CellCoords} coords Coordinates to use.
   * @returns {CellRange}
   */
  setHighlight(coords) {
    this.highlight = coords.clone();
    return this;
  }

  /**
   * Sets the `coords` coordinates as the start of your range.
   *
   * @param {CellCoords} coords Coordinates to use.
   * @returns {CellRange}
   */
  setFrom(coords) {
    this.from = coords.clone();
    return this;
  }

  /**
   * Sets the `coords` coordinates as the end of your range.
   *
   * @param {CellCoords} coords Coordinates to use.
   * @returns {CellRange}
   */
  setTo(coords) {
    this.to = coords.clone();
    return this;
  }

  /**
   * Checks if the coordinates in your `CellRange` instance are valid
   * in the context of given table parameters.
   *
   * See the [`isValid()`](@/api/cellCoords.md#isvalid) method of the [`CellCoords`](@/api/cellCoords.md) class.
   *
   * @param {object} tableParams An object with a defined table size.
   * @param {number} tableParams.countRows The total number of rows.
   * @param {number} tableParams.countCols The total number of columns.
   * @param {number} tableParams.countRowHeaders A number of row headers.
   * @param {number} tableParams.countColHeaders A number of column headers.
   * @returns {boolean}
   */
  isValid(tableParams) {
    return this.from.isValid(tableParams) && this.to.isValid(tableParams);
  }

  /**
   * Checks if your range is just a single cell or header.
   *
   * @returns {boolean}
   */
  isSingle() {
    return this.isSingleCell() || this.isSingleHeader();
  }

  /**
   * Checks if your range is just a single cell.
   *
   * @returns {boolean}
   */
  isSingleCell() {
    return this.from.row >= 0 && this.from.row === this.to.row && this.from.col >= 0 && this.from.col === this.to.col;
  }

  /**
   * Checks if your range is just a single header.
   *
   * @returns {boolean}
   */
  isSingleHeader() {
    return (this.from.row < 0 || this.from.col < 0) && this.from.row === this.to.row && this.from.col === this.to.col;
  }

  /**
   * Checks if your range covers only headers range (negative coordinates, without any cells).
   *
   * @returns {boolean}
   */
  isHeader() {
    if (this.from.isHeader() && this.to.isHeader()) {
      return true;
    }
    return this.from.col < 0 && this.to.col < 0 || this.from.row < 0 && this.to.row < 0;
  }

  /**
   * Checks if your range overlaps headers range (negative coordinates).
   *
   * @returns {boolean}
   */
  containsHeaders() {
    return this.from.isHeader() || this.to.isHeader();
  }

  /**
   * Returns the height of your range (as a number of rows, including row headers).
   *
   * @returns {number}
   */
  getOuterHeight() {
    return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;
  }

  /**
   * Returns the width of your range (as a number of columns, including column headers).
   *
   * @returns {number}
   */
  getOuterWidth() {
    return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;
  }

  /**
   * Returns the height of your range (as a number of rows, excluding row headers).
   *
   * @returns {number}
   */
  getHeight() {
    // if the selection contains only row headers, return 0
    if (this.from.row < 0 && this.to.row < 0) {
      return 0;
    }
    const fromRow = Math.max(this.from.row, 0);
    const toRow = Math.max(this.to.row, 0);
    return Math.max(fromRow, toRow) - Math.min(fromRow, toRow) + 1;
  }

  /**
   * Returns the width of your range (as a number of columns, excluding column headers).
   *
   * @returns {number}
   */
  getWidth() {
    // if the selection contains only column headers, return 0
    if (this.from.col < 0 && this.to.col < 0) {
      return 0;
    }
    const fromCol = Math.max(this.from.col, 0);
    const toCol = Math.max(this.to.col, 0);
    return Math.max(fromCol, toCol) - Math.min(fromCol, toCol) + 1;
  }

  /**
   * Returns the number of cells within your range (excluding column and row headers).
   *
   * @returns {number}
   */
  getCellsCount() {
    return this.getWidth() * this.getHeight();
  }

  /**
   * Checks if another set of coordinates (`cellCoords`)
   * is within the `from` and `to` coordinates of your range.
   *
   * @param {CellCoords} cellCoords Coordinates to check.
   * @returns {boolean}
   */
  includes(cellCoords) {
    const {
      row,
      col
    } = cellCoords;
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    return topStart.row <= row && bottomEnd.row >= row && topStart.col <= col && bottomEnd.col >= col;
  }

  /**
   * Checks if another range (`cellRange`) is within your range.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  includesRange(cellRange) {
    return this.includes(cellRange.getOuterTopStartCorner()) && this.includes(cellRange.getOuterBottomEndCorner());
  }

  /**
   * Checks if another range (`cellRange`) is equal to your range.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  isEqual(cellRange) {
    return Math.min(this.from.row, this.to.row) === Math.min(cellRange.from.row, cellRange.to.row) && Math.max(this.from.row, this.to.row) === Math.max(cellRange.from.row, cellRange.to.row) && Math.min(this.from.col, this.to.col) === Math.min(cellRange.from.col, cellRange.to.col) && Math.max(this.from.col, this.to.col) === Math.max(cellRange.from.col, cellRange.to.col);
  }

  /**
   * Checks if another range (`cellRange`) overlaps your range.
   *
   * Range A overlaps range B if the intersection of A and B (or B and A) is not empty.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  overlaps(cellRange) {
    return cellRange.isSouthEastOf(this.getOuterTopLeftCorner()) && cellRange.isNorthWestOf(this.getOuterBottomRightCorner());
  }

  /**
   * Checks if coordinates point is south-east of your range.
   *
   * @param {CellCoords} cellCoords Coordinates to check.
   * @returns {boolean}
   */
  isSouthEastOf(cellCoords) {
    return this.getOuterTopLeftCorner().isSouthEastOf(cellCoords) || this.getOuterBottomRightCorner().isSouthEastOf(cellCoords);
  }

  /**
   * Checks if coordinates point is north-west of your range.
   *
   * @param {CellRange} cellCoords Coordinates to check.
   * @returns {boolean}
   */
  isNorthWestOf(cellCoords) {
    return this.getOuterTopLeftCorner().isNorthWestOf(cellCoords) || this.getOuterBottomRightCorner().isNorthWestOf(cellCoords);
  }

  /**
   * Checks if another range (`cellRange`) overlaps your range horizontally.
   *
   * For example: returns `true` if the last column of your range is `5`
   * and the first column of the `cellRange` range is `3`.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  isOverlappingHorizontally(cellRange) {
    return this.getOuterTopEndCorner().col >= cellRange.getOuterTopStartCorner().col && this.getOuterTopEndCorner().col <= cellRange.getOuterTopEndCorner().col || this.getOuterTopStartCorner().col <= cellRange.getOuterTopEndCorner().col && this.getOuterTopStartCorner().col >= cellRange.getOuterTopStartCorner().col;
  }

  /**
   * Checks if another range (`cellRange`) overlaps your range vertically.
   *
   * For example: returns `true` if the last row of your range is `5`
   * and the first row of the `cellRange` range is `3`.
   *
   * @param {CellRange} cellRange A range to check.
   * @returns {boolean}
   */
  isOverlappingVertically(cellRange) {
    return this.getOuterBottomStartCorner().row >= cellRange.getOuterTopRightCorner().row && this.getOuterBottomStartCorner().row <= cellRange.getOuterBottomStartCorner().row || this.getOuterTopEndCorner().row <= cellRange.getOuterBottomStartCorner().row && this.getOuterTopEndCorner().row >= cellRange.getOuterTopRightCorner().row;
  }

  /**
   * Adds a cell to your range, at `cellCoords` coordinates.
   *
   * The `cellCoords` coordinates must exceed a corner of your range.
   *
   * @param {CellCoords} cellCoords A new cell's coordinates.
   * @returns {boolean}
   */
  expand(cellCoords) {
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    if (cellCoords.row < topStart.row || cellCoords.col < topStart.col || cellCoords.row > bottomEnd.row || cellCoords.col > bottomEnd.col) {
      this.from = this._createCellCoords(Math.min(topStart.row, cellCoords.row), Math.min(topStart.col, cellCoords.col));
      this.to = this._createCellCoords(Math.max(bottomEnd.row, cellCoords.row), Math.max(bottomEnd.col, cellCoords.col));
      return true;
    }
    return false;
  }

  /**
   * Expand your range with another range (`expandingRange`).
   *
   * @param {CellRange} expandingRange A new range.
   * @param {boolean} [changeDirection=true] If `true`, the direction of your range is changed to the direction
   * of the `expandingRange` range.
   * @returns {boolean}
   */
  expandByRange(expandingRange) {
    let changeDirection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {
      return false;
    }
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    const initialDirection = this.getDirection();
    const expandingTopStart = expandingRange.getOuterTopStartCorner();
    const expandingBottomEnd = expandingRange.getOuterBottomEndCorner();
    const resultTopRow = Math.min(topStart.row, expandingTopStart.row);
    const resultTopCol = Math.min(topStart.col, expandingTopStart.col);
    const resultBottomRow = Math.max(bottomEnd.row, expandingBottomEnd.row);
    const resultBottomCol = Math.max(bottomEnd.col, expandingBottomEnd.col);
    const finalFrom = this._createCellCoords(resultTopRow, resultTopCol);
    const finalTo = this._createCellCoords(resultBottomRow, resultBottomCol);
    this.from = finalFrom;
    this.to = finalTo;
    this.setDirection(initialDirection);
    if (changeDirection) {
      if (this.highlight.row === this.getOuterBottomRightCorner().row && this.getVerticalDirection() === 'N-S') {
        this.flipDirectionVertically();
      }
      if (this.highlight.col === this.getOuterTopRightCorner().col && this.getHorizontalDirection() === 'W-E') {
        this.flipDirectionHorizontally();
      }
    }
    return true;
  }

  /**
   * Gets the direction of the selection.
   *
   * @returns {string} Returns one of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.
   */
  getDirection() {
    if (this.from.isNorthWestOf(this.to)) {
      // NorthWest - SouthEast
      return 'NW-SE';
    } else if (this.from.isNorthEastOf(this.to)) {
      // NorthEast - SouthWest
      return 'NE-SW';
    } else if (this.from.isSouthEastOf(this.to)) {
      // SouthEast - NorthWest
      return 'SE-NW';
    } else if (this.from.isSouthWestOf(this.to)) {
      // SouthWest - NorthEast
      return 'SW-NE';
    }
  }

  /**
   * Sets the direction of the selection.
   *
   * @param {string} direction One of the values: `'NW-SE'`, `'NE-SW'`, `'SE-NW'`, `'SW-NE'`.
   */
  setDirection(direction) {
    switch (direction) {
      case 'NW-SE':
        [this.from, this.to] = [this.getOuterTopLeftCorner(), this.getOuterBottomRightCorner()];
        break;
      case 'NE-SW':
        [this.from, this.to] = [this.getOuterTopRightCorner(), this.getOuterBottomLeftCorner()];
        break;
      case 'SE-NW':
        [this.from, this.to] = [this.getOuterBottomRightCorner(), this.getOuterTopLeftCorner()];
        break;
      case 'SW-NE':
        [this.from, this.to] = [this.getOuterBottomLeftCorner(), this.getOuterTopRightCorner()];
        break;
      default:
        break;
    }
  }

  /**
   * Gets the vertical direction of the selection.
   *
   * @returns {string} Returns one of the values: `N-S` (north->south), `S-N` (south->north).
   */
  getVerticalDirection() {
    return ['NE-SW', 'NW-SE'].indexOf(this.getDirection()) > -1 ? 'N-S' : 'S-N';
  }

  /**
   * Gets the horizontal direction of the selection.
   *
   * @returns {string} Returns one of the values: `W-E` (west->east), `E-W` (east->west).
   */
  getHorizontalDirection() {
    return ['NW-SE', 'SW-NE'].indexOf(this.getDirection()) > -1 ? 'W-E' : 'E-W';
  }

  /**
   * Flips the direction of your range vertically (e.g., `NW-SE` changes to `SW-NE`).
   */
  flipDirectionVertically() {
    const direction = this.getDirection();
    switch (direction) {
      case 'NW-SE':
        this.setDirection('SW-NE');
        break;
      case 'NE-SW':
        this.setDirection('SE-NW');
        break;
      case 'SE-NW':
        this.setDirection('NE-SW');
        break;
      case 'SW-NE':
        this.setDirection('NW-SE');
        break;
      default:
        break;
    }
  }

  /**
   * Flips the direction of your range horizontally (e.g., `NW-SE` changes to `NE-SW`).
   */
  flipDirectionHorizontally() {
    const direction = this.getDirection();
    switch (direction) {
      case 'NW-SE':
        this.setDirection('NE-SW');
        break;
      case 'NE-SW':
        this.setDirection('NW-SE');
        break;
      case 'SE-NW':
        this.setDirection('SW-NE');
        break;
      case 'SW-NE':
        this.setDirection('SE-NW');
        break;
      default:
        break;
    }
  }

  /**
   * Gets the top-left (in LTR) or top-right (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getTopStartCorner() {
    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();
  }

  /**
   * Gets the top-left corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getTopLeftCorner() {
    return _classPrivateFieldGet(_isRtl, this) ? this.getTopEndCorner() : this.getTopStartCorner();
  }

  /**
   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getBottomEndCorner() {
    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();
  }

  /**
   * Gets the bottom right corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getBottomRightCorner() {
    return _classPrivateFieldGet(_isRtl, this) ? this.getBottomStartCorner() : this.getBottomEndCorner();
  }

  /**
   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getTopEndCorner() {
    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col)).normalize();
  }

  /**
   * Gets the top right corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getTopRightCorner() {
    return _classPrivateFieldGet(_isRtl, this) ? this.getTopStartCorner() : this.getTopEndCorner();
  }

  /**
   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getBottomStartCorner() {
    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col)).normalize();
  }

  /**
   * Gets the bottom left corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the corner coordinates are normalized to `0`.
   *
   * @returns {CellCoords}
   */
  getBottomLeftCorner() {
    return _classPrivateFieldGet(_isRtl, this) ? this.getBottomEndCorner() : this.getBottomStartCorner();
  }

  /**
   * Gets the top left (in LTR) or top right (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the top and start coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterTopStartCorner() {
    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
  }

  /**
   * Gets the top left corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the top and left coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterTopLeftCorner() {
    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterTopEndCorner() : this.getOuterTopStartCorner();
  }

  /**
   * Gets the bottom right (in LTR) or bottom left (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the top and start coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterBottomEndCorner() {
    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
  }

  /**
   * Gets the bottom right corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the top and left coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterBottomRightCorner() {
    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterBottomStartCorner() : this.getOuterBottomEndCorner();
  }

  /**
   * Gets the top right (in LTR) or top left (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the top and start coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterTopEndCorner() {
    return this._createCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
  }

  /**
   * Gets the top right corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the top and left coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterTopRightCorner() {
    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterTopStartCorner() : this.getOuterTopEndCorner();
  }

  /**
   * Gets the bottom left (in LTR) or bottom right (in RTL) corner coordinates of your range.
   *
   * If the corner contains header coordinates (negative values),
   * the top and start coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterBottomStartCorner() {
    return this._createCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
  }

  /**
   * Gets the bottom left corner coordinates of your range,
   * both in the LTR and RTL layout direction.
   *
   * If the corner contains header coordinates (negative values),
   * the top and left coordinates are pointed to that header.
   *
   * @returns {CellCoords}
   */
  getOuterBottomLeftCorner() {
    return _classPrivateFieldGet(_isRtl, this) ? this.getOuterBottomEndCorner() : this.getOuterBottomStartCorner();
  }

  /**
   * Checks if a set of coordinates (`coords`) matches one of the 4 corners of your range.
   *
   * @param {CellCoords} coords Coordinates to check.
   * @returns {boolean}
   */
  isCorner(coords) {
    return coords.isEqual(this.getOuterTopLeftCorner()) || coords.isEqual(this.getOuterTopRightCorner()) || coords.isEqual(this.getOuterBottomLeftCorner()) || coords.isEqual(this.getOuterBottomRightCorner());
  }

  /**
   * Gets the coordinates of a range corner opposite to the provided `coords`.
   *
   * For example: if the `coords` coordinates match the bottom-right corner of your range,
   * the coordinates of the top-left corner of your range are returned.
   *
   * @param {CellCoords} coords Coordinates to check.
   * @returns {CellCoords}
   */
  getOppositeCorner(coords) {
    if (!(coords instanceof _coords.default)) {
      return false;
    }
    if (coords.isEqual(this.getOuterBottomEndCorner())) {
      return this.getOuterTopStartCorner();
    } else if (coords.isEqual(this.getOuterTopStartCorner())) {
      return this.getOuterBottomEndCorner();
    } else if (coords.isEqual(this.getOuterTopEndCorner())) {
      return this.getOuterBottomStartCorner();
    } else if (coords.isEqual(this.getOuterBottomStartCorner())) {
      return this.getOuterTopEndCorner();
    }
  }

  /**
   * Indicates which borders (top, right, bottom, left) are shared between
   * your `CellRange`instance and another `range` that's within your range.
   *
   * @param {CellRange} range A range to compare with.
   * @returns {Array<'top' | 'right' | 'bottom' | 'left'>}
   */
  getBordersSharedWith(range) {
    if (!this.includesRange(range)) {
      return [];
    }
    const thisBorders = {
      top: Math.min(this.from.row, this.to.row),
      bottom: Math.max(this.from.row, this.to.row),
      left: Math.min(this.from.col, this.to.col),
      right: Math.max(this.from.col, this.to.col)
    };
    const rangeBorders = {
      top: Math.min(range.from.row, range.to.row),
      bottom: Math.max(range.from.row, range.to.row),
      left: Math.min(range.from.col, range.to.col),
      right: Math.max(range.from.col, range.to.col)
    };
    const result = [];
    if (thisBorders.top === rangeBorders.top) {
      result.push('top');
    }
    if (thisBorders.right === rangeBorders.right) {
      result.push(_classPrivateFieldGet(_isRtl, this) ? 'left' : 'right');
    }
    if (thisBorders.bottom === rangeBorders.bottom) {
      result.push('bottom');
    }
    if (thisBorders.left === rangeBorders.left) {
      result.push(_classPrivateFieldGet(_isRtl, this) ? 'right' : 'left');
    }
    return result;
  }

  /**
   * Gets the coordinates of the inner cells of your range.
   *
   * @returns {CellCoords[]}
   */
  getInner() {
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    const out = [];
    for (let r = topStart.row; r <= bottomEnd.row; r++) {
      for (let c = topStart.col; c <= bottomEnd.col; c++) {
        if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
          out.push(this._createCellCoords(r, c));
        }
      }
    }
    return out;
  }

  /**
   * Gets the coordinates of all cells of your range.
   *
   * @returns {CellCoords[]}
   */
  getAll() {
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    const out = [];
    for (let r = topStart.row; r <= bottomEnd.row; r++) {
      for (let c = topStart.col; c <= bottomEnd.col; c++) {
        if (topStart.row === r && topStart.col === c) {
          out.push(topStart);
        } else if (bottomEnd.row === r && bottomEnd.col === c) {
          out.push(bottomEnd);
        } else {
          out.push(this._createCellCoords(r, c));
        }
      }
    }
    return out;
  }

  /**
   * Runs a callback function on all cells within your range.
   *
   * You can break the iteration by returning `false` in the callback function.
   *
   * @param {function(number, number): boolean} callback A callback function.
   */
  forAll(callback) {
    const topStart = this.getOuterTopStartCorner();
    const bottomEnd = this.getOuterBottomEndCorner();
    for (let r = topStart.row; r <= bottomEnd.row; r++) {
      for (let c = topStart.col; c <= bottomEnd.col; c++) {
        const breakIteration = callback(r, c);
        if (breakIteration === false) {
          return;
        }
      }
    }
  }

  /**
   * Clones your `CellRange` instance.
   *
   * @returns {CellRange}
   */
  clone() {
    return new CellRange(this.highlight, this.from, this.to, _classPrivateFieldGet(_isRtl, this));
  }

  /**
   * Converts your `CellRange` instance into an object literal with the following properties:
   *
   * - `from`
   *    - `row`
   *    - `col`
   * - `to`
   *    - `row`
   *    - `col`
   *
   * @returns {{from: {row: number, col: number}, to: {row: number, col: number}}} An object literal with `from` and `to` properties.
   */
  toObject() {
    return {
      from: this.from.toObject(),
      to: this.to.toObject()
    };
  }

  /**
   * Creates and returns a new instance of the `CellCoords` class.
   *
   * The new `CellCoords` instance automatically inherits the LTR/RTL flag
   * from your `CellRange` instance.
   *
   * @private
   * @param {number} row A row index.
   * @param {number} column A column index.
   * @returns {CellCoords}
   */
  _createCellCoords(row, column) {
    return new _coords.default(row, column, _classPrivateFieldGet(_isRtl, this));
  }
}
var _default = exports["default"] = CellRange;

/***/ }),
/* 557 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _core = _interopRequireDefault(__webpack_require__(558));
var _base = _interopRequireDefault(__webpack_require__(589));
/**
 * This layer cares about backward compatibility.
 *
 * @class WalkontableFacade
 * @augments Walkontable
 * @inheritDoc
 */
class WalkontableFacade {
  /**
   * @param {SettingsPure|Walkontable} settingsOrInstance The Walkontable settings.
   */
  constructor(settingsOrInstance) {
    if (settingsOrInstance instanceof _base.default) {
      this._wot = settingsOrInstance;
    } else {
      this._initFromSettings(settingsOrInstance);
    }
  }
  _initFromSettings(settings) {
    settings.facade = instance => {
      const facade = new WalkontableFacade(instance);
      return () => facade;
    };
    this._wot = new _core.default(settings.table, settings);
  }
  get guid() {
    return this._wot.guid;
  }
  get rootDocument() {
    return this._wot.domBindings.rootDocument;
  }
  get rootWindow() {
    return this._wot.domBindings.rootWindow;
  }
  get wtSettings() {
    return this._wot.wtSettings; // todo create facade
  }
  get cloneSource() {
    return this._wot.cloneSource; // todo create facade
  }
  get cloneOverlay() {
    return this._wot.cloneOverlay; // todo create facade
  }
  get selectionManager() {
    return this._wot.selectionManager; // todo create facade
  }
  get wtViewport() {
    return this._wot.wtViewport; // todo create facade
  }
  get wtOverlays() {
    return this._wot.wtOverlays; // todo create facade
  }
  get wtTable() {
    return this._wot.wtTable; // todo create facade
  }
  get wtEvent() {
    return this._wot.wtEvent; // todo create facade
  }
  get wtScroll() {
    return this._wot.wtScroll; // todo create facade
  }
  get drawn() {
    return this._wot.drawn;
  }
  set drawn(value) {
    this._wot.drawn = value;
  }
  get activeOverlayName() {
    return this._wot.activeOverlayName;
  }
  get drawInterrupted() {
    return this._wot.drawInterrupted;
  }
  set drawInterrupted(value) {
    this._wot.drawInterrupted = value;
  }
  get lastMouseOver() {
    return this._wot.lastMouseOver;
  }
  set lastMouseOver(value) {
    this._wot.lastMouseOver = value;
  }
  get momentumScrolling() {
    return this._wot.momentumScrolling;
  }
  set momentumScrolling(value) {
    this._wot.momentumScrolling = value;
  }
  get touchApplied() {
    return this._wot.touchApplied;
  }
  set touchApplied(value) {
    this._wot.touchApplied = value;
  }
  get domBindings() {
    return this._wot.domBindings;
  }
  get eventListeners() {
    return this._wot.eventListeners;
  }
  set eventListeners(value) {
    this._wot.eventListeners = value;
  }
  get eventManager() {
    return this._wot.eventManager;
  }
  get stylesHandler() {
    return this._wot.stylesHandler;
  }
  createCellCoords(row, column) {
    return this._wot.createCellCoords(row, column);
  }
  createCellRange(highlight, from, to) {
    return this._wot.createCellRange(highlight, from, to);
  }
  draw() {
    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this._wot.draw(fastDraw);
    return this;
  }
  getCell(coords) {
    let topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return this._wot.getCell(coords, topmost);
  }
  scrollViewport(coords, horizontalSnap, verticalSnap) {
    return this._wot.scrollViewport(coords, horizontalSnap, verticalSnap);
  }
  scrollViewportHorizontally(column, snapping) {
    return this._wot.scrollViewportHorizontally(column, snapping);
  }
  scrollViewportVertically(row, snapping) {
    return this._wot.scrollViewportVertically(row, snapping);
  }
  getViewport() {
    return this._wot.getViewport();
  }
  getOverlayName() {
    return this._wot.cloneOverlay ? this._wot.cloneOverlay.type : 'master';
  }
  getOverlayByName(overlayName) {
    return this._wot.getOverlayByName(overlayName);
  }
  exportSettingsAsClassNames() {
    return this._wot.exportSettingsAsClassNames();
  }
  update(settings, value) {
    this._wot.wtSettings.update(settings, value);
    return this;
  }
  getSetting(key, param1, param2, param3, param4) {
    return this._wot.wtSettings.getSetting(key, param1, param2, param3, param4);
  }
  hasSetting(key) {
    return this._wot.wtSettings.hasSetting(key);
  }
  destroy() {
    this._wot.destroy();
  }
}
exports["default"] = WalkontableFacade;

/***/ }),
/* 558 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _event = _interopRequireDefault(__webpack_require__(559));
var _overlays = _interopRequireDefault(__webpack_require__(560));
var _overlay = __webpack_require__(561);
var _settings = _interopRequireDefault(__webpack_require__(611));
var _master = _interopRequireDefault(__webpack_require__(612));
var _viewport = _interopRequireDefault(__webpack_require__(613));
var _base = _interopRequireDefault(__webpack_require__(589));
var _manager = __webpack_require__(602);
var _object = __webpack_require__(499);
var _element = __webpack_require__(351);
var _stylesHandler = __webpack_require__(614);
/**
 * @class Walkontable
 */
class Walkontable extends _base.default {
  /**
   * @param {HTMLTableElement} table Main table.
   * @param {SettingsPure} settings The Walkontable settings.
   */
  constructor(table, settings) {
    super(table, new _settings.default(settings));
    this.stylesHandler = new _stylesHandler.StylesHandler(this.domBindings);
    const facadeGetter = this.wtSettings.getSetting('facade', this); // todo rethink. I would like to have no access to facade from the internal scope.

    this.wtTable = new _master.default(this.getTableDao(), facadeGetter, this.domBindings, this.wtSettings);
    this.wtViewport = new _viewport.default(this.getViewportDao(), this.domBindings, this.wtSettings, this.eventManager, this.wtTable);
    this.selectionManager = new _manager.SelectionManager(this.wtSettings.getSetting('selections'));
    this.wtEvent = new _event.default(facadeGetter, this.domBindings, this.wtSettings, this.eventManager, this.wtTable, this.selectionManager);
    this.wtOverlays = new _overlays.default(
    // TODO create DAO and remove reference to the Walkontable instance.
    this, facadeGetter, this.domBindings, this.wtSettings, this.eventManager, this.wtTable);
    this.exportSettingsAsClassNames();
    this.findOriginalHeaders();
  }

  /**
   * Export settings as class names added to the parent element of the table.
   */
  exportSettingsAsClassNames() {
    const toExport = {
      rowHeaders: 'htRowHeaders',
      columnHeaders: 'htColumnHeaders'
    };
    const allClassNames = [];
    const newClassNames = [];
    (0, _object.objectEach)(toExport, (className, key) => {
      if (this.wtSettings.getSetting(key).length) {
        newClassNames.push(className);
      }
      allClassNames.push(className);
    });
    (0, _element.removeClass)(this.wtTable.wtRootElement.parentNode, allClassNames);
    (0, _element.addClass)(this.wtTable.wtRootElement.parentNode, newClassNames);
  }

  /**
   * Gets the overlay instance by its name.
   *
   * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'} overlayName The overlay name.
   * @returns {Overlay | null}
   */
  getOverlayByName(overlayName) {
    var _this$wtOverlays;
    if (!_overlay.CLONE_TYPES.includes(overlayName)) {
      return null;
    }
    const camelCaseOverlay = overlayName.replace(/_([a-z])/g, match => match[1].toUpperCase());
    return (_this$wtOverlays = this.wtOverlays[`${camelCaseOverlay}Overlay`]) !== null && _this$wtOverlays !== void 0 ? _this$wtOverlays : null;
  }

  /**
   * @returns {ViewportDao}
   */
  getViewportDao() {
    const wot = this;
    return {
      get wot() {
        return wot;
      },
      get topOverlayTrimmingContainer() {
        return wot.wtOverlays.topOverlay.trimmingContainer;
      },
      get inlineStartOverlayTrimmingContainer() {
        return wot.wtOverlays.inlineStartOverlay.trimmingContainer;
      },
      get topScrollPosition() {
        return wot.wtOverlays.topOverlay.getScrollPosition();
      },
      get topParentOffset() {
        return wot.wtOverlays.topOverlay.getTableParentOffset();
      },
      get inlineStartScrollPosition() {
        return wot.wtOverlays.inlineStartOverlay.getScrollPosition();
      },
      get inlineStartParentOffset() {
        return wot.wtOverlays.inlineStartOverlay.getTableParentOffset();
      },
      get topOverlay() {
        return wot.wtOverlays.topOverlay; // TODO refactoring: move outside dao, use IOC
      },
      get inlineStartOverlay() {
        return wot.wtOverlays.inlineStartOverlay; // TODO refactoring: move outside dao, use IOC
      },
      get bottomOverlay() {
        return wot.wtOverlays.bottomOverlay; // TODO refactoring: move outside dao, use IOC
      }
    };
  }
}
exports["default"] = Walkontable;

/***/ }),
/* 559 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(201);
var _element = __webpack_require__(351);
var _function = __webpack_require__(497);
var _feature = __webpack_require__(502);
var _browser = __webpack_require__(498);
var _mixed = __webpack_require__(354);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @class Event
 */
var _wtSettings = /*#__PURE__*/new WeakMap();
var _domBindings = /*#__PURE__*/new WeakMap();
var _wtTable = /*#__PURE__*/new WeakMap();
var _selectionManager = /*#__PURE__*/new WeakMap();
var _parent = /*#__PURE__*/new WeakMap();
var _eventManager = /*#__PURE__*/new WeakMap();
var _facadeGetter = /*#__PURE__*/new WeakMap();
var _selectedCellBeforeTouchEnd = /*#__PURE__*/new WeakMap();
var _dblClickTimeout = /*#__PURE__*/new WeakMap();
var _dblClickOrigin = /*#__PURE__*/new WeakMap();
class Event {
  /**
   * @param {FacadeGetter} facadeGetter Gets an instance facade.
   * @param {DomBindings} domBindings Bindings into dom.
   * @param {Settings} wtSettings The walkontable settings.
   * @param {EventManager} eventManager The walkontable event manager.
   * @param {Table} wtTable The table.
   * @param {SelectionManager} selectionManager Selections.
   * @param {Event} [parent=null] The main Event instance.
   */
  constructor(facadeGetter, domBindings, wtSettings, eventManager, wtTable, selectionManager) {
    let parent = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
    _classPrivateFieldInitSpec(this, _wtSettings, void 0);
    _classPrivateFieldInitSpec(this, _domBindings, void 0);
    _classPrivateFieldInitSpec(this, _wtTable, void 0);
    _classPrivateFieldInitSpec(this, _selectionManager, void 0);
    _classPrivateFieldInitSpec(this, _parent, void 0);
    /**
     * Instance of {@link EventManager}.
     *
     * @type {EventManager}
     */
    _classPrivateFieldInitSpec(this, _eventManager, void 0);
    /**
     * Should be use only for passing face called external origin methods, like registered event listeners.
     * It provides backward compatibility by getting instance facade.
     *
     * @todo Consider about removing this from Event class, because it make relationship into facade (implicit circular
     *   dependency).
     * @todo Con. Maybe passing listener caller as an ioc from faced resolves this issue. To rethink later.
     *
     * @type {FacadeGetter}
     */
    _classPrivateFieldInitSpec(this, _facadeGetter, void 0);
    /**
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _selectedCellBeforeTouchEnd, void 0);
    /**
     * @type {number[]}
     */
    _classPrivateFieldInitSpec(this, _dblClickTimeout, [null, null]);
    /**
     * @type {number[]}
     */
    _classPrivateFieldInitSpec(this, _dblClickOrigin, [null, null]);
    _classPrivateFieldSet(_wtSettings, this, wtSettings);
    _classPrivateFieldSet(_domBindings, this, domBindings);
    _classPrivateFieldSet(_wtTable, this, wtTable);
    _classPrivateFieldSet(_selectionManager, this, selectionManager);
    _classPrivateFieldSet(_parent, this, parent);
    _classPrivateFieldSet(_eventManager, this, eventManager);
    _classPrivateFieldSet(_facadeGetter, this, facadeGetter);
    this.registerEvents();
  }

  /**
   * Adds listeners for mouse and touch events.
   *
   * @private
   */
  registerEvents() {
    _classPrivateFieldGet(_eventManager, this).addEventListener(_classPrivateFieldGet(_wtTable, this).holder, 'contextmenu', event => this.onContextMenu(event));
    _classPrivateFieldGet(_eventManager, this).addEventListener(_classPrivateFieldGet(_wtTable, this).TABLE, 'mouseover', event => this.onMouseOver(event));
    _classPrivateFieldGet(_eventManager, this).addEventListener(_classPrivateFieldGet(_wtTable, this).TABLE, 'mouseout', event => this.onMouseOut(event));
    const initTouchEvents = () => {
      _classPrivateFieldGet(_eventManager, this).addEventListener(_classPrivateFieldGet(_wtTable, this).holder, 'touchstart', event => this.onTouchStart(event));
      _classPrivateFieldGet(_eventManager, this).addEventListener(_classPrivateFieldGet(_wtTable, this).holder, 'touchend', event => this.onTouchEnd(event));
      if (!this.momentumScrolling) {
        this.momentumScrolling = {};
      }
      _classPrivateFieldGet(_eventManager, this).addEventListener(_classPrivateFieldGet(_wtTable, this).holder, 'scroll', () => {
        clearTimeout(this.momentumScrolling._timeout);
        if (!this.momentumScrolling.ongoing) {
          _classPrivateFieldGet(_wtSettings, this).getSetting('onBeforeTouchScroll');
        }
        this.momentumScrolling.ongoing = true;
        this.momentumScrolling._timeout = setTimeout(() => {
          if (!this.touchApplied) {
            this.momentumScrolling.ongoing = false;
            _classPrivateFieldGet(_wtSettings, this).getSetting('onAfterMomentumScroll');
          }
        }, 200);
      });
    };
    const initMouseEvents = () => {
      _classPrivateFieldGet(_eventManager, this).addEventListener(_classPrivateFieldGet(_wtTable, this).holder, 'mouseup', event => this.onMouseUp(event));
      _classPrivateFieldGet(_eventManager, this).addEventListener(_classPrivateFieldGet(_wtTable, this).holder, 'mousedown', event => this.onMouseDown(event));
    };
    if ((0, _browser.isMobileBrowser)()) {
      initTouchEvents();
    } else {
      // PC like devices which support both methods (touchscreen and ability to plug-in mouse).
      if ((0, _feature.isTouchSupported)()) {
        initTouchEvents();
      }
      initMouseEvents();
    }
  }

  /**
   * Checks if an element is already selected.
   *
   * @private
   * @param {Element} touchTarget An element to check.
   * @returns {boolean}
   */
  selectedCellWasTouched(touchTarget) {
    const cellUnderFinger = this.parentCell(touchTarget);
    const coordsOfCellUnderFinger = cellUnderFinger.coords;
    if (_classPrivateFieldGet(_selectedCellBeforeTouchEnd, this) && coordsOfCellUnderFinger) {
      const [rowTouched, rowSelected] = [coordsOfCellUnderFinger.row, _classPrivateFieldGet(_selectedCellBeforeTouchEnd, this).from.row];
      const [colTouched, colSelected] = [coordsOfCellUnderFinger.col, _classPrivateFieldGet(_selectedCellBeforeTouchEnd, this).from.col];
      return rowTouched === rowSelected && colTouched === colSelected;
    }
    return false;
  }

  /**
   * Gets closest TD or TH element.
   *
   * @private
   * @param {Element} elem An element from the traversing starts.
   * @returns {object} Contains coordinates and reference to TD or TH if it exists. Otherwise it's empty object.
   */
  parentCell(elem) {
    const cell = {};
    const TABLE = _classPrivateFieldGet(_wtTable, this).TABLE;
    const TD = (0, _element.closestDown)(elem, ['TD', 'TH'], TABLE);
    if (TD) {
      cell.coords = _classPrivateFieldGet(_wtTable, this).getCoords(TD);
      cell.TD = TD;
    } else if ((0, _element.hasClass)(elem, 'wtBorder') && (0, _element.hasClass)(elem, 'current')) {
      cell.coords = _classPrivateFieldGet(_selectionManager, this).getFocusSelection().cellRange.highlight;
      cell.TD = _classPrivateFieldGet(_wtTable, this).getCell(cell.coords);
    } else if ((0, _element.hasClass)(elem, 'wtBorder') && (0, _element.hasClass)(elem, 'area')) {
      if (_classPrivateFieldGet(_selectionManager, this).getAreaSelection().cellRange) {
        cell.coords = _classPrivateFieldGet(_selectionManager, this).getAreaSelection().cellRange.to;
        cell.TD = _classPrivateFieldGet(_wtTable, this).getCell(cell.coords);
      }
    }
    return cell;
  }

  /**
   * OnMouseDown callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onMouseDown(event) {
    const activeElement = _classPrivateFieldGet(_domBindings, this).rootDocument.activeElement;
    const getParentNode = (0, _function.partial)(_element.getParent, event.target);
    const realTarget = event.target;

    // ignore non-TD focusable elements from mouse down processing
    // (https://github.com/handsontable/handsontable/issues/3555)
    if (!['TD', 'TH'].includes(activeElement.nodeName) && (realTarget === activeElement || getParentNode(0) === activeElement || getParentNode(1) === activeElement)) {
      return;
    }
    const cell = this.parentCell(realTarget);
    if ((0, _element.hasClass)(realTarget, 'corner')) {
      _classPrivateFieldGet(_wtSettings, this).getSetting('onCellCornerMouseDown', event, realTarget);
    } else if (cell.TD && _classPrivateFieldGet(_wtSettings, this).has('onCellMouseDown')) {
      this.callListener('onCellMouseDown', event, cell.coords, cell.TD);
    }

    // doubleclick reacts only for left mouse button or from touch events
    if ((event.button === 0 || this.touchApplied) && cell.TD) {
      _classPrivateFieldGet(_dblClickOrigin, this)[0] = cell.TD;
      clearTimeout(_classPrivateFieldGet(_dblClickTimeout, this)[0]);
      _classPrivateFieldGet(_dblClickTimeout, this)[0] = setTimeout(() => {
        _classPrivateFieldGet(_dblClickOrigin, this)[0] = null;
      }, 1000);
    }
  }

  /**
   * OnContextMenu callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onContextMenu(event) {
    if (_classPrivateFieldGet(_wtSettings, this).has('onCellContextMenu')) {
      const cell = this.parentCell(event.target);
      if (cell.TD) {
        this.callListener('onCellContextMenu', event, cell.coords, cell.TD);
      }
    }
  }

  /**
   * OnMouseOver callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onMouseOver(event) {
    if (!_classPrivateFieldGet(_wtSettings, this).has('onCellMouseOver')) {
      return;
    }
    const table = _classPrivateFieldGet(_wtTable, this).TABLE;
    const td = (0, _element.closestDown)(event.target, ['TD', 'TH'], table);
    const parent = _classPrivateFieldGet(_parent, this) || this;
    if (td && td !== parent.lastMouseOver && (0, _element.isChildOf)(td, table)) {
      parent.lastMouseOver = td;
      this.callListener('onCellMouseOver', event, _classPrivateFieldGet(_wtTable, this).getCoords(td), td);
    }
  }

  /**
   * OnMouseOut callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onMouseOut(event) {
    if (!_classPrivateFieldGet(_wtSettings, this).has('onCellMouseOut')) {
      return;
    }
    const table = _classPrivateFieldGet(_wtTable, this).TABLE;
    const lastTD = (0, _element.closestDown)(event.target, ['TD', 'TH'], table);
    const nextTD = (0, _element.closestDown)(event.relatedTarget, ['TD', 'TH'], table);
    const parent = _classPrivateFieldGet(_parent, this) || this;
    if (lastTD && lastTD !== nextTD && (0, _element.isChildOf)(lastTD, table)) {
      this.callListener('onCellMouseOut', event, _classPrivateFieldGet(_wtTable, this).getCoords(lastTD), lastTD);
      if (nextTD === null) {
        parent.lastMouseOver = null;
      }
    }
  }

  /**
   * OnMouseUp callback.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onMouseUp(event) {
    const cell = this.parentCell(event.target);
    if (cell.TD && _classPrivateFieldGet(_wtSettings, this).has('onCellMouseUp')) {
      this.callListener('onCellMouseUp', event, cell.coords, cell.TD);
    }

    // if not left mouse button, and the origin event is not comes from touch
    if (event.button !== 0 && !this.touchApplied) {
      return;
    }
    if (cell.TD === _classPrivateFieldGet(_dblClickOrigin, this)[0] && cell.TD === _classPrivateFieldGet(_dblClickOrigin, this)[1]) {
      if ((0, _element.hasClass)(event.target, 'corner')) {
        this.callListener('onCellCornerDblClick', event, cell.coords, cell.TD);
      } else {
        this.callListener('onCellDblClick', event, cell.coords, cell.TD);
      }
      _classPrivateFieldGet(_dblClickOrigin, this)[0] = null;
      _classPrivateFieldGet(_dblClickOrigin, this)[1] = null;
    } else if (cell.TD === _classPrivateFieldGet(_dblClickOrigin, this)[0]) {
      _classPrivateFieldGet(_dblClickOrigin, this)[1] = cell.TD;
      clearTimeout(_classPrivateFieldGet(_dblClickTimeout, this)[1]);
      _classPrivateFieldGet(_dblClickTimeout, this)[1] = setTimeout(() => {
        _classPrivateFieldGet(_dblClickOrigin, this)[1] = null;
      }, 500);
    }
  }

  /**
   * OnTouchStart callback. Simulates mousedown event.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onTouchStart(event) {
    _classPrivateFieldSet(_selectedCellBeforeTouchEnd, this, _classPrivateFieldGet(_selectionManager, this).getFocusSelection().cellRange);
    this.touchApplied = true;
    this.onMouseDown(event);
  }

  /**
   * OnTouchEnd callback. Simulates mouseup event.
   *
   * @private
   * @param {MouseEvent} event The mouse event object.
   */
  onTouchEnd(event) {
    var _this$parentCell;
    const target = event.target;
    const parentCellCoords = (_this$parentCell = this.parentCell(target)) === null || _this$parentCell === void 0 ? void 0 : _this$parentCell.coords;
    const isCellsRange = (0, _mixed.isDefined)(parentCellCoords) && parentCellCoords.row >= 0 && parentCellCoords.col >= 0;
    const isEventCancelable = event.cancelable && isCellsRange && _classPrivateFieldGet(_wtSettings, this).getSetting('isDataViewInstance');

    // To prevent accidental redirects or other actions that the interactive elements (e.q "A" link) do
    // while the cell is highlighted, all touch events that are triggered on different cells are
    // "preventDefault"'ed. The user can interact with the element (e.q. click on the link that opens
    // a new page) only when the same cell was previously selected (see related PR #7980).
    if (isEventCancelable) {
      const interactiveElements = ['A', 'BUTTON', 'INPUT'];

      // For browsers that use the WebKit as an engine (excluding Safari), there is a bug. The prevent
      // default has to be called all the time. Otherwise, the second tap won't be triggered (probably
      // caused by the native ~300ms delay - https://webkit.org/blog/5610/more-responsive-tapping-on-ios/).
      // To make the interactive elements work, the event target element has to be check. If the element
      // matches the allow-list, the event is not prevented.
      if ((0, _browser.isIOS)() && ((0, _browser.isChromeWebKit)() || (0, _browser.isFirefoxWebKit)()) && this.selectedCellWasTouched(target) && !interactiveElements.includes(target.tagName)) {
        event.preventDefault();
      } else if (!this.selectedCellWasTouched(target)) {
        // For other browsers, prevent default is fired only for the first tap and only when the previous
        // highlighted cell was different.
        event.preventDefault();
      }
    }
    this.onMouseUp(event);
    this.touchApplied = false;
  }

  /**
   * Call listener with backward compatibility.
   *
   * @private
   * @param {string} name Name of listener.
   * @param {MouseEvent} event The event object.
   * @param {CellCoords} coords Coordinates.
   * @param {HTMLElement} target Event target.
   */
  callListener(name, event, coords, target) {
    const listener = _classPrivateFieldGet(_wtSettings, this).getSettingPure(name);
    if (listener) {
      listener(event, coords, target, _classPrivateFieldGet(_facadeGetter, this).call(this));
    }
  }

  /**
   * Clears double-click timeouts and destroys the internal eventManager instance.
   */
  destroy() {
    clearTimeout(_classPrivateFieldGet(_dblClickTimeout, this)[0]);
    clearTimeout(_classPrivateFieldGet(_dblClickTimeout, this)[1]);
    _classPrivateFieldGet(_eventManager, this).destroy();
  }
}
var _default = exports["default"] = Event;

/***/ }),
/* 560 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(311);
__webpack_require__(329);
__webpack_require__(530);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _feature = __webpack_require__(502);
var _array = __webpack_require__(495);
var _unicode = __webpack_require__(508);
var _browser = __webpack_require__(498);
var _console = __webpack_require__(512);
var _overlay = __webpack_require__(561);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @class Overlays
 */
var _overlays = /*#__PURE__*/new WeakMap();
var _hasRenderingStateChanged = /*#__PURE__*/new WeakMap();
var _containerDomResizeCount = /*#__PURE__*/new WeakMap();
var _containerDomResizeCountTimeout = /*#__PURE__*/new WeakMap();
class Overlays {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @todo refactoring remove.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {EventManager} eventManager The walkontable event manager.
   * @param {MasterTable} wtTable The master table.
   */
  constructor(wotInstance, facadeGetter, domBindings, wtSettings, eventManager, wtTable) {
    /**
     * Walkontable instance's reference.
     *
     * @protected
     * @type {Walkontable}
     */
    (0, _defineProperty2.default)(this, "wot", null);
    /**
     * An array of the all overlays.
     *
     * @type {Overlay[]}
     */
    _classPrivateFieldInitSpec(this, _overlays, []);
    /**
     * Refer to the TopOverlay instance.
     *
     * @protected
     * @type {TopOverlay}
     */
    (0, _defineProperty2.default)(this, "topOverlay", null);
    /**
     * Refer to the BottomOverlay instance.
     *
     * @protected
     * @type {BottomOverlay}
     */
    (0, _defineProperty2.default)(this, "bottomOverlay", null);
    /**
     * Refer to the InlineStartOverlay or instance.
     *
     * @protected
     * @type {InlineStartOverlay}
     */
    (0, _defineProperty2.default)(this, "inlineStartOverlay", null);
    /**
     * Refer to the TopInlineStartCornerOverlay instance.
     *
     * @protected
     * @type {TopInlineStartCornerOverlay}
     */
    (0, _defineProperty2.default)(this, "topInlineStartCornerOverlay", null);
    /**
     * Refer to the BottomInlineStartCornerOverlay instance.
     *
     * @protected
     * @type {BottomInlineStartCornerOverlay}
     */
    (0, _defineProperty2.default)(this, "bottomInlineStartCornerOverlay", null);
    /**
     * Browser line height for purposes of translating mouse wheel.
     *
     * @private
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "browserLineHeight", undefined);
    /**
     * The walkontable settings.
     *
     * @protected
     * @type {Settings}
     */
    (0, _defineProperty2.default)(this, "wtSettings", null);
    /**
     * Indicates whether the rendering state has changed for one of the overlays.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _hasRenderingStateChanged, false);
    /**
     * The amount of times the ResizeObserver callback was fired in direct succession.
     *
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _containerDomResizeCount, 0);
    /**
     * The timeout ID for the ResizeObserver endless-loop-blocking logic.
     *
     * @type {number}
     */
    _classPrivateFieldInitSpec(this, _containerDomResizeCountTimeout, null);
    /**
     * The instance of the ResizeObserver that observes the size of the Walkontable wrapper element.
     * In case of the size change detection the `onContainerElementResize` is fired.
     *
     * @private
     * @type {ResizeObserver}
     */
    (0, _defineProperty2.default)(this, "resizeObserver", new ResizeObserver(entries => {
      (0, _feature.requestAnimationFrame)(() => {
        if (!Array.isArray(entries) || !entries.length) {
          return;
        }
        _classPrivateFieldSet(_containerDomResizeCount, this, _classPrivateFieldGet(_containerDomResizeCount, this) + 1);
        if (_classPrivateFieldGet(_containerDomResizeCount, this) === 100) {
          (0, _console.warn)('The ResizeObserver callback was fired too many times in direct succession.' + '\nThis may be due to an infinite loop caused by setting a dynamic height/width (for example, ' + 'with the `dvh` units) to a Handsontable container\'s parent. ' + '\nThe observer will be disconnected.');
          this.resizeObserver.disconnect();
        }

        // This logic is required to prevent an endless loop of the ResizeObserver callback.
        // https://github.com/handsontable/dev-handsontable/issues/1898#issuecomment-2154794817
        if (_classPrivateFieldGet(_containerDomResizeCountTimeout, this) !== null) {
          clearTimeout(_classPrivateFieldGet(_containerDomResizeCountTimeout, this));
        }
        _classPrivateFieldSet(_containerDomResizeCountTimeout, this, setTimeout(() => {
          _classPrivateFieldSet(_containerDomResizeCount, this, 0);
        }, 100));
        this.wtSettings.getSetting('onContainerElementResize');
      });
    }));
    this.wot = wotInstance;
    this.wtSettings = wtSettings;
    this.domBindings = domBindings;
    this.facadeGetter = facadeGetter;
    this.wtTable = wtTable;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;

    // legacy support
    this.instance = this.wot; // todo refactoring: move to facade
    this.eventManager = eventManager;

    // TODO refactoring: probably invalid place to this logic
    this.scrollbarSize = (0, _element.getScrollbarWidth)(rootDocument);
    const isOverflowHidden = rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden';
    this.scrollableElement = isOverflowHidden ? wtTable.holder : (0, _element.getScrollableElement)(wtTable.TABLE);
    this.initOverlays();
    this.destroyed = false;
    this.keyPressed = false;
    this.spreaderLastSize = {
      width: null,
      height: null
    };
    this.verticalScrolling = false;
    this.horizontalScrolling = false;
    this.initBrowserLineHeight();
    this.registerListeners();
    this.lastScrollX = rootWindow.scrollX;
    this.lastScrollY = rootWindow.scrollY;
  }

  /**
   * Get the list of references to all overlays.
   *
   * @param {boolean} [includeMaster = false] If set to `true`, the list will contain the master table as the last
   * element.
   * @returns {(TopOverlay|TopInlineStartCornerOverlay|InlineStartOverlay|BottomOverlay|BottomInlineStartCornerOverlay)[]}
   */
  getOverlays() {
    let includeMaster = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const overlays = [..._classPrivateFieldGet(_overlays, this)];
    if (includeMaster) {
      overlays.push(this.wtTable);
    }
    return overlays;
  }

  /**
   * Retrieve browser line height and apply its value to `browserLineHeight`.
   *
   * @private
   */
  initBrowserLineHeight() {
    const {
      rootWindow,
      rootDocument
    } = this.domBindings;
    const computedStyle = rootWindow.getComputedStyle(rootDocument.body);
    /**
     * Sometimes `line-height` might be set to 'normal'. In that case, a default `font-size` should be multiplied by roughly 1.2.
     * Https://developer.mozilla.org/pl/docs/Web/CSS/line-height#Values.
     */
    const lineHeight = parseInt(computedStyle.lineHeight, 10);
    const lineHeightFalback = parseInt(computedStyle.fontSize, 10) * 1.2;
    this.browserLineHeight = lineHeight || lineHeightFalback;
  }

  /**
   * Prepare overlays based on user settings.
   *
   * @private
   */
  initOverlays() {
    const args = [this.wot, this.facadeGetter, this.wtSettings, this.domBindings];

    // todo refactoring: IOC, collection or factories.
    // TODO refactoring, conceive about using generic collection of overlays.
    this.topOverlay = new _overlay.TopOverlay(...args);
    this.bottomOverlay = new _overlay.BottomOverlay(...args);
    this.inlineStartOverlay = new _overlay.InlineStartOverlay(...args);

    // TODO discuss, the controversial here would be removing the lazy creation mechanism for corners.
    // TODO cond. Has no any visual impact. They're initially hidden in same way like left, top, and bottom overlays.
    this.topInlineStartCornerOverlay = new _overlay.TopInlineStartCornerOverlay(...args, this.topOverlay, this.inlineStartOverlay);
    this.bottomInlineStartCornerOverlay = new _overlay.BottomInlineStartCornerOverlay(...args, this.bottomOverlay, this.inlineStartOverlay);
    _classPrivateFieldSet(_overlays, this, [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay]);
  }

  /**
   * Runs logic for the overlays before the table is drawn.
   */
  beforeDraw() {
    _classPrivateFieldSet(_hasRenderingStateChanged, this, _classPrivateFieldGet(_overlays, this).reduce((acc, overlay) => {
      return overlay.hasRenderingStateChanged() || acc;
    }, false));
    _classPrivateFieldGet(_overlays, this).forEach(overlay => overlay.updateStateOfRendering('before'));
  }

  /**
   * Runs logic for the overlays after the table is drawn.
   */
  afterDraw() {
    this.syncScrollWithMaster();
    _classPrivateFieldGet(_overlays, this).forEach(overlay => {
      const hasRenderingStateChanged = overlay.hasRenderingStateChanged();
      overlay.updateStateOfRendering('after');
      if (hasRenderingStateChanged && !overlay.needFullRender) {
        overlay.reset();
      }
    });
  }

  /**
   * Refresh and redraw table.
   */
  refreshAll() {
    if (!this.wot.drawn) {
      return;
    }
    if (!this.wtTable.holder.parentNode) {
      // Walkontable was detached from DOM, but this handler was not removed
      this.destroy();
      return;
    }
    this.wot.draw(true);
    if (this.verticalScrolling) {
      this.inlineStartOverlay.onScroll(); // todo the inlineStartOverlay.onScroll() fires hook. Why is it needed there, not in any another place?
    }
    if (this.horizontalScrolling) {
      this.topOverlay.onScroll();
    }
    this.verticalScrolling = false;
    this.horizontalScrolling = false;
  }

  /**
   * Register all necessary event listeners.
   */
  registerListeners() {
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const {
      mainTableScrollableElement: topOverlayScrollableElement
    } = this.topOverlay;
    const {
      mainTableScrollableElement: inlineStartOverlayScrollableElement
    } = this.inlineStartOverlay;
    this.eventManager.addEventListener(rootDocument.documentElement, 'keydown', event => this.onKeyDown(event));
    this.eventManager.addEventListener(rootDocument.documentElement, 'keyup', () => this.onKeyUp());
    this.eventManager.addEventListener(rootDocument, 'visibilitychange', () => this.onKeyUp());
    this.eventManager.addEventListener(topOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {
      passive: true
    });
    if (topOverlayScrollableElement !== inlineStartOverlayScrollableElement) {
      this.eventManager.addEventListener(inlineStartOverlayScrollableElement, 'scroll', event => this.onTableScroll(event), {
        passive: true
      });
    }
    const isHighPixelRatio = rootWindow.devicePixelRatio && rootWindow.devicePixelRatio > 1;
    const isScrollOnWindow = this.scrollableElement === rootWindow;
    const preventWheel = this.wtSettings.getSetting('preventWheel');
    const wheelEventOptions = {
      passive: isScrollOnWindow
    };
    if (preventWheel || isHighPixelRatio || !(0, _browser.isChrome)()) {
      this.eventManager.addEventListener(this.wtTable.wtRootElement, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);
    }
    const overlays = [this.topOverlay, this.bottomOverlay, this.inlineStartOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
    overlays.forEach(overlay => {
      if (overlay && overlay.needFullRender) {
        const {
          holder
        } = overlay.clone.wtTable; // todo rethink, maybe: overlay.getHolder()

        this.eventManager.addEventListener(holder, 'wheel', event => this.onCloneWheel(event, preventWheel), wheelEventOptions);
      }
    });
    let resizeTimeout;
    this.eventManager.addEventListener(rootWindow, 'resize', () => {
      (0, _feature.requestAnimationFrame)(() => {
        clearTimeout(resizeTimeout);
        this.wtSettings.getSetting('onWindowResize');
        resizeTimeout = setTimeout(() => {
          // Remove resizing the window from the ResizeObserver's endless-loop-blocking logic.
          _classPrivateFieldSet(_containerDomResizeCount, this, 0);
        }, 200);
      });
    });
    if (!isScrollOnWindow) {
      this.resizeObserver.observe(this.wtTable.wtRootElement.parentElement);
    }
  }

  /**
   * Deregister all previously registered listeners.
   */
  deregisterListeners() {
    this.eventManager.clearEvents(true);
  }

  /**
   * Scroll listener.
   *
   * @param {Event} event The mouse event object.
   */
  onTableScroll(event) {
    // There was if statement which controlled flow of this function. It avoided the execution of the next lines
    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.
    const rootWindow = this.domBindings.rootWindow;
    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;
    const masterVertical = this.topOverlay.mainTableScrollableElement;
    const target = event.target;

    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered
    // by hot.refreshBorder
    if (this.keyPressed) {
      if (masterVertical !== rootWindow && target !== rootWindow && !event.target.contains(masterVertical) || masterHorizontal !== rootWindow && target !== rootWindow && !event.target.contains(masterHorizontal)) {
        return;
      }
    }
    this.syncScrollPositions(event);
  }

  /**
   * Wheel listener for cloned overlays.
   *
   * @param {Event} event The mouse event object.
   * @param {boolean} preventDefault If `true`, the `preventDefault` will be called on event object.
   */
  onCloneWheel(event, preventDefault) {
    const {
      rootWindow
    } = this.domBindings;

    // There was if statement which controlled flow of this function. It avoided the execution of the next lines
    // on mobile devices. It was changed. Broader description of this case is included within issue #4856.

    const masterHorizontal = this.inlineStartOverlay.mainTableScrollableElement;
    const masterVertical = this.topOverlay.mainTableScrollableElement;
    const target = event.target;

    // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered
    // by hot.refreshBorder
    const shouldNotWheelVertically = masterVertical !== rootWindow && target !== rootWindow && !target.contains(masterVertical);
    const shouldNotWheelHorizontally = masterHorizontal !== rootWindow && target !== rootWindow && !target.contains(masterHorizontal);
    if (this.keyPressed && (shouldNotWheelVertically || shouldNotWheelHorizontally) || this.scrollableElement === rootWindow) {
      return;
    }
    const isScrollPossible = this.translateMouseWheelToScroll(event);
    if (preventDefault || this.scrollableElement !== rootWindow && isScrollPossible) {
      event.preventDefault();
    }
  }

  /**
   * Key down listener.
   *
   * @param {Event} event The keyboard event object.
   */
  onKeyDown(event) {
    this.keyPressed = (0, _unicode.isKey)(event.keyCode, 'ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT');
  }

  /**
   * Key up listener.
   */
  onKeyUp() {
    this.keyPressed = false;
  }

  /**
   * Translate wheel event into scroll event and sync scroll overlays position.
   *
   * @private
   * @param {Event} event The mouse event object.
   * @returns {boolean}
   */
  translateMouseWheelToScroll(event) {
    let deltaY = isNaN(event.deltaY) ? -1 * event.wheelDeltaY : event.deltaY;
    let deltaX = isNaN(event.deltaX) ? -1 * event.wheelDeltaX : event.deltaX;
    if (event.deltaMode === 1) {
      deltaX += deltaX * this.browserLineHeight;
      deltaY += deltaY * this.browserLineHeight;
    }
    const isScrollVerticallyPossible = this.scrollVertically(deltaY);
    const isScrollHorizontallyPossible = this.scrollHorizontally(deltaX);
    return isScrollVerticallyPossible || isScrollHorizontallyPossible;
  }

  /**
   * Scrolls main scrollable element horizontally.
   *
   * @param {number} delta Relative value to scroll.
   * @returns {boolean}
   */
  scrollVertically(delta) {
    const previousScroll = this.scrollableElement.scrollTop;
    this.scrollableElement.scrollTop += delta;
    return previousScroll !== this.scrollableElement.scrollTop;
  }

  /**
   * Scrolls main scrollable element horizontally.
   *
   * @param {number} delta Relative value to scroll.
   * @returns {boolean}
   */
  scrollHorizontally(delta) {
    const previousScroll = this.scrollableElement.scrollLeft;
    this.scrollableElement.scrollLeft += delta;
    return previousScroll !== this.scrollableElement.scrollLeft;
  }

  /**
   * Synchronize scroll position between master table and overlay table.
   *
   * @private
   */
  syncScrollPositions() {
    if (this.destroyed) {
      return;
    }
    const {
      rootWindow
    } = this.domBindings;
    const topHolder = this.topOverlay.clone.wtTable.holder; // todo rethink
    const leftHolder = this.inlineStartOverlay.clone.wtTable.holder; // todo rethink

    const [scrollLeft, scrollTop] = [this.scrollableElement.scrollLeft, this.scrollableElement.scrollTop];
    this.horizontalScrolling = topHolder.scrollLeft !== scrollLeft || this.lastScrollX !== rootWindow.scrollX;
    this.verticalScrolling = leftHolder.scrollTop !== scrollTop || this.lastScrollY !== rootWindow.scrollY;
    this.lastScrollX = rootWindow.scrollX;
    this.lastScrollY = rootWindow.scrollY;
    if (this.horizontalScrolling) {
      topHolder.scrollLeft = scrollLeft;
      const bottomHolder = this.bottomOverlay.needFullRender ? this.bottomOverlay.clone.wtTable.holder : null; // todo rethink

      if (bottomHolder) {
        bottomHolder.scrollLeft = scrollLeft;
      }
    }
    if (this.verticalScrolling) {
      leftHolder.scrollTop = scrollTop;
    }
    this.refreshAll();
  }

  /**
   * Synchronize overlay scrollbars with the master scrollbar.
   */
  syncScrollWithMaster() {
    if (!_classPrivateFieldGet(_hasRenderingStateChanged, this)) {
      return;
    }
    const master = this.topOverlay.mainTableScrollableElement;
    const {
      scrollLeft,
      scrollTop
    } = master;
    if (this.topOverlay.needFullRender) {
      this.topOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()
    }
    if (this.bottomOverlay.needFullRender) {
      this.bottomOverlay.clone.wtTable.holder.scrollLeft = scrollLeft; // todo rethink, *overlay.setScroll*()
    }
    if (this.inlineStartOverlay.needFullRender) {
      this.inlineStartOverlay.clone.wtTable.holder.scrollTop = scrollTop; // todo rethink, *overlay.setScroll*()
    }
    _classPrivateFieldSet(_hasRenderingStateChanged, this, false);
  }

  /**
   * Update the main scrollable elements for all the overlays.
   */
  updateMainScrollableElements() {
    this.deregisterListeners();
    this.inlineStartOverlay.updateMainScrollableElement();
    this.topOverlay.updateMainScrollableElement();
    if (this.bottomOverlay.needFullRender) {
      this.bottomOverlay.updateMainScrollableElement();
    }
    const {
      wtTable
    } = this;
    const {
      rootWindow
    } = this.domBindings;
    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {
      this.scrollableElement = wtTable.holder;
    } else {
      this.scrollableElement = (0, _element.getScrollableElement)(wtTable.TABLE);
    }
    this.registerListeners();
  }

  /**
   *
   */
  destroy() {
    this.resizeObserver.disconnect();
    this.eventManager.destroy();
    // todo, probably all below `destory` calls has no sense. To analyze
    this.topOverlay.destroy();
    if (this.bottomOverlay.clone) {
      this.bottomOverlay.destroy();
    }
    this.inlineStartOverlay.destroy();
    if (this.topInlineStartCornerOverlay) {
      this.topInlineStartCornerOverlay.destroy();
    }
    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {
      this.bottomInlineStartCornerOverlay.destroy();
    }
    this.destroyed = true;
  }

  /**
   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
   *                                   the data. It will only work if Table.draw() does not force
   *                                   rendering anyway.
   */
  refresh() {
    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const wasSpreaderSizeUpdated = this.updateLastSpreaderSize();
    if (wasSpreaderSizeUpdated) {
      this.adjustElementsSize();
    }
    if (this.bottomOverlay.clone) {
      this.bottomOverlay.refresh(fastDraw);
    }
    this.inlineStartOverlay.refresh(fastDraw);
    this.topOverlay.refresh(fastDraw);
    if (this.topInlineStartCornerOverlay) {
      this.topInlineStartCornerOverlay.refresh(fastDraw);
    }
    if (this.bottomInlineStartCornerOverlay && this.bottomInlineStartCornerOverlay.clone) {
      this.bottomInlineStartCornerOverlay.refresh(fastDraw);
    }
  }

  /**
   * Update the last cached spreader size with the current size.
   *
   * @returns {boolean} `true` if the lastSpreaderSize cache was updated, `false` otherwise.
   */
  updateLastSpreaderSize() {
    const spreader = this.wtTable.spreader;
    const width = spreader.clientWidth;
    const height = spreader.clientHeight;
    const needsUpdating = width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height;
    if (needsUpdating) {
      this.spreaderLastSize.width = width;
      this.spreaderLastSize.height = height;
    }
    return needsUpdating;
  }

  /**
   * Adjust overlays elements size and master table size.
   */
  adjustElementsSize() {
    const {
      wtViewport
    } = this.wot;
    const {
      wtTable
    } = this;
    const {
      rootWindow
    } = this.domBindings;
    const isWindowScrolled = this.scrollableElement === rootWindow;
    const totalColumns = this.wtSettings.getSetting('totalColumns');
    const totalRows = this.wtSettings.getSetting('totalRows');
    const headerRowSize = wtViewport.getRowHeaderWidth();
    const headerColumnSize = wtViewport.getColumnHeaderHeight();
    const proposedHiderHeight = headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1;
    const proposedHiderWidth = headerRowSize + this.inlineStartOverlay.sumCellSizes(0, totalColumns);
    const hiderElement = wtTable.hider;
    const hiderStyle = hiderElement.style;
    const isScrolledBeyondHiderHeight = () => {
      return isWindowScrolled ? false : this.scrollableElement.scrollTop > Math.max(0, proposedHiderHeight - wtTable.holder.clientHeight);
    };
    const isScrolledBeyondHiderWidth = () => {
      return isWindowScrolled ? false : this.scrollableElement.scrollLeft > Math.max(0, proposedHiderWidth - wtTable.holder.clientWidth);
    };
    const columnHeaderBorderCompensation = isScrolledBeyondHiderHeight() ? 1 : 0;
    const rowHeaderBorderCompensation = isScrolledBeyondHiderWidth() ? 1 : 0;

    // If the elements are being adjusted after scrolling the table from the very beginning to the very end,
    // we need to adjust the hider dimensions by the header border size. (https://github.com/handsontable/dev-handsontable/issues/1772)
    hiderStyle.width = `${proposedHiderWidth + rowHeaderBorderCompensation}px`;
    hiderStyle.height = `${proposedHiderHeight + columnHeaderBorderCompensation}px`;
    this.topOverlay.adjustElementsSize();
    this.inlineStartOverlay.adjustElementsSize();
    this.bottomOverlay.adjustElementsSize();
  }

  /**
   * Expand the hider vertically element by the provided delta value.
   *
   * @param {number} heightDelta The delta value to expand the hider element by.
   */
  expandHiderVerticallyBy(heightDelta) {
    const {
      wtTable
    } = this;
    wtTable.hider.style.height = `${parseInt(wtTable.hider.style.height, 10) + heightDelta}px`;
  }

  /**
   * Expand the hider horizontally element by the provided delta value.
   *
   * @param {number} widthDelta The delta value to expand the hider element by.
   */
  expandHiderHorizontallyBy(widthDelta) {
    const {
      wtTable
    } = this;
    wtTable.hider.style.width = `${parseInt(wtTable.hider.style.width, 10) + widthDelta}px`;
  }

  /**
   *
   */
  applyToDOM() {
    if (!this.wtTable.isVisible()) {
      return;
    }
    this.topOverlay.applyToDOM();
    if (this.bottomOverlay.clone) {
      this.bottomOverlay.applyToDOM();
    }
    this.inlineStartOverlay.applyToDOM();
  }

  /**
   * Get the parent overlay of the provided element.
   *
   * @param {HTMLElement} element An element to process.
   * @returns {object|null}
   */
  getParentOverlay(element) {
    if (!element) {
      return null;
    }
    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
    let result = null;
    (0, _array.arrayEach)(overlays, overlay => {
      if (!overlay) {
        return;
      }
      if (overlay.clone && overlay.clone.wtTable.TABLE.contains(element)) {
        // todo demeter
        result = overlay.clone;
      }
    });
    return result;
  }

  /**
   * Synchronize the class names between the main overlay table and the tables on the other overlays.
   *
   */
  syncOverlayTableClassNames() {
    const masterTable = this.wtTable.TABLE;
    const overlays = [this.topOverlay, this.inlineStartOverlay, this.bottomOverlay, this.topInlineStartCornerOverlay, this.bottomInlineStartCornerOverlay];
    (0, _array.arrayEach)(overlays, elem => {
      if (!elem) {
        return;
      }
      elem.clone.wtTable.TABLE.className = masterTable.className; // todo demeter
    });
  }
}
var _default = exports["default"] = Overlays;

/***/ }),
/* 561 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(311);
__webpack_require__(329);
exports.__esModule = true;
var _exportNames = {
  BottomInlineStartCornerOverlay: true,
  BottomOverlay: true,
  InlineStartOverlay: true,
  Overlay: true,
  TopInlineStartCornerOverlay: true,
  TopOverlay: true
};
var _bottomInlineStartCorner = __webpack_require__(562);
exports.BottomInlineStartCornerOverlay = _bottomInlineStartCorner.BottomInlineStartCornerOverlay;
var _bottom = __webpack_require__(591);
exports.BottomOverlay = _bottom.BottomOverlay;
var _inlineStart = __webpack_require__(594);
exports.InlineStartOverlay = _inlineStart.InlineStartOverlay;
var _base = __webpack_require__(586);
exports.Overlay = _base.Overlay;
var _topInlineStartCorner = __webpack_require__(606);
exports.TopInlineStartCornerOverlay = _topInlineStartCorner.TopInlineStartCornerOverlay;
var _top = __webpack_require__(609);
exports.TopOverlay = _top.TopOverlay;
var _constants = __webpack_require__(587);
Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _constants[key]) return;
  exports[key] = _constants[key];
});

/***/ }),
/* 562 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _element = __webpack_require__(351);
var _bottomInlineStartCorner = _interopRequireDefault(__webpack_require__(563));
var _base = __webpack_require__(586);
var _constants = __webpack_require__(587);
/**
 * @class BottomInlineStartCornerOverlay
 */
class BottomInlineStartCornerOverlay extends _base.Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   * @param {BottomOverlay} bottomOverlay The instance of the Top overlay.
   * @param {InlineStartOverlay} inlineStartOverlay The instance of the InlineStart overlay.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings, bottomOverlay, inlineStartOverlay) {
    super(wotInstance, facadeGetter, _constants.CLONE_BOTTOM_INLINE_START_CORNER, wtSettings, domBindings);
    this.bottomOverlay = bottomOverlay;
    this.inlineStartOverlay = inlineStartOverlay;
  }

  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {BottomInlineStartCornerOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new _bottomInlineStartCorner.default(...args);
  }

  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting('shouldRenderBottomOverlay') && this.wtSettings.getSetting('shouldRenderInlineStartOverlay');
  }

  /**
   * Updates the corner overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    const {
      wot
    } = this;
    this.updateTrimmingContainer();
    if (!wot.wtTable.holder.parentNode) {
      // removed from DOM
      return false;
    }
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    overlayRoot.style.top = '';
    if (this.trimmingContainer === this.domBindings.rootWindow) {
      const inlineStartOffset = this.inlineStartOverlay.getOverlayOffset();
      const bottom = this.bottomOverlay.getOverlayOffset();
      overlayRoot.style[this.isRtl() ? 'right' : 'left'] = `${inlineStartOffset}px`;
      overlayRoot.style.bottom = `${bottom}px`;
    } else {
      (0, _element.resetCssTransform)(overlayRoot);
      this.repositionOverlay();
    }
    let tableHeight = (0, _element.outerHeight)(this.clone.wtTable.TABLE);
    const tableWidth = (0, _element.outerWidth)(this.clone.wtTable.TABLE);
    if (!this.wot.wtTable.hasDefinedSize()) {
      tableHeight = 0;
    }
    overlayRoot.style.height = `${tableHeight}px`;
    overlayRoot.style.width = `${tableWidth}px`;
    return false;
  }

  /**
   * Reposition the overlay.
   */
  repositionOverlay() {
    const {
      wtTable,
      wtViewport
    } = this.wot;
    const {
      rootDocument
    } = this.domBindings;
    const cloneRoot = this.clone.wtTable.holder.parentNode;
    let bottomOffset = 0;
    if (!wtViewport.hasVerticalScroll()) {
      bottomOffset += wtViewport.getWorkspaceHeight() - wtTable.getTotalHeight();
    }
    if (wtViewport.hasVerticalScroll() && wtViewport.hasHorizontalScroll()) {
      bottomOffset += (0, _element.getScrollbarWidth)(rootDocument);
    }
    cloneRoot.style.bottom = `${bottomOffset}px`;
  }
}
exports.BottomInlineStartCornerOverlay = BottomInlineStartCornerOverlay;

/***/ }),
/* 563 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _table = _interopRequireDefault(__webpack_require__(564));
var _stickyRowsBottom = _interopRequireDefault(__webpack_require__(584));
var _stickyColumnsStart = _interopRequireDefault(__webpack_require__(585));
var _object = __webpack_require__(499);
var _overlay = __webpack_require__(561);
/**
 * Subclass of `Table` that provides the helper methods relevant to bottomInlineStartCornerOverlay
 * (in RTL mode the overlay sits on the right of the screen), implemented through mixins.
 *
 * @mixes stickyRowsBottom
 * @mixes stickyColumnsStart
 */
class BottomInlineStartCornerOverlayTable extends _table.default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, _overlay.CLONE_BOTTOM_INLINE_START_CORNER);
  }
}
(0, _object.mixin)(BottomInlineStartCornerOverlayTable, _stickyRowsBottom.default);
(0, _object.mixin)(BottomInlineStartCornerOverlayTable, _stickyColumnsStart.default);
var _default = exports["default"] = BottomInlineStartCornerOverlayTable;

/***/ }),
/* 564 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(311);
__webpack_require__(329);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _function = __webpack_require__(497);
var _column = _interopRequireDefault(__webpack_require__(565));
var _row = _interopRequireDefault(__webpack_require__(566));
var _renderer = __webpack_require__(567);
var _column2 = _interopRequireDefault(__webpack_require__(582));
var _row2 = _interopRequireDefault(__webpack_require__(583));
var _overlay = __webpack_require__(561);
var _a11y = __webpack_require__(496);
/**
 * @todo These mixes are never added to the class Table, however their members are used here.
 * @todo Continue: Potentially it works only, because some of these mixes are added to every inherited class.
 * @todo Refactoring, move code from `if(this.isMaster)` into MasterTable, and others like that.
 * @mixes stickyColumnsStart
 * @mixes stickyRowsBottom
 * @mixes stickyRowsTop
 * @mixes calculatedRows
 * @mixes calculatedColumns
 * @abstract
 */
class Table {
  /**
   *
   * @abstract
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {'master'|CLONE_TYPES_ENUM} name Overlay name.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings, name) {
    /**
     * The walkontable settings.
     *
     * @protected
     * @type {Settings}
     */
    (0, _defineProperty2.default)(this, "wtSettings", null);
    (0, _defineProperty2.default)(this, "domBindings", void 0);
    (0, _defineProperty2.default)(this, "TBODY", null);
    (0, _defineProperty2.default)(this, "THEAD", null);
    (0, _defineProperty2.default)(this, "COLGROUP", null);
    /**
     * Indicates if the table has height bigger than 0px.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "hasTableHeight", true);
    /**
     * Indicates if the table has width bigger than 0px.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "hasTableWidth", true);
    /**
     * Indicates if the table is visible. By visible, it means that the holder
     * element has CSS 'display' property different than 'none'.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "isTableVisible", false);
    (0, _defineProperty2.default)(this, "tableOffset", 0);
    (0, _defineProperty2.default)(this, "holderOffset", 0);
    this.domBindings = domBindings;
    /**
     * Indicates if this instance is of type `MasterTable` (i.e. It is NOT an overlay).
     *
     * @type {boolean}
     */
    this.isMaster = name === 'master';
    this.name = name;
    this.dataAccessObject = dataAccessObject;
    this.facadeGetter = facadeGetter;
    this.wtSettings = wtSettings;

    // legacy support
    this.instance = this.dataAccessObject.wot; // TODO refactoring: it might be removed here, and provides legacy support through facade.
    this.wot = this.dataAccessObject.wot;
    this.TABLE = domBindings.rootTable;
    (0, _element.removeTextNodes)(this.TABLE);

    // TODO refactoring, to recognize the legitimacy of moving them into domBidings
    this.spreader = this.createSpreader(this.TABLE);
    this.hider = this.createHider(this.spreader);
    this.holder = this.createHolder(this.hider);
    this.wtRootElement = this.holder.parentNode;
    if (this.isMaster) {
      this.alignOverlaysWithTrimmingContainer(); // todo wow, It calls method from child class (MasterTable).
    }
    this.fixTableDomTree();
    this.rowFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.
    this.columnFilter = null; // TODO refactoring, eliminate all (re)creations of this object, then updates state when needed.
    this.correctHeaderWidth = false;
    const origRowHeaderWidth = this.wtSettings.getSettingPure('rowHeaderWidth');

    // Fix for jumping row headers (https://github.com/handsontable/handsontable/issues/3850)
    this.wtSettings.update('rowHeaderWidth', () => this._modifyRowHeaderWidth(origRowHeaderWidth));
    this.rowUtils = new _row2.default(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.
    this.columnUtils = new _column2.default(this.dataAccessObject, this.wtSettings); // TODO refactoring, It can be passed through IOC.

    this.tableRenderer = new _renderer.Renderer({
      // TODO refactoring, It can be passed through IOC.
      TABLE: this.TABLE,
      THEAD: this.THEAD,
      COLGROUP: this.COLGROUP,
      TBODY: this.TBODY,
      rowUtils: this.rowUtils,
      columnUtils: this.columnUtils,
      cellRenderer: this.wtSettings.getSettingPure('cellRenderer'),
      stylesHandler: this.dataAccessObject.stylesHandler
    });
  }

  /**
   * Returns a boolean that is true if this Table represents a specific overlay, identified by the overlay name.
   * For MasterTable, it returns false.
   *
   * @param {string} overlayTypeName The overlay type.
   * @returns {boolean}
   */
  is(overlayTypeName) {
    // todo refactoring: eliminate all protected and private usages
    return this.name === overlayTypeName;
  }

  /**
   *
   */
  fixTableDomTree() {
    const rootDocument = this.domBindings.rootDocument;
    this.TBODY = this.TABLE.querySelector('tbody');
    if (!this.TBODY) {
      this.TBODY = rootDocument.createElement('tbody');
      this.TABLE.appendChild(this.TBODY);
    }
    this.THEAD = this.TABLE.querySelector('thead');
    if (!this.THEAD) {
      this.THEAD = rootDocument.createElement('thead');
      this.TABLE.insertBefore(this.THEAD, this.TBODY);
    }
    this.COLGROUP = this.TABLE.querySelector('colgroup');
    if (!this.COLGROUP) {
      this.COLGROUP = rootDocument.createElement('colgroup');
      this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
    }
  }

  /**
   * @param {HTMLTableElement} table An element to process.
   * @returns {HTMLElement}
   */
  createSpreader(table) {
    const parent = table.parentNode;
    let spreader;
    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {
      spreader = this.domBindings.rootDocument.createElement('div');
      spreader.className = 'wtSpreader';
      if (parent) {
        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
        parent.insertBefore(spreader, table);
      }
      spreader.appendChild(table);
    }
    spreader.style.position = 'relative';
    if (this.wtSettings.getSetting('ariaTags')) {
      (0, _element.setAttribute)(spreader, [(0, _a11y.A11Y_PRESENTATION)()]);
    }
    return spreader;
  }

  /**
   * @param {HTMLElement} spreader An element to the hider element is injected.
   * @returns {HTMLElement}
   */
  createHider(spreader) {
    const parent = spreader.parentNode;
    let hider;
    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {
      hider = this.domBindings.rootDocument.createElement('div');
      hider.className = 'wtHider';
      if (parent) {
        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
        parent.insertBefore(hider, spreader);
      }
      hider.appendChild(spreader);
    }
    if (this.wtSettings.getSetting('ariaTags')) {
      (0, _element.setAttribute)(hider, [(0, _a11y.A11Y_PRESENTATION)()]);
    }
    return hider;
  }

  /**
   *
   * @param {HTMLElement} hider An element to the holder element is injected.
   * @returns {HTMLElement}
   */
  createHolder(hider) {
    const parent = hider.parentNode;
    let holder;
    if (!parent || parent.nodeType !== Node.ELEMENT_NODE || !(0, _element.hasClass)(parent, 'wtHolder')) {
      holder = this.domBindings.rootDocument.createElement('div');
      holder.style.position = 'relative';
      holder.className = 'wtHolder';
      if (parent) {
        // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
        parent.insertBefore(holder, hider);
      }
      if (this.isMaster) {
        holder.parentNode.className += 'ht_master handsontable';
        holder.parentNode.setAttribute('dir', this.wtSettings.getSettingPure('rtlMode') ? 'rtl' : 'ltr');
        if (this.wtSettings.getSetting('ariaTags')) {
          (0, _element.setAttribute)(holder.parentNode, [(0, _a11y.A11Y_PRESENTATION)()]);
        }
      }
      holder.appendChild(hider);
    }
    if (this.wtSettings.getSetting('ariaTags')) {
      (0, _element.setAttribute)(holder, [(0, _a11y.A11Y_PRESENTATION)()]);
    }
    return holder;
  }

  /**
   * Redraws the table.
   *
   * @param {boolean} [fastDraw=false] If TRUE, will try to avoid full redraw and only update the border positions.
   *                                   If FALSE or UNDEFINED, will perform a full redraw.
   * @returns {Table}
   */
  draw() {
    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const {
      wtSettings
    } = this;
    const {
      wtOverlays,
      wtViewport
    } = this.dataAccessObject;
    const totalRows = wtSettings.getSetting('totalRows');
    const totalColumns = wtSettings.getSetting('totalColumns');
    const rowHeaders = wtSettings.getSetting('rowHeaders');
    const rowHeadersCount = rowHeaders.length;
    const columnHeaders = wtSettings.getSetting('columnHeaders');
    const columnHeadersCount = columnHeaders.length;
    let runFastDraw = fastDraw;
    if (this.isMaster) {
      wtOverlays.beforeDraw();
      this.holderOffset = (0, _element.offset)(this.holder);
      runFastDraw = wtViewport.createCalculators(runFastDraw);
      if (rowHeadersCount && !wtSettings.getSetting('fixedColumnsStart')) {
        const leftScrollPos = wtOverlays.inlineStartOverlay.getScrollPosition();
        const previousState = this.correctHeaderWidth;
        this.correctHeaderWidth = leftScrollPos !== 0;
        if (previousState !== this.correctHeaderWidth) {
          runFastDraw = false;
        }
      }
    }
    if (runFastDraw) {
      if (this.isMaster) {
        wtOverlays.refresh(true);
      }
    } else {
      if (this.isMaster) {
        this.tableOffset = (0, _element.offset)(this.TABLE);
      } else {
        this.tableOffset = this.dataAccessObject.parentTableOffset;
      }
      const startRow = totalRows > 0 ? this.getFirstRenderedRow() : 0;
      const startColumn = totalColumns > 0 ? this.getFirstRenderedColumn() : 0;
      this.rowFilter = new _row.default(startRow, totalRows, columnHeadersCount);
      this.columnFilter = new _column.default(startColumn, totalColumns, rowHeadersCount);
      let performRedraw = true;

      // Only master table rendering can be skipped
      if (this.isMaster) {
        this.alignOverlaysWithTrimmingContainer(); // todo It calls method from child class (MasterTable).
        const skipRender = {};
        this.wtSettings.getSetting('beforeDraw', true, skipRender);
        performRedraw = skipRender.skipRender !== true;
      }
      if (performRedraw) {
        this.tableRenderer.setHeaderContentRenderers(rowHeaders, columnHeaders);
        if (this.is(_overlay.CLONE_BOTTOM) || this.is(_overlay.CLONE_BOTTOM_INLINE_START_CORNER)) {
          // do NOT render headers on the bottom or bottom-left corner overlay
          this.tableRenderer.setHeaderContentRenderers(rowHeaders, []);
        }
        this.resetOversizedRows();
        this.tableRenderer.setActiveOverlayName(this.name).setViewportSize(this.getRenderedRowsCount(), this.getRenderedColumnsCount()).setFilters(this.rowFilter, this.columnFilter).render();
        if (this.isMaster) {
          this.markOversizedColumnHeaders();
        }
        this.adjustColumnHeaderHeights();
        if (this.isMaster || this.is(_overlay.CLONE_BOTTOM)) {
          this.markOversizedRows();
        }
        if (this.isMaster) {
          if (!this.wtSettings.getSetting('externalRowCalculator')) {
            wtViewport.createVisibleCalculators();
          }
          wtOverlays.refresh(false);
          wtOverlays.applyToDOM();
          this.wtSettings.getSetting('onDraw', true);
        } else if (this.is(_overlay.CLONE_BOTTOM)) {
          this.dataAccessObject.cloneSource.wtOverlays.adjustElementsSize();
        }
      }
    }
    let positionChanged = false;
    if (this.isMaster) {
      positionChanged = wtOverlays.topOverlay.resetFixedPosition();
      if (wtOverlays.bottomOverlay.clone) {
        positionChanged = wtOverlays.bottomOverlay.resetFixedPosition() || positionChanged;
      }
      positionChanged = wtOverlays.inlineStartOverlay.resetFixedPosition() || positionChanged;
      if (wtOverlays.topInlineStartCornerOverlay) {
        wtOverlays.topInlineStartCornerOverlay.resetFixedPosition();
      }
      if (wtOverlays.bottomInlineStartCornerOverlay && wtOverlays.bottomInlineStartCornerOverlay.clone) {
        wtOverlays.bottomInlineStartCornerOverlay.resetFixedPosition();
      }
    }
    if (positionChanged) {
      // It refreshes the cells borders caused by a 1px shift (introduced by overlays which add or
      // remove `innerBorderTop` and `innerBorderInlineStart` CSS classes to the DOM element. This happens
      // when there is a switch between rendering from 0 to N rows/columns and vice versa).
      wtOverlays.refreshAll(); // `refreshAll()` internally already calls `refreshSelections()` method
      wtOverlays.adjustElementsSize();
    } else {
      this.dataAccessObject.selectionManager.setActiveOverlay(this.facadeGetter()).render(runFastDraw);
    }
    if (this.isMaster) {
      wtOverlays.afterDraw();
    }
    this.dataAccessObject.drawn = true;
    return this;
  }

  /**
   * @param {number} col The visual column index.
   */
  markIfOversizedColumnHeader(col) {
    const sourceColIndex = this.columnFilter.renderedToSource(col);
    let level = this.wtSettings.getSetting('columnHeaders').length;
    const defaultRowHeight = this.dataAccessObject.stylesHandler.getDefaultRowHeight();
    let previousColHeaderHeight;
    let currentHeader;
    let currentHeaderHeight;
    const columnHeaderHeightSetting = this.wtSettings.getSetting('columnHeaderHeight') || [];
    while (level) {
      level -= 1;
      previousColHeaderHeight = this.getColumnHeaderHeight(level);
      currentHeader = this.getColumnHeader(sourceColIndex, level);
      if (!currentHeader) {
        /* eslint-disable no-continue */
        continue;
      }
      currentHeaderHeight = (0, _element.innerHeight)(currentHeader);
      if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {
        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;
      }
      if (Array.isArray(columnHeaderHeightSetting)) {
        if (columnHeaderHeightSetting[level] !== null && columnHeaderHeightSetting[level] !== undefined) {
          this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level];
        }
      } else if (!isNaN(columnHeaderHeightSetting)) {
        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting;
      }
      if (this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] < (columnHeaderHeightSetting[level] || columnHeaderHeightSetting)) {
        this.dataAccessObject.wtViewport.oversizedColumnHeaders[level] = columnHeaderHeightSetting[level] || columnHeaderHeightSetting; // eslint-disable-line max-len
      }
    }
  }

  /**
   *
   */
  adjustColumnHeaderHeights() {
    const {
      wtSettings
    } = this;
    const children = this.THEAD.childNodes;
    const oversizedColumnHeaders = this.dataAccessObject.wtViewport.oversizedColumnHeaders;
    const columnHeaders = wtSettings.getSetting('columnHeaders');
    for (let i = 0, len = columnHeaders.length; i < len; i++) {
      if (oversizedColumnHeaders[i]) {
        if (!children[i] || children[i].childNodes.length === 0) {
          return;
        }
        children[i].childNodes[0].style.height = `${oversizedColumnHeaders[i]}px`;
      }
    }
  }

  /**
   * Resets cache of row heights. The cache should be cached for each render cycle in a case
   * when new cell values have content which increases/decreases cell height.
   */
  resetOversizedRows() {
    const {
      wtSettings
    } = this;
    const {
      wtViewport
    } = this.dataAccessObject;
    if (!this.isMaster && !this.is(_overlay.CLONE_BOTTOM)) {
      return;
    }
    if (!wtSettings.getSetting('externalRowCalculator')) {
      const rowsToRender = this.getRenderedRowsCount();

      // Reset the oversized row cache for rendered rows
      for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
        const sourceRow = this.rowFilter.renderedToSource(visibleRowIndex);
        if (wtViewport.oversizedRows && wtViewport.oversizedRows[sourceRow]) {
          wtViewport.oversizedRows[sourceRow] = undefined;
        }
      }
    }
  }

  /**
   * Get cell element at coords.
   * Negative coords.row or coords.col are used to retrieve header cells. If there are multiple header levels, the
   * negative value corresponds to the distance from the working area. For example, when there are 3 levels of column
   * headers, coords.col=-1 corresponds to the most inner header element, while coords.col=-3 corresponds to the
   * outmost header element.
   *
   * In case an element for the coords is not rendered, the method returns an error code.
   * To produce the error code, the input parameters are validated in the order in which they
   * are given. Thus, if both the row and the column coords are out of the rendered bounds,
   * the method returns the error code for the row.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @returns {HTMLElement|number} HTMLElement on success or Number one of the exit codes on error:
   *  -1 row before viewport
   *  -2 row after viewport
   *  -3 column before viewport
   *  -4 column after viewport.
   */
  getCell(coords) {
    let row = coords.row;
    let column = coords.col;
    const hookResult = this.wtSettings.getSetting('onModifyGetCellCoords', row, column, !this.isMaster, 'render');
    if (hookResult && Array.isArray(hookResult)) {
      [row, column] = hookResult;
    }
    if (this.isRowBeforeRenderedRows(row)) {
      // row before rendered rows
      return -1;
    } else if (this.isRowAfterRenderedRows(row)) {
      // row after rendered rows
      return -2;
    } else if (this.isColumnBeforeRenderedColumns(column)) {
      // column before rendered columns
      return -3;
    } else if (this.isColumnAfterRenderedColumns(column)) {
      // column after rendered columns
      return -4;
    }
    const TR = this.getRow(row);
    if (!TR && row >= 0) {
      throw new Error('TR was expected to be rendered but is not');
    }
    const TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column)];
    if (!TD && column >= 0) {
      throw new Error('TD or TH was expected to be rendered but is not');
    }
    return TD;
  }

  /**
   * Get the DOM element of the row with the provided index.
   *
   * @param {number} rowIndex Row index.
   * @returns {HTMLTableRowElement|boolean} Return the row's DOM element or `false` if the row with the provided
   * index doesn't exist.
   */
  getRow(rowIndex) {
    let renderedRowIndex = null;
    let parentElement = null;
    if (rowIndex < 0) {
      var _this$rowFilter;
      renderedRowIndex = (_this$rowFilter = this.rowFilter) === null || _this$rowFilter === void 0 ? void 0 : _this$rowFilter.sourceRowToVisibleColHeadedRow(rowIndex);
      parentElement = this.THEAD;
    } else {
      var _this$rowFilter2;
      renderedRowIndex = (_this$rowFilter2 = this.rowFilter) === null || _this$rowFilter2 === void 0 ? void 0 : _this$rowFilter2.sourceToRendered(rowIndex);
      parentElement = this.TBODY;
    }
    if (renderedRowIndex !== undefined && parentElement !== undefined) {
      if (parentElement.childNodes.length < renderedRowIndex + 1) {
        return false;
      } else {
        return parentElement.childNodes[renderedRowIndex];
      }
    }
    return false;
  }

  /**
   * GetColumnHeader.
   *
   * @param {number} col Column index.
   * @param {number} [level=0] Header level (0 = most distant to the table).
   * @returns {object} HTMLElement on success or undefined on error.
   */
  getColumnHeader(col) {
    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const TR = this.THEAD.childNodes[level];
    return TR === null || TR === void 0 ? void 0 : TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
  }

  /**
   * Gets all columns headers (TH elements) from the table.
   *
   * @param {number} column A source column index.
   * @returns {HTMLTableCellElement[]}
   */
  getColumnHeaders(column) {
    const THs = [];
    const visibleColumn = this.columnFilter.sourceColumnToVisibleRowHeadedColumn(column);
    this.THEAD.childNodes.forEach(TR => {
      const TH = TR.childNodes[visibleColumn];
      if (TH) {
        THs.push(TH);
      }
    });
    return THs;
  }

  /**
   * GetRowHeader.
   *
   * @param {number} row Row index.
   * @param {number} [level=0] Header level (0 = most distant to the table).
   * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have
   *   row headers`.
   */
  getRowHeader(row) {
    let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;
    if (level >= rowHeadersCount) {
      return;
    }
    const renderedRow = this.rowFilter.sourceToRendered(row);
    const visibleRow = renderedRow < 0 ? this.rowFilter.sourceRowToVisibleColHeadedRow(row) : renderedRow;
    const parentElement = renderedRow < 0 ? this.THEAD : this.TBODY;
    const TR = parentElement.childNodes[visibleRow];
    return TR === null || TR === void 0 ? void 0 : TR.childNodes[level];
  }

  /**
   * Gets all rows headers (TH elements) from the table.
   *
   * @param {number} row A source row index.
   * @returns {HTMLTableCellElement[]}
   */
  getRowHeaders(row) {
    const THs = [];
    const rowHeadersCount = this.wtSettings.getSetting('rowHeaders').length;
    for (let renderedRowIndex = 0; renderedRowIndex < rowHeadersCount; renderedRowIndex++) {
      const TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
      const TH = TR === null || TR === void 0 ? void 0 : TR.childNodes[renderedRowIndex];
      if (TH) {
        THs.push(TH);
      }
    }
    return THs;
  }

  /**
   * Returns cell coords object for a given TD (or a child element of a TD element).
   *
   * @param {HTMLTableCellElement} TD A cell DOM element (or a child of one).
   * @returns {CellCoords|null} The coordinates of the provided TD element (or the closest TD element) or null, if the
   *   provided element is not applicable.
   */
  getCoords(TD) {
    let cellElement = TD;
    if (cellElement.nodeName !== 'TD' && cellElement.nodeName !== 'TH') {
      cellElement = (0, _element.closest)(cellElement, ['TD', 'TH']);
    }
    if (cellElement === null) {
      return null;
    }
    const TR = cellElement.parentNode;
    const CONTAINER = TR.parentNode;
    let row = (0, _element.index)(TR);
    let col = cellElement.cellIndex;
    if ((0, _element.overlayContainsElement)(_overlay.CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_overlay.CLONE_TOP, cellElement, this.wtRootElement)) {
      if (CONTAINER.nodeName === 'THEAD') {
        row -= CONTAINER.childNodes.length;
      }
    } else if ((0, _element.overlayContainsElement)(_overlay.CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_overlay.CLONE_BOTTOM, cellElement, this.wtRootElement)) {
      const totalRows = this.wtSettings.getSetting('totalRows');
      row = totalRows - CONTAINER.childNodes.length + row;
    } else if (CONTAINER === this.THEAD) {
      row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
    } else {
      row = this.rowFilter.renderedToSource(row);
    }
    if ((0, _element.overlayContainsElement)(_overlay.CLONE_TOP_INLINE_START_CORNER, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_overlay.CLONE_INLINE_START, cellElement, this.wtRootElement) || (0, _element.overlayContainsElement)(_overlay.CLONE_BOTTOM_INLINE_START_CORNER, cellElement, this.wtRootElement)) {
      col = this.columnFilter.offsettedTH(col);
    } else {
      col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(col);
    }
    const hookResult = this.wtSettings.getSetting('onModifyGetCoordsElement', row, col);
    if (hookResult && Array.isArray(hookResult)) {
      [row, col] = hookResult;
    }
    return this.wot.createCellCoords(row, col);
  }

  /**
   * Check if any of the rendered rows is higher than expected, and if so, cache them.
   */
  markOversizedRows() {
    if (this.wtSettings.getSetting('externalRowCalculator')) {
      return;
    }
    let rowCount = this.TBODY.childNodes.length;
    const expectedTableHeight = rowCount * this.dataAccessObject.stylesHandler.getDefaultRowHeight();
    const actualTableHeight = (0, _element.innerHeight)(this.TBODY) - 1;
    const borderBoxSizing = this.wot.stylesHandler.areCellsBorderBox();
    const rowHeightFn = borderBoxSizing ? _element.outerHeight : _element.innerHeight;
    const borderCompensation = borderBoxSizing ? 0 : 1;
    const firstRowBorderCompensation = borderBoxSizing ? 1 : 0;
    let previousRowHeight;
    let rowCurrentHeight;
    let sourceRowIndex;
    let currentTr;
    let rowHeader;
    if (expectedTableHeight === actualTableHeight && !this.wtSettings.getSetting('fixedRowsBottom')) {
      // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them
      return;
    }
    while (rowCount) {
      rowCount -= 1;
      sourceRowIndex = this.rowFilter.renderedToSource(rowCount);
      previousRowHeight = this.getRowHeight(sourceRowIndex);
      currentTr = this.getTrForRow(sourceRowIndex);
      rowHeader = currentTr.querySelector('th');
      const topBorderCompensation = sourceRowIndex === 0 ? firstRowBorderCompensation : 0;
      if (rowHeader) {
        rowCurrentHeight = rowHeightFn(rowHeader);
      } else {
        rowCurrentHeight = rowHeightFn(currentTr) - borderCompensation;
      }
      if (!previousRowHeight && this.dataAccessObject.stylesHandler.getDefaultRowHeight() < rowCurrentHeight - topBorderCompensation || previousRowHeight < rowCurrentHeight) {
        if (!borderBoxSizing) {
          rowCurrentHeight += 1;
        }
        this.dataAccessObject.wtViewport.oversizedRows[sourceRowIndex] = rowCurrentHeight;
      }
    }
  }

  /**
   * @param {number} row The visual row index.
   * @returns {HTMLTableElement}
   */
  getTrForRow(row) {
    return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
  }

  /**
   * Checks if the column index (negative value from -1 to N) is rendered.
   *
   * @param {number} column The column index (negative value from -1 to N).
   * @returns {boolean}
   */
  isColumnHeaderRendered(column) {
    if (column >= 0) {
      return false;
    }
    const rowHeaders = this.wtSettings.getSetting('rowHeaders');
    const rowHeadersCount = rowHeaders.length;
    return Math.abs(column) <= rowHeadersCount;
  }

  /**
   * Checks if the row index (negative value from -1 to N) is rendered.
   *
   * @param {number} row The row index (negative value from -1 to N).
   * @returns {boolean}
   */
  isRowHeaderRendered(row) {
    if (row >= 0) {
      return false;
    }
    const columnHeaders = this.wtSettings.getSetting('columnHeaders');
    const columnHeadersCount = columnHeaders.length;
    return Math.abs(row) <= columnHeadersCount;
  }

  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Check if the given row index is lower than the index of the first row that
   * is currently rendered and return TRUE in that case, or FALSE otherwise.
   *
   * Negative row index is used to check the columns' headers.
   *
   *  Headers
   *           +--------------+                                     │
   *       -3  │    │    │    │                                     │
   *           +--------------+                                     │
   *       -2  │    │    │    │                                     │ TRUE
   *           +--------------+                                     │
   *       -1  │    │    │    │                                     │
   *  Cells  +==================+                                   │
   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │
   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)
   *        1  │ A2 │ B2 │ C2 │      not render the first row.      │
   *           +--------------+                                     │ FALSE
   *        2  │ A3 │ B3 │ C3 │                                     │
   *           +--------------+                                  ---+ last rendered row
   *                                                                │
   *                                                                │ FALSE
   *
   * @param {number} row The visual row index.
   * @memberof Table#
   * @function isRowBeforeRenderedRows
   * @returns {boolean}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  isRowBeforeRenderedRows(row) {
    const first = this.getFirstRenderedRow();

    // Check the headers only in case when the first rendered row is -1 or 0.
    // This is an indication that the overlay is placed on the most top position.
    if (row < 0 && first <= 0) {
      return !this.isRowHeaderRendered(row);
    }
    return row < first;
  }

  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Check if the given column index is greater than the index of the last column that
   * is currently rendered and return TRUE in that case, or FALSE otherwise.
   *
   * The negative row index is used to check the columns' headers. However,
   * keep in mind that for negative indexes, the method always returns FALSE as
   * it is not possible to render headers partially. The "after" index can not be
   * lower than -1.
   *
   *  Headers
   *           +--------------+                                     │
   *       -3  │    │    │    │                                     │
   *           +--------------+                                     │
   *       -2  │    │    │    │                                     │ FALSE
   *           +--------------+                                     │
   *       -1  │    │    │    │                                     │
   *  Cells  +==================+                                   │
   *        0  ┇    ┇    ┇    ┇ <--- For fixedRowsTop: 1            │
   *           +--------------+      the master overlay do       ---+ first rendered row (index 1)
   *        1  │ A2 │ B2 │ C2 │      not render the first rows      │
   *           +--------------+                                     │ FALSE
   *        2  │ A3 │ B3 │ C3 │                                     │
   *           +--------------+                                  ---+ last rendered row
   *                                                                │
   *                                                                │ TRUE
   *
   * @param {number} row The visual row index.
   * @memberof Table#
   * @function isRowAfterRenderedRows
   * @returns {boolean}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  isRowAfterRenderedRows(row) {
    return row > this.getLastRenderedRow();
  }

  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Check if the given column index is lower than the index of the first column that
   * is currently rendered and return TRUE in that case, or FALSE otherwise.
   *
   * Negative column index is used to check the rows' headers.
   *
   *                            For fixedColumnsStart: 1 the master overlay
   *                            do not render this first columns.
   *  Headers    -3   -2   -1    |
   *           +----+----+----║┄ ┄ +------+------+
   *           │    │    │    ║    │  B1  │  C1  │
   *           +--------------║┄ ┄ --------------│
   *           │    │    │    ║    │  B2  │  C2  │
   *           +--------------║┄ ┄ --------------│
   *           │    │    │    ║    │  B3  │  C3  │
   *           +----+----+----║┄ ┄ +------+------+
   *                               ╷             ╷
   *      -------------------------+-------------+---------------->
   *          TRUE             first    FALSE   last         FALSE
   *                           rendered         rendered
   *                           column           column
   *
   * @param {number} column The visual column index.
   * @memberof Table#
   * @function isColumnBeforeRenderedColumns
   * @returns {boolean}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  isColumnBeforeRenderedColumns(column) {
    const first = this.getFirstRenderedColumn();

    // Check the headers only in case when the first rendered column is -1 or 0.
    // This is an indication that the overlay is placed on the most left position.
    if (column < 0 && first <= 0) {
      return !this.isColumnHeaderRendered(column);
    }
    return column < first;
  }

  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Check if the given column index is greater than the index of the last column that
   * is currently rendered and return TRUE in that case, or FALSE otherwise.
   *
   * The negative column index is used to check the rows' headers. However,
   * keep in mind that for negative indexes, the method always returns FALSE as
   * it is not possible to render headers partially. The "after" index can not be
   * lower than -1.
   *
   *                            For fixedColumnsStart: 1 the master overlay
   *                            do not render this first columns.
   *  Headers    -3   -2   -1    |
   *           +----+----+----║┄ ┄ +------+------+
   *           │    │    │    ║    │  B1  │  C1  │
   *           +--------------║┄ ┄ --------------│
   *           │    │    │    ║    │  B2  │  C2  │
   *           +--------------║┄ ┄ --------------│
   *           │    │    │    ║    │  B3  │  C3  │
   *           +----+----+----║┄ ┄ +------+------+
   *                               ╷             ╷
   *      -------------------------+-------------+---------------->
   *          FALSE             first    FALSE   last         TRUE
   *                           rendered         rendered
   *                           column           column
   *
   * @param {number} column The visual column index.
   * @memberof Table#
   * @function isColumnAfterRenderedColumns
   * @returns {boolean}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  isColumnAfterRenderedColumns(column) {
    return this.columnFilter && column > this.getLastRenderedColumn();
  }
  isColumnAfterViewport(column) {
    return this.columnFilter && column > this.getLastVisibleColumn();
  }
  isRowAfterViewport(row) {
    return this.rowFilter && row > this.getLastVisibleRow();
  }
  isColumnBeforeViewport(column) {
    return this.columnFilter && this.columnFilter.sourceToRendered(column) < 0 && column >= 0;
  }
  isLastRowFullyVisible() {
    return this.getLastVisibleRow() === this.getLastRenderedRow();
  }
  isLastColumnFullyVisible() {
    return this.getLastVisibleColumn() === this.getLastRenderedColumn();
  }
  allRowsInViewport() {
    return this.wtSettings.getSetting('totalRows') === this.getVisibleRowsCount();
  }
  allColumnsInViewport() {
    return this.wtSettings.getSetting('totalColumns') === this.getVisibleColumnsCount();
  }

  /**
   * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height.
   *
   * @param {number} sourceRow The physical row index.
   * @returns {number}
   */
  getRowHeight(sourceRow) {
    return this.rowUtils.getHeight(sourceRow);
  }

  /**
   * @param {number} level The column level.
   * @returns {number}
   */
  getColumnHeaderHeight(level) {
    return this.columnUtils.getHeaderHeight(level);
  }

  /**
   * @param {number} sourceColumn The physical column index.
   * @returns {number}
   */
  getColumnWidth(sourceColumn) {
    return this.columnUtils.getWidth(sourceColumn);
  }

  /**
   * Checks if the table has defined size. It returns `true` when the table has width and height
   * set bigger than `0px`.
   *
   * @returns {boolean}
   */
  hasDefinedSize() {
    return this.hasTableHeight && this.hasTableWidth;
  }

  /**
   * Gets table's width. The returned width is the width of the rendered cells that fit in the
   * current viewport. The value may change depends on the viewport position (scroll position).
   *
   * @returns {number}
   */
  getWidth() {
    return (0, _element.outerWidth)(this.TABLE);
  }

  /**
   * Gets table's height. The returned height is the height of the rendered cells that fit in the
   * current viewport. The value may change depends on the viewport position (scroll position).
   *
   * @returns {number}
   */
  getHeight() {
    return (0, _element.outerHeight)(this.TABLE);
  }

  /**
   * Gets table's total width. The returned width is the width of all rendered cells (including headers)
   * that can be displayed in the table.
   *
   * @returns {number}
   */
  getTotalWidth() {
    const width = (0, _element.outerWidth)(this.hider);

    // when the overlay's table does not have any cells the hider returns 0, get then width from the table element
    return width !== 0 ? width : this.getWidth();
  }

  /**
   * Gets table's total height. The returned height is the height of all rendered cells (including headers)
   * that can be displayed in the table.
   *
   * @returns {number}
   */
  getTotalHeight() {
    const height = (0, _element.outerHeight)(this.hider);

    // when the overlay's table does not have any cells the hider returns 0, get then height from the table element
    return height !== 0 ? height : this.getHeight();
  }

  /**
   * Checks if the table is visible. It returns `true` when the holder element (or its parents)
   * has CSS 'display' property different than 'none'.
   *
   * @returns {boolean}
   */
  isVisible() {
    return (0, _element.isVisible)(this.TABLE);
  }

  /**
   * Modify row header widths provided by user in class contructor.
   *
   * @private
   * @param {Function} rowHeaderWidthFactory The function which can provide default width values for rows..
   * @returns {number}
   */
  _modifyRowHeaderWidth(rowHeaderWidthFactory) {
    let widths = (0, _function.isFunction)(rowHeaderWidthFactory) ? rowHeaderWidthFactory() : null;
    if (Array.isArray(widths)) {
      widths = [...widths];
      widths[widths.length - 1] = this._correctRowHeaderWidth(widths[widths.length - 1]);
    } else {
      widths = this._correctRowHeaderWidth(widths);
    }
    return widths;
  }

  /**
   * Correct row header width if necessary.
   *
   * @private
   * @param {number} width The width to process.
   * @returns {number}
   */
  _correctRowHeaderWidth(width) {
    let rowHeaderWidth = width;
    if (typeof width !== 'number') {
      rowHeaderWidth = this.wtSettings.getSetting('defaultColumnWidth');
    }
    if (this.correctHeaderWidth) {
      rowHeaderWidth += 1;
    }
    return rowHeaderWidth;
  }
}
var _default = exports["default"] = Table;

/***/ }),
/* 565 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @class ColumnFilter
 */
class ColumnFilter {
  /**
   * @param {number} offset The scroll horizontal offset.
   * @param {number} total The total width of the table.
   * @param {number} countTH The number of rendered row headers.
   */
  constructor(offset, total, countTH) {
    /**
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "offset", void 0);
    /**
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "total", void 0);
    /**
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "countTH", void 0);
    this.offset = offset;
    this.total = total;
    this.countTH = countTH;
  }

  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  offsetted(index) {
    return index + this.offset;
  }

  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  unOffsetted(index) {
    return index - this.offset;
  }

  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  renderedToSource(index) {
    return this.offsetted(index);
  }

  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  sourceToRendered(index) {
    return this.unOffsetted(index);
  }

  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  offsettedTH(index) {
    return index - this.countTH;
  }

  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  unOffsettedTH(index) {
    return index + this.countTH;
  }

  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  visibleRowHeadedColumnToSourceColumn(index) {
    return this.renderedToSource(this.offsettedTH(index));
  }

  /**
   * @param {number} index The visual column index.
   * @returns {number}
   */
  sourceColumnToVisibleRowHeadedColumn(index) {
    return this.unOffsettedTH(this.sourceToRendered(index));
  }
}
var _default = exports["default"] = ColumnFilter;

/***/ }),
/* 566 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * @class RowFilter
 */
class RowFilter {
  /**
   * @param {number} offset The scroll vertical offset.
   * @param {number} total The total height of the table.
   * @param {number} countTH The number of rendered column headers.
   */
  constructor(offset, total, countTH) {
    /**
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "offset", void 0);
    /**
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "total", void 0);
    /**
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "countTH", void 0);
    this.offset = offset;
    this.total = total;
    this.countTH = countTH;
  }

  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  offsetted(index) {
    return index + this.offset;
  }

  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  unOffsetted(index) {
    return index - this.offset;
  }

  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  renderedToSource(index) {
    return this.offsetted(index);
  }

  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  sourceToRendered(index) {
    return this.unOffsetted(index);
  }

  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  offsettedTH(index) {
    return index - this.countTH;
  }

  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  unOffsettedTH(index) {
    return index + this.countTH;
  }

  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  visibleColHeadedRowToSourceRow(index) {
    return this.renderedToSource(this.offsettedTH(index));
  }

  /**
   * @param {number} index The visual row index.
   * @returns {number}
   */
  sourceRowToVisibleColHeadedRow(index) {
    return this.unOffsettedTH(this.sourceToRendered(index));
  }
}
var _default = exports["default"] = RowFilter;

/***/ }),
/* 567 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _rowHeaders = _interopRequireDefault(__webpack_require__(568));
exports.RowHeadersRenderer = _rowHeaders.default;
var _columnHeaders = _interopRequireDefault(__webpack_require__(577));
exports.ColumnHeadersRenderer = _columnHeaders.default;
var _colGroup = _interopRequireDefault(__webpack_require__(578));
exports.ColGroupRenderer = _colGroup.default;
var _rows = _interopRequireDefault(__webpack_require__(579));
exports.RowsRenderer = _rows.default;
var _cells = _interopRequireDefault(__webpack_require__(580));
exports.CellsRenderer = _cells.default;
var _table = _interopRequireDefault(__webpack_require__(581));
exports.TableRenderer = _table.default;
/**
 * Content renderer.
 *
 * @class Renderer
 */
class Renderer {
  constructor() {
    let {
      TABLE,
      THEAD,
      COLGROUP,
      TBODY,
      rowUtils,
      columnUtils,
      cellRenderer,
      stylesHandler
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    /**
     * General renderer class used to render Walkontable content on screen.
     *
     * @type {TableRenderer}
     */
    this.renderer = new _table.default(TABLE, {
      cellRenderer,
      stylesHandler
    });
    this.renderer.setRenderers({
      rowHeaders: new _rowHeaders.default(),
      columnHeaders: new _columnHeaders.default(THEAD),
      colGroup: new _colGroup.default(COLGROUP),
      rows: new _rows.default(TBODY),
      cells: new _cells.default()
    });
    this.renderer.setAxisUtils(rowUtils, columnUtils);
  }

  /**
   * Sets the overlay that is currently rendered. If `null` is provided, the master overlay is set.
   *
   * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'|'master'} overlayName The overlay name.
   * @returns {Renderer}
   */
  setActiveOverlayName(overlayName) {
    this.renderer.setActiveOverlayName(overlayName);
    return this;
  }

  /**
   * Sets filter calculators for newly calculated row and column position. The filters are used to transform visual
   * indexes (0 to N) to source indexes provided by Handsontable.
   *
   * @param {RowFilter} rowFilter The row filter instance.
   * @param {ColumnFilter} columnFilter The column filter instance.
   * @returns {Renderer}
   */
  setFilters(rowFilter, columnFilter) {
    this.renderer.setFilters(rowFilter, columnFilter);
    return this;
  }

  /**
   * Sets the viewport size of the rendered table.
   *
   * @param {number} rowsCount An amount of rows to render.
   * @param {number} columnsCount An amount of columns to render.
   * @returns {Renderer}
   */
  setViewportSize(rowsCount, columnsCount) {
    this.renderer.setViewportSize(rowsCount, columnsCount);
    return this;
  }

  /**
   * Sets row and column header functions.
   *
   * @param {Function[]} rowHeaders Row header functions. Factories for creating content for row headers.
   * @param {Function[]} columnHeaders Column header functions. Factories for creating content for column headers.
   * @returns {Renderer}
   */
  setHeaderContentRenderers(rowHeaders, columnHeaders) {
    this.renderer.setHeaderContentRenderers(rowHeaders, columnHeaders);
    return this;
  }

  /**
   * Adjusts the table (preparing for render).
   */
  adjust() {
    this.renderer.adjust();
  }

  /**
   * Renders the table.
   */
  render() {
    this.renderer.render();
  }
}
exports.Renderer = Renderer;

/***/ }),
/* 568 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _orderView = __webpack_require__(569);
var _base = _interopRequireDefault(__webpack_require__(575));
var _element = __webpack_require__(351);
var _a11y = __webpack_require__(496);
/**
 * Row headers renderer responsible for managing (inserting, tracking, rendering) TR elements belongs to TR.
 *
 *   <tr> (root node)
 *     ├ <th>   --- RowHeadersRenderer
 *     ├ <td>   \
 *     ├ <td>    \
 *     ├ <td>     - CellsRenderer
 *     ├ <td>    /
 *     └ <td>   /.
 *
 * @class {CellsRenderer}
 */
class RowHeadersRenderer extends _base.default {
  constructor() {
    super('TH');
    /**
     * Cache for OrderView classes connected to specified node.
     *
     * @type {WeakMap}
     */
    (0, _defineProperty2.default)(this, "orderViews", new WeakMap());
    /**
     * Row index which specifies the row position of the processed row header.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "sourceRowIndex", 0);
  }

  /**
   * Obtains the instance of the SharedOrderView class which is responsible for rendering the nodes to the root node.
   *
   * @param {HTMLTableRowElement} rootNode The TR element, which is root element for row headers (TH).
   * @returns {SharedOrderView}
   */
  obtainOrderView(rootNode) {
    let orderView;
    if (this.orderViews.has(rootNode)) {
      orderView = this.orderViews.get(rootNode);
    } else {
      orderView = new _orderView.SharedOrderView(rootNode, sourceColumnIndex => this.nodesPool.obtain(this.sourceRowIndex, sourceColumnIndex), this.nodeType);
      this.orderViews.set(rootNode, orderView);
    }
    return orderView;
  }

  /**
   * Renders the cells.
   */
  render() {
    const {
      rowsToRender,
      rowHeaderFunctions,
      rowHeadersCount,
      rows,
      cells
    } = this.table;
    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
      const sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
      const TR = rows.getRenderedNode(visibleRowIndex);
      this.sourceRowIndex = sourceRowIndex;
      const orderView = this.obtainOrderView(TR);
      const cellsView = cells.obtainOrderView(TR);
      orderView.appendView(cellsView).setSize(rowHeadersCount).setOffset(this.table.renderedColumnToSource(0)).start();
      for (let visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
        orderView.render();
        const TH = orderView.getCurrentNode();
        TH.className = '';
        TH.removeAttribute('style');

        // Remove all accessibility-related attributes for the header to start fresh.
        (0, _element.removeAttribute)(TH, [new RegExp('aria-(.*)'), new RegExp('role')]);
        if (this.table.isAriaEnabled()) {
          (0, _element.setAttribute)(TH, [(0, _a11y.A11Y_ROWHEADER)(), (0, _a11y.A11Y_SCOPE_ROW)(), (0, _a11y.A11Y_COLINDEX)(visibleColumnIndex + 1), (0, _a11y.A11Y_TABINDEX)(-1)]);
        }
        rowHeaderFunctions[visibleColumnIndex](sourceRowIndex, TH, visibleColumnIndex);
      }
      orderView.end();
    }
  }
}
exports["default"] = RowHeadersRenderer;

/***/ }),
/* 569 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _view = _interopRequireDefault(__webpack_require__(570));
exports.OrderView = _view.default;
var _sharedView = _interopRequireDefault(__webpack_require__(574));
exports.SharedOrderView = _sharedView.default;

/***/ }),
/* 570 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _constants = __webpack_require__(571);
var _viewSizeSet = _interopRequireDefault(__webpack_require__(572));
/**
 * Executive model for each table renderer. It's responsible for injecting DOM nodes in a
 * specified order and adjusting the number of elements in the root node.
 *
 * Only this class have rights to juggling DOM elements within the root node (see render method).
 *
 * @class {OrderView}
 */
class OrderView {
  constructor(rootNode, nodesPool, childNodeType) {
    /**
     * The root node to manage with.
     *
     * @type {HTMLElement}
     */
    (0, _defineProperty2.default)(this, "rootNode", void 0);
    /**
     * Factory for newly created DOM elements.
     *
     * @type {Function}
     */
    (0, _defineProperty2.default)(this, "nodesPool", void 0);
    /**
     * Holder for sizing and positioning of the view.
     *
     * @type {ViewSizeSet}
     */
    (0, _defineProperty2.default)(this, "sizeSet", new _viewSizeSet.default());
    /**
     * Node type which the order view will manage while rendering the DOM elements.
     *
     * @type {string}
     */
    (0, _defineProperty2.default)(this, "childNodeType", void 0);
    /**
     * The visual index of currently processed row.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "visualIndex", 0);
    /**
     * The list of DOM elements which are rendered for this render cycle.
     *
     * @type {HTMLElement[]}
     */
    (0, _defineProperty2.default)(this, "collectedNodes", []);
    this.rootNode = rootNode;
    this.nodesPool = nodesPool;
    this.childNodeType = childNodeType.toUpperCase();
  }

  /**
   * Sets the size for rendered elements. It can be a size for rows, cells or size for row
   * headers etc. It depends for what table renderer this instance was created.
   *
   * @param {number} size The size.
   * @returns {OrderView}
   */
  setSize(size) {
    this.sizeSet.setSize(size);
    return this;
  }

  /**
   * Sets the offset for rendered elements. The offset describes the shift between 0 and
   * the first rendered element according to the scroll position.
   *
   * @param {number} offset The offset.
   * @returns {OrderView}
   */
  setOffset(offset) {
    this.sizeSet.setOffset(offset);
    return this;
  }

  /**
   * Checks if this instance of the view shares the root node with another instance. This happens only once when
   * a row (TR) as a root node is managed by two OrderView instances. If this happens another DOM injection
   * algorithm is performed to achieve consistent order.
   *
   * @returns {boolean}
   */
  isSharedViewSet() {
    return this.sizeSet.isShared();
  }

  /**
   * Returns rendered DOM element based on visual index.
   *
   * @param {number} visualIndex The visual index.
   * @returns {HTMLElement}
   */
  getNode(visualIndex) {
    return visualIndex < this.collectedNodes.length ? this.collectedNodes[visualIndex] : null;
  }

  /**
   * Returns currently processed DOM element.
   *
   * @returns {HTMLElement}
   */
  getCurrentNode() {
    const length = this.collectedNodes.length;
    return length > 0 ? this.collectedNodes[length - 1] : null;
  }

  /**
   * Returns rendered child count for this instance.
   *
   * @returns {number}
   */
  getRenderedChildCount() {
    const {
      rootNode,
      sizeSet
    } = this;
    let childElementCount = 0;
    if (this.isSharedViewSet()) {
      let element = rootNode.firstElementChild;
      while (element) {
        if (element.tagName === this.childNodeType) {
          childElementCount += 1;
        } else if (sizeSet.isPlaceOn(_constants.WORKING_SPACE_TOP)) {
          break;
        }
        element = element.nextElementSibling;
      }
    } else {
      childElementCount = rootNode.childElementCount;
    }
    return childElementCount;
  }

  /**
   * Setups and prepares all necessary properties and start the rendering process.
   * This method has to be called only once (at the start) for the render cycle.
   */
  start() {
    this.collectedNodes.length = 0;
    this.visualIndex = 0;
    const {
      rootNode,
      sizeSet
    } = this;
    const isShared = this.isSharedViewSet();
    const {
      nextSize
    } = sizeSet.getViewSize();
    let childElementCount = this.getRenderedChildCount();
    while (childElementCount < nextSize) {
      const newNode = this.nodesPool();
      if (!isShared || isShared && sizeSet.isPlaceOn(_constants.WORKING_SPACE_BOTTOM)) {
        rootNode.appendChild(newNode);
      } else {
        rootNode.insertBefore(newNode, rootNode.firstChild);
      }
      childElementCount += 1;
    }
    const isSharedPlacedOnTop = isShared && sizeSet.isPlaceOn(_constants.WORKING_SPACE_TOP);
    while (childElementCount > nextSize) {
      rootNode.removeChild(isSharedPlacedOnTop ? rootNode.firstChild : rootNode.lastChild);
      childElementCount -= 1;
    }
  }

  /**
   * Renders the DOM element based on visual index (which is calculated internally).
   * This method has to be called as many times as the size count is met (to cover all previously rendered DOM elements).
   */
  render() {
    const {
      rootNode,
      sizeSet
    } = this;
    let visualIndex = this.visualIndex;
    if (this.isSharedViewSet() && sizeSet.isPlaceOn(_constants.WORKING_SPACE_BOTTOM)) {
      visualIndex += sizeSet.sharedSize.nextSize;
    }
    let node = rootNode.childNodes[visualIndex];
    if (node.tagName !== this.childNodeType) {
      const newNode = this.nodesPool();
      rootNode.replaceChild(newNode, node);
      node = newNode;
    }
    this.collectedNodes.push(node);
    this.visualIndex += 1;
  }

  /**
   * Ends the render process.
   * This method has to be called only once (at the end) for the render cycle.
   */
  end() {}
}
exports["default"] = OrderView;

/***/ }),
/* 571 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
/**
 * Describes that ViewSizeSet instance doesn't share sizes with another
 * instance (root node can contain only one type of children nodes).
 *
 * @type {number}
 */
const WORKING_SPACE_ALL = exports.WORKING_SPACE_ALL = 0;
/**
 * Describes that ViewSizeSet instance share sizes with another instance and
 * set working space for this instance to 'top' (root node can contain multiple
 * types of children and this instance will be occupied top space of the root node).
 *
 * @type {number}
 */
const WORKING_SPACE_TOP = exports.WORKING_SPACE_TOP = 1;
/**
 * Describes that ViewSizeSet instance share sizes with another instance and
 * set working space for this instance to 'bottom' (root node can contain multiple
 * types of children and this instance will be occupied bottom space of the root node).
 *
 * @type {number}
 */
const WORKING_SPACE_BOTTOM = exports.WORKING_SPACE_BOTTOM = 2;

/***/ }),
/* 572 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _viewSize = _interopRequireDefault(__webpack_require__(573));
var _constants = __webpack_require__(571);
/**
 * The class is a source of the truth of information about the current and
 * next size of the rendered DOM elements and current and next offset of
 * the view. That information allows us to calculate diff between current
 * DOM order and this which should be rendered without touching the DOM API at all.
 *
 * Mostly the ViewSizeSet is created for each individual renderer. But in
 * the table, there is one case where this size information should be shared
 * between two different instances (different table renderers). This is a TR
 * element which can contain TH elements - managed by own renderer and
 * TD elements - managed by another renderer. To generate correct DOM order
 * for them it is required to connect these two instances by reference
 * through `sharedSize`.
 *
 * @class {ViewSizeSet}
 */
class ViewSizeSet {
  constructor() {
    /**
     * Holder for current and next view size and offset.
     *
     * @type {ViewSize}
     */
    (0, _defineProperty2.default)(this, "size", new _viewSize.default());
    /**
     * Defines if this instance shares its size with another instance. If it's in the shared
     * mode it defines what space it occupies ('top' or 'bottom').
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "workingSpace", _constants.WORKING_SPACE_ALL);
    /**
     * Shared Size instance.
     *
     * @type {ViewSize}
     */
    (0, _defineProperty2.default)(this, "sharedSize", null);
  }
  /**
   * Sets the size for rendered elements. It can be a size for rows, cells or size for row
   * headers etc.
   *
   * @param {number} size The size.
   */
  setSize(size) {
    this.size.setSize(size);
  }

  /**
   * Sets the offset for rendered elements. The offset describes the shift between 0 and
   * the first rendered element according to the scroll position.
   *
   * @param {number} offset The offset.
   */
  setOffset(offset) {
    this.size.setOffset(offset);
  }

  /**
   * Returns ViewSize instance.
   *
   * @returns {ViewSize}
   */
  getViewSize() {
    return this.size;
  }

  /**
   * Checks if this ViewSizeSet is sharing the size with another instance.
   *
   * @returns {boolean}
   */
  isShared() {
    return this.sharedSize instanceof _viewSize.default;
  }

  /**
   * Checks what working space describes this size instance.
   *
   * @param {number} workingSpace The number which describes the type of the working space (see constants.js).
   * @returns {boolean}
   */
  isPlaceOn(workingSpace) {
    return this.workingSpace === workingSpace;
  }

  /**
   * Appends the ViewSizeSet instance to this instance that turns it into a shared mode.
   *
   * @param {ViewSizeSet} viewSize The instance of the ViewSizeSet class.
   */
  append(viewSize) {
    this.workingSpace = _constants.WORKING_SPACE_TOP;
    viewSize.workingSpace = _constants.WORKING_SPACE_BOTTOM;
    this.sharedSize = viewSize.getViewSize();
  }

  /**
   * Prepends the ViewSize instance to this instance that turns it into a shared mode.
   *
   * @param {ViewSizeSet} viewSize The instance of the ViewSizeSet class.
   */
  prepend(viewSize) {
    this.workingSpace = _constants.WORKING_SPACE_BOTTOM;
    viewSize.workingSpace = _constants.WORKING_SPACE_TOP;
    this.sharedSize = viewSize.getViewSize();
  }
}
exports["default"] = ViewSizeSet;

/***/ }),
/* 573 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * Holder for current and next size (count of rendered and to render DOM elements) and offset.
 *
 * @class {ViewSize}
 */
class ViewSize {
  constructor() {
    /**
     * Current size of the rendered DOM elements.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "currentSize", 0);
    /**
     * Next size of the rendered DOM elements which should be fulfilled.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "nextSize", 0);
    /**
     * Current offset.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "currentOffset", 0);
    /**
     * Next offset.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "nextOffset", 0);
  }
  /**
   * Sets new size of the rendered DOM elements.
   *
   * @param {number} size The size.
   */
  setSize(size) {
    this.currentSize = this.nextSize;
    this.nextSize = size;
  }

  /**
   * Sets new offset.
   *
   * @param {number} offset The offset.
   */
  setOffset(offset) {
    this.currentOffset = this.nextOffset;
    this.nextOffset = offset;
  }
}
exports["default"] = ViewSize;

/***/ }),
/* 574 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _view = _interopRequireDefault(__webpack_require__(570));
/**
 * Executive model for TR root nodes.
 *
 * @class {SharedOrderView}
 */
class SharedOrderView extends _view.default {
  /**
   * The method results in merging external order view into the current order. This happens only for order views which
   * operate on the same root node.
   *
   * In the table, there is only one scenario when this happens. TR root element
   * has a common root node with cells order view and row headers order view. Both classes have to share
   * information about their order sizes to make proper diff calculations.
   *
   * @param {OrderView} orderView The order view to merging with. The view will be added at the beginning of the list.
   * @returns {SharedOrderView}
   */
  prependView(orderView) {
    this.sizeSet.prepend(orderView.sizeSet);
    orderView.sizeSet.append(this.sizeSet);
    return this;
  }

  /**
   * The method results in merging external order view into the current order. This happens only for order views which
   * operate on the same root node.
   *
   * In the table, there is only one scenario when this happens. TR root element
   * has a common root node with cells order view and row headers order view. Both classes have to share
   * information about their order sizes to make proper diff calculations.
   *
   * @param {OrderView} orderView The order view to merging with. The view will be added at the end of the list.
   * @returns {SharedOrderView}
   */
  appendView(orderView) {
    this.sizeSet.append(orderView.sizeSet);
    orderView.sizeSet.prepend(this.sizeSet);
    return this;
  }
}
exports["default"] = SharedOrderView;

/***/ }),
/* 575 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _nodesPool = _interopRequireDefault(__webpack_require__(576));
/**
 * Base renderer class, abstract logic for specialized renderers.
 *
 * @class BaseRenderer
 */
class BaseRenderer {
  constructor(nodeType, rootNode) {
    /**
     * Factory for newly created DOM elements.
     *
     * NodePool should be used for each renderer. For the first stage of the refactoring
     * process, only some of the renderers are implemented a new approach.
     *
     * @type {NodesPool|null}
     */
    (0, _defineProperty2.default)(this, "nodesPool", null);
    /**
     * Node type which the renderer will manage while building the table (eg. 'TD', 'TR', 'TH').
     *
     * @type {string}
     */
    (0, _defineProperty2.default)(this, "nodeType", void 0);
    /**
     * The root node to which newly created elements will be inserted.
     *
     * @type {HTMLElement}
     */
    (0, _defineProperty2.default)(this, "rootNode", void 0);
    /**
     * The instance of the Table class, a wrapper for all renderers and holder for properties describe table state.
     *
     * @type {TableRenderer}
     */
    (0, _defineProperty2.default)(this, "table", null);
    /**
     * Counter of nodes already added.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "renderedNodes", 0);
    this.nodesPool = typeof nodeType === 'string' ? new _nodesPool.default(nodeType) : null;
    this.nodeType = nodeType;
    this.rootNode = rootNode;
  }

  /**
   * Sets the table renderer instance to the current renderer.
   *
   * @param {TableRenderer} table The TableRenderer instance.
   */
  setTable(table) {
    if (this.nodesPool) {
      this.nodesPool.setRootDocument(table.rootDocument);
    }
    this.table = table;
  }

  /**
   * Adjusts the number of rendered nodes.
   */
  adjust() {}

  /**
   * Renders the contents to the elements.
   */
  render() {}
}
exports["default"] = BaseRenderer;

/***/ }),
/* 576 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * Factory for newly created DOM elements.
 *
 * @class {NodesPool}
 */
class NodesPool {
  constructor(nodeType) {
    /**
     * Node type to generate (ew 'th', 'td').
     *
     * @type {string}
     */
    (0, _defineProperty2.default)(this, "nodeType", void 0);
    this.nodeType = nodeType.toUpperCase();
  }

  /**
   * Set document owner for this instance.
   *
   * @param {HTMLDocument} rootDocument The document window owner.
   */
  setRootDocument(rootDocument) {
    this.rootDocument = rootDocument;
  }

  /**
   * Obtains an element. The returned elements in the feature can be cached.
   *
   * @returns {HTMLElement}
   */
  obtain() {
    return this.rootDocument.createElement(this.nodeType);
  }
}
exports["default"] = NodesPool;

/***/ }),
/* 577 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _element = __webpack_require__(351);
var _base = _interopRequireDefault(__webpack_require__(575));
var _a11y = __webpack_require__(496);
/**
 * Column headers renderer responsible for managing (inserting, tracking, rendering) TR and TH elements.
 *
 *   <thead> (root node)
 *     ├ <tr>   \
 *     ├ <tr>    \
 *     ├ <tr>     - ColumnHeadersRenderer
 *     ├ <tr>    /
 *     └ <tr>   /.
 *
 * @class {ColumnHeadersRenderer}
 */
class ColumnHeadersRenderer extends _base.default {
  constructor(rootNode) {
    super(null, rootNode); // NodePool is not implemented for this renderer yet
  }

  /**
   * Adjusts the number of the rendered elements.
   */
  adjust() {
    const {
      columnHeadersCount,
      rowHeadersCount
    } = this.table;
    let TR = this.rootNode.firstChild;
    if (columnHeadersCount) {
      const {
        columnsToRender
      } = this.table;
      const allColumnsToRender = columnsToRender + rowHeadersCount;
      for (let i = 0, len = columnHeadersCount; i < len; i++) {
        TR = this.rootNode.childNodes[i];
        if (!TR) {
          TR = this.table.rootDocument.createElement('tr');
          this.rootNode.appendChild(TR);
        }
        this.renderedNodes = TR.childNodes.length;
        while (this.renderedNodes < allColumnsToRender) {
          TR.appendChild(this.table.rootDocument.createElement('th'));
          this.renderedNodes += 1;
        }
        while (this.renderedNodes > allColumnsToRender) {
          TR.removeChild(TR.lastChild);
          this.renderedNodes -= 1;
        }
      }
      const theadChildrenLength = this.rootNode.childNodes.length;
      if (theadChildrenLength > columnHeadersCount) {
        for (let i = columnHeadersCount; i < theadChildrenLength; i++) {
          this.rootNode.removeChild(this.rootNode.lastChild);
        }
      }
    } else if (TR) {
      (0, _element.empty)(TR);
    }
  }

  /**
   * Renders the TH elements.
   */
  render() {
    const {
      columnHeadersCount
    } = this.table;
    if (this.table.isAriaEnabled()) {
      (0, _element.setAttribute)(this.rootNode, [(0, _a11y.A11Y_ROWGROUP)()]);
    }
    for (let rowHeaderIndex = 0; rowHeaderIndex < columnHeadersCount; rowHeaderIndex += 1) {
      const {
        columnHeaderFunctions,
        columnsToRender,
        rowHeadersCount
      } = this.table;
      const TR = this.rootNode.childNodes[rowHeaderIndex];
      if (this.table.isAriaEnabled()) {
        (0, _element.setAttribute)(TR, [(0, _a11y.A11Y_ROW)(), (0, _a11y.A11Y_ROWINDEX)(rowHeaderIndex + 1)]);
      }
      for (let renderedColumnIndex = -1 * rowHeadersCount; renderedColumnIndex < columnsToRender; renderedColumnIndex += 1) {
        // eslint-disable-line max-len
        const sourceColumnIndex = this.table.renderedColumnToSource(renderedColumnIndex);
        const TH = TR.childNodes[renderedColumnIndex + rowHeadersCount];
        TH.className = '';
        TH.removeAttribute('style');

        // Remove all accessibility-related attributes for the header to start fresh.
        (0, _element.removeAttribute)(TH, [new RegExp('aria-(.*)'), new RegExp('role')]);
        if (this.table.isAriaEnabled()) {
          (0, _element.setAttribute)(TH, [(0, _a11y.A11Y_COLINDEX)(renderedColumnIndex + 1 + this.table.rowHeadersCount), (0, _a11y.A11Y_TABINDEX)(-1), (0, _a11y.A11Y_COLUMNHEADER)(), ...(renderedColumnIndex >= 0 ? [(0, _a11y.A11Y_SCOPE_COL)()] : [
          // Adding `role=row` to the corner headers to prevent
          // https://github.com/handsontable/dev-handsontable/issues/1574
          (0, _a11y.A11Y_ROW)()])]);
        }
        columnHeaderFunctions[rowHeaderIndex](sourceColumnIndex, TH, rowHeaderIndex);
      }
    }
  }
}
exports["default"] = ColumnHeadersRenderer;

/***/ }),
/* 578 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _base = _interopRequireDefault(__webpack_require__(575));
var _console = __webpack_require__(512);
var _templateLiteralTag = __webpack_require__(494);
var _element = __webpack_require__(351);
let performanceWarningAppeared = false;

/**
 * Colgroup renderer responsible for managing (inserting, tracking, rendering) COL elements.
 *
 *   <colgroup> (root node)
 *     ├ <col>   \
 *     ├ <col>    \
 *     ├ <col>     - ColGroupRenderer
 *     ├ <col>    /
 *     └ <col>   /.
 *
 * @class {ColGroupRenderer}
 */
class ColGroupRenderer extends _base.default {
  constructor(rootNode) {
    super(null, rootNode); // NodePool is not implemented for this renderer yet
  }

  /**
   * Adjusts the number of the rendered elements.
   */
  adjust() {
    const {
      columnsToRender,
      rowHeadersCount
    } = this.table;
    const allColumnsToRender = columnsToRender + rowHeadersCount;
    while (this.renderedNodes < allColumnsToRender) {
      this.rootNode.appendChild(this.table.rootDocument.createElement('col'));
      this.renderedNodes += 1;
    }
    while (this.renderedNodes > allColumnsToRender) {
      this.rootNode.removeChild(this.rootNode.lastChild);
      this.renderedNodes -= 1;
    }
  }

  /**
   * Renders the col group elements.
   */
  render() {
    this.adjust();
    const {
      columnsToRender,
      rowHeadersCount
    } = this.table;
    if (!performanceWarningAppeared && columnsToRender > 1000) {
      performanceWarningAppeared = true;
      (0, _console.warn)((0, _templateLiteralTag.toSingleLine)`Performance tip: Handsontable rendered more than 1000 visible columns.\x20
        Consider limiting the number of rendered columns by specifying the table width and/or\x20
        turning off the "renderAllColumns" option.`);
    }

    // Render column nodes for row headers
    for (let visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
      const sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
      const width = this.table.columnUtils.getHeaderWidth(sourceColumnIndex);
      this.rootNode.childNodes[visibleColumnIndex].style.width = `${width}px`;
    }

    // Render column nodes for cells
    for (let visibleColumnIndex = 0; visibleColumnIndex < columnsToRender; visibleColumnIndex++) {
      const sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
      const width = this.table.columnUtils.getWidth(sourceColumnIndex);
      this.rootNode.childNodes[visibleColumnIndex + rowHeadersCount].style.width = `${width}px`;
    }
    const firstChild = this.rootNode.firstChild;
    if (firstChild) {
      (0, _element.addClass)(firstChild, 'rowHeader');
    }
  }
}
exports["default"] = ColGroupRenderer;

/***/ }),
/* 579 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _base = _interopRequireDefault(__webpack_require__(575));
var _console = __webpack_require__(512);
var _templateLiteralTag = __webpack_require__(494);
var _orderView = __webpack_require__(569);
var _element = __webpack_require__(351);
var _a11y = __webpack_require__(496);
const ROW_CLASSNAMES = {
  rowEven: 'ht__row_even',
  rowOdd: 'ht__row_odd'
};
let performanceWarningAppeared = false;

/**
 * Rows renderer responsible for managing (inserting, tracking, rendering) TR elements belongs to TBODY.
 *
 *   <tbody> (root node)
 *     ├ <tr>   \
 *     ├ <tr>    \
 *     ├ <tr>     - RowsRenderer
 *     ├ <tr>    /
 *     └ <tr>   /.
 *
 * @class {RowsRenderer}
 */
class RowsRenderer extends _base.default {
  constructor(rootNode) {
    super('TR', rootNode);
    /**
     * Cache for OrderView classes connected to specified node.
     *
     * @type {WeakMap}
     */
    (0, _defineProperty2.default)(this, "orderView", void 0);
    this.orderView = new _orderView.OrderView(rootNode, sourceRowIndex => this.nodesPool.obtain(sourceRowIndex), this.nodeType);
  }

  /**
   * Returns currently rendered node.
   *
   * @param {string} visualIndex Visual index of the rendered node (it always goeas from 0 to N).
   * @returns {HTMLTableRowElement}
   */
  getRenderedNode(visualIndex) {
    return this.orderView.getNode(visualIndex);
  }

  /**
   * Renders the cells.
   */
  render() {
    const {
      rowsToRender
    } = this.table;
    if (!performanceWarningAppeared && rowsToRender > 1000) {
      performanceWarningAppeared = true;
      (0, _console.warn)((0, _templateLiteralTag.toSingleLine)`Performance tip: Handsontable rendered more than 1000 visible rows.\x20
        Consider limiting the number of rendered rows by specifying the table height and/or\x20
        turning off the "renderAllRows" option.`);
    }
    if (this.table.isAriaEnabled()) {
      (0, _element.setAttribute)(this.rootNode, [(0, _a11y.A11Y_ROWGROUP)()]);
    }
    this.orderView.setSize(rowsToRender).setOffset(this.table.renderedRowToSource(0)).start();
    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
      this.orderView.render();
      const TR = this.orderView.getCurrentNode();
      const sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
      if (this.table.isAriaEnabled()) {
        var _this$table$rowUtils$, _this$table$rowUtils;
        (0, _element.setAttribute)(TR, [(0, _a11y.A11Y_ROW)(),
        // `aria-rowindex` is incremented by both tbody and thead rows.
        (0, _a11y.A11Y_ROWINDEX)(sourceRowIndex + ((_this$table$rowUtils$ = (_this$table$rowUtils = this.table.rowUtils) === null || _this$table$rowUtils === void 0 || (_this$table$rowUtils = _this$table$rowUtils.dataAccessObject) === null || _this$table$rowUtils === void 0 ? void 0 : _this$table$rowUtils.columnHeaders.length) !== null && _this$table$rowUtils$ !== void 0 ? _this$table$rowUtils$ : 0) + 1)]);
      }
      (0, _element.removeClass)(TR, [ROW_CLASSNAMES.rowEven, ROW_CLASSNAMES.rowOdd]);
      if ((sourceRowIndex + 1) % 2 === 0) {
        (0, _element.addClass)(TR, ROW_CLASSNAMES.rowEven);
      } else {
        (0, _element.addClass)(TR, ROW_CLASSNAMES.rowOdd);
      }
    }
    this.orderView.end();
  }
}
exports["default"] = RowsRenderer;

/***/ }),
/* 580 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _orderView = __webpack_require__(569);
var _base = _interopRequireDefault(__webpack_require__(575));
var _a11y = __webpack_require__(496);
/**
 * Cell renderer responsible for managing (inserting, tracking, rendering) TD elements.
 *
 *   <tr> (root node)
 *     ├ <th>   --- RowHeadersRenderer
 *     ├ <td>   \
 *     ├ <td>    \
 *     ├ <td>     - CellsRenderer
 *     ├ <td>    /
 *     └ <td>   /.
 *
 * @class {CellsRenderer}
 */
class CellsRenderer extends _base.default {
  constructor() {
    super('TD');
    /**
     * Cache for OrderView classes connected to specified node.
     *
     * @type {WeakMap}
     */
    (0, _defineProperty2.default)(this, "orderViews", new WeakMap());
    /**
     * Row index which specifies the row position of the processed cell.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "sourceRowIndex", 0);
  }

  /**
   * Obtains the instance of the SharedOrderView class which is responsible for rendering the nodes to the root node.
   *
   * @param {HTMLTableRowElement} rootNode The TR element, which is root element for cells (TD).
   * @returns {SharedOrderView}
   */
  obtainOrderView(rootNode) {
    let orderView;
    if (this.orderViews.has(rootNode)) {
      orderView = this.orderViews.get(rootNode);
    } else {
      orderView = new _orderView.SharedOrderView(rootNode, sourceColumnIndex => this.nodesPool.obtain(this.sourceRowIndex, sourceColumnIndex), this.nodeType);
      this.orderViews.set(rootNode, orderView);
    }
    return orderView;
  }

  /**
   * Renders the cells.
   */
  render() {
    const {
      rowsToRender,
      columnsToRender,
      rows,
      rowHeaders
    } = this.table;
    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
      const sourceRowIndex = this.table.renderedRowToSource(visibleRowIndex);
      const TR = rows.getRenderedNode(visibleRowIndex);
      this.sourceRowIndex = sourceRowIndex;
      const orderView = this.obtainOrderView(TR);
      const rowHeadersView = rowHeaders.obtainOrderView(TR);

      // @TODO(perf-tip): For cells other than "visual 0" generating diff leads/commands can be skipped. New order view
      // should share state between next orderViews.
      orderView.prependView(rowHeadersView).setSize(columnsToRender).setOffset(this.table.renderedColumnToSource(0)).start();
      for (let visibleColumnIndex = 0; visibleColumnIndex < columnsToRender; visibleColumnIndex++) {
        orderView.render();
        const TD = orderView.getCurrentNode();
        const sourceColumnIndex = this.table.renderedColumnToSource(visibleColumnIndex);
        if (!(0, _element.hasClass)(TD, 'hide')) {
          // Workaround for hidden columns plugin
          TD.className = '';
        }
        TD.removeAttribute('style');
        TD.removeAttribute('dir');

        // Remove all accessibility-related attributes for the cell to start fresh.
        (0, _element.removeAttribute)(TD, [new RegExp('aria-(.*)'), new RegExp('role')]);
        this.table.cellRenderer(sourceRowIndex, sourceColumnIndex, TD);
        if (this.table.isAriaEnabled()) {
          var _this$table$rowUtils$, _this$table$rowUtils;
          (0, _element.setAttribute)(TD, [...(TD.hasAttribute('role') ? [] : [(0, _a11y.A11Y_GRIDCELL)()]), (0, _a11y.A11Y_TABINDEX)(-1),
          // `aria-colindex` is incremented by both tbody and thead rows.
          (0, _a11y.A11Y_COLINDEX)(sourceColumnIndex + ((_this$table$rowUtils$ = (_this$table$rowUtils = this.table.rowUtils) === null || _this$table$rowUtils === void 0 || (_this$table$rowUtils = _this$table$rowUtils.dataAccessObject) === null || _this$table$rowUtils === void 0 ? void 0 : _this$table$rowUtils.rowHeaders.length) !== null && _this$table$rowUtils$ !== void 0 ? _this$table$rowUtils$ : 0) + 1)]);
        }
      }
      orderView.end();
    }
  }
}
exports["default"] = CellsRenderer;

/***/ }),
/* 581 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * TableRenderer class collects all renderers and properties necessary for table creation. It's
 * responsible for adjusting and rendering each renderer.
 *
 * Below is a diagram of the renderers together with an indication of what they are responisble for.
 *   <table>
 *     <colgroup>  \ (root node)
 *       <col>      \
 *       <col>       \___ ColGroupRenderer
 *       <col>       /
 *       <col>      /
 *     </colgroup> /
 *     <thead>     \ (root node)
 *       <tr>       \
 *         <th>      \
 *         <th>       \____ ColumnHeadersRenderer
 *         <th>       /
 *         <th>      /
 *       </tr>      /
 *     </thead>    /
 *     <tbody>   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\ (root node)
 *       <tr>   (root node)          \
 *         <th>  --- RowHeadersRenderer
 *         <td>  \                     \
 *         <td>   -- CellsRenderer      \
 *         <td>  /                       \
 *       </tr>                            \
 *       <tr>   (root node)                \
 *         <th>  --- RowHeadersRenderer     \
 *         <td>  \                           \___ RowsRenderer
 *         <td>   -- CellsRenderer           /
 *         <td>  /                          /
 *       </tr>                             /
 *       <tr>   (root node)               /
 *         <th>  --- RowHeadersRenderer  /
 *         <td>  \                      /
 *         <td>   -- CellsRenderer     /
 *         <td>  /                    /
 *       </tr>                       /
 *     </tbody>  ___________________/
 *   </table>.
 *
 * @class {RowsRenderer}
 */
class TableRenderer {
  constructor(rootNode) {
    let {
      cellRenderer,
      stylesHandler
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    /**
     * Table element which will be used to render the children element.
     *
     * @type {HTMLTableElement}
     */
    (0, _defineProperty2.default)(this, "rootNode", void 0);
    /**
     * Document owner of the root node.
     *
     * @type {HTMLDocument}
     */
    (0, _defineProperty2.default)(this, "rootDocument", void 0);
    /**
     * Renderer class responsible for rendering row headers.
     *
     * @type {RowsRenderer}
     */
    (0, _defineProperty2.default)(this, "rowHeaders", null);
    /**
     * Renderer class responsible for rendering column headers.
     *
     * @type {ColumnHeadersRenderer}
     */
    (0, _defineProperty2.default)(this, "columnHeaders", null);
    /**
     * Renderer class responsible for rendering col in colgroup.
     *
     * @type {ColGroupRenderer}
     */
    (0, _defineProperty2.default)(this, "colGroup", null);
    /**
     * Renderer class responsible for rendering rows in tbody.
     *
     * @type {RowsRenderer}
     */
    (0, _defineProperty2.default)(this, "rows", null);
    /**
     * Renderer class responsible for rendering cells.
     *
     * @type {CellsRenderer}
     */
    (0, _defineProperty2.default)(this, "cells", null);
    /**
     * Row filter which contains all necessary information about row index transformation.
     *
     * @type {RowFilter}
     */
    (0, _defineProperty2.default)(this, "rowFilter", null);
    /**
     * Column filter which contains all necessary information about column index transformation.
     *
     * @type {ColumnFilter}
     */
    (0, _defineProperty2.default)(this, "columnFilter", null);
    /**
     * Row utils class which contains all necessary information about sizes of the rows.
     *
     * @type {RowUtils}
     */
    (0, _defineProperty2.default)(this, "rowUtils", null);
    /**
     * Column utils class which contains all necessary information about sizes of the columns.
     *
     * @type {ColumnUtils}
     */
    (0, _defineProperty2.default)(this, "columnUtils", null);
    /**
     * Indicates how much rows should be rendered to fill whole table viewport.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "rowsToRender", 0);
    /**
     * Indicates how much columns should be rendered to fill whole table viewport.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "columnsToRender", 0);
    /**
     * An array of functions to be used as a content factory to row headers.
     *
     * @type {Function[]}
     */
    (0, _defineProperty2.default)(this, "rowHeaderFunctions", []);
    /**
     * Count of the function used to render row headers.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "rowHeadersCount", 0);
    /**
     * An array of functions to be used as a content factory to column headers.
     *
     * @type {Function[]}
     */
    (0, _defineProperty2.default)(this, "columnHeaderFunctions", []);
    /**
     * Count of the function used to render column headers.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "columnHeadersCount", 0);
    /**
     * Cell renderer used to render cells content.
     *
     * @type {Function}
     */
    (0, _defineProperty2.default)(this, "cellRenderer", void 0);
    /**
     * Holds the name of the currently active overlay.
     *
     * @type {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'|'master'}
     */
    (0, _defineProperty2.default)(this, "activeOverlayName", void 0);
    /**
     * Styles handler instance.
     */
    (0, _defineProperty2.default)(this, "stylesHandler", void 0);
    this.rootNode = rootNode;
    this.rootDocument = this.rootNode.ownerDocument;
    this.cellRenderer = cellRenderer;
    this.stylesHandler = stylesHandler;
  }

  /**
   * Sets the overlay that is currently rendered. If `null` is provided, the master overlay is set.
   *
   * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'|'master'} overlayName The overlay name.
   */
  setActiveOverlayName(overlayName) {
    this.activeOverlayName = overlayName;
  }

  /**
   * Set row and column util classes.
   *
   * @param {RowUtils} rowUtils RowUtils instance which provides useful methods related to row sizes.
   * @param {ColumnUtils} columnUtils ColumnUtils instance which provides useful methods related to row sizes.
   */
  setAxisUtils(rowUtils, columnUtils) {
    this.rowUtils = rowUtils;
    this.columnUtils = columnUtils;
  }

  /**
   * Sets viewport size of the table.
   *
   * @param {number} rowsCount An amount of rows to render.
   * @param {number} columnsCount An amount of columns to render.
   */
  setViewportSize(rowsCount, columnsCount) {
    this.rowsToRender = rowsCount;
    this.columnsToRender = columnsCount;
  }

  /**
   * Sets row and column filter instances.
   *
   * @param {RowFilter} rowFilter Row filter instance which contains all necessary information about row index transformation.
   * @param {ColumnFilter} columnFilter Column filter instance which contains all necessary information about row
   * index transformation.
   */
  setFilters(rowFilter, columnFilter) {
    this.rowFilter = rowFilter;
    this.columnFilter = columnFilter;
  }

  /**
   * Sets row and column header functions.
   *
   * @param {Function[]} rowHeaders Row header functions. Factories for creating content for row headers.
   * @param {Function[]} columnHeaders Column header functions. Factories for creating content for column headers.
   */
  setHeaderContentRenderers(rowHeaders, columnHeaders) {
    this.rowHeaderFunctions = rowHeaders;
    this.rowHeadersCount = rowHeaders.length;
    this.columnHeaderFunctions = columnHeaders;
    this.columnHeadersCount = columnHeaders.length;
  }

  /**
   * Sets table renderers.
   *
   * @param {renderers} renderers The renderer units.
   * @param {RowHeadersRenderer} renderers.rowHeaders Row headers renderer.
   * @param {ColumnHeadersRenderer} renderers.columnHeaders Column headers renderer.
   * @param {ColGroupRenderer} renderers.colGroup Col group renderer.
   * @param {RowsRenderer} renderers.rows Rows renderer.
   * @param {CellsRenderer} renderers.cells Cells renderer.
   */
  setRenderers() {
    let {
      rowHeaders,
      columnHeaders,
      colGroup,
      rows,
      cells
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    rowHeaders.setTable(this);
    columnHeaders.setTable(this);
    colGroup.setTable(this);
    rows.setTable(this);
    cells.setTable(this);
    this.rowHeaders = rowHeaders;
    this.columnHeaders = columnHeaders;
    this.colGroup = colGroup;
    this.rows = rows;
    this.cells = cells;
  }

  /**
   * Transforms visual/rendered row index to source index.
   *
   * @param {number} rowIndex Rendered index.
   * @returns {number}
   */
  renderedRowToSource(rowIndex) {
    return this.rowFilter.renderedToSource(rowIndex);
  }

  /**
   * Transforms visual/rendered column index to source index.
   *
   * @param {number} columnIndex Rendered index.
   * @returns {number}
   */
  renderedColumnToSource(columnIndex) {
    return this.columnFilter.renderedToSource(columnIndex);
  }

  /**
   * Returns `true` if the accessibility-related ARIA tags should be added to the table, `false` otherwise.
   *
   * @returns {boolean}
   */
  isAriaEnabled() {
    return this.rowUtils.wtSettings.getSetting('ariaTags');
  }

  /**
   * Renders the table.
   */
  render() {
    this.colGroup.adjust();
    this.columnHeaders.adjust();
    this.rows.adjust();
    this.rowHeaders.adjust();
    this.columnHeaders.render();
    this.rows.render();
    this.rowHeaders.render();
    this.cells.render();

    // After the cells are rendered calculate columns width to prepare proper values
    // for colGroup renderer (which renders COL elements).
    this.columnUtils.calculateWidths();
    this.colGroup.render();
    const {
      rowsToRender,
      rows
    } = this;

    // Fix for multi-line content and for supporting `rowHeights` option.
    for (let visibleRowIndex = 0; visibleRowIndex < rowsToRender; visibleRowIndex++) {
      const TR = rows.getRenderedNode(visibleRowIndex);
      const rowUtils = this.rowUtils;
      if (TR.firstChild) {
        const sourceRowIndex = this.renderedRowToSource(visibleRowIndex);
        const rowHeight = rowUtils.getHeightByOverlayName(sourceRowIndex, this.activeOverlayName);
        const isBorderBoxSizing = this.stylesHandler.areCellsBorderBox();
        const borderCompensation = isBorderBoxSizing ? 0 : 1;
        if (rowHeight) {
          // Decrease height. 1 pixel will be "replaced" by 1px border top
          TR.firstChild.style.height = `${rowHeight - borderCompensation}px`;
        } else {
          TR.firstChild.style.height = '';
        }
      }
    }
  }
}
exports["default"] = TableRenderer;

/***/ }),
/* 582 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * Column utils class contains all necessary information about sizes of the columns.
 *
 * @class {ColumnUtils}
 */
class ColumnUtils {
  /**
   * @param {TableDao} dataAccessObject The table Data Access Object.
   * @param {Settings} wtSettings The walkontable settings.
   */
  constructor(dataAccessObject, wtSettings) {
    /**
     * @type {TableDao}
     */
    (0, _defineProperty2.default)(this, "dataAccessObject", void 0);
    /**
     * @type {Settings}
     */
    (0, _defineProperty2.default)(this, "wtSettings", void 0);
    /**
     * @type {Map<number, number>}
     */
    (0, _defineProperty2.default)(this, "headerWidths", new Map());
    this.dataAccessObject = dataAccessObject;
    this.wtSettings = wtSettings;
  }

  /**
   * Returns column width based on passed source index.
   *
   * @param {number} sourceIndex Column source index.
   * @returns {number}
   */
  getWidth(sourceIndex) {
    const width = this.wtSettings.getSetting('columnWidth', sourceIndex) || this.wtSettings.getSetting('defaultColumnWidth');
    return width;
  }

  /**
   * Returns column header height based on passed header level.
   *
   * @param {number} level Column header level.
   * @returns {number}
   */
  getHeaderHeight(level) {
    let height = this.dataAccessObject.stylesHandler.getDefaultRowHeight();
    const oversizedHeight = this.dataAccessObject.wtViewport.oversizedColumnHeaders[level];
    if (oversizedHeight !== undefined) {
      height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
    }
    return height;
  }

  /**
   * Returns column header width based on passed source index.
   *
   * @param {number} sourceIndex Column source index.
   * @returns {number}
   */
  getHeaderWidth(sourceIndex) {
    return this.headerWidths.get(this.dataAccessObject.wtTable.columnFilter.sourceToRendered(sourceIndex));
  }

  /**
   * Calculates column header widths that can be retrieved from the cache.
   */
  calculateWidths() {
    const {
      wtSettings
    } = this;
    let rowHeaderWidthSetting = wtSettings.getSetting('rowHeaderWidth');
    rowHeaderWidthSetting = wtSettings.getSetting('onModifyRowHeaderWidth', rowHeaderWidthSetting);
    if (rowHeaderWidthSetting !== null && rowHeaderWidthSetting !== undefined) {
      const rowHeadersCount = wtSettings.getSetting('rowHeaders').length;
      const defaultColumnWidth = wtSettings.getSetting('defaultColumnWidth');
      for (let visibleColumnIndex = 0; visibleColumnIndex < rowHeadersCount; visibleColumnIndex++) {
        let width = Array.isArray(rowHeaderWidthSetting) ? rowHeaderWidthSetting[visibleColumnIndex] : rowHeaderWidthSetting;
        width = width === null || width === undefined ? defaultColumnWidth : width;
        this.headerWidths.set(visibleColumnIndex, width);
      }
    }
  }
}
exports["default"] = ColumnUtils;

/***/ }),
/* 583 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * Row utils class contains all necessary information about sizes of the rows.
 *
 * @class {RowUtils}
 */
class RowUtils {
  /**
   * @param {TableDao} dataAccessObject The table Data Access Object.
   * @param {Settings} wtSettings The walkontable settings.
   */
  constructor(dataAccessObject, wtSettings) {
    /**
     * @type {TableDao}
     */
    (0, _defineProperty2.default)(this, "dataAccessObject", void 0);
    /**
     * @type {Settings}
     */
    (0, _defineProperty2.default)(this, "wtSettings", void 0);
    this.dataAccessObject = dataAccessObject;
    this.wtSettings = wtSettings;
  }

  /**
   * Returns row height based on passed source index.
   *
   * @param {number} sourceIndex Row source index.
   * @returns {number}
   */
  getHeight(sourceIndex) {
    let height = this.wtSettings.getSetting('rowHeight', sourceIndex);
    const oversizedHeight = this.dataAccessObject.wtViewport.oversizedRows[sourceIndex];
    if (oversizedHeight !== undefined) {
      height = height === undefined ? oversizedHeight : Math.max(height, oversizedHeight);
    }
    return height;
  }

  /**
   * Returns row height based on passed source index for the specified overlay type.
   *
   * @param {number} sourceIndex Row source index.
   * @param {'inline_start'|'top'|'top_inline_start_corner'|'bottom'|'bottom_inline_start_corner'|'master'} overlayName The overlay name.
   * @returns {number}
   */
  getHeightByOverlayName(sourceIndex, overlayName) {
    let height = this.wtSettings.getSetting('rowHeightByOverlayName', sourceIndex, overlayName);
    const oversizedHeight = this.dataAccessObject.wtViewport.oversizedRows[sourceIndex];
    if (oversizedHeight !== undefined) {
      height = height === undefined ? oversizedHeight : Math.max(height, oversizedHeight);
    }
    return height;
  }
}
exports["default"] = RowUtils;

/***/ }),
/* 584 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _object = __webpack_require__(499);
const MIXIN_NAME = 'stickyRowsBottom';

/**
 * Mixin for the subclasses of `Table` with implementations of
 * helper methods that are related to rows.
 * This mixin is meant to be applied in the subclasses of `Table`
 * that use sticky rendering of the bottom rows in the vertical axis.
 *
 * @type {object}
 */
const stickyRowsBottom = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow() {
    const totalRows = this.wtSettings.getSetting('totalRows');
    const fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');
    const index = totalRows - fixedRowsBottom;
    if (totalRows === 0 || fixedRowsBottom === 0) {
      return -1;
    }
    if (index < 0) {
      return 0;
    }
    return index;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow() {
    return this.getFirstRenderedRow();
  },
  /**
   * Get the source index of the first row partially visible in the viewport. If no rows are partially visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstPartiallyVisibleRow() {
    return this.getFirstRenderedRow();
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow() {
    return this.wtSettings.getSetting('totalRows') - 1;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow() {
    return this.getLastRenderedRow();
  },
  /**
   * Get the source index of the last row partially visible in the viewport. If no rows are partially visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastPartiallyVisibleRow() {
    return this.getLastRenderedRow();
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount() {
    const totalRows = this.wtSettings.getSetting('totalRows');
    return Math.min(this.wtSettings.getSetting('fixedRowsBottom'), totalRows);
  },
  /**
   * Get the number of fully visible rows in the viewport.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount() {
    return this.getRenderedRowsCount();
  },
  /**
   * Get the number of rendered column headers.
   *
   * @returns {number}
   * @this Table
   */
  getColumnHeadersCount() {
    return 0;
  }
};
(0, _object.defineGetter)(stickyRowsBottom, 'MIXIN_NAME', MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var _default = exports["default"] = stickyRowsBottom;

/***/ }),
/* 585 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _object = __webpack_require__(499);
const MIXIN_NAME = 'stickyColumnsStart';

/**
 * Mixin for the subclasses of `Table` with implementations of
 * helper methods that are related to columns.
 * This mixin is meant to be applied in the subclasses of `Table`
 * that use sticky rendering of the first columns in the horizontal axis.
 *
 * @type {object}
 */
const stickyColumnsStart = {
  /**
   * Get the source index of the first rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedColumn() {
    const totalColumns = this.wtSettings.getSetting('totalColumns');
    if (totalColumns === 0) {
      return -1;
    }
    return 0;
  },
  /**
   * Get the source index of the first column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleColumn() {
    return this.getFirstRenderedColumn();
  },
  /**
   * Get the source index of the first column partially visible in the viewport. If no columns are partially visible, returns an error code: -1.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstPartiallyVisibleColumn() {
    return this.getFirstRenderedColumn();
  },
  /**
   * Get the source index of the last rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedColumn() {
    return this.getRenderedColumnsCount() - 1;
  },
  /**
   * Get the source index of the last column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleColumn() {
    return this.getLastRenderedColumn();
  },
  /**
   * Get the source index of the last column partially visible in the viewport. If no columns are partially visible, returns an error code: -1.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastPartiallyVisibleColumn() {
    return this.getLastRenderedColumn();
  },
  /**
   * Get the number of rendered columns.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedColumnsCount() {
    const totalColumns = this.wtSettings.getSetting('totalColumns');
    return Math.min(this.wtSettings.getSetting('fixedColumnsStart'), totalColumns);
  },
  /**
   * Get the number of fully visible columns in the viewport.
   * Assumes that all rendered columns are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleColumnsCount() {
    return this.getRenderedColumnsCount();
  },
  /**
   * Get the number of rendered row headers.
   *
   * @returns {number}
   * @this Table
   */
  getRowHeadersCount() {
    return this.dataAccessObject.rowHeaders.length;
  }
};
(0, _object.defineGetter)(stickyColumnsStart, 'MIXIN_NAME', MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var _default = exports["default"] = stickyColumnsStart;

/***/ }),
/* 586 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(311);
__webpack_require__(329);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _object = __webpack_require__(499);
var _console = __webpack_require__(512);
var _constants = __webpack_require__(587);
var _clone = _interopRequireDefault(__webpack_require__(588));
var _a11y = __webpack_require__(496);
/**
 * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable
 * and (optionally) implements behavior needed for native horizontal and vertical scrolling.
 *
 * @abstract
 * @class Overlay
 * @property {Walkontable} wot The Walkontable instance.
 */
class Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {CLONE_TYPES_ENUM} type The overlay type name (clone name).
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   */
  constructor(wotInstance, facadeGetter, type, wtSettings, domBindings) {
    /**
     *  The Walkontable settings.
     *
     * @private
     * @type {Settings}
     */
    (0, _defineProperty2.default)(this, "wtSettings", null);
    (0, _object.defineGetter)(this, 'wot', wotInstance, {
      writable: false
    });
    this.domBindings = domBindings;
    this.facadeGetter = facadeGetter;
    this.wtSettings = wtSettings;
    const {
      TABLE,
      hider,
      spreader,
      holder,
      wtRootElement
    } = this.wot.wtTable; // todo ioc

    // legacy support, deprecated in the future
    this.instance = this.wot;
    this.type = type;
    this.mainTableScrollableElement = null;
    this.TABLE = TABLE;
    this.hider = hider;
    this.spreader = spreader;
    this.holder = holder;
    this.wtRootElement = wtRootElement;
    this.trimmingContainer = (0, _element.getTrimmingContainer)(this.hider.parentNode.parentNode);
    this.needFullRender = this.shouldBeRendered();
    this.clone = this.makeClone();
  }

  /**
   * Checks if the overlay rendering state has changed.
   *
   * @returns {boolean}
   */
  hasRenderingStateChanged() {
    return this.needFullRender !== this.shouldBeRendered();
  }

  /**
   * Updates internal state with an information about the need of full rendering of the overlay in the next draw cycles.
   *
   * If the state is changed to render the overlay, the `needFullRender` property is set to `true` which means that
   * the overlay will be fully rendered in the current draw cycle. If the state is changed to not render the overlay,
   * the `needFullRender` property is set to `false` which means that the overlay will be fully rendered in the
   * current draw cycle but it will not be rendered in the next draw cycles.
   *
   * @param {'before' | 'after'} drawPhase The phase of the rendering process.
   */
  updateStateOfRendering(drawPhase) {
    if (drawPhase === 'before' && this.shouldBeRendered()) {
      this.needFullRender = true;
    } else if (drawPhase === 'after' && !this.shouldBeRendered()) {
      this.needFullRender = false;
    }
  }

  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return true;
  }

  /**
   * Update the trimming container.
   */
  updateTrimmingContainer() {
    this.trimmingContainer = (0, _element.getTrimmingContainer)(this.hider.parentNode.parentNode);
  }

  /**
   * Update the main scrollable element.
   */
  updateMainScrollableElement() {
    const {
      wtTable
    } = this.wot;
    const {
      rootWindow
    } = this.domBindings;
    if (rootWindow.getComputedStyle(wtTable.wtRootElement.parentNode).getPropertyValue('overflow') === 'hidden') {
      this.mainTableScrollableElement = this.wot.wtTable.holder;
    } else {
      this.mainTableScrollableElement = (0, _element.getScrollableElement)(wtTable.TABLE);
    }
  }

  /**
   * Calculates coordinates of the provided element, relative to the root Handsontable element.
   * NOTE: The element needs to be a child of the overlay in order for the method to work correctly.
   *
   * @param {HTMLElement} element The cell element to calculate the position for.
   * @param {number} rowIndex Visual row index.
   * @param {number} columnIndex Visual column index.
   * @returns {{top: number, start: number}|undefined}
   */
  getRelativeCellPosition(element, rowIndex, columnIndex) {
    if (this.clone.wtTable.holder.contains(element) === false) {
      (0, _console.warn)(`The provided element is not a child of the ${this.type} overlay`);
      return;
    }
    const windowScroll = this.mainTableScrollableElement === this.domBindings.rootWindow;
    const fixedColumnStart = columnIndex < this.wtSettings.getSetting('fixedColumnsStart');
    const fixedRowTop = rowIndex < this.wtSettings.getSetting('fixedRowsTop');
    const fixedRowBottom = rowIndex >= this.wtSettings.getSetting('totalRows') - this.wtSettings.getSetting('fixedRowsBottom');
    const spreader = this.clone.wtTable.spreader;
    const spreaderOffset = {
      start: this.getRelativeStartPosition(spreader),
      top: spreader.offsetTop
    };
    const elementOffset = {
      start: this.getRelativeStartPosition(element),
      top: element.offsetTop
    };
    let offsetObject = null;
    if (windowScroll) {
      offsetObject = this.getRelativeCellPositionWithinWindow(fixedRowTop, fixedColumnStart, elementOffset, spreaderOffset);
    } else {
      offsetObject = this.getRelativeCellPositionWithinHolder(fixedRowTop, fixedRowBottom, fixedColumnStart, elementOffset, spreaderOffset);
    }
    return offsetObject;
  }

  /**
   * Get inline start value depending of direction.
   *
   * @param {HTMLElement} el Element.
   * @returns {number}
   */
  getRelativeStartPosition(el) {
    return this.isRtl() ? el.offsetParent.offsetWidth - el.offsetLeft - el.offsetWidth : el.offsetLeft;
  }

  /**
   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window
   * as a scrollable element.
   *
   * @private
   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.
   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.
   * @param {number} elementOffset Offset position of the cell element.
   * @param {number} spreaderOffset Offset position of the spreader element.
   * @returns {{top: number, left: number}}
   */
  getRelativeCellPositionWithinWindow(onFixedRowTop, onFixedColumn, elementOffset, spreaderOffset) {
    const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER
    let horizontalOffset = 0;
    let verticalOffset = 0;
    if (!onFixedColumn) {
      horizontalOffset = spreaderOffset.start;
    } else {
      let absoluteRootElementStartPosition = absoluteRootElementPosition.left;
      if (this.isRtl()) {
        absoluteRootElementStartPosition = this.domBindings.rootWindow.innerWidth - (absoluteRootElementPosition.left + absoluteRootElementPosition.width + (0, _element.getScrollbarWidth)());
      }
      horizontalOffset = absoluteRootElementStartPosition <= 0 ? -1 * absoluteRootElementStartPosition : 0;
    }
    if (onFixedRowTop) {
      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect();
      verticalOffset = absoluteOverlayPosition.top - absoluteRootElementPosition.top;
    } else {
      verticalOffset = spreaderOffset.top;
    }
    return {
      start: elementOffset.start + horizontalOffset,
      top: elementOffset.top + verticalOffset
    };
  }

  /**
   * Calculates coordinates of the provided element, relative to the root Handsontable element within a table with window
   * as a scrollable element.
   *
   * @private
   * @param {boolean} onFixedRowTop `true` if the coordinates point to a place within the top fixed rows.
   * @param {boolean} onFixedRowBottom `true` if the coordinates point to a place within the bottom fixed rows.
   * @param {boolean} onFixedColumn `true` if the coordinates point to a place within the fixed columns.
   * @param {number} elementOffset Offset position of the cell element.
   * @param {number} spreaderOffset Offset position of the spreader element.
   * @returns {{top: number, left: number}}
   */
  getRelativeCellPositionWithinHolder(onFixedRowTop, onFixedRowBottom, onFixedColumn, elementOffset, spreaderOffset) {
    const tableScrollPosition = {
      horizontal: this.wot.wtOverlays.inlineStartOverlay.getScrollPosition(),
      vertical: this.wot.wtOverlays.topOverlay.getScrollPosition()
    };
    let horizontalOffset = 0;
    let verticalOffset = 0;
    if (!onFixedColumn) {
      horizontalOffset = tableScrollPosition.horizontal - spreaderOffset.start;
    }
    if (onFixedRowBottom) {
      const absoluteRootElementPosition = this.wot.wtTable.wtRootElement.getBoundingClientRect(); // todo refactoring: DEMETER
      const absoluteOverlayPosition = this.clone.wtTable.TABLE.getBoundingClientRect(); // todo refactoring: DEMETER

      verticalOffset = absoluteOverlayPosition.top * -1 + absoluteRootElementPosition.top;
    } else if (!onFixedRowTop) {
      verticalOffset = tableScrollPosition.vertical - spreaderOffset.top;
    }
    return {
      start: elementOffset.start - horizontalOffset,
      top: elementOffset.top - verticalOffset
    };
  }

  /**
   * Make a clone of table for overlay.
   *
   * @returns {Clone}
   */
  makeClone() {
    if (_constants.CLONE_TYPES.indexOf(this.type) === -1) {
      throw new Error(`Clone type "${this.type}" is not supported.`);
    }
    const {
      wtTable,
      wtSettings
    } = this.wot;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const clone = rootDocument.createElement('div');
    const clonedTable = rootDocument.createElement('table');
    const tableParent = wtTable.wtRootElement.parentNode;
    clone.className = `${_constants.CLONE_CLASS_NAMES.get(this.type)} handsontable`;
    clone.setAttribute('dir', this.isRtl() ? 'rtl' : 'ltr');
    clone.style.position = 'absolute';
    clone.style.top = 0;
    clone.style.overflow = 'visible';
    if (this.isRtl()) {
      clone.style.right = 0;
    } else {
      clone.style.left = 0;
    }
    if (wtSettings.getSetting('ariaTags')) {
      (0, _element.setAttribute)(clone, [(0, _a11y.A11Y_PRESENTATION)()]);
    }
    clonedTable.className = wtTable.TABLE.className;

    // Clone the main table's `role` attribute to the cloned table.
    const mainTableRole = wtTable.TABLE.getAttribute('role');
    if (mainTableRole) {
      clonedTable.setAttribute('role', wtTable.TABLE.getAttribute('role'));
    }
    clone.appendChild(clonedTable);
    tableParent.appendChild(clone);
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    if (preventOverflow === true || preventOverflow === 'horizontal' && this.type === _constants.CLONE_TOP || preventOverflow === 'vertical' && this.type === _constants.CLONE_INLINE_START) {
      this.mainTableScrollableElement = rootWindow;
    } else if (rootWindow.getComputedStyle(tableParent).getPropertyValue('overflow') === 'hidden') {
      this.mainTableScrollableElement = wtTable.holder;
    } else {
      this.mainTableScrollableElement = (0, _element.getScrollableElement)(wtTable.TABLE);
    }

    // Create a new instance of the Walkontable class
    return new _clone.default(clonedTable, this.wtSettings, {
      // todo ioc factory
      source: this.wot,
      overlay: this,
      viewport: this.wot.wtViewport,
      // todo ioc , or factor func if used only here
      event: this.wot.wtEvent,
      // todo ioc , or factory func if used only here
      selectionManager: this.wot.selectionManager,
      // todo ioc , or factory func if used only here
      stylesHandler: this.wot.stylesHandler
    });
  }

  /**
   * Refresh/Redraw overlay.
   *
   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
   *                                   the data. It will only work if Table.draw() does not force
   *                                   rendering anyway.
   */
  refresh() {
    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (this.needFullRender) {
      const cloneSource = this.clone.cloneSource;
      cloneSource.activeOverlayName = this.clone.wtTable.name;
      this.clone.draw(fastDraw);
      cloneSource.activeOverlayName = 'master';
    }
  }

  /**
   * Reset overlay styles to initial values.
   */
  reset() {
    const holder = this.clone.wtTable.holder; // todo refactoring: DEMETER
    const hider = this.clone.wtTable.hider; // todo refactoring: DEMETER
    const holderStyle = holder.style;
    const hiderStyle = hider.style;
    const rootStyle = holder.parentNode.style;
    [holderStyle, hiderStyle, rootStyle].forEach(style => {
      style.width = '';
      style.height = '';
    });
  }

  /**
   * Determine if Walkontable is running in RTL mode.
   *
   * @returns {boolean}
   */
  isRtl() {
    return this.wtSettings.getSetting('rtlMode');
  }

  /**
   * Destroy overlay instance.
   */
  destroy() {
    this.clone.eventManager.destroy(); // todo check if it is good place for that operation
  }
}
exports.Overlay = Overlay;

/***/ }),
/* 587 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
/**
 * @typedef {'top'|'bottom'|'inline_start'|'top_inline_start_corner'|'bottom_inline_start_corner'} CLONE_TYPES_ENUM
 */
const CLONE_TOP = exports.CLONE_TOP = 'top';
const CLONE_BOTTOM = exports.CLONE_BOTTOM = 'bottom';
const CLONE_INLINE_START = exports.CLONE_INLINE_START = 'inline_start';
const CLONE_TOP_INLINE_START_CORNER = exports.CLONE_TOP_INLINE_START_CORNER = 'top_inline_start_corner';
const CLONE_BOTTOM_INLINE_START_CORNER = exports.CLONE_BOTTOM_INLINE_START_CORNER = 'bottom_inline_start_corner';
const CLONE_TYPES = exports.CLONE_TYPES = [CLONE_TOP, CLONE_BOTTOM, CLONE_INLINE_START, CLONE_TOP_INLINE_START_CORNER, CLONE_BOTTOM_INLINE_START_CORNER];
const CLONE_CLASS_NAMES = exports.CLONE_CLASS_NAMES = new Map([[CLONE_TOP, `ht_clone_${CLONE_TOP}`], [CLONE_BOTTOM, `ht_clone_${CLONE_BOTTOM}`], [CLONE_INLINE_START, `ht_clone_${CLONE_INLINE_START} ht_clone_left`], [CLONE_TOP_INLINE_START_CORNER, `ht_clone_${CLONE_TOP_INLINE_START_CORNER} ht_clone_top_left_corner`], [CLONE_BOTTOM_INLINE_START_CORNER, `ht_clone_${CLONE_BOTTOM_INLINE_START_CORNER} ht_clone_bottom_left_corner`]]);

/***/ }),
/* 588 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _event = _interopRequireDefault(__webpack_require__(559));
var _base = _interopRequireDefault(__webpack_require__(589));
/**
 * @class Walkontable
 */
class Clone extends _base.default {
  /**
   * @param {HTMLTableElement} table Main table.
   * @param {SettingsPure|Settings} settings The Walkontable settings.
   * @param {WalkontableCloneOptions} clone Clone data.
   */
  constructor(table, settings, clone) {
    super(table, settings);
    /**
     * @type {Walkontable}
     */
    (0, _defineProperty2.default)(this, "cloneSource", void 0);
    /**
     * @type {Overlay}
     */
    (0, _defineProperty2.default)(this, "cloneOverlay", void 0);
    const facadeGetter = this.wtSettings.getSetting('facade', this);
    this.cloneSource = clone.source;
    this.cloneOverlay = clone.overlay;
    this.stylesHandler = clone.stylesHandler;
    this.wtTable = this.cloneOverlay.createTable(this.getTableDao(), facadeGetter, this.domBindings, this.wtSettings);
    this.wtViewport = clone.viewport;
    this.selectionManager = clone.selectionManager;
    this.wtEvent = new _event.default(facadeGetter, this.domBindings, this.wtSettings, this.eventManager, this.wtTable, this.selectionManager, clone.event);
    this.findOriginalHeaders();
  }
}
exports["default"] = Clone;

/***/ }),
/* 589 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _string = __webpack_require__(352);
var _eventManager = _interopRequireDefault(__webpack_require__(522));
var _scroll = _interopRequireDefault(__webpack_require__(590));
var _coords = _interopRequireDefault(__webpack_require__(555));
var _range = _interopRequireDefault(__webpack_require__(556));
/**
 * @abstract
 * @class Walkontable
 */
class CoreAbstract {
  get eventManager() {
    return new _eventManager.default(this);
  }

  /**
   * @param {HTMLTableElement} table Main table.
   * @param {Settings} settings The Walkontable settings.
   */
  constructor(table, settings) {
    (0, _defineProperty2.default)(this, "wtTable", void 0);
    (0, _defineProperty2.default)(this, "wtScroll", void 0);
    (0, _defineProperty2.default)(this, "wtViewport", void 0);
    (0, _defineProperty2.default)(this, "wtOverlays", void 0);
    (0, _defineProperty2.default)(this, "selectionManager", void 0);
    (0, _defineProperty2.default)(this, "wtEvent", void 0);
    /**
     * The walkontable instance id.
     *
     * @public
     * @type {Readonly<string>}
     */
    (0, _defineProperty2.default)(this, "guid", `wt_${(0, _string.randomString)()}`);
    (0, _defineProperty2.default)(this, "drawInterrupted", false);
    (0, _defineProperty2.default)(this, "drawn", false);
    /**
     * The name of the overlay that currently renders the table.
     *
     * @public
     * @type {string}
     */
    (0, _defineProperty2.default)(this, "activeOverlayName", 'master');
    /**
     * The DOM bindings.
     *
     * @public
     * @type {DomBindings}
     */
    (0, _defineProperty2.default)(this, "domBindings", void 0);
    /**
     * Settings.
     *
     * @public
     * @type {Settings}
     */
    (0, _defineProperty2.default)(this, "wtSettings", void 0);
    this.domBindings = {
      rootTable: table,
      rootDocument: table.ownerDocument,
      rootWindow: table.ownerDocument.defaultView
    };
    this.wtSettings = settings;
    this.wtScroll = new _scroll.default(this.createScrollDao());
  }
  findOriginalHeaders() {
    const originalHeaders = [];

    // find original headers
    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
      for (let c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
      }
      if (!this.wtSettings.getSetting('columnHeaders').length) {
        this.wtSettings.update('columnHeaders', [function (column, TH) {
          (0, _element.fastInnerText)(TH, originalHeaders[column]);
        }]);
      }
    }
  }

  /**
   * Creates and returns the CellCoords object.
   *
   * @param {*} row The row index.
   * @param {*} column The column index.
   * @returns {CellCoords}
   */
  createCellCoords(row, column) {
    return new _coords.default(row, column, this.wtSettings.getSetting('rtlMode'));
  }

  /**
   * Creates and returns the CellRange object.
   *
   * @param {CellCoords} highlight The highlight coordinates.
   * @param {CellCoords} from The from coordinates.
   * @param {CellCoords} to The to coordinates.
   * @returns {CellRange}
   */
  createCellRange(highlight, from, to) {
    return new _range.default(highlight, from, to, this.wtSettings.getSetting('rtlMode'));
  }

  /**
   * Force rerender of Walkontable.
   *
   * @param {boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
   *                                   the data. It will only work if Table.draw() does not force
   *                                   rendering anyway.
   * @returns {Walkontable}
   */
  draw() {
    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.drawInterrupted = false;
    if (!this.wtTable.isVisible()) {
      // draw interrupted because TABLE is not visible
      this.drawInterrupted = true;
    } else {
      this.wtTable.draw(fastDraw);
    }
    return this;
  }

  /**
   * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,
   * if not set or set to false, returns TD from the master table.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @param {boolean} [topmost=false] If set to `true`, it returns the TD element from the topmost overlay. For example,
   *                                  if the wanted cell is in the range of fixed rows, it will return a TD element
   *                                  from the top overlay.
   * @returns {HTMLElement}
   */
  getCell(coords) {
    let topmost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (!topmost) {
      return this.wtTable.getCell(coords);
    }
    const totalRows = this.wtSettings.getSetting('totalRows');
    const fixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');
    const fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');
    const fixedColumnsStart = this.wtSettings.getSetting('fixedColumnsStart');
    if (coords.row < fixedRowsTop && coords.col < fixedColumnsStart) {
      return this.wtOverlays.topInlineStartCornerOverlay.clone.wtTable.getCell(coords);
    } else if (coords.row < fixedRowsTop) {
      return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);
    } else if (coords.col < fixedColumnsStart && coords.row >= totalRows - fixedRowsBottom) {
      if (this.wtOverlays.bottomInlineStartCornerOverlay && this.wtOverlays.bottomInlineStartCornerOverlay.clone) {
        return this.wtOverlays.bottomInlineStartCornerOverlay.clone.wtTable.getCell(coords);
      }
    } else if (coords.col < fixedColumnsStart) {
      return this.wtOverlays.inlineStartOverlay.clone.wtTable.getCell(coords);
    } else if (coords.row < totalRows && coords.row >= totalRows - fixedRowsBottom) {
      if (this.wtOverlays.bottomOverlay && this.wtOverlays.bottomOverlay.clone) {
        return this.wtOverlays.bottomOverlay.clone.wtTable.getCell(coords);
      }
    }
    return this.wtTable.getCell(coords);
  }

  /**
   * Scrolls the viewport to a cell (rerenders if needed).
   *
   * @param {CellCoords} coords The cell coordinates to scroll to.
   * @param {'auto' | 'start' | 'end'} [horizontalSnap='auto'] If `'start'`, viewport is scrolled to show
   * the cell on the left of the table. If `'end'`, viewport is scrolled to show the cell on the right of
   * the table. When `'auto'`, the viewport is scrolled only when the column is outside of the viewport.
   * @param {'auto' | 'top' | 'bottom'} [verticalSnap='auto'] If `'top'`, viewport is scrolled to show
   * the cell on the top of the table. If `'bottom'`, viewport is scrolled to show the cell on the bottom of
   * the table. When `'auto'`, the viewport is scrolled only when the row is outside of the viewport.
   * @returns {boolean}
   */
  scrollViewport(coords, horizontalSnap, verticalSnap) {
    return this.wtScroll.scrollViewport(coords, horizontalSnap, verticalSnap);
  }

  /**
   * Scrolls the viewport to a column (rerenders if needed).
   *
   * @param {number} column Visual column index.
   * @param {'auto' | 'start' | 'end'} [snapping='auto'] If `'start'`, viewport is scrolled to show
   * the cell on the left of the table. If `'end'`, viewport is scrolled to show the cell on the right of
   * the table. When `'auto'`, the viewport is scrolled only when the column is outside of the viewport.
   * @returns {boolean}
   */
  scrollViewportHorizontally(column, snapping) {
    return this.wtScroll.scrollViewportHorizontally(column, snapping);
  }

  /**
   * Scrolls the viewport to a row (rerenders if needed).
   *
   * @param {number} row Visual row index.
   * @param {'auto' | 'top' | 'bottom'} [snapping='auto'] If `'top'`, viewport is scrolled to show
   * the cell on the top of the table. If `'bottom'`, viewport is scrolled to show the cell on
   * the bottom of the table. When `'auto'`, the viewport is scrolled only when the row is outside of
   * the viewport.
   * @returns {boolean}
   */
  scrollViewportVertically(row, snapping) {
    return this.wtScroll.scrollViewportVertically(row, snapping);
  }

  /**
   * @returns {Array}
   */
  getViewport() {
    return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];
  }

  /**
   * Destroy instance.
   */
  destroy() {
    this.wtOverlays.destroy();
    this.wtEvent.destroy();
  }

  /**
   * Create data access object for scroll.
   *
   * @protected
   * @returns {ScrollDao}
   */
  createScrollDao() {
    const wot = this;
    return {
      get drawn() {
        return wot.drawn; // TODO refactoring: consider about injecting `isDrawn` function : ()=>return wot.drawn. (it'll enables remove dao layer)
      },
      get topOverlay() {
        return wot.wtOverlays.topOverlay; // TODO refactoring: move outside dao, use IOC
      },
      get inlineStartOverlay() {
        return wot.wtOverlays.inlineStartOverlay; // TODO refactoring: move outside dao, use IOC
      },
      get wtTable() {
        return wot.wtTable; // TODO refactoring: move outside dao, use IOC
      },
      get wtViewport() {
        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC
      },
      get wtSettings() {
        return wot.wtSettings;
      },
      get rootWindow() {
        return wot.domBindings.rootWindow; // TODO refactoring: move outside dao
      },
      // TODO refactoring, consider about using injecting wtSettings into scroll (it'll enables remove dao layer)
      get totalRows() {
        return wot.wtSettings.getSetting('totalRows');
      },
      get totalColumns() {
        return wot.wtSettings.getSetting('totalColumns');
      },
      get fixedRowsTop() {
        return wot.wtSettings.getSetting('fixedRowsTop');
      },
      get fixedRowsBottom() {
        return wot.wtSettings.getSetting('fixedRowsBottom');
      },
      get fixedColumnsStart() {
        return wot.wtSettings.getSetting('fixedColumnsStart');
      }
    };
  }
  // TODO refactoring: it will be much better to not use DAO objects. They are needed for now to provide
  // dynamically access to related objects
  /**
   * Create data access object for wtTable.
   *
   * @protected
   * @returns {TableDao}
   */
  getTableDao() {
    const wot = this;
    return {
      get wot() {
        return wot;
      },
      get parentTableOffset() {
        return wot.cloneSource.wtTable.tableOffset; // TODO rethink: cloneSource exists only in Clone type.
      },
      get cloneSource() {
        return wot.cloneSource; // TODO rethink: cloneSource exists only in Clone type.
      },
      get workspaceWidth() {
        return wot.wtViewport.getWorkspaceWidth();
      },
      get wtViewport() {
        return wot.wtViewport; // TODO refactoring: move outside dao, use IOC
      },
      get wtOverlays() {
        return wot.wtOverlays; // TODO refactoring: move outside dao, use IOC
      },
      get selectionManager() {
        return wot.selectionManager; // TODO refactoring: move outside dao, use IOC
      },
      get stylesHandler() {
        return wot.stylesHandler;
      },
      get drawn() {
        return wot.drawn;
      },
      set drawn(v) {
        // TODO rethink: this breaks assumes of data access object, however it is required until invent better way to handle WOT state.
        wot.drawn = v;
      },
      get wtTable() {
        return wot.wtTable; // TODO refactoring: it provides itself
      },
      get startColumnRendered() {
        return wot.wtViewport.columnsRenderCalculator.startColumn;
      },
      get startColumnVisible() {
        return wot.wtViewport.columnsVisibleCalculator.startColumn;
      },
      get startColumnPartiallyVisible() {
        return wot.wtViewport.columnsPartiallyVisibleCalculator.startColumn;
      },
      get endColumnRendered() {
        return wot.wtViewport.columnsRenderCalculator.endColumn;
      },
      get endColumnVisible() {
        return wot.wtViewport.columnsVisibleCalculator.endColumn;
      },
      get endColumnPartiallyVisible() {
        return wot.wtViewport.columnsPartiallyVisibleCalculator.endColumn;
      },
      get countColumnsRendered() {
        return wot.wtViewport.columnsRenderCalculator.count;
      },
      get countColumnsVisible() {
        return wot.wtViewport.columnsVisibleCalculator.count;
      },
      get startRowRendered() {
        return wot.wtViewport.rowsRenderCalculator.startRow;
      },
      get startRowVisible() {
        return wot.wtViewport.rowsVisibleCalculator.startRow;
      },
      get startRowPartiallyVisible() {
        return wot.wtViewport.rowsPartiallyVisibleCalculator.startRow;
      },
      get endRowRendered() {
        return wot.wtViewport.rowsRenderCalculator.endRow;
      },
      get endRowVisible() {
        return wot.wtViewport.rowsVisibleCalculator.endRow;
      },
      get endRowPartiallyVisible() {
        return wot.wtViewport.rowsPartiallyVisibleCalculator.endRow;
      },
      get countRowsRendered() {
        return wot.wtViewport.rowsRenderCalculator.count;
      },
      get countRowsVisible() {
        return wot.wtViewport.rowsVisibleCalculator.count;
      },
      get columnHeaders() {
        return wot.wtSettings.getSetting('columnHeaders');
      },
      get rowHeaders() {
        return wot.wtSettings.getSetting('rowHeaders');
      }
    };
  }
}
exports["default"] = CoreAbstract;

/***/ }),
/* 590 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _object = __webpack_require__(499);
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @class Scroll
 */
var _Scroll_brand = /*#__PURE__*/new WeakSet();
class Scroll {
  /**
   * @param {ScrollDao} dataAccessObject Tha data access object.
   */
  constructor(dataAccessObject) {
    /**
     * Get last visible column based on virtual dom and how table is visible in browser window viewport.
     *
     * @param {number} lastColumnIndex The last visible column index.
     * @returns {number}
     */
    _classPrivateMethodInitSpec(this, _Scroll_brand);
    /**
     * The data access object.
     *
     * @protected
     * @type {ScrollDao}
     */
    (0, _defineProperty2.default)(this, "dataAccessObject", void 0);
    this.dataAccessObject = dataAccessObject;
  }

  /**
   * Scrolls viewport to a cell.
   *
   * @param {CellCoords} coords The cell coordinates.
   * @param {'auto' | 'start' | 'end'} [horizontalSnap='auto'] If `'start'`, viewport is scrolled to show
   * the cell on the left of the table. If `'end'`, viewport is scrolled to show the cell on the right of
   * the table. When `'auto'`, the viewport is scrolled only when the column is outside of the viewport.
   * @param {'auto' | 'top' | 'bottom'} [verticalSnap='auto'] If `'top'`, viewport is scrolled to show
   * the cell on the top of the table. If `'bottom'`, viewport is scrolled to show the cell on the bottom of
   * the table. When `'auto'`, the viewport is scrolled only when the row is outside of the viewport.
   * @returns {boolean}
   */
  scrollViewport(coords, horizontalSnap, verticalSnap) {
    if (coords.col < 0 || coords.row < 0) {
      return false;
    }
    const scrolledHorizontally = this.scrollViewportHorizontally(coords.col, horizontalSnap);
    const scrolledVertically = this.scrollViewportVertically(coords.row, verticalSnap);
    return scrolledHorizontally || scrolledVertically;
  }

  /**
   * Scrolls viewport to a column.
   *
   * @param {number} column Visual column index.
   * @param {'auto' | 'start' | 'end'} [snapping='auto'] If `'start'`, viewport is scrolled to show
   * the cell on the left of the table. If `'end'`, viewport is scrolled to show the cell on the right of
   * the table. When `'auto'`, the viewport is scrolled only when the column is outside of the viewport.
   * @returns {boolean}
   */
  scrollViewportHorizontally(column) {
    let snapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';
    const {
      drawn,
      totalColumns
    } = this.dataAccessObject;
    if (!drawn) {
      return false;
    }
    const snappingObject = (0, _object.createObjectPropListener)(snapping);
    column = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollHorizontally', column, snappingObject);
    if (!Number.isInteger(column) || column < 0 || column > totalColumns) {
      return false;
    }
    snapping = snappingObject.value;
    const {
      fixedColumnsStart,
      inlineStartOverlay
    } = this.dataAccessObject;
    const autoSnapping = snapping === 'auto';

    // for auto-snapping do not scroll the viewport when the columns points to the overlays
    if (autoSnapping && column < fixedColumnsStart) {
      return false;
    }
    const firstColumn = this.getFirstVisibleColumn();
    const lastColumn = this.getLastVisibleColumn();
    let result = false;
    if (autoSnapping && (column < firstColumn || column > lastColumn) || !autoSnapping) {
      // if there is at least one fully visible column determine the snapping direction based on
      // that columns or by snapping flag, if provided.
      result = inlineStartOverlay.scrollTo(column, autoSnapping ? column >= this.getLastPartiallyVisibleColumn() : snapping === 'end');
    }
    return result;
  }

  /**
   * Scrolls viewport to a row.
   *
   * @param {number} row Visual row index.
   * @param {'auto' | 'top' | 'bottom'} [snapping='auto'] If `'top'`, viewport is scrolled to show
   * the cell on the top of the table. If `'bottom'`, viewport is scrolled to show the cell on
   * the bottom of the table. When `'auto'`, the viewport is scrolled only when the row is outside of
   * the viewport.
   * @returns {boolean}
   */
  scrollViewportVertically(row) {
    let snapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';
    const {
      drawn,
      totalRows
    } = this.dataAccessObject;
    if (!drawn) {
      return false;
    }
    const snappingObject = (0, _object.createObjectPropListener)(snapping);
    row = this.dataAccessObject.wtSettings.getSetting('onBeforeViewportScrollVertically', row, snappingObject);
    if (!Number.isInteger(row) || row < 0 || row > totalRows) {
      return false;
    }
    snapping = snappingObject.value;
    const {
      fixedRowsBottom,
      fixedRowsTop,
      topOverlay
    } = this.dataAccessObject;
    const autoSnapping = snapping === 'auto';

    // for auto-snapping do not scroll the viewport when the rows points to the overlays
    if (autoSnapping && (row < fixedRowsTop || row > totalRows - fixedRowsBottom - 1)) {
      return false;
    }
    const firstRow = this.getFirstVisibleRow();
    const lastRow = this.getLastVisibleRow();
    let result = false;
    if (autoSnapping && (row < firstRow || row > lastRow) || !autoSnapping) {
      // if there is at least one fully visible row determine the snapping direction based on
      // that rows or by snapping flag, if provided.
      result = topOverlay.scrollTo(row, autoSnapping ? row >= this.getLastPartiallyVisibleRow() : snapping === 'bottom');
    }
    return result;
  }

  /**
   * Get first visible row based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getFirstVisibleRow() {
    return this.dataAccessObject.wtTable.getFirstVisibleRow();
  }

  /**
   * Get last visible row based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getLastVisibleRow() {
    return _assertClassBrand(_Scroll_brand, this, _getLastRowIndex).call(this, this.dataAccessObject.wtTable.getLastVisibleRow());
  }

  /**
   * Get first partially visible row based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getFirstPartiallyVisibleRow() {
    return this.dataAccessObject.wtTable.getFirstPartiallyVisibleRow();
  }

  /**
   * Get last visible row based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getLastPartiallyVisibleRow() {
    return _assertClassBrand(_Scroll_brand, this, _getLastRowIndex).call(this, this.dataAccessObject.wtTable.getLastPartiallyVisibleRow());
  }

  /**
   * Get first visible column based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getFirstVisibleColumn() {
    return this.dataAccessObject.wtTable.getFirstVisibleColumn();
  }

  /**
   * Get last visible column based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getLastVisibleColumn() {
    return _assertClassBrand(_Scroll_brand, this, _getLastColumnIndex).call(this, this.dataAccessObject.wtTable.getLastVisibleColumn());
  }

  /**
   * Get first partially visible column based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getFirstPartiallyVisibleColumn() {
    return this.dataAccessObject.wtTable.getFirstPartiallyVisibleColumn();
  }

  /**
   * Get last partially visible column based on virtual dom and how table is visible in browser window viewport.
   *
   * @returns {number}
   */
  getLastPartiallyVisibleColumn() {
    return _assertClassBrand(_Scroll_brand, this, _getLastColumnIndex).call(this, this.dataAccessObject.wtTable.getLastPartiallyVisibleColumn());
  }
}
function _getLastColumnIndex(lastColumnIndex) {
  const {
    wtSettings,
    inlineStartOverlay,
    wtTable,
    wtViewport,
    totalColumns,
    rootWindow
  } = this.dataAccessObject;
  if (inlineStartOverlay.mainTableScrollableElement === rootWindow) {
    const isRtl = wtSettings.getSetting('rtlMode');
    let inlineStartRootElementOffset = null;
    if (isRtl) {
      const tableRect = wtTable.TABLE.getBoundingClientRect();
      const rootDocument = this.dataAccessObject.rootWindow.document;
      const docOffsetWidth = rootDocument.documentElement.offsetWidth;
      inlineStartRootElementOffset = Math.abs(tableRect.right - docOffsetWidth);
    } else {
      const rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);
      inlineStartRootElementOffset = rootElementOffset.left;
    }
    const windowScrollLeft = Math.abs((0, _element.getScrollLeft)(rootWindow, rootWindow));

    // Only calculate lastColumnIndex when table didn't filled (from right) whole viewport space
    if (inlineStartRootElementOffset > windowScrollLeft) {
      const windowWidth = (0, _element.innerWidth)(rootWindow);
      let columnsWidth = wtViewport.getRowHeaderWidth();
      for (let column = 1; column <= totalColumns; column++) {
        columnsWidth += inlineStartOverlay.sumCellSizes(column - 1, column);
        if (inlineStartRootElementOffset + columnsWidth - windowScrollLeft >= windowWidth) {
          // Return physical column - 1 (-2 because rangeEach gives column index + 1 - sumCellSizes requirements)
          lastColumnIndex = column - 2;
          break;
        }
      }
    }
  }
  return lastColumnIndex;
}
/**
 * Get last visible row based on virtual dom and how table is visible in browser window viewport.
 *
 * @param {number} lastRowIndex The last visible row index.
 * @returns {number}
 */
function _getLastRowIndex(lastRowIndex) {
  const {
    topOverlay,
    wtTable,
    wtViewport,
    totalRows,
    rootWindow
  } = this.dataAccessObject;
  if (topOverlay.mainTableScrollableElement === rootWindow) {
    const rootElementOffset = (0, _element.offset)(wtTable.wtRootElement);
    const windowScrollTop = (0, _element.getScrollTop)(rootWindow, rootWindow);

    // Only calculate lastRowIndex when table didn't filled (from bottom) whole viewport space
    if (rootElementOffset.top > windowScrollTop) {
      const windowHeight = (0, _element.innerHeight)(rootWindow);
      let rowsHeight = wtViewport.getColumnHeaderHeight();
      for (let row = 1; row <= totalRows; row++) {
        rowsHeight += topOverlay.sumCellSizes(row - 1, row);
        if (rootElementOffset.top + rowsHeight - windowScrollTop >= windowHeight) {
          // Return physical row - 1 (-2 because rangeEach gives row index + 1 - sumCellSizes requirements)
          lastRowIndex = row - 2;
          break;
        }
      }
    }
  }
  return lastRowIndex;
}
var _default = exports["default"] = Scroll;

/***/ }),
/* 591 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _bottom = _interopRequireDefault(__webpack_require__(592));
var _base = __webpack_require__(586);
var _constants = __webpack_require__(587);
/**
 * @class BottomOverlay
 */
class BottomOverlay extends _base.Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {
    super(wotInstance, facadeGetter, _constants.CLONE_BOTTOM, wtSettings, domBindings);
    /**
     * Cached value which holds the previous value of the `fixedRowsBottom` option.
     * It is used as a comparison value that can be used to detect changes in that value.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "cachedFixedRowsBottom", -1);
    this.cachedFixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');
  }

  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {BottomOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new _bottom.default(...args);
  }

  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting('shouldRenderBottomOverlay');
  }

  /**
   * Updates the top overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    if (!this.needFullRender || !this.shouldBeRendered() || !this.wot.wtTable.holder.parentNode) {
      // removed from DOM
      return false;
    }
    const {
      rootWindow
    } = this.domBindings;
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    overlayRoot.style.top = '';
    let overlayPosition = 0;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'vertical')) {
      overlayPosition = this.getOverlayOffset();
      overlayRoot.style.bottom = `${overlayPosition}px`;
    } else {
      overlayPosition = this.getScrollPosition();
      this.repositionOverlay();
    }
    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);
    this.adjustElementsSize();
    return positionChanged;
  }

  /**
   * Updates the bottom overlay position.
   */
  repositionOverlay() {
    const {
      wtTable,
      wtViewport
    } = this.wot;
    const {
      rootDocument
    } = this.domBindings;
    const cloneRoot = this.clone.wtTable.holder.parentNode;
    let bottomOffset = 0;
    if (!wtViewport.hasVerticalScroll()) {
      bottomOffset += wtViewport.getWorkspaceHeight() - wtTable.getTotalHeight();
    }
    if (wtViewport.hasVerticalScroll() && wtViewport.hasHorizontalScroll()) {
      bottomOffset += (0, _element.getScrollbarWidth)(rootDocument);
    }
    cloneRoot.style.bottom = `${bottomOffset}px`;
  }

  /**
   * Sets the main overlay's vertical scroll position.
   *
   * @param {number} pos The scroll position.
   * @returns {boolean}
   */
  setScrollPosition(pos) {
    const {
      rootWindow
    } = this.domBindings;
    let result = false;
    if (this.mainTableScrollableElement === rootWindow) {
      rootWindow.scrollTo((0, _element.getWindowScrollLeft)(rootWindow), pos);
      result = true;
    } else if (this.mainTableScrollableElement.scrollTop !== pos) {
      this.mainTableScrollableElement.scrollTop = pos;
      result = true;
    }
    return result;
  }

  /**
   * Triggers onScroll hook callback.
   */
  onScroll() {
    this.wtSettings.getSetting('onScrollHorizontally');
  }

  /**
   * Calculates total sum cells height.
   *
   * @param {number} from Row index which calculates started from.
   * @param {number} to Row index where calculation is finished.
   * @returns {number} Height sum.
   */
  sumCellSizes(from, to) {
    const {
      wtTable,
      stylesHandler
    } = this.wot;
    const defaultRowHeight = stylesHandler.getDefaultRowHeight();
    let row = from;
    let sum = 0;
    while (row < to) {
      const height = wtTable.getRowHeight(row);
      sum += height === undefined ? defaultRowHeight : height;
      row += 1;
    }
    return sum;
  }

  /**
   * Adjust overlay root element, children and master table element sizes (width, height).
   */
  adjustElementsSize() {
    this.updateTrimmingContainer();
    if (this.needFullRender) {
      this.adjustRootElementSize();
      this.adjustRootChildrenSize();
    }
  }

  /**
   * Adjust overlay root element size (width and height).
   */
  adjustRootElementSize() {
    const {
      wtTable,
      wtViewport
    } = this.wot;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const overlayRootStyle = overlayRoot.style;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    if (this.trimmingContainer !== rootWindow || preventOverflow === 'horizontal') {
      let width = wtViewport.getWorkspaceWidth();
      if (wtViewport.hasVerticalScroll()) {
        width -= (0, _element.getScrollbarWidth)(rootDocument);
      }
      width = Math.min(width, wtTable.wtRootElement.scrollWidth);
      overlayRootStyle.width = `${width}px`;
    } else {
      overlayRootStyle.width = '';
    }
    this.clone.wtTable.holder.style.width = overlayRootStyle.width;
    let tableHeight = (0, _element.outerHeight)(this.clone.wtTable.TABLE);
    if (!wtTable.hasDefinedSize()) {
      tableHeight = 0;
    }
    overlayRootStyle.height = `${tableHeight}px`;
  }

  /**
   * Adjust overlay root childs size.
   */
  adjustRootChildrenSize() {
    const {
      holder
    } = this.clone.wtTable;
    this.clone.wtTable.hider.style.width = this.hider.style.width;
    holder.style.width = holder.parentNode.style.width;
    holder.style.height = holder.parentNode.style.height;
  }

  /**
   * Adjust the overlay dimensions and position.
   */
  applyToDOM() {
    const total = this.wtSettings.getSetting('totalRows');
    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
      this.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;
    } else if (total === 0) {
      // can happen if there are 0 rows
      this.spreader.style.top = '0';
    } else {
      throw new Error('Incorrect value of the rowsRenderCalculator');
    }
    this.spreader.style.bottom = '';
    if (this.needFullRender) {
      this.syncOverlayOffset();
    }
  }

  /**
   * Synchronize calculated left position to an element.
   */
  syncOverlayOffset() {
    const styleProperty = this.isRtl() ? 'right' : 'left';
    const {
      spreader
    } = this.clone.wtTable;
    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
      spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;
    } else {
      spreader.style[styleProperty] = '';
    }
  }

  /**
   * Scrolls vertically to a row.
   *
   * @param {number} sourceRow Row index which you want to scroll to.
   * @param {boolean} [bottomEdge=false] If `true`, scrolls according to the bottom edge (top edge is by default).
   */
  scrollTo(sourceRow, bottomEdge) {
    let newY = this.getTableParentOffset();
    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
    const mainHolder = sourceInstance.wtTable.holder;
    let scrollbarCompensation = 0;
    if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
      scrollbarCompensation = (0, _element.getScrollbarWidth)(this.domBindings.rootDocument);
    }
    if (bottomEdge) {
      newY += this.sumCellSizes(0, sourceRow + 1);
      newY -= this.wot.wtViewport.getViewportHeight();
      // Fix 1 pixel offset when cell is selected
      newY += 1;
    } else {
      newY += this.sumCellSizes(this.wtSettings.getSetting('fixedRowsBottom'), sourceRow);
    }
    newY += scrollbarCompensation;
    this.setScrollPosition(newY);
  }

  /**
   * Gets table parent top position.
   *
   * @returns {number}
   */
  getTableParentOffset() {
    if (this.mainTableScrollableElement === this.domBindings.rootWindow) {
      return this.wot.wtTable.holderOffset.top;
    }
    return 0;
  }

  /**
   * Gets the main overlay's vertical scroll position.
   *
   * @returns {number} Main table's vertical scroll position.
   */
  getScrollPosition() {
    return (0, _element.getScrollTop)(this.mainTableScrollableElement, this.domBindings.rootWindow);
  }

  /**
   * Gets the main overlay's vertical overlay offset.
   *
   * @returns {number} Main table's vertical overlay offset.
   */
  getOverlayOffset() {
    const {
      rootWindow
    } = this.domBindings;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    let overlayOffset = 0;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'vertical')) {
      const rootHeight = this.wot.wtTable.getTotalHeight();
      const overlayRootHeight = this.clone.wtTable.getTotalHeight();
      const maxOffset = rootHeight - overlayRootHeight;
      const docClientHeight = this.domBindings.rootDocument.documentElement.clientHeight;
      overlayOffset = Math.max(this.getTableParentOffset() - this.getScrollPosition() - docClientHeight + rootHeight, 0);
      if (overlayOffset > maxOffset) {
        overlayOffset = 0;
      }
    }
    return overlayOffset;
  }

  /**
   * Adds css classes to hide the header border's header (cell-selection border hiding issue).
   *
   * @param {number} position Header Y position if trimming container is window or scroll top if not.
   * @returns {boolean}
   */
  adjustHeaderBordersPosition(position) {
    const fixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');
    const areFixedRowsBottomChanged = this.cachedFixedRowsBottom !== fixedRowsBottom;
    const columnHeaders = this.wtSettings.getSetting('columnHeaders');
    let positionChanged = false;
    if ((areFixedRowsBottomChanged || fixedRowsBottom === 0) && columnHeaders.length > 0) {
      const masterParent = this.wot.wtTable.holder.parentNode;
      const previousState = (0, _element.hasClass)(masterParent, 'innerBorderBottom');
      this.cachedFixedRowsBottom = this.wtSettings.getSetting('fixedRowsBottom');
      if (position || this.wtSettings.getSetting('totalRows') === 0) {
        (0, _element.addClass)(masterParent, 'innerBorderBottom');
        positionChanged = !previousState;
      } else {
        (0, _element.removeClass)(masterParent, 'innerBorderBottom');
        positionChanged = previousState;
      }
    }
    return positionChanged;
  }
}
exports.BottomOverlay = BottomOverlay;

/***/ }),
/* 592 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _table = _interopRequireDefault(__webpack_require__(564));
var _stickyRowsBottom = _interopRequireDefault(__webpack_require__(584));
var _calculatedColumns = _interopRequireDefault(__webpack_require__(593));
var _object = __webpack_require__(499);
var _overlay = __webpack_require__(561);
/**
 * Subclass of `Table` that provides the helper methods relevant to BottomOverlay, implemented through mixins.
 *
 * @mixes stickyRowsBottom
 * @mixes calculatedColumns
 */
class BottomOverlayTable extends _table.default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, _overlay.CLONE_BOTTOM);
  }
}
(0, _object.mixin)(BottomOverlayTable, _stickyRowsBottom.default);
(0, _object.mixin)(BottomOverlayTable, _calculatedColumns.default);
var _default = exports["default"] = BottomOverlayTable;

/***/ }),
/* 593 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _object = __webpack_require__(499);
const MIXIN_NAME = 'calculatedColumns';

/**
 * Mixin for the subclasses of `Table` with implementations of
 * helper methods that are related to columns.
 * This mixin is meant to be applied in the subclasses of `Table`
 * that use virtual rendering in the horizontal axis.
 *
 * @type {object}
 */
const calculatedColumns = {
  /**
   * Get the source index of the first rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedColumn() {
    const startColumn = this.dataAccessObject.startColumnRendered;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  /**
   * Get the source index of the first column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleColumn() {
    const startColumn = this.dataAccessObject.startColumnVisible;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  /**
   * Get the source index of the first column partially visible in the viewport. If no columns are partially visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstPartiallyVisibleColumn() {
    const startColumn = this.dataAccessObject.startColumnPartiallyVisible;
    if (startColumn === null) {
      return -1;
    }
    return startColumn;
  },
  /**
   * Get the source index of the last rendered column. If no columns are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedColumn() {
    const endColumn = this.dataAccessObject.endColumnRendered;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  /**
   * Get the source index of the last column fully visible in the viewport. If no columns are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleColumn() {
    const endColumn = this.dataAccessObject.endColumnVisible;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  /**
   * Get the source index of the last column partially visible in the viewport. If no columns are partially visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastPartiallyVisibleColumn() {
    const endColumn = this.dataAccessObject.endColumnPartiallyVisible;
    if (endColumn === null) {
      return -1;
    }
    return endColumn;
  },
  /**
   * Get the number of rendered columns.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedColumnsCount() {
    return this.dataAccessObject.countColumnsRendered;
  },
  /**
   * Get the number of fully visible columns in the viewport.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleColumnsCount() {
    return this.dataAccessObject.countColumnsVisible;
  },
  /**
   * Get the number of rendered row headers.
   *
   * @returns {number}
   * @this Table
   */
  getRowHeadersCount() {
    return this.dataAccessObject.rowHeaders.length;
  }
};
(0, _object.defineGetter)(calculatedColumns, 'MIXIN_NAME', MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var _default = exports["default"] = calculatedColumns;

/***/ }),
/* 594 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _element = __webpack_require__(351);
var _inlineStart = _interopRequireDefault(__webpack_require__(595));
var _base = __webpack_require__(586);
var _selection = __webpack_require__(597);
var _constants = __webpack_require__(587);
/**
 * @class InlineStartOverlay
 */
class InlineStartOverlay extends _base.Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {
    super(wotInstance, facadeGetter, _constants.CLONE_INLINE_START, wtSettings, domBindings);
  }

  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {InlineStartOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new _inlineStart.default(...args);
  }

  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting('shouldRenderInlineStartOverlay');
  }

  /**
   * Updates the left overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    const {
      wtTable
    } = this.wot;
    if (!this.needFullRender || !this.shouldBeRendered() || !wtTable.holder.parentNode) {
      // removed from DOM
      return false;
    }
    const {
      rootWindow
    } = this.domBindings;
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    let overlayPosition = 0;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {
      overlayPosition = this.getOverlayOffset() * (this.isRtl() ? -1 : 1);
      (0, _element.setOverlayPosition)(overlayRoot, `${overlayPosition}px`, '0px');
    } else {
      overlayPosition = this.getScrollPosition();
      (0, _element.resetCssTransform)(overlayRoot);
    }
    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition);
    this.adjustElementsSize();
    return positionChanged;
  }

  /**
   * Sets the main overlay's horizontal scroll position.
   *
   * @param {number} pos The scroll position.
   * @returns {boolean}
   */
  setScrollPosition(pos) {
    const {
      rootWindow
    } = this.domBindings;
    let result = false;
    if (this.isRtl()) {
      pos = -pos;
    }
    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollX !== pos) {
      rootWindow.scrollTo(pos, (0, _element.getWindowScrollTop)(rootWindow));
      result = true;
    } else if (this.mainTableScrollableElement.scrollLeft !== pos) {
      this.mainTableScrollableElement.scrollLeft = pos;
      result = true;
    }
    return result;
  }

  /**
   * Triggers onScroll hook callback.
   */
  onScroll() {
    this.wtSettings.getSetting('onScrollVertically');
  }

  /**
   * Calculates total sum cells width.
   *
   * @param {number} from Column index which calculates started from.
   * @param {number} to Column index where calculation is finished.
   * @returns {number} Width sum.
   */
  sumCellSizes(from, to) {
    const defaultColumnWidth = this.wtSettings.getSetting('defaultColumnWidth');
    let column = from;
    let sum = 0;
    while (column < to) {
      sum += this.wot.wtTable.getColumnWidth(column) || defaultColumnWidth;
      column += 1;
    }
    return sum;
  }

  /**
   * Adjust overlay root element, children and master table element sizes (width, height).
   */
  adjustElementsSize() {
    this.updateTrimmingContainer();
    if (this.needFullRender) {
      this.adjustRootElementSize();
      this.adjustRootChildrenSize();
    }
  }

  /**
   * Adjust overlay root element size (width and height).
   */
  adjustRootElementSize() {
    const {
      wtTable,
      wtViewport
    } = this.wot;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const overlayRootStyle = overlayRoot.style;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    if (this.trimmingContainer !== rootWindow || preventOverflow === 'vertical') {
      let height = wtViewport.getWorkspaceHeight();
      if (wtViewport.hasHorizontalScroll()) {
        height -= (0, _element.getScrollbarWidth)(rootDocument);
      }
      height = Math.min(height, wtTable.wtRootElement.scrollHeight);
      overlayRootStyle.height = `${height}px`;
    } else {
      overlayRootStyle.height = '';
    }
    this.clone.wtTable.holder.style.height = overlayRootStyle.height;
    const tableWidth = (0, _element.outerWidth)(this.clone.wtTable.TABLE);
    overlayRootStyle.width = `${tableWidth}px`;
  }

  /**
   * Adjust overlay root childs size.
   */
  adjustRootChildrenSize() {
    const {
      holder
    } = this.clone.wtTable;
    const cornerStyle = (0, _selection.getCornerStyle)(this.wot);
    const selectionCornerOffset = this.wot.selectionManager.getFocusSelection() ? parseInt(cornerStyle.width, 10) / 2 : 0;
    this.clone.wtTable.hider.style.height = this.hider.style.height;
    holder.style.height = holder.parentNode.style.height;
    // Add selection corner protruding part to the holder total width to make sure that
    // borders' corner won't be cut after horizontal scroll (#6937).
    holder.style.width = `${parseInt(holder.parentNode.style.width, 10) + selectionCornerOffset}px`;
  }

  /**
   * Adjust the overlay dimensions and position.
   */
  applyToDOM() {
    const total = this.wtSettings.getSetting('totalColumns');
    const styleProperty = this.isRtl() ? 'right' : 'left';
    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
      this.spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;
    } else if (total === 0) {
      this.spreader.style[styleProperty] = '0';
    } else {
      throw new Error('Incorrect value of the columnsRenderCalculator');
    }
    if (this.isRtl()) {
      this.spreader.style.left = '';
    } else {
      this.spreader.style.right = '';
    }
    if (this.needFullRender) {
      this.syncOverlayOffset();
    }
  }

  /**
   * Synchronize calculated top position to an element.
   */
  syncOverlayOffset() {
    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
      this.clone.wtTable.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;
    } else {
      this.clone.wtTable.spreader.style.top = '';
    }
  }

  /**
   * Scrolls horizontally to a column at the left edge of the viewport.
   *
   * @param {number} sourceCol  Column index which you want to scroll to.
   * @param {boolean} [beyondRendered]  If `true`, scrolls according to the right
   *                                    edge (left edge is by default).
   * @returns {boolean}
   */
  scrollTo(sourceCol, beyondRendered) {
    const {
      wtSettings
    } = this;
    const rowHeaders = wtSettings.getSetting('rowHeaders');
    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');
    const sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
    const mainHolder = sourceInstance.wtTable.holder;
    const rowHeaderBorderCompensation = fixedColumnsStart === 0 && rowHeaders.length > 0 && !(0, _element.hasClass)(mainHolder.parentNode, 'innerBorderInlineStart') ? 1 : 0;
    let newX = this.getTableParentOffset();
    let scrollbarCompensation = 0;
    if (beyondRendered) {
      const columnWidth = this.wot.wtTable.getColumnWidth(sourceCol);
      const viewportWidth = this.wot.wtViewport.getViewportWidth();
      if (columnWidth > viewportWidth) {
        beyondRendered = false;
      }
    }
    if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {
      scrollbarCompensation = (0, _element.getScrollbarWidth)(this.domBindings.rootDocument);
    }
    if (beyondRendered) {
      newX += this.sumCellSizes(0, sourceCol + 1);
      newX -= this.wot.wtViewport.getViewportWidth();
      // Compensate for the right header border if scrolled from the absolute left.
      newX += rowHeaderBorderCompensation;
    } else {
      newX += this.sumCellSizes(this.wtSettings.getSetting('fixedColumnsStart'), sourceCol);
    }
    newX += scrollbarCompensation;

    // If the table is scrolled all the way left when starting the scroll and going to be scrolled to the far right,
    // we need to compensate for the potential header border width.
    if ((0, _element.getMaximumScrollLeft)(this.mainTableScrollableElement) === newX - rowHeaderBorderCompensation && rowHeaderBorderCompensation > 0) {
      this.wot.wtOverlays.expandHiderHorizontallyBy(rowHeaderBorderCompensation);
    }
    return this.setScrollPosition(newX);
  }

  /**
   * Gets table parent left position.
   *
   * @returns {number}
   */
  getTableParentOffset() {
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    let offset = 0;
    if (!preventOverflow && this.trimmingContainer === this.domBindings.rootWindow) {
      offset = this.wot.wtTable.holderOffset.left;
    }
    return offset;
  }

  /**
   * Gets the main overlay's horizontal scroll position.
   *
   * @returns {number} Main table's horizontal scroll position.
   */
  getScrollPosition() {
    return Math.abs((0, _element.getScrollLeft)(this.mainTableScrollableElement, this.domBindings.rootWindow));
  }

  /**
   * Gets the main overlay's horizontal overlay offset.
   *
   * @returns {number} Main table's horizontal overlay offset.
   */
  getOverlayOffset() {
    const {
      rootWindow
    } = this.domBindings;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    let overlayOffset = 0;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'horizontal')) {
      if (this.isRtl()) {
        overlayOffset = Math.abs(Math.min(this.getTableParentOffset() - this.getScrollPosition(), 0));
      } else {
        overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);
      }
      const rootWidth = this.wot.wtTable.getTotalWidth();
      const overlayRootWidth = this.clone.wtTable.getTotalWidth();
      const maxOffset = rootWidth - overlayRootWidth;
      if (overlayOffset > maxOffset) {
        overlayOffset = 0;
      }
    }
    return overlayOffset;
  }

  /**
   * Adds css classes to hide the header border's header (cell-selection border hiding issue).
   *
   * @param {number} position Header X position if trimming container is window or scroll top if not.
   * @returns {boolean}
   */
  adjustHeaderBordersPosition(position) {
    const {
      wtSettings
    } = this;
    const masterParent = this.wot.wtTable.holder.parentNode;
    const rowHeaders = wtSettings.getSetting('rowHeaders');
    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');
    const totalRows = wtSettings.getSetting('totalRows');
    const preventVerticalOverflow = wtSettings.getSetting('preventOverflow') === 'vertical';
    if (totalRows) {
      (0, _element.removeClass)(masterParent, 'emptyRows');
    } else {
      (0, _element.addClass)(masterParent, 'emptyRows');
    }
    let positionChanged = false;
    if (!preventVerticalOverflow) {
      if (fixedColumnsStart && !rowHeaders.length) {
        // "innerBorderLeft" is for backward compatibility
        (0, _element.addClass)(masterParent, 'innerBorderLeft innerBorderInlineStart');
      } else if (!fixedColumnsStart && rowHeaders.length) {
        const previousState = (0, _element.hasClass)(masterParent, 'innerBorderInlineStart');
        if (position) {
          (0, _element.addClass)(masterParent, 'innerBorderLeft innerBorderInlineStart');
          positionChanged = !previousState;
        } else {
          (0, _element.removeClass)(masterParent, 'innerBorderLeft innerBorderInlineStart');
          positionChanged = previousState;
        }
      }
    }
    return positionChanged;
  }
}
exports.InlineStartOverlay = InlineStartOverlay;

/***/ }),
/* 595 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _table = _interopRequireDefault(__webpack_require__(564));
var _calculatedRows = _interopRequireDefault(__webpack_require__(596));
var _stickyColumnsStart = _interopRequireDefault(__webpack_require__(585));
var _object = __webpack_require__(499);
var _overlay = __webpack_require__(561);
/**
 * Subclass of `Table` that provides the helper methods relevant to InlineStartOverlayTable, implemented through mixins.
 */
class InlineStartOverlayTable extends _table.default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, _overlay.CLONE_INLINE_START);
  }
}
(0, _object.mixin)(InlineStartOverlayTable, _calculatedRows.default);
(0, _object.mixin)(InlineStartOverlayTable, _stickyColumnsStart.default);
var _default = exports["default"] = InlineStartOverlayTable;

/***/ }),
/* 596 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _object = __webpack_require__(499);
const MIXIN_NAME = 'calculatedRows';

/**
 * Mixin for the subclasses of `Table` with implementations of
 * helper methods that are related to rows.
 * This mixin is meant to be applied in the subclasses of `Table`
 * that use virtual rendering in the vertical axis.
 *
 * @type {object}
 */
const calculatedRows = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow() {
    const startRow = this.dataAccessObject.startRowRendered;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow() {
    const startRow = this.dataAccessObject.startRowVisible;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  /**
   * Get the source index of the first row partially visible in the viewport. If no rows are partially visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstPartiallyVisibleRow() {
    const startRow = this.dataAccessObject.startRowPartiallyVisible;
    if (startRow === null) {
      return -1;
    }
    return startRow;
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow() {
    const endRow = this.dataAccessObject.endRowRendered;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow() {
    const endRow = this.dataAccessObject.endRowVisible;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  /**
   * Get the source index of the last row partially visible in the viewport. If no rows are partially visible, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastPartiallyVisibleRow() {
    const endRow = this.dataAccessObject.endRowPartiallyVisible;
    if (endRow === null) {
      return -1;
    }
    return endRow;
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount() {
    return this.dataAccessObject.countRowsRendered;
  },
  /**
   * Get the number of fully visible rows in the viewport.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount() {
    return this.dataAccessObject.countRowsVisible;
  },
  /**
   * Get the number of rendered column headers.
   *
   * @returns {number}
   * @this Table
   */
  getColumnHeadersCount() {
    return this.dataAccessObject.columnHeaders.length;
  }
};
(0, _object.defineGetter)(calculatedRows, 'MIXIN_NAME', MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var _default = exports["default"] = calculatedRows;

/***/ }),
/* 597 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(311);
__webpack_require__(329);
var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _exportNames = {
  SelectionManager: true,
  Selection: true
};
var _selection = _interopRequireDefault(__webpack_require__(598));
exports.Selection = _selection.default;
var _constants = __webpack_require__(600);
Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _constants[key]) return;
  exports[key] = _constants[key];
});
var _utils = __webpack_require__(601);
Object.keys(_utils).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _utils[key]) return;
  exports[key] = _utils[key];
});
var _manager = __webpack_require__(602);
exports.SelectionManager = _manager.SelectionManager;

/***/ }),
/* 598 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _object = __webpack_require__(499);
var _localHooks = _interopRequireDefault(__webpack_require__(599));
/**
 * The Selection class allows highlighting (by applying CSS class) the table's cells or headers
 * and setting up the borders if defined in the settings.
 *
 * The Selection coordinates may point to the cells (positive numbers) or headers (negative numbers).
 *
 * @class Selection
 */
class Selection {
  /**
   * @param {object} settings The selection settings object. @todo type.
   * @param {CellRange} cellRange The cell range instance.
   */
  constructor(settings, cellRange) {
    this.settings = settings;
    this.cellRange = cellRange || null;
  }

  /**
   * Checks if selection is empty.
   *
   * @returns {boolean}
   */
  isEmpty() {
    return this.cellRange === null;
  }

  /**
   * Adds a cell coords to the selection.
   *
   * @param {CellCoords} coords The cell coordinates to add.
   * @returns {Selection}
   */
  add(coords) {
    if (this.isEmpty()) {
      this.cellRange = this.settings.createCellRange(coords);
    } else {
      this.cellRange.expand(coords);
    }
    return this;
  }

  /**
   * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean
   * information about success.
   *
   * @param {CellCoords} oldCoords An old cell coordinates to replace.
   * @param {CellCoords} newCoords The new cell coordinates.
   * @returns {boolean}
   */
  replace(oldCoords, newCoords) {
    if (!this.isEmpty()) {
      if (this.cellRange.from.isEqual(oldCoords)) {
        this.cellRange.from = newCoords;
        return true;
      }
      if (this.cellRange.to.isEqual(oldCoords)) {
        this.cellRange.to = newCoords;
        return true;
      }
    }
    return false;
  }

  /**
   * Clears selection.
   *
   * @returns {Selection}
   */
  clear() {
    this.cellRange = null;
    return this;
  }

  /**
   * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection coordinates.
   *
   * @returns {number[]} Returns array of coordinates for example `[1, 1, 5, 5]`.
   */
  getCorners() {
    const topStart = this.cellRange.getOuterTopStartCorner();
    const bottomEnd = this.cellRange.getOuterBottomEndCorner();
    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];
  }

  /**
   * Destroys the instance.
   */
  destroy() {
    this.runLocalHooks('destroy');
  }
}
(0, _object.mixin)(Selection, _localHooks.default);
var _default = exports["default"] = Selection;

/***/ }),
/* 599 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(283);
var _object = __webpack_require__(499);
var _function = __webpack_require__(497);
const MIXIN_NAME = 'localHooks';

/**
 * Mixin object to extend objects functionality for local hooks.
 *
 * @type {object}
 */
const localHooks = {
  /**
   * Internal hooks storage.
   */
  _localHooks: Object.create(null),
  /**
   * Add hook to the collection.
   *
   * @param {string} key The hook name.
   * @param {Function} callback The hook callback.
   * @returns {object}
   */
  addLocalHook(key, callback) {
    if (!this._localHooks[key]) {
      this._localHooks[key] = [];
    }
    this._localHooks[key].push(callback);
    return this;
  },
  /**
   * Run hooks.
   *
   * @param {string} key The name of the hook to run.
   * @param {*} [arg1] An additional parameter passed to the callback function.
   * @param {*} [arg2] An additional parameter passed to the callback function.
   * @param {*} [arg3] An additional parameter passed to the callback function.
   * @param {*} [arg4] An additional parameter passed to the callback function.
   * @param {*} [arg5] An additional parameter passed to the callback function.
   * @param {*} [arg6] An additional parameter passed to the callback function.
   */
  runLocalHooks(key, arg1, arg2, arg3, arg4, arg5, arg6) {
    if (this._localHooks[key]) {
      const length = this._localHooks[key].length;

      // don't optimize this loop with the `arrayEach()` method or arrow functions
      // otherwise, performance will decrease because of garbage collection
      // using the `...rest` syntax (ES6 and later) will decrease performance as well
      for (let i = 0; i < length; i++) {
        (0, _function.fastCall)(this._localHooks[key][i], this, arg1, arg2, arg3, arg4, arg5, arg6);
      }
    }
  },
  /**
   * Clear all added hooks.
   *
   * @returns {object}
   */
  clearLocalHooks() {
    this._localHooks = {};
    return this;
  }
};
(0, _object.defineGetter)(localHooks, 'MIXIN_NAME', MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var _default = exports["default"] = localHooks;

/***/ }),
/* 600 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
/**
 * Selection type that is visible only if the row or column header is clicked. If that happened
 * all row or column header layers are highlighted.
 *
 * @type {string}
 */
const ACTIVE_HEADER_TYPE = exports.ACTIVE_HEADER_TYPE = 'active-header';
/**
 * Selection type that is visible only if the a cell or cells are clicked. If that happened
 * only the most closest to the cells row or column header is highlighted.
 *
 * @type {string}
 */
const HEADER_TYPE = exports.HEADER_TYPE = 'header';
/**
 * Selection type that is visible when a cell or cells are clicked. The selected cells are
 * highlighted.
 *
 * @type {string}
 */
const AREA_TYPE = exports.AREA_TYPE = 'area';
/**
 * Selection type defines a cell that follows the user (keyboard navigation).
 *
 * @type {string}
 */
const FOCUS_TYPE = exports.FOCUS_TYPE = 'focus';
/**
 * Selection type defines borders for the autofill functionality.
 *
 * @type {string}
 */
const FILL_TYPE = exports.FILL_TYPE = 'fill';
/**
 * Selection type defines highlights for the `currentRowClassName` option.
 *
 * @type {string}
 */
const ROW_TYPE = exports.ROW_TYPE = 'row';
/**
 * Selection type defines highlights for the `currentColumnClassName` option.
 *
 * @type {string}
 */
const COLUMN_TYPE = exports.COLUMN_TYPE = 'column';
/**
 * Selection type defines highlights managed by the CustomBorders plugin.
 *
 * @type {string}
 */
const CUSTOM_SELECTION_TYPE = exports.CUSTOM_SELECTION_TYPE = 'custom-selection';

/***/ }),
/* 601 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
const getCornerStyle = wot => {
  const stylesHandler = wot.stylesHandler;
  if (stylesHandler.isClassicTheme()) {
    return Object.freeze({
      width: 6,
      height: 6,
      borderWidth: 1,
      borderStyle: 'solid',
      borderColor: '#FFF'
    });
  }
  const cornerSizeFromVar = stylesHandler.getCSSVariableValue('cell-autofill-size');
  const cornerBorderWidthFromVar = stylesHandler.getCSSVariableValue('cell-autofill-border-width');
  const cornerColorFromVar = stylesHandler.getCSSVariableValue('cell-autofill-border-color');
  return Object.freeze({
    width: cornerSizeFromVar,
    height: cornerSizeFromVar,
    borderWidth: cornerBorderWidthFromVar,
    borderStyle: 'solid',
    borderColor: cornerColorFromVar
  });
};
exports.getCornerStyle = getCornerStyle;

/***/ }),
/* 602 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(603);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(329);
__webpack_require__(338);
var _element = __webpack_require__(351);
var _scanner2 = __webpack_require__(604);
var _border = _interopRequireDefault(__webpack_require__(605));
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Module responsible for rendering selections (CSS classes) and borders based on the
 * collection of the Selection instances provided throughout the `selections` Walkontable
 * setting.
 *
 * @private
 */
var _activeOverlaysWot = /*#__PURE__*/new WeakMap();
var _selections = /*#__PURE__*/new WeakMap();
var _scanner = /*#__PURE__*/new WeakMap();
var _appliedClasses = /*#__PURE__*/new WeakMap();
var _destroyListeners = /*#__PURE__*/new WeakMap();
var _selectionBorders = /*#__PURE__*/new WeakMap();
var _SelectionManager_brand = /*#__PURE__*/new WeakSet();
class SelectionManager {
  constructor(selections) {
    /**
     * Resets the elements to their initial state (remove the CSS classes that are added in the
     * previous render cycle).
     */
    _classPrivateMethodInitSpec(this, _SelectionManager_brand);
    /**
     * The overlay's Walkontable instance that are currently processed.
     *
     * @type {Walkontable}
     */
    _classPrivateFieldInitSpec(this, _activeOverlaysWot, void 0);
    /**
     * The Highlight instance that holds Selections instances within it.
     *
     * @type {Highlight|null}
     */
    _classPrivateFieldInitSpec(this, _selections, void 0);
    /**
     * The SelectionScanner allows to scan and collect the cell and header elements that matches
     * to the coords defined in the selections.
     *
     * @type {SelectionScanner}
     */
    _classPrivateFieldInitSpec(this, _scanner, new _scanner2.SelectionScanner());
    /**
     * The Map tracks applied CSS classes. It's used to reset the elements state to their initial state.
     *
     * @type {WeakMap}
     */
    _classPrivateFieldInitSpec(this, _appliedClasses, new WeakMap());
    /**
     * The Map tracks applied "destroy" listeners for Selection instances.
     *
     * @type {WeakMap}
     */
    _classPrivateFieldInitSpec(this, _destroyListeners, new WeakSet());
    /**
     * The Map holds references to Border classes for Selection instances which requires that when
     * the "border" setting is defined.
     *
     * @type {Map}
     */
    _classPrivateFieldInitSpec(this, _selectionBorders, new Map());
    _classPrivateFieldSet(_selections, this, selections);
  }

  /**
   * Sets the active Walkontable instance.
   *
   * @param {Walkontable} activeWot The overlays or master Walkontable instance.
   * @returns {SelectionManager}
   */
  setActiveOverlay(activeWot) {
    _classPrivateFieldSet(_activeOverlaysWot, this, activeWot);
    _classPrivateFieldGet(_scanner, this).setActiveOverlay(_classPrivateFieldGet(_activeOverlaysWot, this));
    if (!_classPrivateFieldGet(_appliedClasses, this).has(_classPrivateFieldGet(_activeOverlaysWot, this))) {
      _classPrivateFieldGet(_appliedClasses, this).set(_classPrivateFieldGet(_activeOverlaysWot, this), new Set());
    }
    return this;
  }

  /**
   * Gets the Selection instance of the "focus" type.
   *
   * @returns {Selection|null}
   */
  getFocusSelection() {
    return _classPrivateFieldGet(_selections, this) !== null ? _classPrivateFieldGet(_selections, this).getFocus() : null;
  }

  /**
   * Gets the Selection instance of the "area" type.
   *
   * @returns {Selection|null}
   */
  getAreaSelection() {
    return _classPrivateFieldGet(_selections, this) !== null ? _classPrivateFieldGet(_selections, this).createLayeredArea() : null;
  }

  /**
   * Gets the Border instance associated with Selection instance.
   *
   * @param {Selection} selection The selection instance.
   * @returns {Border|null} Returns the Border instance (new for each overlay Walkontable instance).
   */
  getBorderInstance(selection) {
    if (!selection.settings.border) {
      return null;
    }
    if (_classPrivateFieldGet(_selectionBorders, this).has(selection)) {
      const borders = _classPrivateFieldGet(_selectionBorders, this).get(selection);
      if (borders.has(_classPrivateFieldGet(_activeOverlaysWot, this))) {
        return borders.get(_classPrivateFieldGet(_activeOverlaysWot, this));
      }
      const border = new _border.default(_classPrivateFieldGet(_activeOverlaysWot, this), selection.settings);
      borders.set(_classPrivateFieldGet(_activeOverlaysWot, this), border);
      return border;
    }
    const border = new _border.default(_classPrivateFieldGet(_activeOverlaysWot, this), selection.settings);
    _classPrivateFieldGet(_selectionBorders, this).set(selection, new Map([[_classPrivateFieldGet(_activeOverlaysWot, this), border]]));
    return border;
  }

  /**
   * Gets all Border instances associated with Selection instance for all overlays.
   *
   * @param {Selection} selection The selection instance.
   * @returns {Border[]}
   */
  getBorderInstances(selection) {
    var _classPrivateFieldGet2, _classPrivateFieldGet3;
    return Array.from((_classPrivateFieldGet2 = (_classPrivateFieldGet3 = _classPrivateFieldGet(_selectionBorders, this).get(selection)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.values()) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : []);
  }

  /**
   * Destroys the Border instance associated with Selection instance.
   *
   * @param {Selection} selection The selection instance.
   */
  destroyBorders(selection) {
    _classPrivateFieldGet(_selectionBorders, this).get(selection).forEach(border => border.destroy());
    _classPrivateFieldGet(_selectionBorders, this).delete(selection);
  }

  /**
   * Renders all the selections (add CSS classes to cells and draw borders).
   *
   * @param {boolean} fastDraw Indicates the render cycle type (fast/slow).
   */
  render(fastDraw) {
    if (_classPrivateFieldGet(_selections, this) === null) {
      return;
    }
    if (fastDraw) {
      // there was no rerender, so we need to remove classNames by ourselves
      _assertClassBrand(_SelectionManager_brand, this, _resetCells).call(this);
    }
    const selections = Array.from(_classPrivateFieldGet(_selections, this));
    const classNamesMap = new Map();
    const headerAttributesMap = new Map();
    for (let i = 0; i < selections.length; i++) {
      const selection = selections[i];
      const {
        className,
        headerAttributes,
        createLayers,
        selectionType
      } = selection.settings;
      if (!_classPrivateFieldGet(_destroyListeners, this).has(selection)) {
        _classPrivateFieldGet(_destroyListeners, this).add(selection);
        selection.addLocalHook('destroy', () => this.destroyBorders(selection));
      }
      const borderInstance = this.getBorderInstance(selection);
      if (selection.isEmpty()) {
        borderInstance === null || borderInstance === void 0 || borderInstance.disappear();
        continue; // eslint-disable-line no-continue
      }
      if (className) {
        const elements = _classPrivateFieldGet(_scanner, this).setActiveSelection(selection).scan();
        elements.forEach(element => {
          if (classNamesMap.has(element)) {
            const classNamesLayers = classNamesMap.get(element);
            if (classNamesLayers.has(className) && createLayers === true) {
              classNamesLayers.set(className, classNamesLayers.get(className) + 1);
            } else {
              classNamesLayers.set(className, 1);
            }
          } else {
            classNamesMap.set(element, new Map([[className, 1]]));
          }
          if (headerAttributes) {
            if (!headerAttributesMap.has(element)) {
              headerAttributesMap.set(element, []);
            }
            if (element.nodeName === 'TH') {
              headerAttributesMap.get(element).push(...headerAttributes);
            }
          }
        });
      }
      const corners = selection.getCorners();
      _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onBeforeDrawBorders', corners, selectionType);
      borderInstance === null || borderInstance === void 0 || borderInstance.appear(corners);
    }
    classNamesMap.forEach((classNamesLayers, element) => {
      var _classPrivateFieldGet4;
      const classNames = Array.from(classNamesLayers).map(_ref => {
        let [className, occurrenceCount] = _ref;
        if (occurrenceCount === 1) {
          return className;
        }
        return [className, ...Array.from({
          length: occurrenceCount - 1
        }, (_, i) => `${className}-${i + 1}`)];
      }).flat();
      classNames.forEach(className => _classPrivateFieldGet(_appliedClasses, this).get(_classPrivateFieldGet(_activeOverlaysWot, this)).add(className));
      (0, _element.addClass)(element, classNames);
      if (element.nodeName === 'TD' && Array.isArray((_classPrivateFieldGet4 = _classPrivateFieldGet(_selections, this).options) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.cellAttributes)) {
        (0, _element.setAttribute)(element, _classPrivateFieldGet(_selections, this).options.cellAttributes);
      }
    });

    // Set the attributes for the headers if they're focused.
    Array.from(headerAttributesMap.keys()).forEach(element => {
      (0, _element.setAttribute)(element, [...headerAttributesMap.get(element)]);
    });
  }
}
exports.SelectionManager = SelectionManager;
function _resetCells() {
  const appliedOverlaysClasses = _classPrivateFieldGet(_appliedClasses, this).get(_classPrivateFieldGet(_activeOverlaysWot, this));
  const classesToRemove = _classPrivateFieldGet(_activeOverlaysWot, this).wtSettings.getSetting('onBeforeRemoveCellClassNames');
  if (Array.isArray(classesToRemove)) {
    for (let i = 0; i < classesToRemove.length; i++) {
      appliedOverlaysClasses.add(classesToRemove[i]);
    }
  }
  appliedOverlaysClasses.forEach(className => {
    var _classPrivateFieldGet5, _classPrivateFieldGet6;
    const nodes = _classPrivateFieldGet(_activeOverlaysWot, this).wtTable.TABLE.querySelectorAll(`.${className}`);
    let cellAttributes = [];
    if (Array.isArray((_classPrivateFieldGet5 = _classPrivateFieldGet(_selections, this).options) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.cellAttributes)) {
      cellAttributes = _classPrivateFieldGet(_selections, this).options.cellAttributes.map(el => el[0]);
    }
    if (Array.isArray((_classPrivateFieldGet6 = _classPrivateFieldGet(_selections, this).options) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.headerAttributes)) {
      cellAttributes = [...cellAttributes, ..._classPrivateFieldGet(_selections, this).options.headerAttributes.map(el => el[0])];
    }
    for (let i = 0, len = nodes.length; i < len; i++) {
      (0, _element.removeClass)(nodes[i], className);
      (0, _element.removeAttribute)(nodes[i], cellAttributes);
    }
  });
  appliedOverlaysClasses.clear();
}

/***/ }),
/* 603 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(518);

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flat');


/***/ }),
/* 604 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
var _element = __webpack_require__(351);
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); } /* eslint-disable no-continue */
/**
 * Selection scanner module scans the rendered cells and headers and if it finds an intersection with
 * the coordinates of the Selection class (highlight) it returns the DOM elements.
 *
 * @private
 */
var _selection = /*#__PURE__*/new WeakMap();
var _activeOverlaysWot = /*#__PURE__*/new WeakMap();
var _SelectionScanner_brand = /*#__PURE__*/new WeakSet();
class SelectionScanner {
  constructor() {
    /**
     * The method triggers a callback for each rendered cell.
     *
     * @param {function(number, number): void} callback The callback function to trigger.
     */
    _classPrivateMethodInitSpec(this, _SelectionScanner_brand);
    /**
     * Active Selection instance to process.
     *
     * @type {Selection}
     */
    _classPrivateFieldInitSpec(this, _selection, void 0);
    /**
     * The Walkontable instance that the scans depends on.
     *
     * @type {Walkontable}
     */
    _classPrivateFieldInitSpec(this, _activeOverlaysWot, void 0);
  }
  /**
   * Sets the Walkontable instance that will be taking into account while scanning the table.
   *
   * @param {Walkontable} activeOverlaysWot The Walkontable instance.
   * @returns {SelectionScanner}
   */
  setActiveOverlay(activeOverlaysWot) {
    _classPrivateFieldSet(_activeOverlaysWot, this, activeOverlaysWot);
    return this;
  }

  /**
   * Sets the Selection instance to process.
   *
   * @param {Selection} selection The Selection instance.
   * @returns {SelectionScanner}
   */
  setActiveSelection(selection) {
    _classPrivateFieldSet(_selection, this, selection);
    return this;
  }

  /**
   * Scans the rendered table with selection and returns elements that intersects
   * with selection coordinates.
   *
   * @returns {HTMLTableElement[]}
   */
  scan() {
    const selectionType = _classPrivateFieldGet(_selection, this).settings.selectionType;
    const elements = new Set();

    // TODO(improvement): use heuristics from coords to detect what type of scan
    // the Selection needs instead of using `selectionType` property.
    if (selectionType === 'active-header') {
      this.scanColumnsInHeadersRange(element => elements.add(element));
      this.scanRowsInHeadersRange(element => elements.add(element));
    } else if (selectionType === 'area') {
      this.scanCellsRange(element => elements.add(element));
    } else if (selectionType === 'focus') {
      this.scanColumnsInHeadersRange(element => elements.add(element));
      this.scanRowsInHeadersRange(element => elements.add(element));
      this.scanCellsRange(element => elements.add(element));
    } else if (selectionType === 'fill') {
      this.scanCellsRange(element => elements.add(element));
    } else if (selectionType === 'header') {
      this.scanColumnsInHeadersRange(element => elements.add(element));
      this.scanRowsInHeadersRange(element => elements.add(element));
    } else if (selectionType === 'row') {
      this.scanRowsInHeadersRange(element => elements.add(element));
      this.scanRowsInCellsRange(element => elements.add(element));
    } else if (selectionType === 'column') {
      this.scanColumnsInHeadersRange(element => elements.add(element));
      this.scanColumnsInCellsRange(element => elements.add(element));
    }
    return elements;
  }

  /**
   * Scans the table (only rendered headers) and collect all column headers (TH) that match
   * the coordinates passed in the Selection instance.
   *
   * @param {function(HTMLTableElement): void} callback The callback function to trigger.
   */
  scanColumnsInHeadersRange(callback) {
    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();
    const {
      wtTable
    } = _classPrivateFieldGet(_activeOverlaysWot, this);
    const renderedColumnsCount = wtTable.getRenderedColumnsCount();
    const columnHeadersCount = wtTable.getColumnHeadersCount();
    let cursor = 0;
    for (let column = -wtTable.getRowHeadersCount(); column < renderedColumnsCount; column++) {
      const sourceColumn = wtTable.columnFilter.renderedToSource(column);
      if (sourceColumn < topColumn || sourceColumn > bottomColumn) {
        continue;
      }
      for (let headerLevel = -columnHeadersCount; headerLevel < 0; headerLevel++) {
        if (headerLevel < topRow || headerLevel > bottomRow) {
          continue;
        }
        const positiveBasedHeaderLevel = headerLevel + columnHeadersCount;
        let TH = wtTable.getColumnHeader(sourceColumn, positiveBasedHeaderLevel);
        const newSourceCol = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onBeforeHighlightingColumnHeader', sourceColumn, positiveBasedHeaderLevel, {
          selectionType: _classPrivateFieldGet(_selection, this).settings.selectionType,
          columnCursor: cursor,
          selectionWidth: bottomColumn - topColumn + 1
        });
        if (newSourceCol === null) {
          continue;
        }
        if (newSourceCol !== sourceColumn) {
          TH = wtTable.getColumnHeader(newSourceCol, positiveBasedHeaderLevel);
        }
        callback(TH);
      }
      cursor += 1;
    }
  }

  /**
   * Scans the table (only rendered headers) and collect all row headers (TH) that match
   * the coordinates passed in the Selection instance.
   *
   * @param {function(HTMLTableElement): void} callback The callback function to trigger.
   */
  scanRowsInHeadersRange(callback) {
    const [topRow, topColumn, bottomRow, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();
    const {
      wtTable
    } = _classPrivateFieldGet(_activeOverlaysWot, this);
    const renderedRowsCount = wtTable.getRenderedRowsCount();
    const rowHeadersCount = wtTable.getRowHeadersCount();
    let cursor = 0;
    for (let row = -wtTable.getColumnHeadersCount(); row < renderedRowsCount; row++) {
      const sourceRow = wtTable.rowFilter.renderedToSource(row);
      if (sourceRow < topRow || sourceRow > bottomRow) {
        continue;
      }
      for (let headerLevel = -rowHeadersCount; headerLevel < 0; headerLevel++) {
        if (headerLevel < topColumn || headerLevel > bottomColumn) {
          continue;
        }
        const positiveBasedHeaderLevel = headerLevel + rowHeadersCount;
        let TH = wtTable.getRowHeader(sourceRow, positiveBasedHeaderLevel);
        const newSourceRow = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onBeforeHighlightingRowHeader', sourceRow, positiveBasedHeaderLevel, {
          selectionType: _classPrivateFieldGet(_selection, this).settings.selectionType,
          rowCursor: cursor,
          selectionHeight: bottomRow - topRow + 1
        });
        if (newSourceRow === null) {
          continue;
        }
        if (newSourceRow !== sourceRow) {
          TH = wtTable.getRowHeader(newSourceRow, positiveBasedHeaderLevel);
        }
        callback(TH);
      }
      cursor += 1;
    }
  }

  /**
   * Scans the table (only rendered cells) and collect all cells (TR) that match
   * the coordinates passed in the Selection instance.
   *
   * @param {function(HTMLTableElement): void} callback The callback function to trigger.
   */
  scanCellsRange(callback) {
    const {
      wtTable
    } = _classPrivateFieldGet(_activeOverlaysWot, this);
    _assertClassBrand(_SelectionScanner_brand, this, _scanCellsRange).call(this, (sourceRow, sourceColumn) => {
      const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));

      // support for old API
      const additionalSelectionClass = _classPrivateFieldGet(_activeOverlaysWot, this).getSetting('onAfterDrawSelection', sourceRow, sourceColumn, _classPrivateFieldGet(_selection, this).settings.layerLevel);
      if (typeof additionalSelectionClass === 'string') {
        (0, _element.addClass)(cell, additionalSelectionClass);
      }
      callback(cell);
    });
  }

  /**
   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates
   * passed in the Selection instance but only for the X axis (rows).
   *
   * @param {function(HTMLTableElement): void} callback The callback function to trigger.
   */
  scanRowsInCellsRange(callback) {
    // eslint-disable-next-line comma-spacing
    const [topRow,, bottomRow] = _classPrivateFieldGet(_selection, this).getCorners();
    const {
      wtTable
    } = _classPrivateFieldGet(_activeOverlaysWot, this);
    _assertClassBrand(_SelectionScanner_brand, this, _scanViewportRange).call(this, (sourceRow, sourceColumn) => {
      if (sourceRow >= topRow && sourceRow <= bottomRow) {
        const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));
        callback(cell);
      }
    });
  }

  /**
   * Scans the table (only rendered cells) and collects all cells (TR) that match the coordinates
   * passed in the Selection instance but only for the Y axis (columns).
   *
   * @param {function(HTMLTableElement): void} callback The callback function to trigger.
   */
  scanColumnsInCellsRange(callback) {
    const [, topColumn,, bottomColumn] = _classPrivateFieldGet(_selection, this).getCorners();
    const {
      wtTable
    } = _classPrivateFieldGet(_activeOverlaysWot, this);
    _assertClassBrand(_SelectionScanner_brand, this, _scanViewportRange).call(this, (sourceRow, sourceColumn) => {
      if (sourceColumn >= topColumn && sourceColumn <= bottomColumn) {
        const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(sourceRow, sourceColumn));
        callback(cell);
      }
    });
  }
}
exports.SelectionScanner = SelectionScanner;
function _scanCellsRange(callback) {
  let [topRow, startColumn, bottomRow, endColumn] = _classPrivateFieldGet(_selection, this).getCorners();
  if (topRow < 0 && bottomRow < 0 || startColumn < 0 && endColumn < 0) {
    return;
  }
  const {
    wtTable
  } = _classPrivateFieldGet(_activeOverlaysWot, this);
  const isMultiple = topRow !== bottomRow || startColumn !== endColumn;
  startColumn = Math.max(startColumn, 0);
  endColumn = Math.max(endColumn, 0);
  topRow = Math.max(topRow, 0);
  bottomRow = Math.max(bottomRow, 0);
  if (isMultiple) {
    startColumn = Math.max(startColumn, wtTable.getFirstRenderedColumn());
    endColumn = Math.min(endColumn, wtTable.getLastRenderedColumn());
    topRow = Math.max(topRow, wtTable.getFirstRenderedRow());
    bottomRow = Math.min(bottomRow, wtTable.getLastRenderedRow());
    if (endColumn < startColumn || bottomRow < topRow) {
      return;
    }
  } else {
    const cell = wtTable.getCell(_classPrivateFieldGet(_activeOverlaysWot, this).createCellCoords(topRow, startColumn));
    if (!(cell instanceof HTMLElement)) {
      return;
    }
  }
  for (let row = topRow; row <= bottomRow; row += 1) {
    for (let column = startColumn; column <= endColumn; column += 1) {
      callback(row, column);
    }
  }
}
/**
 * The method triggers a callback for each rendered cell including headers.
 *
 * @param {function(number, number): void} callback The callback function to trigger.
 */
function _scanViewportRange(callback) {
  const {
    wtTable
  } = _classPrivateFieldGet(_activeOverlaysWot, this);
  const renderedRowsCount = wtTable.getRenderedRowsCount();
  const renderedColumnsCount = wtTable.getRenderedColumnsCount();
  for (let row = 0; row < renderedRowsCount; row += 1) {
    const sourceRow = wtTable.rowFilter.renderedToSource(row);
    for (let column = 0; column < renderedColumnsCount; column += 1) {
      callback(sourceRow, wtTable.columnFilter.renderedToSource(column));
    }
  }
}

/***/ }),
/* 605 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _element = __webpack_require__(351);
var _event = __webpack_require__(509);
var _object = __webpack_require__(499);
var _browser = __webpack_require__(498);
var _utils = __webpack_require__(601);
/**
 *
 */
class Border {
  // TODO As this is an internal class, should be designed for using {Walkontable}. It uses the facade,
  // TODO Con. Because the class is created on place where the instance reference comes from external origin.
  // TODO Imho, the discrimination for handling both, facade and non-facade should be handled.
  /**
   * @param {WalkontableFacade} wotInstance The Walkontable instance.
   * @param {object} settings The border settings.
   */
  constructor(wotInstance, settings) {
    if (!settings) {
      return;
    }
    this.eventManager = wotInstance.eventManager;
    this.instance = wotInstance;
    this.wot = wotInstance;
    this.settings = settings;
    this.mouseDown = false;
    this.main = null;
    this.top = null;
    this.bottom = null;
    this.start = null;
    this.end = null;
    this.topStyle = null;
    this.bottomStyle = null;
    this.startStyle = null;
    this.endStyle = null;
    this.cornerDefaultStyle = (0, _utils.getCornerStyle)(this.instance);
    // Offset to moving the corner to be centered relative to the grid.
    this.cornerCenterPointOffset = -Math.ceil(parseInt(this.cornerDefaultStyle.width, 10) / 2);
    this.corner = null;
    this.cornerStyle = null;
    this.createBorders(settings);
    this.registerListeners();
  }

  /**
   * Register all necessary events.
   */
  registerListeners() {
    const documentBody = this.wot.rootDocument.body;
    this.eventManager.addEventListener(documentBody, 'mousedown', () => this.onMouseDown());
    this.eventManager.addEventListener(documentBody, 'mouseup', () => this.onMouseUp());
    for (let c = 0, len = this.main.childNodes.length; c < len; c++) {
      const element = this.main.childNodes[c];
      this.eventManager.addEventListener(element, 'mouseenter', event => this.onMouseEnter(event, this.main.childNodes[c]));
    }
  }

  /**
   * Mouse down listener.
   *
   * @private
   */
  onMouseDown() {
    this.mouseDown = true;
  }

  /**
   * Mouse up listener.
   *
   * @private
   */
  onMouseUp() {
    this.mouseDown = false;
  }

  /**
   * Mouse enter listener for fragment selection functionality.
   *
   * @private
   * @param {Event} event Dom event.
   * @param {HTMLElement} parentElement Part of border element.
   */
  onMouseEnter(event, parentElement) {
    if (!this.mouseDown || !this.wot.getSetting('hideBorderOnMouseDownOver')) {
      return;
    }
    event.preventDefault();
    (0, _event.stopImmediatePropagation)(event);
    const _this = this;
    const documentBody = this.wot.rootDocument.body;
    const bounds = parentElement.getBoundingClientRect();

    // Hide border to prevents selection jumping when fragmentSelection is enabled.
    parentElement.style.display = 'none';

    /**
     * @param {Event} mouseEvent The mouse event object.
     * @returns {boolean}
     */
    function isOutside(mouseEvent) {
      if (mouseEvent.clientY < Math.floor(bounds.top)) {
        return true;
      }
      if (mouseEvent.clientY > Math.ceil(bounds.top + bounds.height)) {
        return true;
      }
      if (mouseEvent.clientX < Math.floor(bounds.left)) {
        return true;
      }
      if (mouseEvent.clientX > Math.ceil(bounds.left + bounds.width)) {
        return true;
      }
    }

    /**
     * @param {Event} handlerEvent The mouse event object.
     */
    function handler(handlerEvent) {
      if (isOutside(handlerEvent)) {
        _this.eventManager.removeEventListener(documentBody, 'mousemove', handler);
        parentElement.style.display = 'block';
      }
    }
    this.eventManager.addEventListener(documentBody, 'mousemove', handler);
  }

  /**
   * Create border elements.
   *
   * @param {object} settings The border settings.
   */
  createBorders(settings) {
    const {
      rootDocument
    } = this.wot;
    this.main = rootDocument.createElement('div');
    const borderDivs = ['top', 'start', 'bottom', 'end', 'corner'];
    let style = this.main.style;
    style.position = 'absolute';
    style.top = 0;
    style.left = 0;
    for (let i = 0; i < 5; i++) {
      const position = borderDivs[i];
      const div = rootDocument.createElement('div');
      div.className = `wtBorder ${this.settings.className || ''}`; // + borderDivs[i];

      if (this.settings[position] && this.settings[position].hide) {
        div.className += ' hidden';
      }
      style = div.style;
      style.backgroundColor = this.settings[position] && this.settings[position].color ? this.settings[position].color : settings.border.color;
      style.height = this.settings[position] && this.settings[position].width ? `${this.settings[position].width}px` : `${settings.border.width}px`;
      style.width = this.settings[position] && this.settings[position].width ? `${this.settings[position].width}px` : `${settings.border.width}px`;
      this.main.appendChild(div);
    }
    this.top = this.main.childNodes[0];
    this.start = this.main.childNodes[1];
    this.bottom = this.main.childNodes[2];
    this.end = this.main.childNodes[3];
    this.topStyle = this.top.style;
    this.startStyle = this.start.style;
    this.bottomStyle = this.bottom.style;
    this.endStyle = this.end.style;
    this.corner = this.main.childNodes[4];
    this.corner.className += ' corner';
    this.cornerStyle = this.corner.style;
    this.cornerStyle.width = `${this.cornerDefaultStyle.width}px`;
    this.cornerStyle.height = `${this.cornerDefaultStyle.height}px`;
    this.cornerStyle.border = [`${this.cornerDefaultStyle.borderWidth}px`, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(' ');
    if ((0, _browser.isMobileBrowser)() && this.instance.getSetting('isDataViewInstance')) {
      this.createMultipleSelectorHandles();
    }
    this.disappear();
    const {
      wtTable
    } = this.wot;
    let bordersHolder = wtTable.bordersHolder;
    if (!bordersHolder) {
      bordersHolder = rootDocument.createElement('div');
      bordersHolder.className = 'htBorders';
      wtTable.bordersHolder = bordersHolder;
      wtTable.spreader.appendChild(bordersHolder);
    }
    bordersHolder.appendChild(this.main);
  }

  /**
   * Create multiple selector handler for mobile devices.
   */
  createMultipleSelectorHandles() {
    const {
      rootDocument
    } = this.wot;
    this.selectionHandles = {
      top: rootDocument.createElement('DIV'),
      topHitArea: rootDocument.createElement('DIV'),
      bottom: rootDocument.createElement('DIV'),
      bottomHitArea: rootDocument.createElement('DIV')
    };
    const width = 10;
    const hitAreaWidth = 40;
    this.selectionHandles.top.className = 'topSelectionHandle topLeftSelectionHandle';
    this.selectionHandles.topHitArea.className = 'topSelectionHandle-HitArea topLeftSelectionHandle-HitArea';
    this.selectionHandles.bottom.className = 'bottomSelectionHandle bottomRightSelectionHandle';
    this.selectionHandles.bottomHitArea.className = 'bottomSelectionHandle-HitArea bottomRightSelectionHandle-HitArea';
    this.selectionHandles.styles = {
      top: this.selectionHandles.top.style,
      topHitArea: this.selectionHandles.topHitArea.style,
      bottom: this.selectionHandles.bottom.style,
      bottomHitArea: this.selectionHandles.bottomHitArea.style
    };
    const hitAreaStyle = {
      position: 'absolute',
      height: `${hitAreaWidth}px`,
      width: `${hitAreaWidth}px`,
      'border-radius': `${parseInt(hitAreaWidth / 1.5, 10)}px`
    };
    (0, _object.objectEach)(hitAreaStyle, (value, key) => {
      this.selectionHandles.styles.bottomHitArea[key] = value;
      this.selectionHandles.styles.topHitArea[key] = value;
    });
    const handleStyle = {
      position: 'absolute',
      height: `${width}px`,
      width: `${width}px`,
      'border-radius': `${parseInt(width / 1.5, 10)}px`,
      background: '#F5F5FF',
      border: '1px solid #4285c8'
    };
    (0, _object.objectEach)(handleStyle, (value, key) => {
      this.selectionHandles.styles.bottom[key] = value;
      this.selectionHandles.styles.top[key] = value;
    });
    this.main.appendChild(this.selectionHandles.top);
    this.main.appendChild(this.selectionHandles.bottom);
    this.main.appendChild(this.selectionHandles.topHitArea);
    this.main.appendChild(this.selectionHandles.bottomHitArea);
  }

  /**
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @returns {boolean}
   */
  isPartRange(row, col) {
    const areaSelection = this.wot.selectionManager.getAreaSelection();
    if (areaSelection.cellRange) {
      if (row !== areaSelection.cellRange.to.row || col !== areaSelection.cellRange.to.col) {
        return true;
      }
    }
    return false;
  }

  /**
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number} top The top position of the handler.
   * @param {number} left The left position of the handler.
   * @param {number} width The width of the handler.
   * @param {number} height The height of the handler.
   */
  updateMultipleSelectionHandlesPosition(row, col, top, left, width, height) {
    const isRtl = this.wot.wtSettings.getSetting('rtlMode');
    const inlinePosProperty = isRtl ? 'right' : 'left';
    const {
      top: topStyles,
      topHitArea: topHitAreaStyles,
      bottom: bottomStyles,
      bottomHitArea: bottomHitAreaStyles
    } = this.selectionHandles.styles;
    const handleBorderSize = parseInt(topStyles.borderWidth, 10);
    const handleSize = parseInt(topStyles.width, 10);
    const hitAreaSize = parseInt(topHitAreaStyles.width, 10);
    const totalTableWidth = this.wot.wtTable.getWidth();
    const totalTableHeight = this.wot.wtTable.getHeight();
    topStyles.top = `${parseInt(top - handleSize - 1, 10)}px`;
    topStyles[inlinePosProperty] = `${parseInt(left - handleSize - 1, 10)}px`;
    topHitAreaStyles.top = `${parseInt(top - hitAreaSize / 4 * 3, 10)}px`;
    topHitAreaStyles[inlinePosProperty] = `${parseInt(left - hitAreaSize / 4 * 3, 10)}px`;
    const bottomHandlerInline = Math.min(parseInt(left + width, 10), totalTableWidth - handleSize - handleBorderSize * 2);
    const bottomHandlerAreaInline = Math.min(parseInt(left + width - hitAreaSize / 4, 10), totalTableWidth - hitAreaSize - handleBorderSize * 2);
    bottomStyles[inlinePosProperty] = `${bottomHandlerInline}px`;
    bottomHitAreaStyles[inlinePosProperty] = `${bottomHandlerAreaInline}px`;
    const bottomHandlerTop = Math.min(parseInt(top + height, 10), totalTableHeight - handleSize - handleBorderSize * 2);
    const bottomHandlerAreaTop = Math.min(parseInt(top + height - hitAreaSize / 4, 10), totalTableHeight - hitAreaSize - handleBorderSize * 2);
    bottomStyles.top = `${bottomHandlerTop}px`;
    bottomHitAreaStyles.top = `${bottomHandlerAreaTop}px`;
    if (this.settings.border.cornerVisible && this.settings.border.cornerVisible()) {
      topStyles.display = 'block';
      topHitAreaStyles.display = 'block';
      if (this.isPartRange(row, col)) {
        bottomStyles.display = 'none';
        bottomHitAreaStyles.display = 'none';
      } else {
        bottomStyles.display = 'block';
        bottomHitAreaStyles.display = 'block';
      }
    } else {
      topStyles.display = 'none';
      bottomStyles.display = 'none';
      topHitAreaStyles.display = 'none';
      bottomHitAreaStyles.display = 'none';
    }
    if (row === this.wot.wtSettings.getSetting('fixedRowsTop') || col === this.wot.wtSettings.getSetting('fixedColumnsStart')) {
      topStyles.zIndex = '9999';
      topHitAreaStyles.zIndex = '9999';
    } else {
      topStyles.zIndex = '';
      topHitAreaStyles.zIndex = '';
    }
  }

  /**
   * Show border around one or many cells.
   *
   * @param {Array} corners The corner coordinates.
   */
  appear(corners) {
    if (this.disabled) {
      return;
    }
    let [fromRow, fromColumn, toRow, toColumn] = corners;

    // borders can not be rendered on headers so hide them
    if (fromRow < 0 && toRow < 0 || fromColumn < 0 && toColumn < 0) {
      this.disappear();
      return;
    }
    const {
      wtTable,
      rootDocument,
      rootWindow
    } = this.wot;
    const isMultiple = fromRow !== toRow || fromColumn !== toColumn;
    const firstRenderedRow = wtTable.getFirstRenderedRow();
    const lastRenderedRow = wtTable.getLastRenderedRow();
    const firstRenderedColumn = wtTable.getFirstRenderedColumn();
    const lastRenderedColumn = wtTable.getLastRenderedColumn();
    let fromTD;
    if (isMultiple) {
      fromColumn = Math.max(fromColumn, firstRenderedColumn);
      toColumn = Math.min(toColumn, lastRenderedColumn);
      fromRow = Math.max(fromRow, firstRenderedRow);
      toRow = Math.min(toRow, lastRenderedRow);
      if (toColumn < fromColumn || toRow < fromRow) {
        this.disappear();
        return;
      }
      fromTD = wtTable.getCell(this.wot.createCellCoords(fromRow, fromColumn));
    } else {
      fromTD = wtTable.getCell(this.wot.createCellCoords(fromRow, fromColumn));
      if (!(fromTD instanceof HTMLElement)) {
        this.disappear();
        return;
      }
    }
    const toTD = isMultiple ? wtTable.getCell(this.wot.createCellCoords(toRow, toColumn)) : fromTD;
    const fromOffset = (0, _element.offset)(fromTD);
    const toOffset = isMultiple ? (0, _element.offset)(toTD) : fromOffset;
    const containerOffset = (0, _element.offset)(wtTable.TABLE);
    const minTop = fromOffset.top;
    const minLeft = fromOffset.left;
    const isRtl = this.wot.wtSettings.getSetting('rtlMode');
    let inlineStartPos = 0;
    let width = 0;
    if (isRtl) {
      const containerWidth = (0, _element.outerWidth)(wtTable.TABLE);
      const fromWidth = (0, _element.outerWidth)(fromTD);
      const gridRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;
      width = minLeft + fromWidth - toOffset.left;
      inlineStartPos = rootWindow.innerWidth - minLeft - fromWidth - gridRightPos - 1;
    } else {
      width = toOffset.left + (0, _element.outerWidth)(toTD) - minLeft;
      inlineStartPos = minLeft - containerOffset.left - 1;
    }
    if (this.isEntireColumnSelected(fromRow, toRow)) {
      const rowHeader = fromRow;
      const modifiedValues = this.getDimensionsFromHeader('columns', fromColumn, toColumn, rowHeader, containerOffset);
      let fromTH = null;
      if (modifiedValues) {
        [fromTH, inlineStartPos, width] = modifiedValues;
      }
      if (fromTH) {
        fromTD = fromTH;
      }
    }
    let top = minTop - containerOffset.top - 1;
    let height = toOffset.top + (0, _element.outerHeight)(toTD) - minTop;
    if (this.isEntireRowSelected(fromColumn, toColumn)) {
      const columnHeader = fromColumn;
      const modifiedValues = this.getDimensionsFromHeader('rows', fromRow, toRow, columnHeader, containerOffset);
      let fromTH = null;
      if (modifiedValues) {
        [fromTH, top, height] = modifiedValues;
      }
      if (fromTH) {
        fromTD = fromTH;
      }
    }
    const style = rootWindow.getComputedStyle(fromTD);
    if (parseInt(style.borderTopWidth, 10) > 0) {
      top += 1;
      height = height > 0 ? height - 1 : 0;
    }
    if (parseInt(style[isRtl ? 'borderRightWidth' : 'borderLeftWidth'], 10) > 0) {
      inlineStartPos += 1;
      width = width > 0 ? width - 1 : 0;
    }
    const inlinePosProperty = isRtl ? 'right' : 'left';
    this.topStyle.top = `${top}px`;
    this.topStyle[inlinePosProperty] = `${inlineStartPos}px`;
    this.topStyle.width = `${width}px`;
    this.topStyle.display = 'block';
    this.startStyle.top = `${top}px`;
    this.startStyle[inlinePosProperty] = `${inlineStartPos}px`;
    this.startStyle.height = `${height}px`;
    this.startStyle.display = 'block';
    const delta = Math.floor(this.settings.border.width / 2);
    this.bottomStyle.top = `${top + height - delta}px`;
    this.bottomStyle[inlinePosProperty] = `${inlineStartPos}px`;
    this.bottomStyle.width = `${width}px`;
    this.bottomStyle.display = 'block';
    this.endStyle.top = `${top}px`;
    this.endStyle[inlinePosProperty] = `${inlineStartPos + width - delta}px`;
    this.endStyle.height = `${height + 1}px`;
    this.endStyle.display = 'block';
    let cornerVisibleSetting = this.settings.border.cornerVisible;
    cornerVisibleSetting = typeof cornerVisibleSetting === 'function' ? cornerVisibleSetting(this.settings.layerLevel) : cornerVisibleSetting;
    const hookResult = this.wot.getSetting('onModifyGetCellCoords', toRow, toColumn, false, 'render');
    let [checkRow, checkCol] = [toRow, toColumn];
    if (hookResult && Array.isArray(hookResult)) {
      [,, checkRow, checkCol] = hookResult;
    }
    if ((0, _browser.isMobileBrowser)() || !cornerVisibleSetting || this.isPartRange(checkRow, checkCol)) {
      this.cornerStyle.display = 'none';
    } else {
      this.cornerStyle.top = `${top + height + this.cornerCenterPointOffset - this.cornerDefaultStyle.borderWidth}px`;
      this.cornerStyle[inlinePosProperty] = `${inlineStartPos + width + this.cornerCenterPointOffset - this.cornerDefaultStyle.borderWidth}px`;
      this.cornerStyle.borderRightWidth = `${this.cornerDefaultStyle.borderWidth}px`;
      this.cornerStyle.borderLeftWidth = `${this.cornerDefaultStyle.borderWidth}px`;
      this.cornerStyle.borderBottomWidth = `${this.cornerDefaultStyle.borderWidth}px`;
      this.cornerStyle.width = this.cornerDefaultStyle.width;

      // Hide the fill handle, so the possible further adjustments won't force unneeded scrollbars.
      this.cornerStyle.display = 'none';
      let trimmingContainer = (0, _element.getTrimmingContainer)(wtTable.TABLE);
      const trimToWindow = trimmingContainer === rootWindow;
      if (trimToWindow) {
        trimmingContainer = rootDocument.documentElement;
      }

      // -1 was initially removed from the base position to compansate for the table border. We need to exclude it from
      // the corner width.
      const cornerBorderCompensation = parseInt(this.cornerDefaultStyle.borderWidth, 10) - 1;
      const cornerHalfWidth = Math.ceil(parseInt(this.cornerDefaultStyle.width, 10) / 2);
      const cornerHalfHeight = Math.ceil(parseInt(this.cornerDefaultStyle.height, 10) / 2);
      if (toColumn === this.wot.getSetting('totalColumns') - 1) {
        const toTdOffsetLeft = trimToWindow ? toTD.getBoundingClientRect().left : toTD.offsetLeft;
        let cornerOverlappingContainer = false;
        let cornerEdge = 0;
        if (isRtl) {
          cornerEdge = toTdOffsetLeft - parseInt(this.cornerDefaultStyle.width, 10) / 2;
          cornerOverlappingContainer = cornerEdge < 0;
        } else {
          cornerEdge = toTdOffsetLeft + (0, _element.outerWidth)(toTD) + parseInt(this.cornerDefaultStyle.width, 10) / 2;
          cornerOverlappingContainer = cornerEdge >= (0, _element.innerWidth)(trimmingContainer);
        }
        if (cornerOverlappingContainer) {
          this.cornerStyle[inlinePosProperty] = `${Math.floor(inlineStartPos + width + this.cornerCenterPointOffset - cornerHalfWidth - cornerBorderCompensation)}px`;
          this.cornerStyle[isRtl ? 'borderLeftWidth' : 'borderRightWidth'] = 0;
        }
      }
      if (toRow === this.wot.getSetting('totalRows') - 1) {
        const toTdOffsetTop = trimToWindow ? toTD.getBoundingClientRect().top : toTD.offsetTop;
        const cornerBottomEdge = toTdOffsetTop + (0, _element.outerHeight)(toTD) + parseInt(this.cornerDefaultStyle.height, 10) / 2;
        const cornerOverlappingContainer = cornerBottomEdge >= (0, _element.innerHeight)(trimmingContainer);
        if (cornerOverlappingContainer) {
          this.cornerStyle.top = `${Math.floor(top + height + this.cornerCenterPointOffset - cornerHalfHeight - cornerBorderCompensation)}px`;
          this.cornerStyle.borderBottomWidth = 0;
        }
      }
      this.cornerStyle.display = 'block';
    }
    if ((0, _browser.isMobileBrowser)() && this.instance.getSetting('isDataViewInstance')) {
      this.updateMultipleSelectionHandlesPosition(toRow, toColumn, top, inlineStartPos, width, height);
    }
  }

  /**
   * Check whether an entire column of cells is selected.
   *
   * @private
   * @param {number} startRowIndex Start row index.
   * @param {number} endRowIndex End row index.
   * @returns {boolean}
   */
  isEntireColumnSelected(startRowIndex, endRowIndex) {
    return startRowIndex === this.wot.wtTable.getFirstRenderedRow() && endRowIndex === this.wot.wtTable.getLastRenderedRow();
  }

  /**
   * Check whether an entire row of cells is selected.
   *
   * @private
   * @param {number} startColumnIndex Start column index.
   * @param {number} endColumnIndex End column index.
   * @returns {boolean}
   */
  isEntireRowSelected(startColumnIndex, endColumnIndex) {
    return startColumnIndex === this.wot.wtTable.getFirstRenderedColumn() && endColumnIndex === this.wot.wtTable.getLastRenderedColumn();
  }

  /**
   * Get left/top index and width/height depending on the `direction` provided.
   *
   * @private
   * @param {string} direction `rows` or `columns`, defines if an entire column or row is selected.
   * @param {number} fromIndex Start index of the selection.
   * @param {number} toIndex End index of the selection.
   * @param {number} headerIndex The header index as negative value.
   * @param {number} containerOffset Offset of the container.
   * @returns {Array|boolean} Returns an array of [headerElement, left, width] or [headerElement, top, height], depending on `direction` (`false` in case of an error getting the headers).
   */
  getDimensionsFromHeader(direction, fromIndex, toIndex, headerIndex, containerOffset) {
    const {
      wtTable
    } = this.wot;
    const rootHotElement = wtTable.wtRootElement.parentNode;
    let getHeaderFn = null;
    let dimensionFn = null;
    let entireSelectionClassname = null;
    let index = null;
    let dimension = null;
    let dimensionProperty = null;
    let startHeader = null;
    let endHeader = null;
    switch (direction) {
      case 'rows':
        getHeaderFn = function () {
          return wtTable.getRowHeader(...arguments);
        };
        dimensionFn = function () {
          return (0, _element.outerHeight)(...arguments);
        };
        entireSelectionClassname = 'ht__selection--rows';
        dimensionProperty = 'top';
        break;
      case 'columns':
        getHeaderFn = function () {
          return wtTable.getColumnHeader(...arguments);
        };
        dimensionFn = function () {
          return (0, _element.outerWidth)(...arguments);
        };
        entireSelectionClassname = 'ht__selection--columns';
        dimensionProperty = 'left';
        break;
      default:
    }
    if (rootHotElement.classList.contains(entireSelectionClassname)) {
      const columnHeaderLevelCount = this.wot.getSetting('columnHeaders').length;
      startHeader = getHeaderFn(fromIndex, columnHeaderLevelCount - headerIndex);
      endHeader = getHeaderFn(toIndex, columnHeaderLevelCount - headerIndex);
      if (!startHeader || !endHeader) {
        return false;
      }
      const startHeaderOffset = (0, _element.offset)(startHeader);
      const endOffset = (0, _element.offset)(endHeader);
      if (startHeader && endHeader) {
        index = startHeaderOffset[dimensionProperty] - containerOffset[dimensionProperty] - 1;
        dimension = endOffset[dimensionProperty] + dimensionFn(endHeader) - startHeaderOffset[dimensionProperty];
      }
      return [startHeader, index, dimension];
    }
    return false;
  }

  /**
   * Change border style.
   *
   * @private
   * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.
   * @param {object} border The border object descriptor.
   */
  changeBorderStyle(borderElement, border) {
    const style = this[borderElement].style;
    const borderStyle = border[borderElement];
    if (!borderStyle || borderStyle.hide) {
      (0, _element.addClass)(this[borderElement], 'hidden');
    } else {
      if ((0, _element.hasClass)(this[borderElement], 'hidden')) {
        (0, _element.removeClass)(this[borderElement], 'hidden');
      }
      style.backgroundColor = borderStyle.color;
      if (borderElement === 'top' || borderElement === 'bottom') {
        style.height = `${borderStyle.width}px`;
      }
      if (borderElement === 'start' || borderElement === 'end') {
        style.width = `${borderStyle.width}px`;
      }
    }
  }

  /**
   * Change border style to default.
   *
   * @private
   * @param {string} position The position type ("top", "bottom", "start", "end") to change.
   */
  changeBorderToDefaultStyle(position) {
    const defaultBorder = {
      width: 1,
      color: '#000'
    };
    const style = this[position].style;
    style.backgroundColor = defaultBorder.color;
    style.width = `${defaultBorder.width}px`;
    style.height = `${defaultBorder.width}px`;
  }

  /**
   * Toggle class 'hidden' to element.
   *
   * @private
   * @param {string} borderElement Coordinate where add/remove border: top, bottom, start, end.
   * @param {boolean} [remove] Defines type of the action to perform.
   */
  toggleHiddenClass(borderElement, remove) {
    this.changeBorderToDefaultStyle(borderElement);
    if (remove) {
      (0, _element.addClass)(this[borderElement], 'hidden');
    } else {
      (0, _element.removeClass)(this[borderElement], 'hidden');
    }
  }

  /**
   * Hide border.
   */
  disappear() {
    this.topStyle.display = 'none';
    this.bottomStyle.display = 'none';
    this.startStyle.display = 'none';
    this.endStyle.display = 'none';
    this.cornerStyle.display = 'none';
    if ((0, _browser.isMobileBrowser)() && this.instance.getSetting('isDataViewInstance')) {
      this.selectionHandles.styles.top.display = 'none';
      this.selectionHandles.styles.topHitArea.display = 'none';
      this.selectionHandles.styles.bottom.display = 'none';
      this.selectionHandles.styles.bottomHitArea.display = 'none';
    }
  }

  /**
   * Cleans up all the DOM state related to a Border instance. Call this prior to deleting a Border instance.
   */
  destroy() {
    this.eventManager.destroyWithOwnEventsOnly();
    this.main.parentNode.removeChild(this.main);
  }
}
var _default = exports["default"] = Border;

/***/ }),
/* 606 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _topInlineStartCorner = _interopRequireDefault(__webpack_require__(607));
var _base = __webpack_require__(586);
var _constants = __webpack_require__(587);
/**
 * @class TopInlineStartCornerOverlay
 */
class TopInlineStartCornerOverlay extends _base.Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   * @param {TopOverlay} topOverlay The instance of the Top overlay.
   * @param {InlineStartOverlay} inlineStartOverlay The instance of the InlineStart overlay.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings, topOverlay, inlineStartOverlay) {
    super(wotInstance, facadeGetter, _constants.CLONE_TOP_INLINE_START_CORNER, wtSettings, domBindings);
    /**
     * The instance of the Top overlay.
     *
     * @type {TopOverlay}
     */
    (0, _defineProperty2.default)(this, "topOverlay", void 0);
    /**
     * The instance of the InlineStart overlay.
     *
     * @type {InlineStartOverlay}
     */
    (0, _defineProperty2.default)(this, "inlineStartOverlay", void 0);
    this.topOverlay = topOverlay;
    this.inlineStartOverlay = inlineStartOverlay;
  }

  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {TopInlineStartCornerOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new _topInlineStartCorner.default(...args);
  }

  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting('shouldRenderTopOverlay') && this.wtSettings.getSetting('shouldRenderInlineStartOverlay');
  }

  /**
   * Updates the corner overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    this.updateTrimmingContainer();
    if (!this.wot.wtTable.holder.parentNode) {
      // removed from DOM
      return false;
    }
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    if (this.trimmingContainer === this.domBindings.rootWindow) {
      const left = this.inlineStartOverlay.getOverlayOffset() * (this.isRtl() ? -1 : 1);
      const top = this.topOverlay.getOverlayOffset();
      (0, _element.setOverlayPosition)(overlayRoot, `${left}px`, `${top}px`);
    } else {
      (0, _element.resetCssTransform)(overlayRoot);
    }
    let tableHeight = (0, _element.outerHeight)(this.clone.wtTable.TABLE);
    const tableWidth = (0, _element.outerWidth)(this.clone.wtTable.TABLE);
    if (!this.wot.wtTable.hasDefinedSize()) {
      tableHeight = 0;
    }
    overlayRoot.style.height = `${tableHeight}px`;
    overlayRoot.style.width = `${tableWidth}px`;
    return false;
  }
}
exports.TopInlineStartCornerOverlay = TopInlineStartCornerOverlay;

/***/ }),
/* 607 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _table = _interopRequireDefault(__webpack_require__(564));
var _stickyRowsTop = _interopRequireDefault(__webpack_require__(608));
var _stickyColumnsStart = _interopRequireDefault(__webpack_require__(585));
var _object = __webpack_require__(499);
var _overlay = __webpack_require__(561);
/**
 * Subclass of `Table` that provides the helper methods relevant to topInlineStartCornerOverlay
 * (in RTL mode the overlay sits on the right of the screen), implemented through mixins.
 *
 * @mixes stickyRowsTop
 * @mixes stickyColumnsStart
 */
class TopInlineStartCornerOverlayTable extends _table.default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, _overlay.CLONE_TOP_INLINE_START_CORNER);
  }
}
(0, _object.mixin)(TopInlineStartCornerOverlayTable, _stickyRowsTop.default);
(0, _object.mixin)(TopInlineStartCornerOverlayTable, _stickyColumnsStart.default);
var _default = exports["default"] = TopInlineStartCornerOverlayTable;

/***/ }),
/* 608 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _object = __webpack_require__(499);
const MIXIN_NAME = 'stickyRowsTop';

/**
 * Mixin for the subclasses of `Table` with implementations of
 * helper methods that are related to rows.
 * This mixin is meant to be applied in the subclasses of `Table`
 * that use sticky rendering of the top rows in the vertical axis.
 *
 * @type {object}
 */
const stickyRowsTop = {
  /**
   * Get the source index of the first rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getFirstRenderedRow() {
    const totalRows = this.wtSettings.getSetting('totalRows');
    if (totalRows === 0) {
      return -1;
    }
    return 0;
  },
  /**
   * Get the source index of the first row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstVisibleRow() {
    return this.getFirstRenderedRow();
  },
  /**
   * Get the source index of the first row partially visible in the viewport. If no rows are partially visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getFirstPartiallyVisibleRow() {
    return this.getFirstRenderedRow();
  },
  /**
   * Get the source index of the last rendered row. If no rows are rendered, returns an error code: -1.
   *
   * @returns {number}
   * @this Table
   */
  getLastRenderedRow() {
    return this.getRenderedRowsCount() - 1;
  },
  /**
   * Get the source index of the last row fully visible in the viewport. If no rows are fully visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastVisibleRow() {
    return this.getLastRenderedRow();
  },
  /**
   * Get the source index of the last row partially visible in the viewport. If no rows are partially visible, returns an error code: -1.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getLastPartiallyVisibleRow() {
    return this.getLastRenderedRow();
  },
  /**
   * Get the number of rendered rows.
   *
   * @returns {number}
   * @this Table
   */
  getRenderedRowsCount() {
    const totalRows = this.wtSettings.getSetting('totalRows');
    return Math.min(this.wtSettings.getSetting('fixedRowsTop'), totalRows);
  },
  /**
   * Get the number of fully visible rows in the viewport.
   * Assumes that all rendered rows are fully visible.
   *
   * @returns {number}
   * @this Table
   */
  getVisibleRowsCount() {
    return this.getRenderedRowsCount();
  },
  /**
   * Get the number of rendered column headers.
   *
   * @returns {number}
   * @this Table
   */
  getColumnHeadersCount() {
    return this.dataAccessObject.columnHeaders.length;
  }
};
(0, _object.defineGetter)(stickyRowsTop, 'MIXIN_NAME', MIXIN_NAME, {
  writable: false,
  enumerable: false
});
var _default = exports["default"] = stickyRowsTop;

/***/ }),
/* 609 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _top = _interopRequireDefault(__webpack_require__(610));
var _base = __webpack_require__(586);
var _selection = __webpack_require__(597);
var _constants = __webpack_require__(587);
/**
 * @class TopOverlay
 */
class TopOverlay extends _base.Overlay {
  /**
   * @param {Walkontable} wotInstance The Walkontable instance. @TODO refactoring: check if can be deleted.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {DomBindings} domBindings Dom elements bound to the current instance.
   */
  constructor(wotInstance, facadeGetter, wtSettings, domBindings) {
    super(wotInstance, facadeGetter, _constants.CLONE_TOP, wtSettings, domBindings);
    /**
     * Cached value which holds the previous value of the `fixedRowsTop` option.
     * It is used as a comparison value that can be used to detect changes in this value.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "cachedFixedRowsTop", -1);
    this.cachedFixedRowsTop = this.wtSettings.getSetting('fixedRowsTop');
  }

  /**
   * Factory method to create a subclass of `Table` that is relevant to this overlay.
   *
   * @see Table#constructor
   * @param {...*} args Parameters that will be forwarded to the `Table` constructor.
   * @returns {TopOverlayTable}
   */
  createTable() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new _top.default(...args);
  }

  /**
   * Checks if overlay should be fully rendered.
   *
   * @returns {boolean}
   */
  shouldBeRendered() {
    return this.wtSettings.getSetting('shouldRenderTopOverlay');
  }

  /**
   * Updates the top overlay position.
   *
   * @returns {boolean}
   */
  resetFixedPosition() {
    if (!this.needFullRender || !this.shouldBeRendered() || !this.wot.wtTable.holder.parentNode) {
      // removed from DOM
      return false;
    }
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const {
      rootWindow
    } = this.domBindings;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    let overlayPosition = 0;
    let skipInnerBorderAdjusting = false;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'vertical')) {
      const {
        wtTable
      } = this.wot;
      const hiderRect = wtTable.hider.getBoundingClientRect();
      const bottom = Math.ceil(hiderRect.bottom);
      const rootHeight = overlayRoot.offsetHeight;

      // This checks if the overlay is going to an infinite loop caused by added (or removed)
      // `innerBorderTop` class name. Toggling the class name shifts the viewport by 1px and
      // triggers the `scroll` event. It causes the table to render. The new render cycle takes into,
      // account the shift and toggles the class name again. This causes the next loops. This
      // happens only on Chrome (#7256).
      //
      // When we detect that the table bottom position is the same as the overlay bottom,
      // do not toggle the class name.
      //
      // This workaround will be able to be cleared after merging the SVG borders, which introduces
      // frozen lines (no more `innerBorderTop` workaround).
      skipInnerBorderAdjusting = bottom === rootHeight;
      overlayPosition = this.getOverlayOffset();
      (0, _element.setOverlayPosition)(overlayRoot, '0px', `${overlayPosition}px`);
    } else {
      overlayPosition = this.getScrollPosition();
      (0, _element.resetCssTransform)(overlayRoot);
    }
    const positionChanged = this.adjustHeaderBordersPosition(overlayPosition, skipInnerBorderAdjusting);
    this.adjustElementsSize();
    return positionChanged;
  }

  /**
   * Sets the main overlay's vertical scroll position.
   *
   * @param {number} pos The scroll position.
   * @returns {boolean}
   */
  setScrollPosition(pos) {
    const rootWindow = this.domBindings.rootWindow;
    let result = false;
    if (this.mainTableScrollableElement === rootWindow && rootWindow.scrollY !== pos) {
      rootWindow.scrollTo((0, _element.getWindowScrollLeft)(rootWindow), pos);
      result = true;
    } else if (this.mainTableScrollableElement.scrollTop !== pos) {
      this.mainTableScrollableElement.scrollTop = pos;
      result = true;
    }
    return result;
  }

  /**
   * Triggers onScroll hook callback.
   */
  onScroll() {
    this.wtSettings.getSetting('onScrollHorizontally');
  }

  /**
   * Calculates total sum cells height.
   *
   * @param {number} from Row index which calculates started from.
   * @param {number} to Row index where calculation is finished.
   * @returns {number} Height sum.
   */
  sumCellSizes(from, to) {
    const defaultRowHeight = this.wot.stylesHandler.getDefaultRowHeight();
    let row = from;
    let sum = 0;
    while (row < to) {
      const height = this.wot.wtTable.getRowHeight(row);
      sum += height === undefined ? defaultRowHeight : height;
      row += 1;
    }
    return sum;
  }

  /**
   * Adjust overlay root element, children and master table element sizes (width, height).
   */
  adjustElementsSize() {
    this.updateTrimmingContainer();
    if (this.needFullRender) {
      this.adjustRootElementSize();
      this.adjustRootChildrenSize();
    }
  }

  /**
   * Adjust overlay root element size (width and height).
   */
  adjustRootElementSize() {
    const {
      wtTable,
      wtViewport
    } = this.wot;
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const overlayRoot = this.clone.wtTable.holder.parentNode;
    const overlayRootStyle = overlayRoot.style;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    if (this.trimmingContainer !== rootWindow || preventOverflow === 'horizontal') {
      let width = wtViewport.getWorkspaceWidth();
      if (wtViewport.hasVerticalScroll()) {
        width -= (0, _element.getScrollbarWidth)(rootDocument);
      }
      width = Math.min(width, wtTable.wtRootElement.scrollWidth);
      overlayRootStyle.width = `${width}px`;
    } else {
      overlayRootStyle.width = '';
    }
    this.clone.wtTable.holder.style.width = overlayRootStyle.width;
    let tableHeight = (0, _element.outerHeight)(this.clone.wtTable.TABLE);
    if (!wtTable.hasDefinedSize()) {
      tableHeight = 0;
    }
    overlayRootStyle.height = `${tableHeight}px`;
  }

  /**
   * Adjust overlay root childs size.
   */
  adjustRootChildrenSize() {
    const {
      holder
    } = this.clone.wtTable;
    const cornerStyle = (0, _selection.getCornerStyle)(this.wot);
    const selectionCornerOffset = this.wot.selectionManager.getFocusSelection() ? parseInt(cornerStyle.height, 10) / 2 : 0;
    this.clone.wtTable.hider.style.width = this.hider.style.width;
    holder.style.width = holder.parentNode.style.width;
    // Add selection corner protruding part to the holder total height to make sure that
    // borders' corner won't be cut after vertical scroll (#6937).
    holder.style.height = `${parseInt(holder.parentNode.style.height, 10) + selectionCornerOffset}px`;
  }

  /**
   * Adjust the overlay dimensions and position.
   */
  applyToDOM() {
    const total = this.wtSettings.getSetting('totalRows');
    if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
      this.spreader.style.top = `${this.wot.wtViewport.rowsRenderCalculator.startPosition}px`;
    } else if (total === 0) {
      // can happen if there are 0 rows
      this.spreader.style.top = '0';
    } else {
      throw new Error('Incorrect value of the rowsRenderCalculator');
    }
    this.spreader.style.bottom = '';
    if (this.needFullRender) {
      this.syncOverlayOffset();
    }
  }

  /**
   * Synchronize calculated left position to an element.
   */
  syncOverlayOffset() {
    const styleProperty = this.isRtl() ? 'right' : 'left';
    const {
      spreader
    } = this.clone.wtTable;
    if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
      spreader.style[styleProperty] = `${this.wot.wtViewport.columnsRenderCalculator.startPosition}px`;
    } else {
      spreader.style[styleProperty] = '';
    }
  }

  /**
   * Scrolls vertically to a row.
   *
   * @param {number} sourceRow Row index which you want to scroll to.
   * @param {boolean} [bottomEdge] If `true`, scrolls according to the bottom edge (top edge is by default).
   * @returns {boolean}
   */
  scrollTo(sourceRow, bottomEdge) {
    const {
      wot,
      wtSettings
    } = this;
    const sourceInstance = wot.cloneSource ? wot.cloneSource : wot;
    const mainHolder = sourceInstance.wtTable.holder;
    const columnHeaders = wtSettings.getSetting('columnHeaders');
    const fixedRowsTop = wtSettings.getSetting('fixedRowsTop');
    const columnHeaderBorderCompensation = fixedRowsTop === 0 && columnHeaders.length > 0 && !(0, _element.hasClass)(mainHolder.parentNode, 'innerBorderTop') ? 1 : 0;
    let newY = this.getTableParentOffset();
    let scrollbarCompensation = 0;
    if (bottomEdge) {
      const rowHeight = this.wot.wtTable.getRowHeight(sourceRow);
      const viewportHeight = this.wot.wtViewport.getViewportHeight();
      if (rowHeight > viewportHeight) {
        bottomEdge = false;
      }
    }
    if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
      scrollbarCompensation = (0, _element.getScrollbarWidth)(this.domBindings.rootDocument);
    }
    if (bottomEdge) {
      const fixedRowsBottom = wtSettings.getSetting('fixedRowsBottom');
      const totalRows = wtSettings.getSetting('totalRows');
      newY += this.sumCellSizes(0, sourceRow + 1);
      newY -= wot.wtViewport.getViewportHeight() - this.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
      // Fix 1 pixel offset when cell is selected
      newY += 1;
      // Compensate for the bottom header border if scrolled from the absolute top.
      newY += columnHeaderBorderCompensation;
    } else {
      newY += this.sumCellSizes(wtSettings.getSetting('fixedRowsTop'), sourceRow);
    }
    newY += scrollbarCompensation;

    // If the table is scrolled all the way up when starting the scroll and going to be scrolled to the bottom,
    // we need to compensate for the potential header bottom border height.
    if ((0, _element.getMaximumScrollTop)(this.mainTableScrollableElement) === newY - columnHeaderBorderCompensation && columnHeaderBorderCompensation > 0) {
      this.wot.wtOverlays.expandHiderVerticallyBy(columnHeaderBorderCompensation);
    }
    return this.setScrollPosition(newY);
  }

  /**
   * Gets table parent top position.
   *
   * @returns {number}
   */
  getTableParentOffset() {
    if (this.mainTableScrollableElement === this.domBindings.rootWindow) {
      return this.wot.wtTable.holderOffset.top;
    }
    return 0;
  }

  /**
   * Gets the main overlay's vertical scroll position.
   *
   * @returns {number} Main table's vertical scroll position.
   */
  getScrollPosition() {
    return (0, _element.getScrollTop)(this.mainTableScrollableElement, this.domBindings.rootWindow);
  }

  /**
   * Gets the main overlay's vertical overlay offset.
   *
   * @returns {number} Main table's vertical overlay offset.
   */
  getOverlayOffset() {
    const {
      rootWindow
    } = this.domBindings;
    const preventOverflow = this.wtSettings.getSetting('preventOverflow');
    let overlayOffset = 0;
    if (this.trimmingContainer === rootWindow && (!preventOverflow || preventOverflow !== 'vertical')) {
      const rootHeight = this.wot.wtTable.getTotalHeight();
      const overlayRootHeight = this.clone.wtTable.getTotalHeight();
      const maxOffset = rootHeight - overlayRootHeight;
      overlayOffset = Math.max(this.getScrollPosition() - this.getTableParentOffset(), 0);
      if (overlayOffset > maxOffset) {
        overlayOffset = 0;
      }
    }
    return overlayOffset;
  }

  /**
   * Adds css classes to hide the header border's header (cell-selection border hiding issue).
   *
   * @param {number} position Header Y position if trimming container is window or scroll top if not.
   * @param {boolean} [skipInnerBorderAdjusting=false] If `true` the inner border adjusting will be skipped.
   * @returns {boolean}
   */
  adjustHeaderBordersPosition(position) {
    let skipInnerBorderAdjusting = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const {
      wtSettings
    } = this;
    const masterParent = this.wot.wtTable.holder.parentNode;
    const totalColumns = wtSettings.getSetting('totalColumns');
    const preventHorizontalOverflow = wtSettings.getSetting('preventOverflow') === 'horizontal';
    if (totalColumns) {
      (0, _element.removeClass)(masterParent, 'emptyColumns');
    } else {
      (0, _element.addClass)(masterParent, 'emptyColumns');
    }
    let positionChanged = false;
    if (!skipInnerBorderAdjusting && !preventHorizontalOverflow) {
      const fixedRowsTop = wtSettings.getSetting('fixedRowsTop');
      const areFixedRowsTopChanged = this.cachedFixedRowsTop !== fixedRowsTop;
      const columnHeaders = wtSettings.getSetting('columnHeaders');
      if ((areFixedRowsTopChanged || fixedRowsTop === 0) && columnHeaders.length > 0) {
        const previousState = (0, _element.hasClass)(masterParent, 'innerBorderTop');
        this.cachedFixedRowsTop = wtSettings.getSetting('fixedRowsTop');
        if (position || wtSettings.getSetting('totalRows') === 0) {
          (0, _element.addClass)(masterParent, 'innerBorderTop');
          positionChanged = !previousState;
        } else {
          (0, _element.removeClass)(masterParent, 'innerBorderTop');
          positionChanged = previousState;
        }
      }
    }
    return positionChanged;
  }
}
exports.TopOverlay = TopOverlay;

/***/ }),
/* 610 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _table = _interopRequireDefault(__webpack_require__(564));
var _stickyRowsTop = _interopRequireDefault(__webpack_require__(608));
var _calculatedColumns = _interopRequireDefault(__webpack_require__(593));
var _object = __webpack_require__(499);
var _overlay = __webpack_require__(561);
/**
 * Subclass of `Table` that provides the helper methods relevant to TopOverlay, implemented through mixins.
 *
 * @mixes stickyRowsTop
 * @mixes calculatedColumns
 */
class TopOverlayTable extends _table.default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, _overlay.CLONE_TOP);
  }
}
(0, _object.mixin)(TopOverlayTable, _stickyRowsTop.default);
(0, _object.mixin)(TopOverlayTable, _calculatedColumns.default);
var _default = exports["default"] = TopOverlayTable;

/***/ }),
/* 611 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _element = __webpack_require__(351);
var _object = __webpack_require__(499);
/**
 * @todo Describe options.
 * @typedef SettingsPure
 *
 * @property {Option} facade @todo desc.
 * @property {Option} ariaTags Option `ariaTags`.
 * @property {Option} cellRenderer Option `cellRenderer`.
 * @property {Option} columnHeaders Option `columnHeaders`.
 * @property {Option} columnWidth Option `columnWidth`.
 * @property {Option} currentRowClassName Option `currentRowClassName`.
 * @property {Option} data Option `data`.
 * @property {Option} defaultColumnWidth Option `defaultColumnWidth`.
 * @property {Option} externalRowCalculator Option `externalRowCalculator`.
 * @property {Option} fixedColumnsStart Option `fixedColumnsStart`.
 * @property {Option} fixedRowsBottom Option `fixedRowsBottom`.
 * @property {Option} fixedRowsTop Option `fixedRowsTop`.
 * @property {Option} groups Option `groups`.
 * @property {Option} hideBorderOnMouseDownOver Option `hideBorderOnMouseDownOver`.
 * @property {Option} isRtl Option `isRtl`.
 * @property {Option} isDataViewInstance Option `isDataViewInstance`.
 * @property {Option} minSpareRows Option `minSpareRows`.
 * @property {Option} onBeforeHighlightingColumnHeader Option `onBeforeHighlightingColumnHeader`.
 * @property {Option} onBeforeHighlightingRowHeader Option `onBeforeHighlightingRowHeader`.
 * @property {Option} onBeforeRemoveCellClassNames Option `onBeforeRemoveCellClassNames`.
 * @property {Option} preventOverflow Option `preventOverflow`.
 * @property {Option} preventWheel Option `preventWheel`.
 * @property {Option} renderAllColumns Option `renderAllColumns`.
 * @property {Option} renderAllRows Option `renderAllRows`.
 * @property {Option} rowHeaders Option `rowHeaders`.
 * @property {Option} rowHeightOption `rowHeight`.
 * @property {Option} rowHeightByOverlayName Option `rowHeightByOverlayName`.
 * @property {Option} shouldRenderBottomOverlay Option `shouldRenderBottomOverlay`.
 * @property {Option} shouldRenderInlineStartOverlay Option `shouldRenderInlineStartOverlay`.
 * @property {Option} shouldRenderTopOverlay Option `shouldRenderTopOverlay`.
 * @property {Option} table Option `table`.
 * @property {Option} totalColumns Option `totalColumns`.
 * @property {Option} totalRows Option `totalRows`.
 * @property {?Option} beforeDraw Option `beforeDraw`.
 * @property {?Option} columnHeaderHeight Option `columnHeaderHeight`.
 * @property {?Option} currentColumnClassName Option `currentColumnClassName`.
 * @property {?Option} headerClassName Option `headerClassName`.
 * @property {?Option} onAfterDrawSelection Option `onAfterDrawSelection`.
 * @property {?Option} onAfterMomentumScroll Option `onAfterMomentumScroll`.
 * @property {?Option} onBeforeDrawBorders Option `onBeforeDrawBorders`.
 * @property {?Option} onBeforeTouchScroll Option `onBeforeTouchScroll`.
 * @property {?Option} onCellContextMenu Option `onCellContextMenu`.
 * @property {?Option} onCellCornerDblClick Option `onCellCornerDblClick`.
 * @property {?Option} onCellCornerMouseDown Option `onCellCornerMouseDown`.
 * @property {?Option} onCellDblClick Option `onCellDblClick`.
 * @property {?Option} onCellMouseDown Option `onCellMouseDown`.
 * @property {?Option} onCellMouseOut Option `onCellMouseOut`.
 * @property {?Option} onCellMouseOver Option `onCellMouseOver`.
 * @property {?Option} onCellMouseUp Option `onCellMouseUp`.
 * @property {?Option} onDraw Option `onDraw`.
 * @property {?Option} onModifyGetCellCoords Option `onModifyGetCellCoords`.
 * @property {?Option} onModifyGetCoordsElement Option `onModifyGetCoordsElement`.
 * @property {?Option} onModifyGetCoords Option `onModifyGetCoords`.
 * @property {?Option} onModifyRowHeaderWidth Option `onModifyRowHeaderWidth`.
 * @property {?Option} onBeforeViewportScrollHorizontally Option `onBeforeViewportScrollHorizontally`.
 * @property {?Option} onBeforeViewportScrollVertically Option `onBeforeViewportScrollVertically`.
 * @property {?Option} onScrollHorizontally Option `onScrollHorizontally`.
 * @property {?Option} onScrollVertically Option `onScrollVertically`.
 * @property {?Option} onWindowResize Option `onWindowResize`.
 * @property {?Option} rowHeaderWidth Option `rowHeaderWidth`.
 * @property {?Option} selections Option `selections`.
 * @property {?Option} viewportColumnCalculatorOverride Option `viewportColumnCalculatorOverride`.
 * @property {?Option} viewportRowCalculatorOverride Option `viewportRowCalculatorOverride`.
 * @property {?Option} viewportColumnRenderingThreshold Option `viewportColumnRenderingThreshold`.
 * @property {?Option} viewportRowRenderingThreshold Option `viewportRowRenderingThreshold`.
 */

/**
 * @template TValue.
 * @typedef { TValue | Array.<TValue> | (function(...*): TValue) } Option
 */

/**
 * @class Settings
 */
class Settings {
  /**
   * @param {SettingsPure} settings The user defined settings.
   */
  constructor(settings) {
    /**
     * Reference to settings.
     *
     * @protected
     * @type {SettingsPure}
     */
    (0, _defineProperty2.default)(this, "settings", {});
    /**
     * The defaults values of settings.
     * Void 0 means it is required, null means it can be empty.
     *
     * @public
     * @type {Readonly<SettingsPure>}
     */
    (0, _defineProperty2.default)(this, "defaults", Object.freeze(this.getDefaults()));
    (0, _object.objectEach)(this.defaults, (value, key) => {
      if (settings[key] !== undefined) {
        this.settings[key] = settings[key];
      } else if (value === undefined) {
        throw new Error(`A required setting "${key}" was not provided`);
      } else {
        this.settings[key] = value;
      }
    });
  }

  /**
   * Generate defaults for a settings.
   * Void 0 means it is required, null means it can be empty.
   *
   * @private
   * @returns {SettingsPure}
   */
  getDefaults() {
    return {
      facade: undefined,
      table: undefined,
      // Determines whether the Walkontable instance is used as dataset viewer. When its instance is used as
      // a context menu, autocomplete list, etc, the returned value is `false`.
      isDataViewInstance: true,
      // presentation mode
      externalRowCalculator: false,
      currentRowClassName: null,
      currentColumnClassName: null,
      preventOverflow() {
        return false;
      },
      preventWheel: false,
      // data source
      data: undefined,
      // Number of renderable columns for the left overlay.
      fixedColumnsStart: 0,
      // Number of renderable rows for the top overlay.
      fixedRowsTop: 0,
      // Number of renderable rows for the bottom overlay.
      fixedRowsBottom: 0,
      // Enable the inline start overlay when conditions are met (left for LTR and right for RTL document mode).
      shouldRenderInlineStartOverlay: () => {
        return this.getSetting('fixedColumnsStart') > 0 || this.getSetting('rowHeaders').length > 0;
      },
      // Enable the top overlay when conditions are met.
      shouldRenderTopOverlay: () => {
        return this.getSetting('fixedRowsTop') > 0 || this.getSetting('columnHeaders').length > 0;
      },
      // Enable the bottom overlay when conditions are met.
      shouldRenderBottomOverlay: () => {
        return this.getSetting('fixedRowsBottom') > 0;
      },
      minSpareRows: 0,
      // this must be array of functions: [function (row, TH) {}]
      rowHeaders() {
        return [];
      },
      // this must be array of functions: [function (column, TH) {}]
      columnHeaders() {
        return [];
      },
      totalRows: undefined,
      totalColumns: undefined,
      cellRenderer: (row, column, TD) => {
        const cellData = this.getSetting('data', row, column);
        (0, _element.fastInnerText)(TD, cellData === undefined || cellData === null ? '' : cellData);
      },
      // columnWidth: 50,
      columnWidth() {
        // return undefined means use default size for the rendered cell content
      },
      rowHeight() {
        // return undefined means use default size for the rendered cell content
      },
      rowHeightByOverlayName() {
        // return undefined means use default size for the rendered cell content
      },
      defaultColumnWidth: 50,
      selections: null,
      hideBorderOnMouseDownOver: false,
      viewportRowCalculatorOverride: null,
      viewportColumnCalculatorOverride: null,
      viewportRowRenderingThreshold: null,
      viewportColumnRenderingThreshold: null,
      // callbacks
      onCellMouseDown: null,
      onCellContextMenu: null,
      onCellMouseOver: null,
      onCellMouseOut: null,
      onCellMouseUp: null,
      // onCellMouseOut: null,
      onCellDblClick: null,
      onCellCornerMouseDown: null,
      onCellCornerDblClick: null,
      beforeDraw: null,
      onDraw: null,
      onBeforeRemoveCellClassNames: null,
      onAfterDrawSelection: null,
      onBeforeDrawBorders: null,
      // viewport scroll hooks
      onBeforeViewportScrollHorizontally: column => column,
      onBeforeViewportScrollVertically: row => row,
      // native scroll hooks
      onScrollHorizontally: null,
      onScrollVertically: null,
      //
      onBeforeTouchScroll: null,
      onAfterMomentumScroll: null,
      onModifyRowHeaderWidth: null,
      onModifyGetCellCoords: null,
      onModifyGetCoordsElement: null,
      onModifyGetCoords: null,
      onBeforeHighlightingRowHeader: sourceRow => sourceRow,
      onBeforeHighlightingColumnHeader: sourceCol => sourceCol,
      onWindowResize: null,
      onContainerElementResize: null,
      renderAllColumns: false,
      renderAllRows: false,
      groups: false,
      rowHeaderWidth: null,
      columnHeaderHeight: null,
      headerClassName: null,
      rtlMode: false,
      ariaTags: true
    };
  }

  /**
   * Update settings.
   *
   * @param {object|string} settings The singular settings to update or if passed as object to merge with.
   * @param {*} value The value to set if the first argument is passed as string.
   * @returns {Settings}
   */
  update(settings, value) {
    if (value === undefined) {
      // settings is object
      (0, _object.objectEach)(settings, (settingValue, key) => {
        this.settings[key] = settingValue;
      });
    } else {
      // if value is defined then settings is the key
      this.settings[settings] = value;
    }
    return this;
  }

  /**
   * Get setting by name.
   *
   * @param {$Keys<SettingsPure>} key The settings key to retrieve.
   * @param {*} [param1] Additional parameter passed to the options defined as function.
   * @param {*} [param2] Additional parameter passed to the options defined as function.
   * @param {*} [param3] Additional parameter passed to the options defined as function.
   * @param {*} [param4] Additional parameter passed to the options defined as function.
   * @returns {*}
   */
  getSetting(key, param1, param2, param3, param4) {
    if (typeof this.settings[key] === 'function') {
      return this.settings[key](param1, param2, param3, param4);
    } else if (param1 !== undefined && Array.isArray(this.settings[key])) {
      return this.settings[key][param1];
    }
    return this.settings[key];
  }

  /**
   * Get a setting value without any evaluation.
   *
   * @param {string} key The settings key to retrieve.
   * @returns {*}
   */
  getSettingPure(key) {
    return this.settings[key];
  }

  /**
   * Checks if setting exists.
   *
   * @param {boolean} key The settings key to check.
   * @returns {boolean}
   */
  has(key) {
    return !!this.settings[key];
  }
}
exports["default"] = Settings;

/***/ }),
/* 612 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _element = __webpack_require__(351);
var _table = _interopRequireDefault(__webpack_require__(564));
var _calculatedRows = _interopRequireDefault(__webpack_require__(596));
var _calculatedColumns = _interopRequireDefault(__webpack_require__(593));
var _object = __webpack_require__(499);
/**
 * Subclass of `Table` that provides the helper methods relevant to the master table (not overlays), implemented through mixins.
 *
 * @mixes calculatedRows
 * @mixes calculatedColumns
 */
class MasterTable extends _table.default {
  /**
   * @param {TableDao} dataAccessObject The data access object.
   * @param {FacadeGetter} facadeGetter Function which return proper facade.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   */
  constructor(dataAccessObject, facadeGetter, domBindings, wtSettings) {
    super(dataAccessObject, facadeGetter, domBindings, wtSettings, 'master');
  }
  alignOverlaysWithTrimmingContainer() {
    const trimmingElement = (0, _element.getTrimmingContainer)(this.wtRootElement);
    const {
      rootWindow
    } = this.domBindings;
    if (trimmingElement === rootWindow) {
      const preventOverflow = this.wtSettings.getSetting('preventOverflow');
      if (!preventOverflow) {
        this.holder.style.overflow = 'visible';
        this.wtRootElement.style.overflow = 'visible';
      }
    } else {
      const trimmingElementParent = trimmingElement.parentElement;
      const trimmingHeight = (0, _element.getStyle)(trimmingElement, 'height', rootWindow);
      const trimmingOverflow = (0, _element.getStyle)(trimmingElement, 'overflow', rootWindow);
      const holderStyle = this.holder.style;
      const {
        scrollWidth,
        scrollHeight
      } = trimmingElement;
      let width = trimmingElement.offsetWidth;
      let height = trimmingElement.offsetHeight;
      const overflow = ['auto', 'hidden', 'scroll'];
      if (trimmingElementParent && overflow.includes(trimmingOverflow)) {
        const cloneNode = trimmingElement.cloneNode(false);

        // Before calculating the height of the trimming element, set overflow: auto to hide scrollbars.
        // An issue occurred on Firefox, where an empty element with overflow: scroll returns an element height higher than 0px
        // despite an empty content within.
        cloneNode.style.overflow = 'auto';
        // Issue #9545 shows problem with calculating height for HOT on Firefox while placing instance in some
        // flex containers and setting overflow for some `div` section.
        cloneNode.style.position = 'absolute';
        if (trimmingElement.nextElementSibling) {
          trimmingElementParent.insertBefore(cloneNode, trimmingElement.nextElementSibling);
        } else {
          trimmingElementParent.appendChild(cloneNode);
        }
        const cloneHeight = parseInt(rootWindow.getComputedStyle(cloneNode).height, 10);
        trimmingElementParent.removeChild(cloneNode);
        if (cloneHeight === 0) {
          height = 0;
        }
      }
      height = Math.min(height, scrollHeight);
      holderStyle.height = trimmingHeight === 'auto' ? 'auto' : `${height}px`;
      width = Math.min(width, scrollWidth);
      holderStyle.width = `${width}px`;
      holderStyle.overflow = '';
      this.hasTableHeight = holderStyle.height === 'auto' ? true : height > 0;
      this.hasTableWidth = width > 0;
    }
    this.isTableVisible = (0, _element.isVisible)(this.TABLE);
  }
  markOversizedColumnHeaders() {
    const {
      wtSettings
    } = this;
    const {
      wtViewport
    } = this.dataAccessObject;
    const overlayName = 'master';
    const columnHeaders = wtSettings.getSetting('columnHeaders');
    const columnHeadersCount = columnHeaders.length;
    if (columnHeadersCount && !wtViewport.hasOversizedColumnHeadersMarked[overlayName]) {
      const rowHeaders = wtSettings.getSetting('rowHeaders');
      const rowHeaderCount = rowHeaders.length;
      const columnCount = this.getRenderedColumnsCount();
      for (let i = 0; i < columnHeadersCount; i++) {
        for (let renderedColumnIndex = -1 * rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
          // eslint-disable-line max-len
          this.markIfOversizedColumnHeader(renderedColumnIndex);
        }
      }
      wtViewport.hasOversizedColumnHeadersMarked[overlayName] = true;
    }
  }
}
(0, _object.mixin)(MasterTable, _calculatedRows.default);
(0, _object.mixin)(MasterTable, _calculatedColumns.default);
var _default = exports["default"] = MasterTable;

/***/ }),
/* 613 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(338);
var _element = __webpack_require__(351);
var _object = __webpack_require__(499);
var _calculator = __webpack_require__(541);
/**
 * @class Viewport
 */
class Viewport {
  /**
   * @param {ViewportDao} dataAccessObject The Walkontable instance.
   * @param {DomBindings} domBindings Bindings into DOM.
   * @param {Settings} wtSettings The Walkontable settings.
   * @param {EventManager} eventManager The instance event manager.
   * @param {Table} wtTable The table.
   */
  constructor(dataAccessObject, domBindings, wtSettings, eventManager, wtTable) {
    this.dataAccessObject = dataAccessObject;
    // legacy support
    this.wot = dataAccessObject.wot;
    this.instance = this.wot;
    this.domBindings = domBindings;
    this.wtSettings = wtSettings;
    this.wtTable = wtTable;
    this.oversizedRows = [];
    this.oversizedColumnHeaders = [];
    this.hasOversizedColumnHeadersMarked = {};
    this.clientHeight = 0;
    this.rowHeaderWidth = NaN;
    this.rowsVisibleCalculator = null;
    this.columnsVisibleCalculator = null;
    this.rowsCalculatorTypes = new Map([['rendered', () => this.wtSettings.getSetting('renderAllRows') ? new _calculator.RenderedAllRowsCalculationType() : new _calculator.RenderedRowsCalculationType()], ['fullyVisible', () => new _calculator.FullyVisibleRowsCalculationType()], ['partiallyVisible', () => new _calculator.PartiallyVisibleRowsCalculationType()]]);
    this.columnsCalculatorTypes = new Map([['rendered', () => this.wtSettings.getSetting('renderAllColumns') ? new _calculator.RenderedAllColumnsCalculationType() : new _calculator.RenderedColumnsCalculationType()], ['fullyVisible', () => new _calculator.FullyVisibleColumnsCalculationType()], ['partiallyVisible', () => new _calculator.PartiallyVisibleColumnsCalculationType()]]);
    this.eventManager = eventManager;
    this.eventManager.addEventListener(this.domBindings.rootWindow, 'resize', () => {
      this.clientHeight = this.getWorkspaceHeight();
    });
  }

  /**
   * @returns {number}
   */
  getWorkspaceHeight() {
    const currentDocument = this.domBindings.rootDocument;
    const trimmingContainer = this.dataAccessObject.topOverlayTrimmingContainer;
    let height = 0;
    if (trimmingContainer === this.domBindings.rootWindow) {
      height = currentDocument.documentElement.clientHeight;
    } else {
      const elemHeight = (0, _element.outerHeight)(trimmingContainer);

      // returns height without DIV scrollbar
      height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;
    }
    return height;
  }

  /**
   * @returns {number}
   */
  getViewportHeight() {
    let containerHeight = this.getWorkspaceHeight();
    if (containerHeight === Infinity) {
      return containerHeight;
    }
    const columnHeaderHeight = this.getColumnHeaderHeight();
    if (columnHeaderHeight > 0) {
      containerHeight -= columnHeaderHeight;
    }
    return containerHeight;
  }

  /**
   * Gets the width of the table workspace (in pixels). The workspace size in the current
   * implementation returns the width of the table holder element including scrollbar width when
   * the table has defined size and the width of the window excluding scrollbar width when
   * the table has no defined size (the window is a scrollable container).
   *
   * This is a bug, as the method should always return stable values, always without scrollbar width.
   * Changing this behavior would break the column calculators, which would also need to be adjusted.
   *
   * @returns {number}
   */
  getWorkspaceWidth() {
    const {
      rootDocument,
      rootWindow
    } = this.domBindings;
    const trimmingContainer = this.dataAccessObject.inlineStartOverlayTrimmingContainer;
    let width;
    if (trimmingContainer === rootWindow) {
      const totalColumns = this.wtSettings.getSetting('totalColumns');
      width = this.wtTable.holder.offsetWidth;
      if (this.getRowHeaderWidth() + this.sumColumnWidths(0, totalColumns) > width) {
        width = rootDocument.documentElement.clientWidth;
      }
    } else {
      width = trimmingContainer.clientWidth;
    }
    return width;
  }

  /**
   * @returns {number}
   */
  getViewportWidth() {
    const containerWidth = this.getWorkspaceWidth();
    if (containerWidth === Infinity) {
      return containerWidth;
    }
    const rowHeaderWidth = this.getRowHeaderWidth();
    if (rowHeaderWidth > 0) {
      return containerWidth - rowHeaderWidth;
    }
    return containerWidth;
  }

  /**
   * Checks if viewport has vertical scroll.
   *
   * @returns {boolean}
   */
  hasVerticalScroll() {
    return this.wtTable.hider.offsetHeight > this.getWorkspaceHeight();
  }

  /**
   * Checks if viewport has horizontal scroll.
   *
   * @returns {boolean}
   */
  hasHorizontalScroll() {
    return this.wtTable.hider.offsetWidth > this.getWorkspaceWidth();
  }

  /**
   * Checks if the table uses the window as a viewport and if there is a vertical scrollbar.
   *
   * @returns {boolean}
   */
  isVerticallyScrollableByWindow() {
    return this.dataAccessObject.topOverlayTrimmingContainer === this.domBindings.rootWindow;
  }

  /**
   * Checks if the table uses the window as a viewport and if there is a horizontal scrollbar.
   *
   * @returns {boolean}
   */
  isHorizontallyScrollableByWindow() {
    return this.dataAccessObject.inlineStartOverlayTrimmingContainer === this.domBindings.rootWindow;
  }

  /**
   * @param {number} from The visual column index from the width sum is start calculated.
   * @param {number} length The length of the column to traverse.
   * @returns {number}
   */
  sumColumnWidths(from, length) {
    let sum = 0;
    let column = from;
    while (column < length) {
      sum += this.wtTable.getColumnWidth(column);
      column += 1;
    }
    return sum;
  }

  /**
   * @returns {number}
   */
  getWorkspaceOffset() {
    return (0, _element.offset)(this.wtTable.TABLE);
  }

  /**
   * @returns {number}
   */
  getColumnHeaderHeight() {
    const columnHeaders = this.wtSettings.getSetting('columnHeaders');
    if (!columnHeaders.length) {
      this.columnHeaderHeight = 0;
    } else if (isNaN(this.columnHeaderHeight)) {
      this.columnHeaderHeight = (0, _element.outerHeight)(this.wtTable.THEAD);
    }
    return this.columnHeaderHeight;
  }

  /**
   * @returns {number}
   */
  getRowHeaderWidth() {
    const rowHeadersWidthSetting = this.wtSettings.getSetting('rowHeaderWidth');
    const rowHeaders = this.wtSettings.getSetting('rowHeaders');
    if (rowHeadersWidthSetting) {
      this.rowHeaderWidth = 0;
      for (let i = 0, len = rowHeaders.length; i < len; i++) {
        this.rowHeaderWidth += rowHeadersWidthSetting[i] || rowHeadersWidthSetting;
      }
    }
    if (isNaN(this.rowHeaderWidth)) {
      if (rowHeaders.length) {
        let TH = this.wtTable.TABLE.querySelector('TH');
        this.rowHeaderWidth = 0;
        for (let i = 0, len = rowHeaders.length; i < len; i++) {
          if (TH) {
            this.rowHeaderWidth += (0, _element.outerWidth)(TH);
            TH = TH.nextSibling;
          } else {
            // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.
            // TODO: proper fix
            this.rowHeaderWidth += 50;
          }
        }
      } else {
        this.rowHeaderWidth = 0;
      }
    }
    this.rowHeaderWidth = this.wtSettings.getSetting('onModifyRowHeaderWidth', this.rowHeaderWidth) || this.rowHeaderWidth;
    return this.rowHeaderWidth;
  }

  /**
   * Creates rows calculators. The type of the calculations can be chosen from the list:
   *  - 'rendered' Calculates rows that should be rendered within the current table's viewport;
   *  - 'fullyVisible' Calculates rows that are fully visible (used mostly for scrolling purposes);
   *  - 'partiallyVisible' Calculates rows that are partially visible (used mostly for scrolling purposes).
   *
   * @param {'rendered' | 'fullyVisible' | 'partiallyVisible'} calculatorTypes The list of the calculation types.
   * @returns {ViewportRowsCalculator}
   */
  createRowsCalculator() {
    let calculatorTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['rendered', 'fullyVisible', 'partiallyVisible'];
    const {
      wtSettings,
      wtTable
    } = this;
    let height = this.getViewportHeight();
    let scrollbarHeight;
    let fixedRowsHeight;
    this.rowHeaderWidth = NaN;
    let pos = this.dataAccessObject.topScrollPosition - this.dataAccessObject.topParentOffset;
    const fixedRowsTop = wtSettings.getSetting('fixedRowsTop');
    const fixedRowsBottom = wtSettings.getSetting('fixedRowsBottom');
    const totalRows = wtSettings.getSetting('totalRows');
    if (fixedRowsTop && pos >= 0) {
      fixedRowsHeight = this.dataAccessObject.topOverlay.sumCellSizes(0, fixedRowsTop);
      pos += fixedRowsHeight;
      height -= fixedRowsHeight;
    }
    if (fixedRowsBottom && this.dataAccessObject.bottomOverlay.clone) {
      fixedRowsHeight = this.dataAccessObject.bottomOverlay.sumCellSizes(totalRows - fixedRowsBottom, totalRows);
      height -= fixedRowsHeight;
    }
    if (wtTable.holder.clientHeight === wtTable.holder.offsetHeight) {
      scrollbarHeight = 0;
    } else {
      scrollbarHeight = (0, _element.getScrollbarWidth)(this.domBindings.rootDocument);
    }
    return new _calculator.ViewportRowsCalculator({
      calculationTypes: calculatorTypes.map(type => [type, this.rowsCalculatorTypes.get(type)()]),
      viewportHeight: height,
      scrollOffset: pos,
      totalRows: wtSettings.getSetting('totalRows'),
      defaultRowHeight: this.instance.stylesHandler.getDefaultRowHeight(),
      rowHeightFn: sourceRow => wtTable.getRowHeight(sourceRow),
      overrideFn: wtSettings.getSettingPure('viewportRowCalculatorOverride'),
      horizontalScrollbarHeight: scrollbarHeight
    });
  }

  /**
   * Creates columns calculators. The type of the calculations can be chosen from the list:
   *  - 'rendered' Calculates columns that should be rendered within the current table's viewport;
   *  - 'fullyVisible' Calculates columns that are fully visible (used mostly for scrolling purposes);
   *  - 'partiallyVisible' Calculates columns that are partially visible (used mostly for scrolling purposes).
   *
   * @param {'rendered' | 'fullyVisible' | 'partiallyVisible'} calculatorTypes The list of the calculation types.
   * @returns {ViewportColumnsCalculator}
   */
  createColumnsCalculator() {
    let calculatorTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['rendered', 'fullyVisible', 'partiallyVisible'];
    const {
      wtSettings,
      wtTable
    } = this;
    let width = this.getViewportWidth();
    let pos = Math.abs(this.dataAccessObject.inlineStartScrollPosition) - this.dataAccessObject.inlineStartParentOffset;
    this.columnHeaderHeight = NaN;
    const fixedColumnsStart = wtSettings.getSetting('fixedColumnsStart');
    if (fixedColumnsStart && pos >= 0) {
      const fixedColumnsWidth = this.dataAccessObject.inlineStartOverlay.sumCellSizes(0, fixedColumnsStart);
      pos += fixedColumnsWidth;
      width -= fixedColumnsWidth;
    }
    if (wtTable.holder.clientWidth !== wtTable.holder.offsetWidth) {
      width -= (0, _element.getScrollbarWidth)(this.domBindings.rootDocument);
    }
    return new _calculator.ViewportColumnsCalculator({
      calculationTypes: calculatorTypes.map(type => [type, this.columnsCalculatorTypes.get(type)()]),
      viewportWidth: width,
      scrollOffset: pos,
      totalColumns: wtSettings.getSetting('totalColumns'),
      columnWidthFn: sourceCol => wtTable.getColumnWidth(sourceCol),
      overrideFn: wtSettings.getSettingPure('viewportColumnCalculatorOverride'),
      inlineStartOffset: this.dataAccessObject.inlineStartParentOffset
    });
  }

  /**
   * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and
   * cols should be rendered).
   *
   * @param {boolean} fastDraw If `true`, will try to avoid full redraw and only update the border positions.
   *                           If `false` or `undefined`, will perform a full redraw.
   * @returns {boolean} The fastDraw value, possibly modified.
   */
  createCalculators() {
    let fastDraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const {
      wtSettings
    } = this;
    const rowsCalculator = this.createRowsCalculator();
    const columnsCalculator = this.createColumnsCalculator();
    if (fastDraw && !wtSettings.getSetting('renderAllRows')) {
      const proposedRowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');
      fastDraw = this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator);
    }
    if (fastDraw && !wtSettings.getSetting('renderAllColumns')) {
      const proposedColumnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');
      fastDraw = this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator);
    }
    if (!fastDraw) {
      this.rowsRenderCalculator = rowsCalculator.getResultsFor('rendered');
      this.columnsRenderCalculator = columnsCalculator.getResultsFor('rendered');
    }
    this.rowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');
    this.columnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');
    this.rowsPartiallyVisibleCalculator = rowsCalculator.getResultsFor('partiallyVisible');
    this.columnsPartiallyVisibleCalculator = columnsCalculator.getResultsFor('partiallyVisible');
    return fastDraw;
  }

  /**
   * Creates rows and columns calculators (after draw, to determine what are
   * the actually fully visible and partially visible rows and columns).
   */
  createVisibleCalculators() {
    const rowsCalculator = this.createRowsCalculator(['fullyVisible', 'partiallyVisible']);
    const columnsCalculator = this.createColumnsCalculator(['fullyVisible', 'partiallyVisible']);
    this.rowsVisibleCalculator = rowsCalculator.getResultsFor('fullyVisible');
    this.columnsVisibleCalculator = columnsCalculator.getResultsFor('fullyVisible');
    this.rowsPartiallyVisibleCalculator = rowsCalculator.getResultsFor('partiallyVisible');
    this.columnsPartiallyVisibleCalculator = columnsCalculator.getResultsFor('partiallyVisible');
  }

  /**
   * Returns information whether proposedRowsVisibleCalculator viewport
   * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator).
   *
   * @param {ViewportRowsCalculator} proposedRowsVisibleCalculator The instance of the viewport calculator to compare with.
   * @returns {boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).
   *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed).
   */
  areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {
    if (!this.rowsVisibleCalculator) {
      return false;
    }
    let {
      startRow,
      endRow
    } = proposedRowsVisibleCalculator;

    // if there are no fully visible rows at all...
    if (startRow === null && endRow === null) {
      if (!proposedRowsVisibleCalculator.isVisibleInTrimmingContainer) {
        return true;
      }
      // ...use partially visible rows calculator to determine what render type is needed
      startRow = this.rowsPartiallyVisibleCalculator.startRow;
      endRow = this.rowsPartiallyVisibleCalculator.endRow;
    }
    const {
      startRow: renderedStartRow,
      endRow: renderedEndRow,
      rowStartOffset,
      rowEndOffset
    } = this.rowsRenderCalculator;
    const totalRows = this.wtSettings.getSetting('totalRows') - 1;
    const renderingThreshold = this.wtSettings.getSetting('viewportRowRenderingThreshold');
    if (Number.isInteger(renderingThreshold) && renderingThreshold > 0) {
      startRow = Math.max(0, startRow - Math.min(rowStartOffset, renderingThreshold));
      endRow = Math.min(totalRows, endRow + Math.min(rowEndOffset, renderingThreshold));
    } else if (renderingThreshold === 'auto') {
      startRow = Math.max(0, startRow - Math.ceil(rowStartOffset / 2));
      endRow = Math.min(totalRows, endRow + Math.ceil(rowEndOffset / 2));
    }
    if (startRow < renderedStartRow || startRow === renderedStartRow && startRow > 0) {
      return false;
    } else if (endRow > renderedEndRow || endRow === renderedEndRow && endRow < totalRows) {
      return false;
    }
    return true;
  }

  /**
   * Returns information whether proposedColumnsVisibleCalculator viewport
   * is contained inside column rendered in previous draw (cached in columnsRenderCalculator).
   *
   * @param {ViewportRowsCalculator} proposedColumnsVisibleCalculator The instance of the viewport calculator to compare with.
   * @returns {boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).
   *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed).
   */
  areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {
    if (!this.columnsVisibleCalculator) {
      return false;
    }
    let {
      startColumn,
      endColumn
    } = proposedColumnsVisibleCalculator;

    // if there are no fully visible columns at all...
    if (startColumn === null && endColumn === null) {
      if (!proposedColumnsVisibleCalculator.isVisibleInTrimmingContainer) {
        return true;
      }
      // ...use partially visible columns calculator to determine what render type is needed
      startColumn = this.columnsPartiallyVisibleCalculator.startColumn;
      endColumn = this.columnsPartiallyVisibleCalculator.endColumn;
    }
    const {
      startColumn: renderedStartColumn,
      endColumn: renderedEndColumn,
      columnStartOffset,
      columnEndOffset
    } = this.columnsRenderCalculator;
    const totalColumns = this.wtSettings.getSetting('totalColumns') - 1;
    const renderingThreshold = this.wtSettings.getSetting('viewportColumnRenderingThreshold');
    if (Number.isInteger(renderingThreshold) && renderingThreshold > 0) {
      startColumn = Math.max(0, startColumn - Math.min(columnStartOffset, renderingThreshold));
      endColumn = Math.min(totalColumns, endColumn + Math.min(columnEndOffset, renderingThreshold));
    } else if (renderingThreshold === 'auto') {
      startColumn = Math.max(0, startColumn - Math.ceil(columnStartOffset / 2));
      endColumn = Math.min(totalColumns, endColumn + Math.ceil(columnEndOffset / 2));
    }
    if (startColumn < renderedStartColumn || startColumn === renderedStartColumn && startColumn > 0) {
      return false;
    } else if (endColumn > renderedEndColumn || endColumn === renderedEndColumn && endColumn < totalColumns) {
      return false;
    }
    return true;
  }

  /**
   * Resets values in keys of the hasOversizedColumnHeadersMarked object after updateSettings.
   */
  resetHasOversizedColumnHeadersMarked() {
    (0, _object.objectEach)(this.hasOversizedColumnHeadersMarked, (value, key, object) => {
      object[key] = undefined;
    });
  }
}
var _default = exports["default"] = Viewport;

/***/ }),
/* 614 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(311);
__webpack_require__(329);
var _element = __webpack_require__(351);
var _console = __webpack_require__(512);
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
const CLASSIC_THEME_DEFAULT_HEIGHT = 23;

/**
 * Handles the theme-related style operations.
 */
var _themeName = /*#__PURE__*/new WeakMap();
var _rootElement = /*#__PURE__*/new WeakMap();
var _rootComputedStyle = /*#__PURE__*/new WeakMap();
var _rootDocument = /*#__PURE__*/new WeakMap();
var _isClassicTheme = /*#__PURE__*/new WeakMap();
var _cssVars = /*#__PURE__*/new WeakMap();
var _computedStyles = /*#__PURE__*/new WeakMap();
var _StylesHandler_brand = /*#__PURE__*/new WeakSet();
class StylesHandler {
  /**
   * Initializes a new instance of the `StylesHandler` class.
   *
   * @param {object} domBindings - The DOM bindings for the instance.
   */
  constructor(domBindings) {
    /**
     * Calculates the row height based on the current theme and CSS variables.
     *
     * @returns {number|null} The calculated row height, or `null` if any required CSS variable is not found.
     */
    _classPrivateMethodInitSpec(this, _StylesHandler_brand);
    /**
     * The name of the theme.
     *
     * @type {string|undefined}
     */
    _classPrivateFieldInitSpec(this, _themeName, void 0);
    /**
     * The instance's root element.
     *
     * @type {HTMLElement}
     */
    _classPrivateFieldInitSpec(this, _rootElement, void 0);
    /**
     * The computed style of the root element.
     *
     * @type {CSSStyleDeclaration}
     * @private
     */
    _classPrivateFieldInitSpec(this, _rootComputedStyle, void 0);
    /**
     * The root document of the instance.
     *
     * @type {Document}
     * @private
     */
    _classPrivateFieldInitSpec(this, _rootDocument, void 0);
    /**
     * `true` if the classic theme is enabled, `false` otherwise.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _isClassicTheme, true);
    /**
     * An object to store CSS variable values.
     *
     * @type {object}
     * @private
     */
    _classPrivateFieldInitSpec(this, _cssVars, {});
    /**
     * Stores the computed styles for various elements.
     *
     * @type {object} - An object containing the computed styles if a nested structore of `element: { [element type]: {property: value} }`.
     * @private
     */
    _classPrivateFieldInitSpec(this, _computedStyles, {});
    _classPrivateFieldSet(_rootElement, this, domBindings.rootTable.parentElement.parentElement);
    _classPrivateFieldSet(_rootDocument, this, domBindings.rootDocument);
  }

  /**
   * Gets the value indicating whether the classic theme is enabled.
   *
   * @returns {boolean} `true` if the classic theme is enabled, `false` otherwise.
   */
  isClassicTheme() {
    return _classPrivateFieldGet(_isClassicTheme, this);
  }

  /**
   * Retrieves the value of a specified CSS variable.
   *
   * @param {string} variableName - The name of the CSS variable to retrieve.
   * @returns {number|null|undefined} The value of the specified CSS variable, or `undefined` if not found.
   */
  getCSSVariableValue(variableName) {
    var _assertClassBrand$cal;
    if (_classPrivateFieldGet(_isClassicTheme, this)) {
      return null;
    }
    if (_classPrivateFieldGet(_cssVars, this)[`--ht-${variableName}`]) {
      return _classPrivateFieldGet(_cssVars, this)[`--ht-${variableName}`];
    }
    const acquiredValue = (_assertClassBrand$cal = _assertClassBrand(_StylesHandler_brand, this, _getParsedNumericCSSValue).call(this, `--ht-${variableName}`)) !== null && _assertClassBrand$cal !== void 0 ? _assertClassBrand$cal : _assertClassBrand(_StylesHandler_brand, this, _getCSSValue).call(this, `--ht-${variableName}`);
    if (acquiredValue !== null) {
      _classPrivateFieldGet(_cssVars, this)[`--ht-${variableName}`] = acquiredValue;
      return acquiredValue;
    }
  }

  /**
   * Retrieves the computed style value for a specified CSS property of a `td` element.
   *
   * @param {string} cssProperty - The CSS property to retrieve the value for.
   * @returns {number|string|undefined} The value of the specified CSS property, or `undefined` if not found.
   */
  getStyleForTD(cssProperty) {
    var _classPrivateFieldGet2;
    return (_classPrivateFieldGet2 = _classPrivateFieldGet(_computedStyles, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.td[cssProperty];
  }

  /**
   * Calculates the row height based on the current theme and CSS variables.
   *
   * @returns {number} The calculated row height.
   */
  getDefaultRowHeight() {
    if (_classPrivateFieldGet(_isClassicTheme, this)) {
      return CLASSIC_THEME_DEFAULT_HEIGHT;
    }
    const calculatedRowHeight = _assertClassBrand(_StylesHandler_brand, this, _calculateRowHeight).call(this);
    if (!calculatedRowHeight && (0, _element.hasClass)(_classPrivateFieldGet(_rootElement, this), 'ht-wrapper')) {
      (0, _console.warn)(`The "${_classPrivateFieldGet(_themeName, this)}" theme is enabled, but its stylesheets are missing or not imported correctly. \
Import the correct CSS files in order to use that theme.`);
      _classPrivateFieldSet(_isClassicTheme, this, true);
      this.useTheme();
      return CLASSIC_THEME_DEFAULT_HEIGHT;
    }
    return calculatedRowHeight;
  }

  /**
   * Checks if the cells are using the `border-box` box-sizing model.
   *
   * @returns {boolean}
   */
  areCellsBorderBox() {
    return this.getStyleForTD('box-sizing') === 'border-box';
  }

  /**
   * Applies the specified theme to the instance.
   *
   * @param {string|undefined|boolean} [themeName] - The name of the theme to apply.
   */
  useTheme(themeName) {
    if (!themeName) {
      _assertClassBrand(_StylesHandler_brand, this, _cacheStylesheetValues).call(this);
      _classPrivateFieldSet(_isClassicTheme, this, true);
      _classPrivateFieldSet(_themeName, this, themeName || undefined);
      return;
    }
    if (themeName && themeName !== _classPrivateFieldGet(_themeName, this)) {
      if (_classPrivateFieldGet(_themeName, this)) {
        _assertClassBrand(_StylesHandler_brand, this, _clearCachedValues).call(this);
      }
      _classPrivateFieldSet(_themeName, this, themeName);
      _classPrivateFieldSet(_isClassicTheme, this, false);
      _assertClassBrand(_StylesHandler_brand, this, _applyClassNames).call(this);
      _assertClassBrand(_StylesHandler_brand, this, _cacheStylesheetValues).call(this);
    }
  }

  /**
   * Gets the name of the theme.
   *
   * @returns {string|undefined}
   */
  getThemeName() {
    return _classPrivateFieldGet(_themeName, this);
  }

  /**
   * Removes the theme-related class names from the root element.
   */
  removeClassNames() {
    if ((0, _element.hasClass)(_classPrivateFieldGet(_rootElement, this), _classPrivateFieldGet(_themeName, this))) {
      (0, _element.removeClass)(_classPrivateFieldGet(_rootElement, this), _classPrivateFieldGet(_themeName, this));
    }
  }
}
exports.StylesHandler = StylesHandler;
function _calculateRowHeight() {
  const lineHeightVarValue = this.getCSSVariableValue('line-height');
  const verticalPaddingVarValue = this.getCSSVariableValue('cell-vertical-padding');
  const bottomBorderWidth = Math.ceil(parseFloat(this.getStyleForTD('border-bottom-width')));
  if (lineHeightVarValue === null || verticalPaddingVarValue === null || isNaN(bottomBorderWidth)) {
    return null;
  }
  return lineHeightVarValue + 2 * verticalPaddingVarValue + bottomBorderWidth;
}
/**
 * Applies the necessary class names to the root element.
 */
function _applyClassNames() {
  (0, _element.removeClass)(_classPrivateFieldGet(_rootElement, this), /ht-theme-.*/g);
  (0, _element.addClass)(_classPrivateFieldGet(_rootElement, this), _classPrivateFieldGet(_themeName, this));
}
/**
 * Caches the computed style values for the root element and `td` element.
 */
function _cacheStylesheetValues() {
  if (!this.isClassicTheme()) {
    _classPrivateFieldSet(_rootComputedStyle, this, getComputedStyle(_classPrivateFieldGet(_rootElement, this)));
  }
  const stylesForTD = _assertClassBrand(_StylesHandler_brand, this, _getStylesForTD).call(this, ['box-sizing', 'border-bottom-width']);
  _classPrivateFieldGet(_computedStyles, this).td = {
    ..._classPrivateFieldGet(_computedStyles, this).td,
    ...{
      'box-sizing': stylesForTD['box-sizing'],
      'border-bottom-width': stylesForTD['border-bottom-width']
    }
  };
}
/**
 * Retrieves and processes the computed styles for a `td` element.
 *
 * This method creates a temporary table structure, appends it to the root element,
 * retrieves the computed styles for the `td` element, and then removes the table
 * from the DOM. The computed styles are passed to the provided callback function.
 *
 * @param {Array} cssProps - An array of CSS properties to retrieve.
 * @returns {object} An object containing the requested computed styles for the `td` element.
 * @private
 */
function _getStylesForTD(cssProps) {
  const rootDocument = _classPrivateFieldGet(_rootDocument, this);
  const rootElement = _classPrivateFieldGet(_rootElement, this);
  const table = rootDocument.createElement('table');
  const tbody = rootDocument.createElement('tbody');
  const tr = rootDocument.createElement('tr');
  // This needs not to be the first row in order to get "regular" vaules.
  const tr2 = rootDocument.createElement('tr');
  const td = rootDocument.createElement('td');
  tr2.appendChild(td);
  tbody.appendChild(tr);
  tbody.appendChild(tr2);
  table.appendChild(tbody);
  rootElement.appendChild(table);
  const computedStyle = getComputedStyle(td);
  const returnObject = {};
  cssProps.forEach(prop => {
    returnObject[prop] = computedStyle.getPropertyValue(prop);
  });
  rootElement.removeChild(table);
  return returnObject;
}
/**
 * Parses the numeric value of a specified CSS property from the root element's computed style.
 *
 * @param {string} property - The CSS property to retrieve and parse.
 * @returns {number|null} The parsed value of the CSS property or `null` if non-existent.
 */
function _getParsedNumericCSSValue(property) {
  const parsedValue = Math.ceil(parseFloat(_assertClassBrand(_StylesHandler_brand, this, _getCSSValue).call(this, property)));
  return Number.isNaN(parsedValue) ? null : parsedValue;
}
/**
 * Retrieves the non-numeric value of a specified CSS property from the root element's computed style.
 *
 * @param {string} property - The CSS property to retrieve.
 * @returns {string|null} The value of the specified CSS property or `null` if non-existent.
 */
function _getCSSValue(property) {
  const acquiredValue = _classPrivateFieldGet(_rootComputedStyle, this).getPropertyValue(property);
  return acquiredValue === '' ? null : acquiredValue;
}
/**
 * Clears the cached values.
 */
function _clearCachedValues() {
  _classPrivateFieldSet(_computedStyles, this, {});
  _classPrivateFieldSet(_cssVars, this, {});
  _classPrivateFieldSet(_isClassicTheme, this, true);
}

/***/ }),
/* 615 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.handleMouseEvent = handleMouseEvent;
exports.mouseDown = mouseDown;
exports.mouseOver = mouseOver;
var _event = __webpack_require__(509);
/**
 * MouseDown handler.
 *
 * @param {object} options The handler options.
 * @param {boolean} options.isShiftKey The flag which indicates if the shift key is pressed.
 * @param {boolean} options.isLeftClick The flag which indicates if the left mouse button is pressed.
 * @param {boolean} options.isRightClick The flag which indicates if the right mouse button is pressed.
 * @param {CellRange} options.coords The CellCoords object with defined visual coordinates.
 * @param {Selection} options.selection The Selection class instance.
 * @param {object} options.controller An object with keys `row`, `column`, `cell` which indicate what
 *                                    operation will be performed in later selection stages.
 * @param {Function} options.cellCoordsFactory The function factory for CellCoords objects.
 */
function mouseDown(_ref) {
  let {
    isShiftKey,
    isLeftClick,
    isRightClick,
    coords,
    selection,
    controller,
    cellCoordsFactory
  } = _ref;
  const currentSelection = selection.isSelected() ? selection.getSelectedRange().current() : null;
  const selectedCorner = selection.isSelectedByCorner();
  const selectedRow = selection.isSelectedByRowHeader();
  selection.markSource('mouse');
  if (isShiftKey && currentSelection) {
    if (coords.row >= 0 && coords.col >= 0 && !controller.cell) {
      selection.setRangeEnd(coords);
    } else if ((selectedCorner || selectedRow) && coords.row >= 0 && coords.col >= 0 && !controller.cell) {
      selection.setRangeEnd(cellCoordsFactory(coords.row, coords.col));
    } else if (selectedCorner && coords.row < 0 && !controller.column) {
      selection.setRangeEnd(cellCoordsFactory(currentSelection.to.row, coords.col));
    } else if (selectedRow && coords.col < 0 && !controller.row) {
      selection.setRangeEnd(cellCoordsFactory(coords.row, currentSelection.to.col));
    } else if ((!selectedCorner && !selectedRow && coords.col < 0 || selectedCorner && coords.col < 0) && !controller.row) {
      selection.selectRows(Math.max(currentSelection.from.row, 0), coords.row, coords.col);
    } else if ((!selectedCorner && !selectedRow && coords.row < 0 || selectedRow && coords.row < 0) && !controller.column) {
      selection.selectColumns(Math.max(currentSelection.from.col, 0), coords.col, coords.row);
    }
  } else {
    const allowRightClickSelection = !selection.inInSelection(coords);
    const performSelection = isLeftClick || isRightClick && allowRightClickSelection;

    // clicked row header and when some column was selected
    if (coords.row < 0 && coords.col >= 0 && !controller.column) {
      if (performSelection) {
        selection.selectColumns(coords.col, coords.col, coords.row);
      }

      // clicked column header and when some row was selected
    } else if (coords.col < 0 && coords.row >= 0 && !controller.row) {
      if (performSelection) {
        selection.selectRows(coords.row, coords.row, coords.col);
      }
    } else if (coords.col >= 0 && coords.row >= 0 && !controller.cell) {
      if (performSelection) {
        selection.setRangeStart(coords);
      }
    } else if (coords.col < 0 && coords.row < 0) {
      selection.selectAll(true, true, {
        disableHeadersHighlight: true,
        focusPosition: {
          row: 0,
          col: 0
        }
      });
    }
  }
  selection.markEndSource();
}

/**
 * MouseOver handler.
 *
 * @param {object} options The handler options.
 * @param {boolean} options.isLeftClick Indicates that event was fired using the left mouse button.
 * @param {CellRange} options.coords The CellCoords object with defined visual coordinates.
 * @param {Selection} options.selection The Selection class instance.
 * @param {object} options.controller An object with keys `row`, `column`, `cell` which indicate what
 *                                    operation will be performed in later selection stages.
 * @param {Function} options.cellCoordsFactory The function factory for CellCoords objects.
 */
function mouseOver(_ref2) {
  let {
    isLeftClick,
    coords,
    selection,
    controller,
    cellCoordsFactory
  } = _ref2;
  if (!isLeftClick) {
    return;
  }
  const selectedRow = selection.isSelectedByRowHeader();
  const selectedColumn = selection.isSelectedByColumnHeader();
  const countCols = selection.tableProps.countCols();
  const countRows = selection.tableProps.countRows();
  selection.markSource('mouse');
  if (selectedColumn && !controller.column) {
    selection.setRangeEnd(cellCoordsFactory(countRows - 1, coords.col));
  } else if (selectedRow && !controller.row) {
    selection.setRangeEnd(cellCoordsFactory(coords.row, countCols - 1));
  } else if (!controller.cell) {
    selection.setRangeEnd(coords);
  }
  selection.markEndSource();
}
const handlers = new Map([['mousedown', mouseDown], ['mouseover', mouseOver], ['touchstart', mouseDown]]);

/**
 * Mouse handler for selection functionality.
 *
 * @param {Event} event An native event to handle.
 * @param {object} options The handler options.
 * @param {CellRange} options.coords The CellCoords object with defined visual coordinates.
 * @param {Selection} options.selection The Selection class instance.
 * @param {object} options.controller An object with keys `row`, `column`, `cell` which indicate what
 *                                    operation will be performed in later selection stages.
 * @param {Function} options.cellCoordsFactory The function factory for CellCoords objects.
 */
function handleMouseEvent(event, _ref3) {
  let {
    coords,
    selection,
    controller,
    cellCoordsFactory
  } = _ref3;
  handlers.get(event.type)({
    coords,
    selection,
    controller,
    cellCoordsFactory,
    isShiftKey: event.shiftKey,
    isLeftClick: (0, _event.isLeftClick)(event) || event.type === 'touchstart',
    isRightClick: (0, _event.isRightClick)(event)
  });
}

/***/ }),
/* 616 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.hasValidParameter = hasValidParameter;
exports.isRootInstance = isRootInstance;
exports.registerAsRootInstance = registerAsRootInstance;
const holder = exports.holder = new WeakMap();
const rootInstanceSymbol = exports.rootInstanceSymbol = Symbol('rootInstance');

/**
 * Register an object as a root instance.
 *
 * @param  {object} object An object to associate with root instance flag.
 */
function registerAsRootInstance(object) {
  holder.set(object, true);
}

/**
 * Check if the source of the root indication call is valid.
 *
 * @param  {symbol} rootSymbol A symbol as a source of truth.
 * @returns {boolean}
 */
function hasValidParameter(rootSymbol) {
  return rootSymbol === rootInstanceSymbol;
}

/**
 * Check if passed an object was flagged as a root instance.
 *
 * @param  {object} object An object to check.
 * @returns {boolean}
 */
function isRootInstance(object) {
  return holder.has(object);
}

/***/ }),
/* 617 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
__webpack_require__(311);
__webpack_require__(329);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _object = __webpack_require__(499);
var _data = __webpack_require__(618);
var _array = __webpack_require__(495);
var _number = __webpack_require__(534);
var _function = __webpack_require__(497);
/**
 * @class DataSource
 * @private
 */
class DataSource {
  constructor(hotInstance) {
    let dataSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    /**
     * Instance of Handsontable.
     *
     * @type {Handsontable}
     */
    (0, _defineProperty2.default)(this, "hot", void 0);
    /**
     * Data source.
     *
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "data", void 0);
    /**
     * Type of data source.
     *
     * @type {string}
     * @default 'array'
     */
    (0, _defineProperty2.default)(this, "dataType", 'array');
    (0, _defineProperty2.default)(this, "colToProp", () => {});
    (0, _defineProperty2.default)(this, "propToCol", () => {});
    this.hot = hotInstance;
    this.data = dataSource;
  }

  /**
   * Run the `modifyRowData` hook and return either the modified or the source data for the provided row.
   *
   * @private
   * @param {number} rowIndex Row index.
   * @returns {Array|object} Source or modified row of data.
   */
  modifyRowData(rowIndex) {
    let modifyRowData;
    if (this.hot.hasHook('modifyRowData')) {
      modifyRowData = this.hot.runHooks('modifyRowData', rowIndex);
    }
    return modifyRowData !== undefined && !Number.isInteger(modifyRowData) ? modifyRowData : this.data[rowIndex];
  }

  /**
   * Get all data.
   *
   * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided
   *                                  in another format.
   * @returns {Array}
   */
  getData() {
    let toArray = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!this.data || this.data.length === 0) {
      return this.data;
    }
    return this.getByRange(null, null, toArray);
  }

  /**
   * Set new data source.
   *
   * @param {Array} data The new data.
   */
  setData(data) {
    this.data = data;
  }

  /**
   * Returns array of column values from the data source. `column` is the index of the row in the data source.
   *
   * @param {number} column Visual column index.
   * @returns {Array}
   */
  getAtColumn(column) {
    const result = [];
    (0, _array.arrayEach)(this.data, (row, rowIndex) => {
      const value = this.getAtCell(rowIndex, column);
      result.push(value);
    });
    return result;
  }

  /**
   * Returns a single row of the data or a subset of its columns. If a column range or `toArray` arguments are provided, it
   * operates only on the columns declared by the `columns` setting or the data schema.
   *
   * @param {number} row Physical row index.
   * @param {number} [startColumn] Starting index for the column range (optional).
   * @param {number} [endColumn] Ending index for the column range (optional).
   * @param {boolean} [toArray=false] `true` if the returned value should be forced to be presented as an array.
   * @returns {Array|object}
   */
  getAtRow(row, startColumn, endColumn) {
    let toArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const getAllProps = startColumn === undefined && endColumn === undefined;
    const {
      dataDotNotation
    } = this.hot.getSettings();
    let dataRow = null;
    let newDataRow = null;
    dataRow = this.modifyRowData(row);
    if (Array.isArray(dataRow)) {
      newDataRow = [];
      if (getAllProps) {
        dataRow.forEach((cell, column) => {
          newDataRow[column] = this.getAtPhysicalCell(row, column, dataRow);
        });
      } else {
        // Only the columns from the provided range
        (0, _number.rangeEach)(startColumn, endColumn, column => {
          newDataRow[column - startColumn] = this.getAtPhysicalCell(row, column, dataRow);
        });
      }
    } else if ((0, _object.isObject)(dataRow) || (0, _function.isFunction)(dataRow)) {
      if (toArray) {
        newDataRow = [];
      } else {
        newDataRow = {};
      }
      if (!getAllProps || toArray) {
        const rangeStart = 0;
        const rangeEnd = this.countFirstRowKeys() - 1;
        (0, _number.rangeEach)(rangeStart, rangeEnd, column => {
          const prop = this.colToProp(column);
          if (column >= (startColumn || rangeStart) && column <= (endColumn || rangeEnd) && !Number.isInteger(prop)) {
            const cellValue = this.getAtPhysicalCell(row, prop, dataRow);
            if (toArray) {
              newDataRow.push(cellValue);
            } else if (dataDotNotation) {
              (0, _object.setProperty)(newDataRow, prop, cellValue);
            } else {
              newDataRow[prop] = cellValue;
            }
          }
        });
      } else {
        (0, _object.objectEach)(dataRow, (value, prop) => {
          const cellValue = this.getAtPhysicalCell(row, prop, dataRow);
          if (dataDotNotation) {
            (0, _object.setProperty)(newDataRow, prop, cellValue);
          } else {
            newDataRow[prop] = cellValue;
          }
        });
      }
    }
    return newDataRow;
  }

  /**
   * Set the provided value in the source data set at the provided coordinates.
   *
   * @param {number} row Physical row index.
   * @param {number|string} column Property name / physical column index.
   * @param {*} value The value to be set at the provided coordinates.
   */
  setAtCell(row, column, value) {
    if (row >= this.countRows() || column >= this.countFirstRowKeys()) {
      // Not enough rows and/or columns.
      return;
    }
    if (this.hot.hasHook('modifySourceData')) {
      const valueHolder = (0, _object.createObjectPropListener)(value);
      this.hot.runHooks('modifySourceData', row, column, valueHolder, 'set');
      if (valueHolder.isTouched()) {
        value = valueHolder.value;
      }
    }
    if (!Number.isInteger(column)) {
      // column argument is the prop name
      (0, _object.setProperty)(this.data[row], column, value);
    } else {
      this.data[row][column] = value;
    }
  }

  /**
   * Get data from the source data set using the physical indexes.
   *
   * @private
   * @param {number} row Physical row index.
   * @param {string|number|Function} column Physical column index / property / function.
   * @param {Array|object} dataRow A representation of a data row.
   * @returns {*} Value at the provided coordinates.
   */
  getAtPhysicalCell(row, column, dataRow) {
    let result = null;
    if (dataRow) {
      if (typeof column === 'string') {
        const {
          dataDotNotation
        } = this.hot.getSettings();
        result = dataDotNotation ? (0, _object.getProperty)(dataRow, column) : dataRow[column];
      } else if (typeof column === 'function') {
        result = column(dataRow);
      } else {
        result = dataRow[column];
      }
    }
    if (this.hot.hasHook('modifySourceData')) {
      const valueHolder = (0, _object.createObjectPropListener)(result);
      this.hot.runHooks('modifySourceData', row, column, valueHolder, 'get');
      if (valueHolder.isTouched()) {
        result = valueHolder.value;
      }
    }
    return result;
  }

  /**
   * Returns a single value from the data.
   *
   * @param {number} row Physical row index.
   * @param {number} columnOrProp Visual column index or property.
   * @returns {*}
   */
  getAtCell(row, columnOrProp) {
    const dataRow = this.modifyRowData(row);
    return this.getAtPhysicalCell(row, this.colToProp(columnOrProp), dataRow);
  }

  /**
   * Returns source data by passed range.
   *
   * @param {object} [start] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).
   * @param {object} [end] Object with physical `row` and `col` keys (or visual column index, if data type is an array of objects).
   * @param {boolean} [toArray=false] If `true` return source data as an array of arrays even when source data was provided
   *                                  in another format.
   * @returns {Array}
   */
  getByRange() {
    let start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    let toArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let getAllProps = false;
    let startRow = null;
    let startCol = null;
    let endRow = null;
    let endCol = null;
    if (start === null || end === null) {
      getAllProps = true;
      startRow = 0;
      endRow = this.countRows() - 1;
    } else {
      startRow = Math.min(start.row, end.row);
      startCol = Math.min(start.col, end.col);
      endRow = Math.max(start.row, end.row);
      endCol = Math.max(start.col, end.col);
    }
    const result = [];
    (0, _number.rangeEach)(startRow, endRow, currentRow => {
      result.push(getAllProps ? this.getAtRow(currentRow, undefined, undefined, toArray) : this.getAtRow(currentRow, startCol, endCol, toArray));
    });
    return result;
  }

  /**
   * Count number of rows.
   *
   * @returns {number}
   */
  countRows() {
    if (this.hot.hasHook('modifySourceLength')) {
      const modifiedSourceLength = this.hot.runHooks('modifySourceLength');
      if (Number.isInteger(modifiedSourceLength)) {
        return modifiedSourceLength;
      }
    }
    return this.data.length;
  }

  /**
   * Count number of columns.
   *
   * @returns {number}
   */
  countFirstRowKeys() {
    return (0, _data.countFirstRowKeys)(this.data);
  }

  /**
   * Destroy instance.
   */
  destroy() {
    this.data = null;
    this.hot = null;
  }
}
var _default = exports["default"] = DataSource;

/***/ }),
/* 618 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.countFirstRowKeys = countFirstRowKeys;
exports.createEmptySpreadsheetData = createEmptySpreadsheetData;
exports.createSpreadsheetData = createSpreadsheetData;
exports.createSpreadsheetObjectData = createSpreadsheetObjectData;
exports.dataRowToChangesArray = dataRowToChangesArray;
exports.isArrayOfArrays = isArrayOfArrays;
exports.isArrayOfObjects = isArrayOfObjects;
exports.spreadsheetColumnIndex = spreadsheetColumnIndex;
exports.spreadsheetColumnLabel = spreadsheetColumnLabel;
__webpack_require__(283);
__webpack_require__(311);
__webpack_require__(619);
__webpack_require__(329);
var _object = __webpack_require__(499);
const COLUMN_LABEL_BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;

/**
 * Generates spreadsheet-like column names: A, B, C, ..., Z, AA, AB, etc.
 *
 * @param {number} index Column index.
 * @returns {string}
 */
function spreadsheetColumnLabel(index) {
  let dividend = index + 1;
  let columnLabel = '';
  let modulo;
  while (dividend > 0) {
    modulo = (dividend - 1) % COLUMN_LABEL_BASE_LENGTH;
    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
    dividend = parseInt((dividend - modulo) / COLUMN_LABEL_BASE_LENGTH, 10);
  }
  return columnLabel;
}

/**
 * Generates spreadsheet-like column index from theirs labels: A, B, C ...., Z, AA, AB, etc.
 *
 * @param {string} label Column label.
 * @returns {number}
 */
function spreadsheetColumnIndex(label) {
  let result = 0;
  if (label) {
    for (let i = 0, j = label.length - 1; i < label.length; i += 1, j -= 1) {
      result += COLUMN_LABEL_BASE_LENGTH ** j * (COLUMN_LABEL_BASE.indexOf(label[i]) + 1);
    }
  }
  result -= 1;
  return result;
}

/**
 * Creates 2D array of Excel-like values "A1", "A2", ...
 *
 * @param {number} rows Number of rows to generate.
 * @param {number} columns Number of columns to generate.
 * @returns {Array}
 */
function createSpreadsheetData() {
  let rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  let columns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  const _rows = [];
  let i;
  let j;
  for (i = 0; i < rows; i++) {
    const row = [];
    for (j = 0; j < columns; j++) {
      row.push(spreadsheetColumnLabel(j) + (i + 1));
    }
    _rows.push(row);
  }
  return _rows;
}

/**
 * Creates 2D array of Excel-like values "A1", "A2", as an array of objects.
 *
 * @param {number} rows Number of rows to generate.
 * @param {number} colCount Number of columns to generate.
 * @returns {Array}
 */
function createSpreadsheetObjectData() {
  let rows = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
  let colCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;
  const _rows = [];
  let i;
  let j;
  for (i = 0; i < rows; i++) {
    const row = {};
    for (j = 0; j < colCount; j++) {
      row[`prop${j}`] = spreadsheetColumnLabel(j) + (i + 1);
    }
    _rows.push(row);
  }
  return _rows;
}

/**
 * Generates an empty data object.
 *
 * @param {number} rows Number of rows to generate.
 * @param {number} columns Number of columns to generate.
 * @returns {Array}
 */
function createEmptySpreadsheetData(rows, columns) {
  const data = [];
  let row;
  for (let i = 0; i < rows; i++) {
    row = [];
    for (let j = 0; j < columns; j++) {
      row.push('');
    }
    data.push(row);
  }
  return data;
}

/**
 * Transform a data row (either an array or an object) or an array of data rows to array of changes in a form of `[row,
 * prop/col, value]`. Convenient to use with `setDataAtRowProp` and `setSourceDataAtCell` methods.
 *
 * @param {Array|object} dataRow Object of row data, array of row data or an array of either.
 * @param {number} rowOffset Row offset to be passed to the resulting change list. Defaults to `0`.
 * @returns {Array} Array of changes (in a form of an array).
 */
function dataRowToChangesArray(dataRow) {
  let rowOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let dataRows = dataRow;
  const changesArray = [];
  if (!Array.isArray(dataRow) || !Array.isArray(dataRow[0])) {
    dataRows = [dataRow];
  }
  dataRows.forEach((row, rowIndex) => {
    if (Array.isArray(row)) {
      row.forEach((value, column) => {
        changesArray.push([rowIndex + rowOffset, column, value]);
      });
    } else {
      Object.keys(row).forEach(propName => {
        changesArray.push([rowIndex + rowOffset, propName, row[propName]]);
      });
    }
  });
  return changesArray;
}

/**
 * Count the number of keys (or, basically, columns when the data is an array or arrays) in the first row of the
 * provided dataset.
 *
 * @param {Array} data The dataset.
 * @returns {number} Number of keys in the first row of the dataset.
 */
function countFirstRowKeys(data) {
  let result = 0;
  if (Array.isArray(data)) {
    if (data[0] && Array.isArray(data[0])) {
      result = data[0].length;
    } else if (data[0] && (0, _object.isObject)(data[0])) {
      result = (0, _object.deepObjectSize)(data[0]);
    }
  }
  return result;
}

/**
 * Check whether the provided dataset is a *non-empty* array of arrays.
 *
 * @param {Array} data Dataset to be checked.
 * @returns {boolean} `true` if data is an array of arrays, `false` otherwise.
 */
function isArrayOfArrays(data) {
  return !!(Array.isArray(data) && data.length && data.every(el => Array.isArray(el)));
}

/**
 * Check whether the provided dataset is a *non-empty* array of objects.
 *
 * @param {Array} data Dataset to be checked.
 * @returns {boolean} `true` if data is an array of objects, `false` otherwise.
 */
function isArrayOfObjects(data) {
  return !!(Array.isArray(data) && data.length && data.every(el => typeof el === 'object' && !Array.isArray(el) && el !== null));
}

/***/ }),
/* 619 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(620);


/***/ }),
/* 620 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var iterate = __webpack_require__(331);
var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var getIteratorDirect = __webpack_require__(296);

// `Iterator.prototype.every` method
// https://tc39.es/ecma262/#sec-iterator.prototype.every
$({ target: 'Iterator', proto: true, real: true }, {
  every: function every(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return !iterate(record, function (value, stop) {
      if (!predicate(value, counter++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),
/* 621 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(311);
__webpack_require__(329);
exports.__esModule = true;
var _exportNames = {
  IndexMapper: true,
  getRegisteredMapsCounter: true,
  getIncreasedIndexes: true,
  getDecreasedIndexes: true,
  alterUtilsFactory: true
};
var _indexMapper = __webpack_require__(622);
exports.IndexMapper = _indexMapper.IndexMapper;
var _mapCollection = __webpack_require__(638);
exports.getRegisteredMapsCounter = _mapCollection.getRegisteredMapsCounter;
var _utils = __webpack_require__(635);
exports.getIncreasedIndexes = _utils.getIncreasedIndexes;
exports.getDecreasedIndexes = _utils.getDecreasedIndexes;
exports.alterUtilsFactory = _utils.alterUtilsFactory;
var _maps = __webpack_require__(625);
Object.keys(_maps).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _maps[key]) return;
  exports[key] = _maps[key];
});

/***/ }),
/* 622 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
__webpack_require__(201);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(323);
__webpack_require__(338);
__webpack_require__(623);
var _array = __webpack_require__(495);
var _maps = __webpack_require__(625);
var _mapCollections = __webpack_require__(636);
var _localHooks = _interopRequireDefault(__webpack_require__(599));
var _object = __webpack_require__(499);
var _mixed = __webpack_require__(354);
var _observable = __webpack_require__(639);
/**
 * A set of deprecated feature names.
 *
 * @type {Set<string>}
 */
// eslint-disable-next-line no-unused-vars
const deprecationWarns = new Set();

/**
 * @class IndexMapper
 * @description
 *
 * Index mapper stores, registers and manages the indexes on the basis of calculations collected from the subsidiary maps.
 * It should be seen as a single source of truth (regarding row and column indexes, for example, their sequence, information if they are skipped in the process of rendering (hidden or trimmed), values linked to them)
 * for any operation that considers CRUD actions such as **insertion**, **movement**, **removal** etc, and is used to properly calculate physical and visual indexes translations in both ways.
 * It has a built-in cache that is updated only when the data or structure changes.
 *
 * **Physical index** is a type of an index from the sequence of indexes assigned to the data source rows or columns
 *  (from 0 to n, where n is number of the cells on the axis of data set).
 * **Visual index** is a type of an index from the sequence of indexes assigned to rows or columns existing in {@link DataMap} (from 0 to n, where n is number of the cells on the axis of data set).
 * **Renderable index** is a type of an index from the sequence of indexes assigned to rows or columns whose may be rendered (when they are in a viewport; from 0 to n, where n is number of the cells renderable on the axis).
 *
 * There are different kinds of index maps which may be registered in the collections and can be used by a reference.
 * They also expose public API and trigger two local hooks such as `init` (on initialization) and `change` (on change).
 *
 * These are: {@link IndexesSequence}, {@link PhysicalIndexToValueMap}, {@link LinkedPhysicalIndexToValueMap}, {@link HidingMap}, and {@link TrimmingMap}.
 */
class IndexMapper {
  constructor() {
    /**
     * Map for storing the sequence of indexes.
     *
     * It is registered by default and may be used from API methods.
     *
     * @private
     * @type {IndexesSequence}
     */
    (0, _defineProperty2.default)(this, "indexesSequence", new _maps.IndexesSequence());
    /**
     * Collection for different trimming maps. Indexes marked as trimmed in any map WILL NOT be included in
     * the {@link DataMap} and won't be rendered.
     *
     * @private
     * @type {MapCollection}
     */
    (0, _defineProperty2.default)(this, "trimmingMapsCollection", new _mapCollections.AggregatedCollection(valuesForIndex => valuesForIndex.some(value => value === true), false));
    /**
     * Collection for different hiding maps. Indexes marked as hidden in any map WILL be included in the {@link DataMap},
     * but won't be rendered.
     *
     * @private
     * @type {MapCollection}
     */
    (0, _defineProperty2.default)(this, "hidingMapsCollection", new _mapCollections.AggregatedCollection(valuesForIndex => valuesForIndex.some(value => value === true), false));
    /**
     * Collection for another kind of maps. There are stored mappings from indexes (visual or physical) to values.
     *
     * @private
     * @type {MapCollection}
     */
    (0, _defineProperty2.default)(this, "variousMapsCollection", new _mapCollections.MapCollection());
    /**
     * The class instance collects row and column index changes that happen while the Handsontable
     * is running. The object allows creating observers that you can subscribe. Each event represents
     * the index change (e.g., insert, removing, change index value), which can be consumed by a
     * developer to update its logic.
     *
     * @private
     * @type {ChangesObservable}
     */
    (0, _defineProperty2.default)(this, "hidingChangesObservable", new _observable.ChangesObservable({
      initialIndexValue: false
    }));
    /**
     * Cache for list of not trimmed indexes, respecting the indexes sequence (physical indexes).
     *
     * Note: Please keep in mind that trimmed index can be also hidden.
     *
     * @private
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "notTrimmedIndexesCache", []);
    /**
     * Cache for list of not hidden indexes, respecting the indexes sequence (physical indexes).
     *
     * Note: Please keep in mind that hidden index can be also trimmed.
     *
     * @private
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "notHiddenIndexesCache", []);
    /**
     * Flag determining whether actions performed on index mapper have been batched. It's used for cache management.
     *
     * @private
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "isBatched", false);
    /**
     * Flag determining whether any action on indexes sequence has been performed. It's used for cache management.
     *
     * @private
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "indexesSequenceChanged", false);
    /**
     * Flag informing about source of the change.
     *
     * @type {undefined|string}
     */
    (0, _defineProperty2.default)(this, "indexesChangeSource", undefined);
    /**
     * Flag determining whether any action on trimmed indexes has been performed. It's used for cache management.
     *
     * @private
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "trimmedIndexesChanged", false);
    /**
     * Flag determining whether any action on hidden indexes has been performed. It's used for cache management.
     *
     * @private
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "hiddenIndexesChanged", false);
    /**
     * Physical indexes (respecting the sequence of indexes) which may be rendered (when they are in a viewport).
     *
     * @private
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "renderablePhysicalIndexesCache", []);
    /**
     * Visual indexes (native map's value) corresponding to physical indexes (native map's index).
     *
     * @private
     * @type {Map}
     */
    (0, _defineProperty2.default)(this, "fromPhysicalToVisualIndexesCache", new Map());
    /**
     * Visual indexes (native map's value) corresponding to physical indexes (native map's index).
     *
     * @private
     * @type {Map}
     */
    (0, _defineProperty2.default)(this, "fromVisualToRenderableIndexesCache", new Map());
    this.indexesSequence.addLocalHook('change', () => {
      this.indexesSequenceChanged = true;

      // Sequence of stored indexes might change.
      this.updateCache();
      this.runLocalHooks('indexesSequenceChange', this.indexesChangeSource);
      this.runLocalHooks('change', this.indexesSequence, null);
    });
    this.trimmingMapsCollection.addLocalHook('change', changedMap => {
      this.trimmedIndexesChanged = true;

      // Number of trimmed indexes might change.
      this.updateCache();
      this.runLocalHooks('change', changedMap, this.trimmingMapsCollection);
    });
    this.hidingMapsCollection.addLocalHook('change', changedMap => {
      this.hiddenIndexesChanged = true;

      // Number of hidden indexes might change.
      this.updateCache();
      this.runLocalHooks('change', changedMap, this.hidingMapsCollection);
    });
    this.variousMapsCollection.addLocalHook('change', changedMap => {
      this.runLocalHooks('change', changedMap, this.variousMapsCollection);
    });
  }

  /**
   * Suspends the cache update for this map. The method is helpful to group multiple
   * operations, which affects the cache. In this case, the cache will be updated once after
   * calling the `resumeOperations` method.
   */
  suspendOperations() {
    this.isBatched = true;
  }

  /**
   * Resumes the cache update for this map. It recalculates the cache and restores the
   * default behavior where each map modification updates the cache.
   */
  resumeOperations() {
    this.isBatched = false;
    this.updateCache();
  }

  /**
   * It creates and returns the new instance of the ChangesObserver object. The object
   * allows listening to the index changes that happen while the Handsontable is running.
   *
   * @param {string} indexMapType The index map type which we want to observe.
   *                              Currently, only the 'hiding' index map types are observable.
   * @returns {ChangesObserver}
   */
  createChangesObserver(indexMapType) {
    if (indexMapType !== 'hiding') {
      throw new Error(`Unsupported index map type "${indexMapType}".`);
    }
    return this.hidingChangesObservable.createObserver();
  }

  /**
   * Creates and registers a new `IndexMap` for a specified `IndexMapper` instance.
   *
   * @param {string} indexName A unique index name.
   * @param {string} mapType The index map type (e.g., "hiding", "trimming", "physicalIndexToValue").
   * @param {*} [initValueOrFn] The initial value for the index map.
   * @returns {IndexMap}
   */
  createAndRegisterIndexMap(indexName, mapType, initValueOrFn) {
    return this.registerMap(indexName, (0, _maps.createIndexMap)(mapType, initValueOrFn));
  }

  /**
   * Register map which provide some index mappings. Type of map determining to which collection it will be added.
   *
   * @param {string} uniqueName Name of the index map. It should be unique.
   * @param {IndexMap} indexMap Registered index map updated on items removal and insertion.
   * @returns {IndexMap}
   */
  registerMap(uniqueName, indexMap) {
    if (this.trimmingMapsCollection.get(uniqueName) || this.hidingMapsCollection.get(uniqueName) || this.variousMapsCollection.get(uniqueName)) {
      throw Error(`Map with name "${uniqueName}" has been already registered.`);
    }
    if (indexMap instanceof _maps.TrimmingMap) {
      this.trimmingMapsCollection.register(uniqueName, indexMap);
    } else if (indexMap instanceof _maps.HidingMap) {
      this.hidingMapsCollection.register(uniqueName, indexMap);
    } else {
      this.variousMapsCollection.register(uniqueName, indexMap);
    }
    const numberOfIndexes = this.getNumberOfIndexes();

    /*
      We initialize map ony when we have full information about number of indexes and the dataset is not empty.
      Otherwise it's unnecessary. Initialization of empty array would not give any positive changes. After initializing
      it with number of indexes equal to 0 the map would be still empty. What's more there would be triggered
      not needed hook (no real change have occurred). Number of indexes is known after loading data (the `loadData`
      function from the `Core`).
     */
    if (numberOfIndexes > 0) {
      indexMap.init(numberOfIndexes);
    }
    return indexMap;
  }

  /**
   * Unregister a map with given name.
   *
   * @param {string} name Name of the index map.
   */
  unregisterMap(name) {
    this.trimmingMapsCollection.unregister(name);
    this.hidingMapsCollection.unregister(name);
    this.variousMapsCollection.unregister(name);
  }

  /**
   * Unregisters all collected index map instances from all map collection types.
   */
  unregisterAll() {
    this.trimmingMapsCollection.unregisterAll();
    this.hidingMapsCollection.unregisterAll();
    this.variousMapsCollection.unregisterAll();
  }

  /**
   * Get a physical index corresponding to the given visual index.
   *
   * @param {number} visualIndex Visual index.
   * @returns {number|null} Returns translated index mapped by passed visual index.
   */
  getPhysicalFromVisualIndex(visualIndex) {
    // Index in the table boundaries provided by the `DataMap`.
    const physicalIndex = this.notTrimmedIndexesCache[visualIndex];
    if ((0, _mixed.isDefined)(physicalIndex)) {
      return physicalIndex;
    }
    return null;
  }

  /**
   * Get a physical index corresponding to the given renderable index.
   *
   * @param {number} renderableIndex Renderable index.
   * @returns {null|number}
   */
  getPhysicalFromRenderableIndex(renderableIndex) {
    const physicalIndex = this.renderablePhysicalIndexesCache[renderableIndex];

    // Index in the renderable table boundaries.
    if ((0, _mixed.isDefined)(physicalIndex)) {
      return physicalIndex;
    }
    return null;
  }

  /**
   * Get a visual index corresponding to the given physical index.
   *
   * @param {number} physicalIndex Physical index to search.
   * @returns {number|null} Returns a visual index of the index mapper.
   */
  getVisualFromPhysicalIndex(physicalIndex) {
    const visualIndex = this.fromPhysicalToVisualIndexesCache.get(physicalIndex);

    // Index in the table boundaries provided by the `DataMap`.
    if ((0, _mixed.isDefined)(visualIndex)) {
      return visualIndex;
    }
    return null;
  }

  /**
   * Get a visual index corresponding to the given renderable index.
   *
   * @param {number} renderableIndex Renderable index.
   * @returns {null|number}
   */
  getVisualFromRenderableIndex(renderableIndex) {
    return this.getVisualFromPhysicalIndex(this.getPhysicalFromRenderableIndex(renderableIndex));
  }

  /**
   * Get a renderable index corresponding to the given visual index.
   *
   * @param {number} visualIndex Visual index.
   * @returns {null|number}
   */
  getRenderableFromVisualIndex(visualIndex) {
    const renderableIndex = this.fromVisualToRenderableIndexesCache.get(visualIndex);

    // Index in the renderable table boundaries.
    if ((0, _mixed.isDefined)(renderableIndex)) {
      return renderableIndex;
    }
    return null;
  }

  /**
   * Search for the nearest not-hidden row or column.
   *
   * @param {number} fromVisualIndex The visual index of the row or column from which the search starts.<br><br>
   * If the row or column from which the search starts is not hidden, the method simply returns the `fromVisualIndex` number.
   * @param {number} searchDirection The search direction.<br><br>`1`: search from `fromVisualIndex` to the end of the dataset.<br><br>
   * `-1`: search from `fromVisualIndex` to the beginning of the dataset (i.e., to the row or column at visual index `0`).
   * @param {boolean} searchAlsoOtherWayAround `true`: if a search in a first direction failed, try the opposite direction.<br><br>
   * `false`: search in one direction only.
   *
   * @returns {number|null} A visual index of a row or column, or `null`.
   */
  getNearestNotHiddenIndex(fromVisualIndex, searchDirection) {
    let searchAlsoOtherWayAround = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const physicalIndex = this.getPhysicalFromVisualIndex(fromVisualIndex);
    if (physicalIndex === null) {
      return null;
    }
    if (this.fromVisualToRenderableIndexesCache.has(fromVisualIndex)) {
      return fromVisualIndex;
    }
    const visibleIndexes = Array.from(this.fromVisualToRenderableIndexesCache.keys());
    let index = -1;
    if (searchDirection > 0) {
      index = visibleIndexes.findIndex(visualIndex => visualIndex > fromVisualIndex);
    } else {
      index = visibleIndexes.reverse().findIndex(visualIndex => visualIndex < fromVisualIndex);
    }
    if (index === -1) {
      if (searchAlsoOtherWayAround) {
        return this.getNearestNotHiddenIndex(fromVisualIndex, -searchDirection, false);
      }
      return null;
    }
    return visibleIndexes[index];
  }

  /**
   * Set default values for all indexes in registered index maps.
   *
   * @param {number} [length] Destination length for all stored index maps.
   */
  initToLength() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNumberOfIndexes();
    this.notTrimmedIndexesCache = [...new Array(length).keys()];
    this.notHiddenIndexesCache = [...new Array(length).keys()];
    this.suspendOperations();
    this.indexesChangeSource = 'init';
    this.indexesSequence.init(length);
    this.indexesChangeSource = undefined;
    this.trimmingMapsCollection.initEvery(length);
    this.resumeOperations();

    // We move initialization of hidden collection to next batch for purpose of working on sequence of already trimmed indexes.
    this.suspendOperations();
    this.hidingMapsCollection.initEvery(length);

    // It shouldn't reset the cache.
    this.variousMapsCollection.initEvery(length);
    this.resumeOperations();
    this.runLocalHooks('init');
  }

  /**
   * Trim/extend the mappers to fit the desired length.
   *
   * @param {number} length New mapper length.
   */
  fitToLength(length) {
    const currentIndexCount = this.getNumberOfIndexes();
    if (length < currentIndexCount) {
      const indexesToBeRemoved = [...Array(this.getNumberOfIndexes() - length).keys()].map(i => i + length);
      this.removeIndexes(indexesToBeRemoved);
    } else {
      this.insertIndexes(currentIndexCount, length - currentIndexCount);
    }
  }

  /**
   * Get sequence of indexes.
   *
   * @returns {Array} Physical indexes.
   */
  getIndexesSequence() {
    return this.indexesSequence.getValues();
  }

  /**
   * Set completely new indexes sequence.
   *
   * @param {Array} indexes Physical indexes.
   */
  setIndexesSequence(indexes) {
    if (this.indexesChangeSource === undefined) {
      this.indexesChangeSource = 'update';
    }
    this.indexesSequence.setValues(indexes);
    if (this.indexesChangeSource === 'update') {
      this.indexesChangeSource = undefined;
    }
  }

  /**
   * Get all NOT trimmed indexes.
   *
   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.
   *
   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
   * @returns {Array} List of physical indexes. Index of this native array is a "visual index",
   * value of this native array is a "physical index".
   */
  getNotTrimmedIndexes() {
    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (readFromCache === true) {
      return this.notTrimmedIndexesCache;
    }
    const indexesSequence = this.getIndexesSequence();
    return indexesSequence.filter(physicalIndex => this.isTrimmed(physicalIndex) === false);
  }

  /**
   * Get length of all NOT trimmed indexes.
   *
   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.
   *
   * @returns {number}
   */
  getNotTrimmedIndexesLength() {
    return this.getNotTrimmedIndexes().length;
  }

  /**
   * Get all NOT hidden indexes.
   *
   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.
   *
   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
   * @returns {Array} List of physical indexes. Please keep in mind that index of this native array IS NOT a "visual index".
   */
  getNotHiddenIndexes() {
    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (readFromCache === true) {
      return this.notHiddenIndexesCache;
    }
    const indexesSequence = this.getIndexesSequence();
    return indexesSequence.filter(physicalIndex => this.isHidden(physicalIndex) === false);
  }

  /**
   * Get length of all NOT hidden indexes.
   *
   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.
   *
   * @returns {number}
   */
  getNotHiddenIndexesLength() {
    return this.getNotHiddenIndexes().length;
  }

  /**
   * Get list of physical indexes (respecting the sequence of indexes) which may be rendered (when they are in a viewport).
   *
   * @param {boolean} [readFromCache=true] Determine if read indexes from cache.
   * @returns {Array} List of physical indexes. Index of this native array is a "renderable index",
   * value of this native array is a "physical index".
   */
  getRenderableIndexes() {
    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (readFromCache === true) {
      return this.renderablePhysicalIndexesCache;
    }
    const notTrimmedIndexes = this.getNotTrimmedIndexes();
    return notTrimmedIndexes.filter(physicalIndex => this.isHidden(physicalIndex) === false);
  }

  /**
   * Get length of all NOT trimmed and NOT hidden indexes.
   *
   * @returns {number}
   */
  getRenderableIndexesLength() {
    return this.getRenderableIndexes().length;
  }

  /**
   * Get number of all indexes.
   *
   * @returns {number}
   */
  getNumberOfIndexes() {
    return this.getIndexesSequence().length;
  }

  /**
   * Move indexes in the index mapper.
   *
   * @param {number|Array} movedIndexes Visual index(es) to move.
   * @param {number} finalIndex Visual index being a start index for the moved elements.
   */
  moveIndexes(movedIndexes, finalIndex) {
    if (typeof movedIndexes === 'number') {
      movedIndexes = [movedIndexes];
    }
    const physicalMovedIndexes = (0, _array.arrayMap)(movedIndexes, visualIndex => this.getPhysicalFromVisualIndex(visualIndex));
    const notTrimmedIndexesLength = this.getNotTrimmedIndexesLength();
    const movedIndexesLength = movedIndexes.length;

    // Removing moved indexes without re-indexing.
    const notMovedIndexes = (0, _maps.getListWithRemovedItems)(this.getIndexesSequence(), physicalMovedIndexes);
    const notTrimmedNotMovedItems = notMovedIndexes.filter(index => this.isTrimmed(index) === false);

    // When item(s) are moved after the last visible item we assign the last possible index.
    let destinationPosition = notMovedIndexes.indexOf(notTrimmedNotMovedItems[notTrimmedNotMovedItems.length - 1]) + 1;

    // Otherwise, we find proper index for inserted item(s).
    if (finalIndex + movedIndexesLength < notTrimmedIndexesLength) {
      // Physical index at final index position.
      const physicalIndex = notTrimmedNotMovedItems[finalIndex];
      destinationPosition = notMovedIndexes.indexOf(physicalIndex);
    }
    this.indexesChangeSource = 'move';

    // Adding indexes without re-indexing.
    this.setIndexesSequence((0, _maps.getListWithInsertedItems)(notMovedIndexes, destinationPosition, physicalMovedIndexes));
    this.indexesChangeSource = undefined;
  }

  /**
   * Get whether index is trimmed. Index marked as trimmed isn't included in a {@link DataMap} and isn't rendered.
   *
   * @param {number} physicalIndex Physical index.
   * @returns {boolean}
   */
  isTrimmed(physicalIndex) {
    return this.trimmingMapsCollection.getMergedValueAtIndex(physicalIndex);
  }

  /**
   * Get whether index is hidden. Index marked as hidden is included in a {@link DataMap}, but isn't rendered.
   *
   * @param {number} physicalIndex Physical index.
   * @returns {boolean}
   */
  isHidden(physicalIndex) {
    return this.hidingMapsCollection.getMergedValueAtIndex(physicalIndex);
  }

  /**
   * Insert new indexes and corresponding mapping and update values of the others, for all stored index maps.
   *
   * @private
   * @param {number} firstInsertedVisualIndex First inserted visual index.
   * @param {number} amountOfIndexes Amount of inserted indexes.
   */
  insertIndexes(firstInsertedVisualIndex, amountOfIndexes) {
    const nthVisibleIndex = this.getNotTrimmedIndexes()[firstInsertedVisualIndex];
    const firstInsertedPhysicalIndex = (0, _mixed.isDefined)(nthVisibleIndex) ? nthVisibleIndex : this.getNumberOfIndexes();
    const insertionIndex = this.getIndexesSequence().includes(nthVisibleIndex) ? this.getIndexesSequence().indexOf(nthVisibleIndex) : this.getNumberOfIndexes();
    const insertedIndexes = (0, _array.arrayMap)(new Array(amountOfIndexes).fill(firstInsertedPhysicalIndex), (nextIndex, stepsFromStart) => nextIndex + stepsFromStart);
    this.suspendOperations();
    this.indexesChangeSource = 'insert';
    this.indexesSequence.insert(insertionIndex, insertedIndexes);
    this.indexesChangeSource = undefined;
    this.trimmingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
    this.hidingMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
    this.variousMapsCollection.insertToEvery(insertionIndex, insertedIndexes);
    this.resumeOperations();
  }

  /**
   * Remove some indexes and corresponding mappings and update values of the others, for all stored index maps.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  removeIndexes(removedIndexes) {
    this.suspendOperations();
    this.indexesChangeSource = 'remove';
    this.indexesSequence.remove(removedIndexes);
    this.indexesChangeSource = undefined;
    this.trimmingMapsCollection.removeFromEvery(removedIndexes);
    this.hidingMapsCollection.removeFromEvery(removedIndexes);
    this.variousMapsCollection.removeFromEvery(removedIndexes);
    this.resumeOperations();
  }

  /**
   * Rebuild cache for some indexes. Every action on indexes sequence or indexes skipped in the process of rendering
   * by default reset cache, thus batching some index maps actions is recommended.
   *
   * @private
   * @param {boolean} [force=false] Determine if force cache update.
   */
  updateCache() {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const anyCachedIndexChanged = this.indexesSequenceChanged || this.trimmedIndexesChanged || this.hiddenIndexesChanged;
    if (force === true || this.isBatched === false && anyCachedIndexChanged === true) {
      this.trimmingMapsCollection.updateCache();
      this.hidingMapsCollection.updateCache();
      this.notTrimmedIndexesCache = this.getNotTrimmedIndexes(false);
      this.notHiddenIndexesCache = this.getNotHiddenIndexes(false);
      this.renderablePhysicalIndexesCache = this.getRenderableIndexes(false);
      this.cacheFromPhysicalToVisualIndexes();
      this.cacheFromVisualToRenderableIndexes();

      // Currently there's support only for the "hiding" map type.
      if (this.hiddenIndexesChanged) {
        this.hidingChangesObservable.emit(this.hidingMapsCollection.getMergedValues());
      }
      this.runLocalHooks('cacheUpdated', {
        indexesSequenceChanged: this.indexesSequenceChanged,
        trimmedIndexesChanged: this.trimmedIndexesChanged,
        hiddenIndexesChanged: this.hiddenIndexesChanged
      });
      this.indexesSequenceChanged = false;
      this.trimmedIndexesChanged = false;
      this.hiddenIndexesChanged = false;
    }
  }

  /**
   * Update cache for translations from physical to visual indexes.
   *
   * @private
   */
  cacheFromPhysicalToVisualIndexes() {
    const nrOfNotTrimmedIndexes = this.getNotTrimmedIndexesLength();
    this.fromPhysicalToVisualIndexesCache.clear();
    for (let visualIndex = 0; visualIndex < nrOfNotTrimmedIndexes; visualIndex += 1) {
      const physicalIndex = this.getPhysicalFromVisualIndex(visualIndex);

      // Every visual index have corresponding physical index, but some physical indexes may don't have
      // corresponding visual indexes (physical indexes may represent trimmed indexes, beyond the table boundaries)
      this.fromPhysicalToVisualIndexesCache.set(physicalIndex, visualIndex);
    }
  }

  /**
   * Update cache for translations from visual to renderable indexes.
   *
   * @private
   */
  cacheFromVisualToRenderableIndexes() {
    const nrOfRenderableIndexes = this.getRenderableIndexesLength();
    this.fromVisualToRenderableIndexesCache.clear();
    for (let renderableIndex = 0; renderableIndex < nrOfRenderableIndexes; renderableIndex += 1) {
      // Can't use getRenderableFromVisualIndex here because we're building the cache here
      const physicalIndex = this.getPhysicalFromRenderableIndex(renderableIndex);
      const visualIndex = this.getVisualFromPhysicalIndex(physicalIndex);
      this.fromVisualToRenderableIndexesCache.set(visualIndex, renderableIndex);
    }
  }
}
exports.IndexMapper = IndexMapper;
(0, _object.mixin)(IndexMapper, _localHooks.default);

/***/ }),
/* 623 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(624);


/***/ }),
/* 624 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(202);
var iterate = __webpack_require__(331);
var aCallable = __webpack_require__(229);
var anObject = __webpack_require__(245);
var getIteratorDirect = __webpack_require__(296);

// `Iterator.prototype.some` method
// https://tc39.es/ecma262/#sec-iterator.prototype.some
$({ target: 'Iterator', proto: true, real: true }, {
  some: function some(predicate) {
    anObject(this);
    aCallable(predicate);
    var record = getIteratorDirect(this);
    var counter = 0;
    return iterate(record, function (value, stop) {
      if (predicate(value, counter++)) return stop();
    }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
  }
});


/***/ }),
/* 625 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(311);
__webpack_require__(329);
exports.__esModule = true;
var _exportNames = {
  createIndexMap: true,
  HidingMap: true,
  IndexMap: true,
  LinkedPhysicalIndexToValueMap: true,
  PhysicalIndexToValueMap: true,
  TrimmingMap: true
};
exports.createIndexMap = createIndexMap;
__webpack_require__(201);
var _hidingMap = __webpack_require__(626);
exports.HidingMap = _hidingMap.HidingMap;
var _indexMap = __webpack_require__(628);
exports.IndexMap = _indexMap.IndexMap;
var _linkedPhysicalIndexToValueMap = __webpack_require__(630);
exports.LinkedPhysicalIndexToValueMap = _linkedPhysicalIndexToValueMap.LinkedPhysicalIndexToValueMap;
var _physicalIndexToValueMap = __webpack_require__(627);
exports.PhysicalIndexToValueMap = _physicalIndexToValueMap.PhysicalIndexToValueMap;
var _trimmingMap = __webpack_require__(633);
exports.TrimmingMap = _trimmingMap.TrimmingMap;
var _indexesSequence = __webpack_require__(634);
Object.keys(_indexesSequence).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _indexesSequence[key]) return;
  exports[key] = _indexesSequence[key];
});
var _indexesSequence2 = __webpack_require__(631);
Object.keys(_indexesSequence2).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _indexesSequence2[key]) return;
  exports[key] = _indexesSequence2[key];
});
const availableIndexMapTypes = new Map([['hiding', _hidingMap.HidingMap], ['index', _indexMap.IndexMap], ['linkedPhysicalIndexToValue', _linkedPhysicalIndexToValueMap.LinkedPhysicalIndexToValueMap], ['physicalIndexToValue', _physicalIndexToValueMap.PhysicalIndexToValueMap], ['trimming', _trimmingMap.TrimmingMap]]);

/**
 * Creates and returns new IndexMap instance.
 *
 * @param {string} mapType The type of the map.
 * @param {*} [initValueOrFn=null] Initial value or function for index map.
 * @returns {IndexMap}
 */
function createIndexMap(mapType) {
  let initValueOrFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!availableIndexMapTypes.has(mapType)) {
    throw new Error(`The provided map type ("${mapType}") does not exist.`);
  }
  return new (availableIndexMapTypes.get(mapType))(initValueOrFn);
}

/***/ }),
/* 626 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(283);
var _physicalIndexToValueMap = __webpack_require__(627);
var _array = __webpack_require__(495);
/**
 * Map for storing mappings from an physical index to a boolean value. It stores information whether physical index is
 * included in a dataset, but skipped in the process of rendering.
 *
 * @class HidingMap
 */
class HidingMap extends _physicalIndexToValueMap.PhysicalIndexToValueMap {
  constructor() {
    let initValueOrFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    super(initValueOrFn);
  }

  /**
   * Get physical indexes which are hidden.
   *
   * Note: Indexes marked as hidden are included in a {@link DataMap}, but aren't rendered.
   *
   * @returns {Array}
   */
  getHiddenIndexes() {
    return (0, _array.arrayReduce)(this.getValues(), (indexesList, isHidden, physicalIndex) => {
      if (isHidden) {
        indexesList.push(physicalIndex);
      }
      return indexesList;
    }, []);
  }
}
exports.HidingMap = HidingMap;

/***/ }),
/* 627 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _indexMap = __webpack_require__(628);
var _physicallyIndexed = __webpack_require__(629);
/**
 * Map for storing mappings from an physical index to a value.
 *
 * Does not update stored values on remove/add row or column action.
 *
 * @class PhysicalIndexToValueMap
 */
class PhysicalIndexToValueMap extends _indexMap.IndexMap {
  /**
   * Add values to list and reorganize.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    this.indexedValues = (0, _physicallyIndexed.getListWithInsertedItems)(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);
    super.insert(insertionIndex, insertedIndexes);
  }

  /**
   * Remove values from the list and reorganize.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    this.indexedValues = (0, _physicallyIndexed.getListWithRemovedItems)(this.indexedValues, removedIndexes);
    super.remove(removedIndexes);
  }
}
exports.PhysicalIndexToValueMap = PhysicalIndexToValueMap;

/***/ }),
/* 628 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _number = __webpack_require__(534);
var _object = __webpack_require__(499);
var _function = __webpack_require__(497);
var _localHooks = _interopRequireDefault(__webpack_require__(599));
/**
 * Map for storing mappings from an index to a value.
 *
 * @class IndexMap
 */
class IndexMap {
  constructor() {
    let initValueOrFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    /**
     * List of values for particular indexes.
     *
     * @private
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "indexedValues", []);
    /**
     * Initial value or function for each existing index.
     *
     * @private
     * @type {*}
     */
    (0, _defineProperty2.default)(this, "initValueOrFn", void 0);
    this.initValueOrFn = initValueOrFn;
  }

  /**
   * Get full list of values for particular indexes.
   *
   * @returns {Array}
   */
  getValues() {
    return this.indexedValues;
  }

  /**
   * Get value for the particular index.
   *
   * @param {number} index Index for which value is got.
   * @returns {*}
   */
  getValueAtIndex(index) {
    const values = this.indexedValues;
    if (index < values.length) {
      return values[index];
    }
  }

  /**
   * Set new values for particular indexes.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @param {Array} values List of set values.
   */
  setValues(values) {
    this.indexedValues = values.slice();
    this.runLocalHooks('change');
  }

  /**
   * Set new value for the particular index.
   *
   * @param {number} index The index.
   * @param {*} value The value to save.
   *
   * Note: Please keep in mind that it is not possible to set value beyond the map (not respecting already set
   * map's size). Please use the `setValues` method when you would like to extend the map.
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @returns {boolean}
   */
  setValueAtIndex(index, value) {
    if (index < this.indexedValues.length) {
      this.indexedValues[index] = value;
      this.runLocalHooks('change');
      return true;
    }
    return false;
  }

  /**
   * Clear all values to the defaults.
   */
  clear() {
    this.setDefaultValues();
  }

  /**
   * Get length of the index map.
   *
   * @returns {number}
   */
  getLength() {
    return this.getValues().length;
  }

  /**
   * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @private
   * @param {number} [length] Length of list.
   */
  setDefaultValues() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.indexedValues.length;
    this.indexedValues.length = 0;
    if ((0, _function.isFunction)(this.initValueOrFn)) {
      (0, _number.rangeEach)(length - 1, index => this.indexedValues.push(this.initValueOrFn(index)));
    } else {
      (0, _number.rangeEach)(length - 1, () => this.indexedValues.push(this.initValueOrFn));
    }
    this.runLocalHooks('change');
  }

  /**
   * Initialize list with default values for particular indexes.
   *
   * @private
   * @param {number} length New length of indexed list.
   * @returns {IndexMap}
   */
  init(length) {
    this.setDefaultValues(length);
    this.runLocalHooks('init');
    return this;
  }

  /**
   * Add values to the list.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @private
   */
  insert() {
    this.runLocalHooks('change');
  }

  /**
   * Remove values from the list.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @private
   */
  remove() {
    this.runLocalHooks('change');
  }

  /**
   * Destroys the Map instance.
   */
  destroy() {
    this.clearLocalHooks();
    this.indexedValues = null;
    this.initValueOrFn = null;
  }
}
exports.IndexMap = IndexMap;
(0, _object.mixin)(IndexMap, _localHooks.default);

/***/ }),
/* 629 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.getListWithInsertedItems = getListWithInsertedItems;
exports.getListWithRemovedItems = getListWithRemovedItems;
__webpack_require__(338);
var _function = __webpack_require__(497);
var _array = __webpack_require__(495);
/**
 * Insert new items to the list.
 *
 * @private
 * @param {Array} indexedValues List of values for particular indexes.
 * @param {number} insertionIndex Position inside the actual list.
 * @param {Array} insertedIndexes List of inserted indexes.
 * @param {*} insertedValuesMapping Mapping which may provide value or function returning value for the specific parameters.
 * @returns {Array} List with new mappings.
 */
function getListWithInsertedItems(indexedValues, insertionIndex, insertedIndexes, insertedValuesMapping) {
  const firstInsertedIndex = insertedIndexes.length ? insertedIndexes[0] : undefined;
  return [...indexedValues.slice(0, firstInsertedIndex), ...insertedIndexes.map((insertedIndex, ordinalNumber) => {
    if ((0, _function.isFunction)(insertedValuesMapping)) {
      return insertedValuesMapping(insertedIndex, ordinalNumber);
    }
    return insertedValuesMapping;
  }), ...(firstInsertedIndex === undefined ? [] : indexedValues.slice(firstInsertedIndex))];
}

/**
 * Filter items from the list.
 *
 * @private
 * @param {Array} indexedValues List of values for particular indexes.
 * @param {Array} removedIndexes List of removed indexes.
 * @returns {Array} Reduced list of mappings.
 */
function getListWithRemovedItems(indexedValues, removedIndexes) {
  return (0, _array.arrayFilter)(indexedValues, (_, index) => removedIndexes.includes(index) === false);
}

/***/ }),
/* 630 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(338);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _indexMap = __webpack_require__(628);
var _physicallyIndexed = __webpack_require__(629);
var _indexesSequence = __webpack_require__(631);
var _actionsOnIndexes = __webpack_require__(632);
var _function = __webpack_require__(497);
/**
 * Map for storing mappings from an physical index to a value. Those entries are linked and stored in a certain order.
 *
 * It does not update stored values on remove/add row or column action. Otherwise, order of entries is updated after
 * such changes.
 *
 * @class LinkedPhysicalIndexToValueMap
 */
class LinkedPhysicalIndexToValueMap extends _indexMap.IndexMap {
  constructor() {
    super(...arguments);
    /**
     * Indexes and values corresponding to them (entries) are stored in a certain order.
     *
     * @private
     * @type {Array<number>}
     */
    (0, _defineProperty2.default)(this, "orderOfIndexes", []);
  }
  /**
   * Get full list of ordered values for particular indexes.
   *
   * @returns {Array}
   */
  getValues() {
    return this.orderOfIndexes.map(physicalIndex => this.indexedValues[physicalIndex]);
  }

  /**
   * Set new values for particular indexes. Entries are linked and stored in a certain order.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @param {Array} values List of set values.
   */
  setValues(values) {
    this.orderOfIndexes = [...Array(values.length).keys()];
    super.setValues(values);
  }

  /**
   * Set value at index and add it to the linked list of entries. Entries are stored in a certain order.
   *
   * Note: Value will be added at the end of the queue.
   *
   * @param {number} index The index.
   * @param {*} value The value to save.
   * @param {number} position Position to which entry will be added.
   *
   * @returns {boolean}
   */
  setValueAtIndex(index, value) {
    let position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.orderOfIndexes.length;
    if (index < this.indexedValues.length) {
      this.indexedValues[index] = value;
      if (this.orderOfIndexes.includes(index) === false) {
        this.orderOfIndexes.splice(position, 0, index);
      }
      this.runLocalHooks('change');
      return true;
    }
    return false;
  }

  /**
   * Clear value for particular index.
   *
   * @param {number} physicalIndex Physical index.
   */
  clearValue(physicalIndex) {
    this.orderOfIndexes = (0, _indexesSequence.getListWithRemovedItems)(this.orderOfIndexes, [physicalIndex]);
    if ((0, _function.isFunction)(this.initValueOrFn)) {
      super.setValueAtIndex(physicalIndex, this.initValueOrFn(physicalIndex));
    } else {
      super.setValueAtIndex(physicalIndex, this.initValueOrFn);
    }
  }

  /**
   * Get length of the index map.
   *
   * @returns {number}
   */
  getLength() {
    return this.orderOfIndexes.length;
  }

  /**
   * Set default values for elements from `0` to `n`, where `n` is equal to the handled variable.
   *
   * Note: Please keep in mind that `change` hook triggered by the method may not update cache of a collection immediately.
   *
   * @private
   * @param {number} [length] Length of list.
   */
  setDefaultValues() {
    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.indexedValues.length;
    this.orderOfIndexes.length = 0;
    super.setDefaultValues(length);
  }

  /**
   * Add values to list and reorganize. It updates list of indexes related to ordered values.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    this.indexedValues = (0, _physicallyIndexed.getListWithInsertedItems)(this.indexedValues, insertionIndex, insertedIndexes, this.initValueOrFn);
    this.orderOfIndexes = (0, _actionsOnIndexes.getIncreasedIndexes)(this.orderOfIndexes, insertedIndexes);
    super.insert(insertionIndex, insertedIndexes);
  }

  /**
   * Remove values from the list and reorganize. It updates list of indexes related to ordered values.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    this.indexedValues = (0, _physicallyIndexed.getListWithRemovedItems)(this.indexedValues, removedIndexes);
    this.orderOfIndexes = (0, _indexesSequence.getListWithRemovedItems)(this.orderOfIndexes, removedIndexes);
    this.orderOfIndexes = (0, _actionsOnIndexes.getDecreasedIndexes)(this.orderOfIndexes, removedIndexes);
    super.remove(removedIndexes);
  }

  /**
   * Get every entry containing index and value, respecting order of indexes.
   *
   * @returns {Array}
   */
  getEntries() {
    return this.orderOfIndexes.map(physicalIndex => [physicalIndex, this.getValueAtIndex(physicalIndex)]);
  }
}
exports.LinkedPhysicalIndexToValueMap = LinkedPhysicalIndexToValueMap;

/***/ }),
/* 631 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.getListWithInsertedItems = getListWithInsertedItems;
exports.getListWithRemovedItems = getListWithRemovedItems;
var _array = __webpack_require__(495);
/**
 * Insert new items to the list.
 *
 * @private
 * @param {Array} indexedValues List of values for particular indexes.
 * @param {number} insertionIndex Position inside the actual list.
 * @param {Array} insertedIndexes List of inserted indexes.
 * @returns {Array} List with new mappings.
 */
function getListWithInsertedItems(indexedValues, insertionIndex, insertedIndexes) {
  return [...indexedValues.slice(0, insertionIndex), ...insertedIndexes, ...indexedValues.slice(insertionIndex)];
}

/**
 * Filter items from the list.
 *
 * @private
 * @param {Array} indexedValues List of values for particular indexes.
 * @param {Array} removedIndexes List of removed indexes.
 * @returns {Array} Reduced list of mappings.
 */
function getListWithRemovedItems(indexedValues, removedIndexes) {
  return (0, _array.arrayFilter)(indexedValues, index => {
    return removedIndexes.includes(index) === false;
  });
}

/***/ }),
/* 632 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.getDecreasedIndexes = getDecreasedIndexes;
exports.getIncreasedIndexes = getIncreasedIndexes;
__webpack_require__(311);
__webpack_require__(323);
var _array = __webpack_require__(495);
/**
 * Transform mappings after removal.
 *
 * @private
 * @param {Array} indexedValues List of values for particular indexes.
 * @param {Array} removedIndexes List of removed indexes.
 * @returns {Array} List with decreased indexes.
 */
function getDecreasedIndexes(indexedValues, removedIndexes) {
  return (0, _array.arrayMap)(indexedValues, index => index - removedIndexes.filter(removedIndex => removedIndex < index).length);
}

/**
 * Transform mappings after insertion.
 *
 * @private
 * @param {Array} indexedValues List of values for particular indexes.
 * @param {Array} insertedIndexes List of inserted indexes.
 * @returns {Array} List with increased indexes.
 */
function getIncreasedIndexes(indexedValues, insertedIndexes) {
  const firstInsertedIndex = insertedIndexes[0];
  const amountOfIndexes = insertedIndexes.length;
  return (0, _array.arrayMap)(indexedValues, index => {
    if (index >= firstInsertedIndex) {
      return index + amountOfIndexes;
    }
    return index;
  });
}

/***/ }),
/* 633 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(283);
var _physicalIndexToValueMap = __webpack_require__(627);
var _array = __webpack_require__(495);
/**
 * Map for storing mappings from an physical index to a boolean value. It stores information whether physical index is
 * NOT included in a dataset and skipped in the process of rendering.
 *
 * @class TrimmingMap
 */
class TrimmingMap extends _physicalIndexToValueMap.PhysicalIndexToValueMap {
  constructor() {
    let initValueOrFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    super(initValueOrFn);
  }

  /**
   * Get physical indexes which are trimmed.
   *
   * Note: Indexes marked as trimmed aren't included in a {@link DataMap} and aren't rendered.
   *
   * @returns {Array}
   */
  getTrimmedIndexes() {
    return (0, _array.arrayReduce)(this.getValues(), (indexesList, isTrimmed, physicalIndex) => {
      if (isTrimmed) {
        indexesList.push(physicalIndex);
      }
      return indexesList;
    }, []);
  }
}
exports.TrimmingMap = TrimmingMap;

/***/ }),
/* 634 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _indexMap = __webpack_require__(628);
var _indexesSequence = __webpack_require__(631);
var _utils = __webpack_require__(635);
/**
 * Map for storing mappings from an index to a physical index.
 *
 * It also updates the physical indexes (remaining in the map) on remove/add row or column action.
 *
 * @class IndexesSequence
 */
class IndexesSequence extends _indexMap.IndexMap {
  constructor() {
    // Not handling custom init function or init value.
    super(index => index);
  }

  /**
   * Add values to list and reorganize.
   *
   * @private
   * @param {number} insertionIndex Position inside the list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insert(insertionIndex, insertedIndexes) {
    const listAfterUpdate = (0, _utils.getIncreasedIndexes)(this.indexedValues, insertedIndexes);
    this.indexedValues = (0, _indexesSequence.getListWithInsertedItems)(listAfterUpdate, insertionIndex, insertedIndexes);
    super.insert(insertionIndex, insertedIndexes);
  }

  /**
   * Remove values from the list and reorganize.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  remove(removedIndexes) {
    const listAfterUpdate = (0, _indexesSequence.getListWithRemovedItems)(this.indexedValues, removedIndexes);
    this.indexedValues = (0, _utils.getDecreasedIndexes)(listAfterUpdate, removedIndexes);
    super.remove(removedIndexes);
  }
}
exports.IndexesSequence = IndexesSequence;

/***/ }),
/* 635 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(201);
var _actionsOnIndexes = __webpack_require__(632);
exports.getDecreasedIndexes = _actionsOnIndexes.getDecreasedIndexes;
exports.getIncreasedIndexes = _actionsOnIndexes.getIncreasedIndexes;
var _indexesSequence = __webpack_require__(631);
var _physicallyIndexed = __webpack_require__(629);
const alterStrategies = new Map([['indexesSequence', {
  getListWithInsertedItems: _indexesSequence.getListWithInsertedItems,
  getListWithRemovedItems: _indexesSequence.getListWithRemovedItems
}], ['physicallyIndexed', {
  getListWithInsertedItems: _physicallyIndexed.getListWithInsertedItems,
  getListWithRemovedItems: _physicallyIndexed.getListWithRemovedItems
}]]);
const alterUtilsFactory = indexationStrategy => {
  if (alterStrategies.has(indexationStrategy) === false) {
    throw new Error(`Alter strategy with ID '${indexationStrategy}' does not exist.`);
  }
  return alterStrategies.get(indexationStrategy);
};
exports.alterUtilsFactory = alterUtilsFactory;

/***/ }),
/* 636 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(311);
__webpack_require__(329);
exports.__esModule = true;
var _aggregatedCollection = __webpack_require__(637);
Object.keys(_aggregatedCollection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _aggregatedCollection[key]) return;
  exports[key] = _aggregatedCollection[key];
});
var _mapCollection = __webpack_require__(638);
Object.keys(_mapCollection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _mapCollection[key]) return;
  exports[key] = _mapCollection[key];
});

/***/ }),
/* 637 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _mapCollection = __webpack_require__(638);
var _array = __webpack_require__(495);
var _mixed = __webpack_require__(354);
/**
 * Collection of maps. This collection aggregate maps with the same type of values. Values from the registered maps
 * can be used to calculate a single result for particular index.
 */
class AggregatedCollection extends _mapCollection.MapCollection {
  constructor(aggregationFunction, fallbackValue) {
    super();
    /**
     * List of merged values. Value for each index is calculated using values inside registered maps.
     *
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "mergedValuesCache", []);
    /**
     * Function which do aggregation on the values for particular index.
     */
    (0, _defineProperty2.default)(this, "aggregationFunction", void 0);
    /**
     * Fallback value when there is no calculated value for particular index.
     */
    (0, _defineProperty2.default)(this, "fallbackValue", void 0);
    this.aggregationFunction = aggregationFunction;
    this.fallbackValue = fallbackValue;
  }

  /**
   * Get merged values for all indexes.
   *
   * @param {boolean} [readFromCache=true] Determine if read results from the cache.
   * @returns {Array}
   */
  getMergedValues() {
    let readFromCache = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (readFromCache === true) {
      return this.mergedValuesCache;
    }
    if (this.getLength() === 0) {
      return [];
    }

    // Below variable stores values for every particular map. Example describing situation when we have 2 registered maps,
    // with length equal to 5.
    //
    // +---------+---------------------------------------------+
    // |         |                  indexes                    |
    // +---------+---------------------------------------------+
    // |   maps  |     0    |   1   |    2  |   3   |    4     |
    // +---------+----------+-------+-------+-------+----------+
    // |    0    | [[ value,  value,  value,  value,  value ], |
    // |    1    | [  value,  value,  value,  value,  value ]] |
    // +---------+----------+-------+-------+-------+----------+
    const mapsValuesMatrix = (0, _array.arrayMap)(this.get(), map => map.getValues());
    // Below variable stores values for every particular index. Example describing situation when we have 2 registered maps,
    // with length equal to 5.
    //
    // +---------+---------------------+
    // |         |         maps        |
    // +---------+---------------------+
    // | indexes |     0    |    1     |
    // +---------+----------+----------+
    // |    0    | [[ value,  value ], |
    // |    1    | [  value,  value ], |
    // |    2    | [  value,  value ], |
    // |    3    | [  value,  value ], |
    // |    4    | [  value,  value ]] |
    // +---------+----------+----------+
    const indexesValuesMatrix = [];
    const mapsLength = (0, _mixed.isDefined)(mapsValuesMatrix[0]) && mapsValuesMatrix[0].length || 0;
    for (let index = 0; index < mapsLength; index += 1) {
      const valuesForIndex = [];
      for (let mapIndex = 0; mapIndex < this.getLength(); mapIndex += 1) {
        valuesForIndex.push(mapsValuesMatrix[mapIndex][index]);
      }
      indexesValuesMatrix.push(valuesForIndex);
    }
    return (0, _array.arrayMap)(indexesValuesMatrix, this.aggregationFunction);
  }

  /**
   * Get merged value for particular index.
   *
   * @param {number} index Index for which we calculate single result.
   * @param {boolean} [readFromCache=true] Determine if read results from the cache.
   * @returns {*}
   */
  getMergedValueAtIndex(index, readFromCache) {
    const valueAtIndex = this.getMergedValues(readFromCache)[index];
    return (0, _mixed.isDefined)(valueAtIndex) ? valueAtIndex : this.fallbackValue;
  }

  /**
   * Rebuild cache for the collection.
   */
  updateCache() {
    this.mergedValuesCache = this.getMergedValues(false);
  }
}
exports.AggregatedCollection = AggregatedCollection;

/***/ }),
/* 638 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.getRegisteredMapsCounter = getRegisteredMapsCounter;
__webpack_require__(311);
__webpack_require__(329);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _mixed = __webpack_require__(354);
var _object = __webpack_require__(499);
var _localHooks = _interopRequireDefault(__webpack_require__(599));
// Counter for checking if there is a memory leak.
let registeredMaps = 0;

/**
 * Collection of index maps having unique names. It allow us to perform bulk operations such as init, remove, insert on all index maps that have been registered in the collection.
 */
class MapCollection {
  constructor() {
    /**
     * Collection of index maps.
     *
     * @type {Map<string, IndexMap>}
     */
    (0, _defineProperty2.default)(this, "collection", new Map());
  }
  /**
   * Register custom index map.
   *
   * @param {string} uniqueName Unique name of the index map.
   * @param {IndexMap} indexMap Index map containing miscellaneous (i.e. Meta data, indexes sequence), updated after remove and insert data actions.
   */
  register(uniqueName, indexMap) {
    if (this.collection.has(uniqueName) === false) {
      this.collection.set(uniqueName, indexMap);
      indexMap.addLocalHook('change', () => this.runLocalHooks('change', indexMap));
      registeredMaps += 1;
    }
  }

  /**
   * Unregister custom index map.
   *
   * @param {string} name Name of the index map.
   */
  unregister(name) {
    const indexMap = this.collection.get(name);
    if ((0, _mixed.isDefined)(indexMap)) {
      indexMap.destroy();
      this.collection.delete(name);
      this.runLocalHooks('change', indexMap);
      registeredMaps -= 1;
    }
  }

  /**
   * Unregisters and destroys all collected index map instances.
   */
  unregisterAll() {
    this.collection.forEach((indexMap, name) => this.unregister(name));
    this.collection.clear();
  }

  /**
   * Get index map for the provided name.
   *
   * @param {string} [name] Name of the index map.
   * @returns {Array|IndexMap}
   */
  get(name) {
    if ((0, _mixed.isUndefined)(name)) {
      return Array.from(this.collection.values());
    }
    return this.collection.get(name);
  }

  /**
   * Get collection size.
   *
   * @returns {number}
   */
  getLength() {
    return this.collection.size;
  }

  /**
   * Remove some indexes and corresponding mappings and update values of the others within all collection's index maps.
   *
   * @private
   * @param {Array} removedIndexes List of removed indexes.
   */
  removeFromEvery(removedIndexes) {
    this.collection.forEach(indexMap => {
      indexMap.remove(removedIndexes);
    });
  }

  /**
   * Insert new indexes and corresponding mapping and update values of the others all collection's index maps.
   *
   * @private
   * @param {number} insertionIndex Position inside the actual list.
   * @param {Array} insertedIndexes List of inserted indexes.
   */
  insertToEvery(insertionIndex, insertedIndexes) {
    this.collection.forEach(indexMap => {
      indexMap.insert(insertionIndex, insertedIndexes);
    });
  }

  /**
   * Set default values to index maps within collection.
   *
   * @param {number} length Destination length for all stored maps.
   */
  initEvery(length) {
    this.collection.forEach(indexMap => {
      indexMap.init(length);
    });
  }
}
exports.MapCollection = MapCollection;
(0, _object.mixin)(MapCollection, _localHooks.default);

/**
 * @returns {number}
 */
function getRegisteredMapsCounter() {
  return registeredMaps;
}

/***/ }),
/* 639 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(329);
var _observer = __webpack_require__(640);
var _utils = __webpack_require__(641);
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * The ChangesObservable module is an object that represents a resource that provides
 * the ability to observe the changes that happened in the index map indexes during
 * the code running.
 *
 * @private
 * @class ChangesObservable
 */
var _observers = /*#__PURE__*/new WeakMap();
var _indexMatrix = /*#__PURE__*/new WeakMap();
var _currentIndexState = /*#__PURE__*/new WeakMap();
var _isMatrixIndexesInitialized = /*#__PURE__*/new WeakMap();
var _initialIndexValue = /*#__PURE__*/new WeakMap();
class ChangesObservable {
  constructor() {
    let {
      initialIndexValue
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    /**
     * The list of registered ChangesObserver instances.
     *
     * @type {ChangesObserver[]}
     */
    _classPrivateFieldInitSpec(this, _observers, new Set());
    /**
     * An array with default values that act as a base array that will be compared with
     * the last saved index state. The changes are generated and immediately send through
     * the newly created ChangesObserver object. Thanks to that, the observer initially has
     * all information about what indexes are currently changed.
     *
     * @type {Array}
     */
    _classPrivateFieldInitSpec(this, _indexMatrix, []);
    /**
     * An array that holds the indexes state that is currently valid. The value is changed on every
     * index mapper cache update.
     *
     * @type {Array}
     */
    _classPrivateFieldInitSpec(this, _currentIndexState, []);
    /**
     * The flag determines if the observable is initialized or not. Not initialized object creates
     * index matrix once while emitting new changes.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _isMatrixIndexesInitialized, false);
    /**
     * The initial index value allows control from what value the index matrix array will be created.
     * Changing that value changes how the array diff generates the changes for the initial data
     * sent to the subscribers. For example, the changes can be triggered by detecting the changes
     * from `false` to `true` value or vice versa. Generally, it depends on which index map type
     * the Observable will work with. For "hiding" or "trimming" index types, it will be boolean
     * values. For various index maps, it can be anything, but I suspect that the most appropriate
     * initial value will be "undefined" in that case.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _initialIndexValue, false);
    _classPrivateFieldSet(_initialIndexValue, this, initialIndexValue !== null && initialIndexValue !== void 0 ? initialIndexValue : false);
  }

  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Creates and returns a new instance of the ChangesObserver object. The resource
   * allows subscribing to the index changes that during the code running may change.
   * Changes are emitted as an array of the index change. Each change is represented
   * separately as an object with `op`, `index`, `oldValue`, and `newValue` props.
   *
   * For example:
   * ```
   * [
   *   { op: 'replace', index: 1, oldValue: false, newValue: true },
   *   { op: 'replace', index: 3, oldValue: false, newValue: true },
   *   { op: 'insert', index: 4, oldValue: false, newValue: true },
   * ]
   * // or when the new index map changes have less indexes
   * [
   *   { op: 'replace', index: 1, oldValue: false, newValue: true },
   *   { op: 'remove', index: 4, oldValue: false, newValue: true },
   * ]
   * ```
   *
   * @returns {ChangesObserver}
   */
  /* eslint-enable jsdoc/require-description-complete-sentence */
  createObserver() {
    const observer = new _observer.ChangesObserver();
    _classPrivateFieldGet(_observers, this).add(observer);
    observer.addLocalHook('unsubscribe', () => {
      _classPrivateFieldGet(_observers, this).delete(observer);
    });
    observer._writeInitialChanges((0, _utils.arrayDiff)(_classPrivateFieldGet(_indexMatrix, this), _classPrivateFieldGet(_currentIndexState, this)));
    return observer;
  }

  /**
   * The method is an entry point for triggering new index map changes. Emitting the
   * changes triggers comparing algorithm which compares last saved state with a new
   * state. When there are some differences, the changes are sent to all subscribers.
   *
   * @param {Array} indexesState An array with index map state.
   */
  emit(indexesState) {
    let currentIndexState = _classPrivateFieldGet(_currentIndexState, this);
    if (!_classPrivateFieldGet(_isMatrixIndexesInitialized, this) || _classPrivateFieldGet(_indexMatrix, this).length !== indexesState.length) {
      if (indexesState.length === 0) {
        indexesState = new Array(currentIndexState.length).fill(_classPrivateFieldGet(_initialIndexValue, this));
      } else {
        _classPrivateFieldSet(_indexMatrix, this, new Array(indexesState.length).fill(_classPrivateFieldGet(_initialIndexValue, this)));
      }
      if (!_classPrivateFieldGet(_isMatrixIndexesInitialized, this)) {
        _classPrivateFieldSet(_isMatrixIndexesInitialized, this, true);
        currentIndexState = _classPrivateFieldGet(_indexMatrix, this);
      }
    }
    const changes = (0, _utils.arrayDiff)(currentIndexState, indexesState);
    _classPrivateFieldGet(_observers, this).forEach(observer => observer._write(changes));
    _classPrivateFieldSet(_currentIndexState, this, indexesState);
  }
}
exports.ChangesObservable = ChangesObservable;

/***/ }),
/* 640 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _object = __webpack_require__(499);
var _localHooks = _interopRequireDefault(__webpack_require__(599));
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * The ChangesObserver module is an object that represents a disposable resource
 * provided by the ChangesObservable module.
 *
 * @class ChangesObserver
 */
var _currentInitialChanges = /*#__PURE__*/new WeakMap();
class ChangesObserver {
  constructor() {
    /**
     * The field holds initial changes that will be used to notify the callbacks added using
     * subscribe method. Regardless of the moment of listening for changes, the subscriber
     * will be notified once with all changes made before subscribing.
     *
     * @type {Array}
     */
    _classPrivateFieldInitSpec(this, _currentInitialChanges, []);
  }
  /**
   * Subscribes to the observer.
   *
   * @param {Function} callback A function that will be called when the new changes will appear.
   * @returns {ChangesObserver}
   */
  subscribe(callback) {
    this.addLocalHook('change', callback);
    this._write(_classPrivateFieldGet(_currentInitialChanges, this));
    return this;
  }

  /**
   * Unsubscribes all subscriptions. After the method call, the observer would not produce
   * any new events.
   *
   * @returns {ChangesObserver}
   */
  unsubscribe() {
    this.runLocalHooks('unsubscribe');
    this.clearLocalHooks();
    return this;
  }

  /**
   * The write method is executed by the ChangesObservable module. The module produces all
   * changes events that are distributed further by the observer.
   *
   * @private
   * @param {object} changes The chunk of changes produced by the ChangesObservable module.
   * @returns {ChangesObserver}
   */
  _write(changes) {
    if (changes.length > 0) {
      this.runLocalHooks('change', changes);
    }
    return this;
  }

  /**
   * The write method is executed by the ChangesObservable module. The module produces initial
   * changes that will be used to notify new subscribers.
   *
   * @private
   * @param {object} initialChanges The chunk of changes produced by the ChangesObservable module.
   */
  _writeInitialChanges(initialChanges) {
    _classPrivateFieldSet(_currentInitialChanges, this, initialChanges);
  }
}
exports.ChangesObserver = ChangesObserver;
(0, _object.mixin)(ChangesObserver, _localHooks.default);

/***/ }),
/* 641 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.arrayDiff = arrayDiff;
__webpack_require__(283);
/**
 * An array diff implementation. The function iterates through the arrays and depends
 * on the diff results, collect the changes as a list of the objects.
 *
 * Each object contains information about the differences in the indexes of the arrays.
 * The changes also contain data about the new and previous array values.
 *
 * @private
 * @param {Array} baseArray The base array to diff from.
 * @param {Array} newArray The new array to compare with.
 * @returns {Array}
 */
function arrayDiff(baseArray, newArray) {
  const changes = [];
  let i = 0;
  let j = 0;

  /* eslint-disable no-plusplus */
  for (; i < baseArray.length && j < newArray.length; i++, j++) {
    if (baseArray[i] !== newArray[j]) {
      changes.push({
        op: 'replace',
        index: j,
        oldValue: baseArray[i],
        newValue: newArray[j]
      });
    }
  }
  for (; i < newArray.length; i++) {
    changes.push({
      op: 'insert',
      index: i,
      oldValue: undefined,
      newValue: newArray[i]
    });
  }
  for (; j < baseArray.length; j++) {
    changes.push({
      op: 'remove',
      index: j,
      oldValue: baseArray[j],
      newValue: undefined
    });
  }
  return changes;
}

/***/ }),
/* 642 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.getDefaultLanguageDictionary = getDefaultLanguageDictionary;
exports.getLanguageDictionary = getLanguageDictionary;
exports.getLanguagesDictionaries = getLanguagesDictionaries;
exports.getTranslatedPhrase = getTranslatedPhrase;
exports.getValidLanguageCode = getValidLanguageCode;
exports.hasLanguageDictionary = hasLanguageDictionary;
exports.registerLanguageDictionary = registerLanguageDictionary;
var _object = __webpack_require__(499);
var _array = __webpack_require__(495);
var _mixed = __webpack_require__(354);
var _utils = __webpack_require__(643);
var _staticRegister = _interopRequireDefault(__webpack_require__(521));
var _phraseFormatters = __webpack_require__(644);
var _enUS = _interopRequireDefault(__webpack_require__(646));
var _dictionaryKeys = _interopRequireWildcard(__webpack_require__(647));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const dictionaryKeys = exports.dictionaryKeys = _dictionaryKeys;
const DEFAULT_LANGUAGE_CODE = exports.DEFAULT_LANGUAGE_CODE = _enUS.default.languageCode;
const {
  register: registerGloballyLanguageDictionary,
  getItem: getGlobalLanguageDictionary,
  hasItem: hasGlobalLanguageDictionary,
  getValues: getGlobalLanguagesDictionaries
} = (0, _staticRegister.default)('languagesDictionaries');

/**
 * Register automatically the default language dictionary.
 */
registerLanguageDictionary(_enUS.default);

/**
 * Register language dictionary for specific language code.
 *
 * @param {string|object} languageCodeOrDictionary Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE' or object representing dictionary.
 * @param {object} dictionary Dictionary for specific language (optional if first parameter has already dictionary).
 * @returns {object}
 */
function registerLanguageDictionary(languageCodeOrDictionary, dictionary) {
  let languageCode = languageCodeOrDictionary;
  let dictionaryObject = dictionary;

  // Dictionary passed as first argument.
  if ((0, _object.isObject)(languageCodeOrDictionary)) {
    dictionaryObject = languageCodeOrDictionary;
    languageCode = dictionaryObject.languageCode;
  }
  extendLanguageDictionary(languageCode, dictionaryObject);
  registerGloballyLanguageDictionary(languageCode, (0, _object.deepClone)(dictionaryObject));

  // We do not allow user to work with dictionary by reference, it can cause lot of bugs.
  return (0, _object.deepClone)(dictionaryObject);
}

/**
 * Extend handled dictionary by default language dictionary. As result, if any dictionary key isn't defined for specific language, it will be filled with default language value ("dictionary gaps" are supplemented).
 *
 * @private
 * @param {string} languageCode Language code.
 * @param {object} dictionary Dictionary which is extended.
 */
function extendLanguageDictionary(languageCode, dictionary) {
  if (languageCode !== DEFAULT_LANGUAGE_CODE) {
    (0, _utils.extendNotExistingKeys)(dictionary, getGlobalLanguageDictionary(DEFAULT_LANGUAGE_CODE));
  }
}

/**
 * Get language dictionary for specific language code.
 *
 * @param {string} languageCode Language code.
 * @returns {object} Object with constants representing identifiers for translation (as keys) and corresponding translation phrases (as values).
 */
function getLanguageDictionary(languageCode) {
  if (!hasLanguageDictionary(languageCode)) {
    return null;
  }
  return (0, _object.deepClone)(getGlobalLanguageDictionary(languageCode));
}

/**
 *
 * Get if language with specified language code was registered.
 *
 * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.
 * @returns {boolean}
 */
function hasLanguageDictionary(languageCode) {
  return hasGlobalLanguageDictionary(languageCode);
}

/**
 * Get default language dictionary.
 *
 * @returns {object} Object with constants representing identifiers for translation (as keys) and corresponding translation phrases (as values).
 */
function getDefaultLanguageDictionary() {
  return _enUS.default;
}

/**
 * Get registered language dictionaries.
 *
 * @returns {Array}
 */
function getLanguagesDictionaries() {
  return getGlobalLanguagesDictionaries();
}

/**
 * Get phrase for specified dictionary key.
 *
 * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.
 * @param {string} dictionaryKey Constant which is dictionary key.
 * @param {*} argumentsForFormatters Arguments which will be handled by formatters.
 *
 * @returns {string}
 */
function getTranslatedPhrase(languageCode, dictionaryKey, argumentsForFormatters) {
  const languageDictionary = getLanguageDictionary(languageCode);
  if (languageDictionary === null) {
    return null;
  }
  const phrasePropositions = languageDictionary[dictionaryKey];
  if ((0, _mixed.isUndefined)(phrasePropositions)) {
    return null;
  }
  const formattedPhrase = getFormattedPhrase(phrasePropositions, argumentsForFormatters);
  if (Array.isArray(formattedPhrase)) {
    return formattedPhrase[0];
  }
  return formattedPhrase;
}

/**
 * Get formatted phrase from phrases propositions for specified dictionary key.
 *
 * @private
 * @param {Array|string} phrasePropositions List of phrase propositions.
 * @param {*} argumentsForFormatters Arguments which will be handled by formatters.
 *
 * @returns {Array|string}
 */
function getFormattedPhrase(phrasePropositions, argumentsForFormatters) {
  let formattedPhrasePropositions = phrasePropositions;
  (0, _array.arrayEach)((0, _phraseFormatters.getPhraseFormatters)(), formatter => {
    formattedPhrasePropositions = formatter(phrasePropositions, argumentsForFormatters);
  });
  return formattedPhrasePropositions;
}

/**
 * Returns valid language code. If the passed language code doesn't exist default one will be used.
 *
 * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.
 * @returns {string}
 */
function getValidLanguageCode(languageCode) {
  let normalizedLanguageCode = (0, _utils.normalizeLanguageCode)(languageCode);
  if (!hasLanguageDictionary(normalizedLanguageCode)) {
    normalizedLanguageCode = DEFAULT_LANGUAGE_CODE;
    (0, _utils.warnUserAboutLanguageRegistration)(languageCode);
  }
  return normalizedLanguageCode;
}

/***/ }),
/* 643 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createCellHeadersRange = createCellHeadersRange;
exports.extendNotExistingKeys = extendNotExistingKeys;
exports.normalizeLanguageCode = normalizeLanguageCode;
exports.warnUserAboutLanguageRegistration = warnUserAboutLanguageRegistration;
var _mixed = __webpack_require__(354);
var _object = __webpack_require__(499);
var _console = __webpack_require__(512);
var _templateLiteralTag = __webpack_require__(494);
/**
 * Perform shallow extend of a target object with only this extension's properties which doesn't exist in the target.
 *
 * TODO: Maybe it should be moved to global helpers? It's changed `extend` function.
 *
 * @param {object} target An object that will receive the new properties.
 * @param {object} extension An object containing additional properties to merge into the target.
 * @returns {object}
 */
function extendNotExistingKeys(target, extension) {
  (0, _object.objectEach)(extension, (value, key) => {
    if ((0, _mixed.isUndefined)(target[key])) {
      target[key] = value;
    }
  });
  return target;
}

/**
 * Create range of values basing on cell indexes. For example, it will create below ranges for specified function arguments:
 *
 * createCellHeadersRange(2, 7) => `2-7`
 * createCellHeadersRange(7, 2) => `2-7`
 * createCellHeadersRange(0, 4, 'A', 'D') => `A-D`
 * createCellHeadersRange(4, 0, 'D', 'A') => `A-D`.
 *
 * @param {number} firstRowIndex Index of "first" cell.
 * @param {number} nextRowIndex Index of "next" cell.
 * @param {*} fromValue Value which will represent "first" cell.
 * @param {*} toValue Value which will represent "next" cell.
 * @returns {string} Value representing range i.e. A-Z, 11-15.
 */
function createCellHeadersRange(firstRowIndex, nextRowIndex) {
  let fromValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : firstRowIndex;
  let toValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : nextRowIndex;
  // Will swap `fromValue` with `toValue` if it's necessary.
  let [from, to] = [fromValue, toValue];
  if (firstRowIndex > nextRowIndex) {
    [from, to] = [to, from];
  }
  return `${from}-${to}`;
}

/**
 * Normalize language code. It takes handled languageCode proposition and change it to proper languageCode.
 * For example, when it takes `eN-us` as parameter it return `en-US`.
 *
 * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.
 * @returns {string}
 */
function normalizeLanguageCode(languageCode) {
  const languageCodePattern = /^([a-zA-Z]{2})-([a-zA-Z]{2})$/;
  const partsOfLanguageCode = languageCodePattern.exec(languageCode);
  if (partsOfLanguageCode) {
    return `${partsOfLanguageCode[1].toLowerCase()}-${partsOfLanguageCode[2].toUpperCase()}`;
  }
  return languageCode;
}

/**
 *
 * Warn user if there is no registered language.
 *
 * @param {string} languageCode Language code for specific language i.e. 'en-US', 'pt-BR', 'de-DE'.
 */
function warnUserAboutLanguageRegistration(languageCode) {
  if ((0, _mixed.isDefined)(languageCode)) {
    (0, _console.error)((0, _templateLiteralTag.toSingleLine)`Language with code "${languageCode}" was not found. You should register particular language\x20
    before using it. Read more about this issue at: https://docs.handsontable.com/i18n/missing-language-code.`);
  }
}

/***/ }),
/* 644 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.getPhraseFormatters = exports.getAll = getAll;
exports.registerPhraseFormatter = exports.register = register;
var _staticRegister = _interopRequireDefault(__webpack_require__(521));
var _pluralize = _interopRequireDefault(__webpack_require__(645));
const {
  register: registerGloballyPhraseFormatter,
  getValues: getGlobalPhraseFormatters
} = (0, _staticRegister.default)('phraseFormatters');

/**
 * Register phrase formatter.
 *
 * @param {string} name Name of formatter.
 * @param {Function} formatterFn Function which will be applied on phrase propositions. It will transform them if it's possible.
 */
function register(name, formatterFn) {
  registerGloballyPhraseFormatter(name, formatterFn);
}

/**
 * Get all registered previously formatters.
 *
 * @returns {Array}
 */
function getAll() {
  return getGlobalPhraseFormatters();
}
register('pluralize', _pluralize.default);

/***/ }),
/* 645 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports["default"] = pluralize;
/**
 * Try to choose plural form from available phrase propositions.
 *
 * @param {Array} phrasePropositions List of phrases propositions.
 * @param {number} pluralForm Number determining which phrase form should be used.
 *
 * @returns {string|Array} One particular phrase if it's possible, list of unchanged phrase propositions otherwise.
 */
function pluralize(phrasePropositions, pluralForm) {
  const isPluralizable = Array.isArray(phrasePropositions) && Number.isInteger(pluralForm);
  if (isPluralizable) {
    return phrasePropositions[pluralForm];
  }
  return phrasePropositions;
}

/***/ }),
/* 646 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var C = _interopRequireWildcard(__webpack_require__(647));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * @preserve
 * Authors: Handsoncode
 * Last updated: Nov 15, 2017
 *
 * Description: Definition file for English - United States language-country.
 */

const dictionary = {
  languageCode: 'en-US',
  [C.CONTEXTMENU_ITEMS_NO_ITEMS]: 'No available options',
  [C.CONTEXTMENU_ITEMS_ROW_ABOVE]: 'Insert row above',
  [C.CONTEXTMENU_ITEMS_ROW_BELOW]: 'Insert row below',
  [C.CONTEXTMENU_ITEMS_INSERT_LEFT]: 'Insert column left',
  [C.CONTEXTMENU_ITEMS_INSERT_RIGHT]: 'Insert column right',
  [C.CONTEXTMENU_ITEMS_REMOVE_ROW]: ['Remove row', 'Remove rows'],
  [C.CONTEXTMENU_ITEMS_REMOVE_COLUMN]: ['Remove column', 'Remove columns'],
  [C.CONTEXTMENU_ITEMS_UNDO]: 'Undo',
  [C.CONTEXTMENU_ITEMS_REDO]: 'Redo',
  [C.CONTEXTMENU_ITEMS_READ_ONLY]: 'Read only',
  [C.CONTEXTMENU_ITEMS_CLEAR_COLUMN]: 'Clear column',
  [C.CONTEXTMENU_ITEMS_ALIGNMENT]: 'Alignment',
  [C.CONTEXTMENU_ITEMS_ALIGNMENT_LEFT]: 'Left',
  [C.CONTEXTMENU_ITEMS_ALIGNMENT_CENTER]: 'Center',
  [C.CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT]: 'Right',
  [C.CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY]: 'Justify',
  [C.CONTEXTMENU_ITEMS_ALIGNMENT_TOP]: 'Top',
  [C.CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE]: 'Middle',
  [C.CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM]: 'Bottom',
  [C.CONTEXTMENU_ITEMS_FREEZE_COLUMN]: 'Freeze column',
  [C.CONTEXTMENU_ITEMS_UNFREEZE_COLUMN]: 'Unfreeze column',
  [C.CONTEXTMENU_ITEMS_BORDERS]: 'Borders',
  [C.CONTEXTMENU_ITEMS_BORDERS_TOP]: 'Top',
  [C.CONTEXTMENU_ITEMS_BORDERS_RIGHT]: 'Right',
  [C.CONTEXTMENU_ITEMS_BORDERS_BOTTOM]: 'Bottom',
  [C.CONTEXTMENU_ITEMS_BORDERS_LEFT]: 'Left',
  [C.CONTEXTMENU_ITEMS_REMOVE_BORDERS]: 'Remove border(s)',
  [C.CONTEXTMENU_ITEMS_ADD_COMMENT]: 'Add comment',
  [C.CONTEXTMENU_ITEMS_EDIT_COMMENT]: 'Edit comment',
  [C.CONTEXTMENU_ITEMS_REMOVE_COMMENT]: 'Delete comment',
  [C.CONTEXTMENU_ITEMS_READ_ONLY_COMMENT]: 'Read-only comment',
  [C.CONTEXTMENU_ITEMS_MERGE_CELLS]: 'Merge cells',
  [C.CONTEXTMENU_ITEMS_UNMERGE_CELLS]: 'Unmerge cells',
  [C.CONTEXTMENU_ITEMS_COPY]: 'Copy',
  [C.CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS]: ['Copy with header', 'Copy with headers'],
  [C.CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS]: ['Copy with group header', 'Copy with group headers'],
  [C.CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY]: ['Copy header only', 'Copy headers only'],
  [C.CONTEXTMENU_ITEMS_CUT]: 'Cut',
  [C.CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD]: 'Insert child row',
  [C.CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD]: 'Detach from parent',
  [C.CONTEXTMENU_ITEMS_HIDE_COLUMN]: ['Hide column', 'Hide columns'],
  [C.CONTEXTMENU_ITEMS_SHOW_COLUMN]: ['Show column', 'Show columns'],
  [C.CONTEXTMENU_ITEMS_HIDE_ROW]: ['Hide row', 'Hide rows'],
  [C.CONTEXTMENU_ITEMS_SHOW_ROW]: ['Show row', 'Show rows'],
  [C.FILTERS_CONDITIONS_NONE]: 'None',
  [C.FILTERS_CONDITIONS_EMPTY]: 'Is empty',
  [C.FILTERS_CONDITIONS_NOT_EMPTY]: 'Is not empty',
  [C.FILTERS_CONDITIONS_EQUAL]: 'Is equal to',
  [C.FILTERS_CONDITIONS_NOT_EQUAL]: 'Is not equal to',
  [C.FILTERS_CONDITIONS_BEGINS_WITH]: 'Begins with',
  [C.FILTERS_CONDITIONS_ENDS_WITH]: 'Ends with',
  [C.FILTERS_CONDITIONS_CONTAINS]: 'Contains',
  [C.FILTERS_CONDITIONS_NOT_CONTAIN]: 'Does not contain',
  [C.FILTERS_CONDITIONS_GREATER_THAN]: 'Greater than',
  [C.FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL]: 'Greater than or equal to',
  [C.FILTERS_CONDITIONS_LESS_THAN]: 'Less than',
  [C.FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL]: 'Less than or equal to',
  [C.FILTERS_CONDITIONS_BETWEEN]: 'Is between',
  [C.FILTERS_CONDITIONS_NOT_BETWEEN]: 'Is not between',
  [C.FILTERS_CONDITIONS_AFTER]: 'After',
  [C.FILTERS_CONDITIONS_BEFORE]: 'Before',
  [C.FILTERS_CONDITIONS_TODAY]: 'Today',
  [C.FILTERS_CONDITIONS_TOMORROW]: 'Tomorrow',
  [C.FILTERS_CONDITIONS_YESTERDAY]: 'Yesterday',
  [C.FILTERS_VALUES_BLANK_CELLS]: 'Blank cells',
  [C.FILTERS_DIVS_FILTER_BY_CONDITION]: 'Filter by condition',
  [C.FILTERS_DIVS_FILTER_BY_VALUE]: 'Filter by value',
  [C.FILTERS_LABELS_CONJUNCTION]: 'And',
  [C.FILTERS_LABELS_DISJUNCTION]: 'Or',
  [C.FILTERS_BUTTONS_SELECT_ALL]: 'Select all',
  [C.FILTERS_BUTTONS_CLEAR]: 'Clear',
  [C.FILTERS_BUTTONS_OK]: 'OK',
  [C.FILTERS_BUTTONS_CANCEL]: 'Cancel',
  [C.FILTERS_BUTTONS_PLACEHOLDER_SEARCH]: 'Search',
  [C.FILTERS_BUTTONS_PLACEHOLDER_VALUE]: 'Value',
  [C.FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE]: 'Second value',
  [C.CHECKBOX_CHECKED]: 'Checked',
  [C.CHECKBOX_UNCHECKED]: 'Unchecked'
};
var _default = exports["default"] = dictionary;

/***/ }),
/* 647 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
/**
 * Constants for parts of translation.
 */

const CONTEXT_MENU_ITEMS_NAMESPACE = exports.CONTEXT_MENU_ITEMS_NAMESPACE = 'ContextMenu:items';
const CM_ALIAS = CONTEXT_MENU_ITEMS_NAMESPACE;
const CONTEXTMENU_ITEMS_NO_ITEMS = exports.CONTEXTMENU_ITEMS_NO_ITEMS = `${CM_ALIAS}.noItems`;
const CONTEXTMENU_ITEMS_ROW_ABOVE = exports.CONTEXTMENU_ITEMS_ROW_ABOVE = `${CM_ALIAS}.insertRowAbove`;
const CONTEXTMENU_ITEMS_ROW_BELOW = exports.CONTEXTMENU_ITEMS_ROW_BELOW = `${CM_ALIAS}.insertRowBelow`;
const CONTEXTMENU_ITEMS_INSERT_LEFT = exports.CONTEXTMENU_ITEMS_INSERT_LEFT = `${CM_ALIAS}.insertColumnOnTheLeft`;
const CONTEXTMENU_ITEMS_INSERT_RIGHT = exports.CONTEXTMENU_ITEMS_INSERT_RIGHT = `${CM_ALIAS}.insertColumnOnTheRight`;
const CONTEXTMENU_ITEMS_REMOVE_ROW = exports.CONTEXTMENU_ITEMS_REMOVE_ROW = `${CM_ALIAS}.removeRow`;
const CONTEXTMENU_ITEMS_REMOVE_COLUMN = exports.CONTEXTMENU_ITEMS_REMOVE_COLUMN = `${CM_ALIAS}.removeColumn`;
const CONTEXTMENU_ITEMS_UNDO = exports.CONTEXTMENU_ITEMS_UNDO = `${CM_ALIAS}.undo`;
const CONTEXTMENU_ITEMS_REDO = exports.CONTEXTMENU_ITEMS_REDO = `${CM_ALIAS}.redo`;
const CONTEXTMENU_ITEMS_READ_ONLY = exports.CONTEXTMENU_ITEMS_READ_ONLY = `${CM_ALIAS}.readOnly`;
const CONTEXTMENU_ITEMS_CLEAR_COLUMN = exports.CONTEXTMENU_ITEMS_CLEAR_COLUMN = `${CM_ALIAS}.clearColumn`;
const CONTEXTMENU_ITEMS_COPY = exports.CONTEXTMENU_ITEMS_COPY = `${CM_ALIAS}.copy`;
const CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS = exports.CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_HEADERS = `${CM_ALIAS}.copyWithHeaders`;
const CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS = exports.CONTEXTMENU_ITEMS_COPY_WITH_COLUMN_GROUP_HEADERS = `${CM_ALIAS}.copyWithGroupHeaders`;
const CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY = exports.CONTEXTMENU_ITEMS_COPY_COLUMN_HEADERS_ONLY = `${CM_ALIAS}.copyHeadersOnly`;
const CONTEXTMENU_ITEMS_CUT = exports.CONTEXTMENU_ITEMS_CUT = `${CM_ALIAS}.cut`;
const CONTEXTMENU_ITEMS_FREEZE_COLUMN = exports.CONTEXTMENU_ITEMS_FREEZE_COLUMN = `${CM_ALIAS}.freezeColumn`;
const CONTEXTMENU_ITEMS_UNFREEZE_COLUMN = exports.CONTEXTMENU_ITEMS_UNFREEZE_COLUMN = `${CM_ALIAS}.unfreezeColumn`;
const CONTEXTMENU_ITEMS_MERGE_CELLS = exports.CONTEXTMENU_ITEMS_MERGE_CELLS = `${CM_ALIAS}.mergeCells`;
const CONTEXTMENU_ITEMS_UNMERGE_CELLS = exports.CONTEXTMENU_ITEMS_UNMERGE_CELLS = `${CM_ALIAS}.unmergeCells`;
const CONTEXTMENU_ITEMS_ADD_COMMENT = exports.CONTEXTMENU_ITEMS_ADD_COMMENT = `${CM_ALIAS}.addComment`;
const CONTEXTMENU_ITEMS_EDIT_COMMENT = exports.CONTEXTMENU_ITEMS_EDIT_COMMENT = `${CM_ALIAS}.editComment`;
const CONTEXTMENU_ITEMS_REMOVE_COMMENT = exports.CONTEXTMENU_ITEMS_REMOVE_COMMENT = `${CM_ALIAS}.removeComment`;
const CONTEXTMENU_ITEMS_READ_ONLY_COMMENT = exports.CONTEXTMENU_ITEMS_READ_ONLY_COMMENT = `${CM_ALIAS}.readOnlyComment`;
const CONTEXTMENU_ITEMS_ALIGNMENT = exports.CONTEXTMENU_ITEMS_ALIGNMENT = `${CM_ALIAS}.align`;
const CONTEXTMENU_ITEMS_ALIGNMENT_LEFT = exports.CONTEXTMENU_ITEMS_ALIGNMENT_LEFT = `${CM_ALIAS}.align.left`;
const CONTEXTMENU_ITEMS_ALIGNMENT_CENTER = exports.CONTEXTMENU_ITEMS_ALIGNMENT_CENTER = `${CM_ALIAS}.align.center`;
const CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT = exports.CONTEXTMENU_ITEMS_ALIGNMENT_RIGHT = `${CM_ALIAS}.align.right`;
const CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY = exports.CONTEXTMENU_ITEMS_ALIGNMENT_JUSTIFY = `${CM_ALIAS}.align.justify`;
const CONTEXTMENU_ITEMS_ALIGNMENT_TOP = exports.CONTEXTMENU_ITEMS_ALIGNMENT_TOP = `${CM_ALIAS}.align.top`;
const CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE = exports.CONTEXTMENU_ITEMS_ALIGNMENT_MIDDLE = `${CM_ALIAS}.align.middle`;
const CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM = exports.CONTEXTMENU_ITEMS_ALIGNMENT_BOTTOM = `${CM_ALIAS}.align.bottom`;
const CONTEXTMENU_ITEMS_BORDERS = exports.CONTEXTMENU_ITEMS_BORDERS = `${CM_ALIAS}.borders`;
const CONTEXTMENU_ITEMS_BORDERS_TOP = exports.CONTEXTMENU_ITEMS_BORDERS_TOP = `${CM_ALIAS}.borders.top`;
const CONTEXTMENU_ITEMS_BORDERS_RIGHT = exports.CONTEXTMENU_ITEMS_BORDERS_RIGHT = `${CM_ALIAS}.borders.right`;
const CONTEXTMENU_ITEMS_BORDERS_BOTTOM = exports.CONTEXTMENU_ITEMS_BORDERS_BOTTOM = `${CM_ALIAS}.borders.bottom`;
const CONTEXTMENU_ITEMS_BORDERS_LEFT = exports.CONTEXTMENU_ITEMS_BORDERS_LEFT = `${CM_ALIAS}.borders.left`;
const CONTEXTMENU_ITEMS_REMOVE_BORDERS = exports.CONTEXTMENU_ITEMS_REMOVE_BORDERS = `${CM_ALIAS}.borders.remove`;
const CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD = exports.CONTEXTMENU_ITEMS_NESTED_ROWS_INSERT_CHILD = `${CM_ALIAS}.nestedHeaders.insertChildRow`; // eslint-disable-line max-len
const CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD = exports.CONTEXTMENU_ITEMS_NESTED_ROWS_DETACH_CHILD = `${CM_ALIAS}.nestedHeaders.detachFromParent`; // eslint-disable-line max-len

const CONTEXTMENU_ITEMS_HIDE_COLUMN = exports.CONTEXTMENU_ITEMS_HIDE_COLUMN = `${CM_ALIAS}.hideColumn`;
const CONTEXTMENU_ITEMS_SHOW_COLUMN = exports.CONTEXTMENU_ITEMS_SHOW_COLUMN = `${CM_ALIAS}.showColumn`;
const CONTEXTMENU_ITEMS_HIDE_ROW = exports.CONTEXTMENU_ITEMS_HIDE_ROW = `${CM_ALIAS}.hideRow`;
const CONTEXTMENU_ITEMS_SHOW_ROW = exports.CONTEXTMENU_ITEMS_SHOW_ROW = `${CM_ALIAS}.showRow`;
const FILTERS_NAMESPACE = exports.FILTERS_NAMESPACE = 'Filters:';
const FILTERS_CONDITIONS_NAMESPACE = exports.FILTERS_CONDITIONS_NAMESPACE = `${FILTERS_NAMESPACE}conditions`;
const FILTERS_CONDITIONS_NONE = exports.FILTERS_CONDITIONS_NONE = `${FILTERS_CONDITIONS_NAMESPACE}.none`;
const FILTERS_CONDITIONS_EMPTY = exports.FILTERS_CONDITIONS_EMPTY = `${FILTERS_CONDITIONS_NAMESPACE}.isEmpty`;
const FILTERS_CONDITIONS_NOT_EMPTY = exports.FILTERS_CONDITIONS_NOT_EMPTY = `${FILTERS_CONDITIONS_NAMESPACE}.isNotEmpty`;
const FILTERS_CONDITIONS_EQUAL = exports.FILTERS_CONDITIONS_EQUAL = `${FILTERS_CONDITIONS_NAMESPACE}.isEqualTo`;
const FILTERS_CONDITIONS_NOT_EQUAL = exports.FILTERS_CONDITIONS_NOT_EQUAL = `${FILTERS_CONDITIONS_NAMESPACE}.isNotEqualTo`;
const FILTERS_CONDITIONS_BEGINS_WITH = exports.FILTERS_CONDITIONS_BEGINS_WITH = `${FILTERS_CONDITIONS_NAMESPACE}.beginsWith`;
const FILTERS_CONDITIONS_ENDS_WITH = exports.FILTERS_CONDITIONS_ENDS_WITH = `${FILTERS_CONDITIONS_NAMESPACE}.endsWith`;
const FILTERS_CONDITIONS_CONTAINS = exports.FILTERS_CONDITIONS_CONTAINS = `${FILTERS_CONDITIONS_NAMESPACE}.contains`;
const FILTERS_CONDITIONS_NOT_CONTAIN = exports.FILTERS_CONDITIONS_NOT_CONTAIN = `${FILTERS_CONDITIONS_NAMESPACE}.doesNotContain`;
const FILTERS_CONDITIONS_BY_VALUE = exports.FILTERS_CONDITIONS_BY_VALUE = `${FILTERS_CONDITIONS_NAMESPACE}.byValue`;
const FILTERS_CONDITIONS_GREATER_THAN = exports.FILTERS_CONDITIONS_GREATER_THAN = `${FILTERS_CONDITIONS_NAMESPACE}.greaterThan`;
const FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL = exports.FILTERS_CONDITIONS_GREATER_THAN_OR_EQUAL = `${FILTERS_CONDITIONS_NAMESPACE}.greaterThanOrEqualTo`;
const FILTERS_CONDITIONS_LESS_THAN = exports.FILTERS_CONDITIONS_LESS_THAN = `${FILTERS_CONDITIONS_NAMESPACE}.lessThan`;
const FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL = exports.FILTERS_CONDITIONS_LESS_THAN_OR_EQUAL = `${FILTERS_CONDITIONS_NAMESPACE}.lessThanOrEqualTo`;
const FILTERS_CONDITIONS_BETWEEN = exports.FILTERS_CONDITIONS_BETWEEN = `${FILTERS_CONDITIONS_NAMESPACE}.isBetween`;
const FILTERS_CONDITIONS_NOT_BETWEEN = exports.FILTERS_CONDITIONS_NOT_BETWEEN = `${FILTERS_CONDITIONS_NAMESPACE}.isNotBetween`;
const FILTERS_CONDITIONS_AFTER = exports.FILTERS_CONDITIONS_AFTER = `${FILTERS_CONDITIONS_NAMESPACE}.after`;
const FILTERS_CONDITIONS_BEFORE = exports.FILTERS_CONDITIONS_BEFORE = `${FILTERS_CONDITIONS_NAMESPACE}.before`;
const FILTERS_CONDITIONS_TODAY = exports.FILTERS_CONDITIONS_TODAY = `${FILTERS_CONDITIONS_NAMESPACE}.today`;
const FILTERS_CONDITIONS_TOMORROW = exports.FILTERS_CONDITIONS_TOMORROW = `${FILTERS_CONDITIONS_NAMESPACE}.tomorrow`;
const FILTERS_CONDITIONS_YESTERDAY = exports.FILTERS_CONDITIONS_YESTERDAY = `${FILTERS_CONDITIONS_NAMESPACE}.yesterday`;
const FILTERS_DIVS_FILTER_BY_CONDITION = exports.FILTERS_DIVS_FILTER_BY_CONDITION = `${FILTERS_NAMESPACE}labels.filterByCondition`;
const FILTERS_DIVS_FILTER_BY_VALUE = exports.FILTERS_DIVS_FILTER_BY_VALUE = `${FILTERS_NAMESPACE}labels.filterByValue`;
const FILTERS_LABELS_CONJUNCTION = exports.FILTERS_LABELS_CONJUNCTION = `${FILTERS_NAMESPACE}labels.conjunction`;
const FILTERS_LABELS_DISJUNCTION = exports.FILTERS_LABELS_DISJUNCTION = `${FILTERS_NAMESPACE}labels.disjunction`;
const FILTERS_VALUES_BLANK_CELLS = exports.FILTERS_VALUES_BLANK_CELLS = `${FILTERS_NAMESPACE}values.blankCells`;
const FILTERS_BUTTONS_SELECT_ALL = exports.FILTERS_BUTTONS_SELECT_ALL = `${FILTERS_NAMESPACE}buttons.selectAll`;
const FILTERS_BUTTONS_CLEAR = exports.FILTERS_BUTTONS_CLEAR = `${FILTERS_NAMESPACE}buttons.clear`;
const FILTERS_BUTTONS_OK = exports.FILTERS_BUTTONS_OK = `${FILTERS_NAMESPACE}buttons.ok`;
const FILTERS_BUTTONS_CANCEL = exports.FILTERS_BUTTONS_CANCEL = `${FILTERS_NAMESPACE}buttons.cancel`;
const FILTERS_BUTTONS_PLACEHOLDER_SEARCH = exports.FILTERS_BUTTONS_PLACEHOLDER_SEARCH = `${FILTERS_NAMESPACE}buttons.placeholder.search`;
const FILTERS_BUTTONS_PLACEHOLDER_VALUE = exports.FILTERS_BUTTONS_PLACEHOLDER_VALUE = `${FILTERS_NAMESPACE}buttons.placeholder.value`;
const FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE = exports.FILTERS_BUTTONS_PLACEHOLDER_SECOND_VALUE = `${FILTERS_NAMESPACE}buttons.placeholder.secondValue`;
const CHECKBOX_RENDERER_NAMESPACE = exports.CHECKBOX_RENDERER_NAMESPACE = 'CheckboxRenderer:';
const CHECKBOX_CHECKED = exports.CHECKBOX_CHECKED = `${CHECKBOX_RENDERER_NAMESPACE}checked`;
const CHECKBOX_UNCHECKED = exports.CHECKBOX_UNCHECKED = `${CHECKBOX_RENDERER_NAMESPACE}unchecked`;

/***/ }),
/* 648 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(311);
__webpack_require__(329);
var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _exportNames = {
  Selection: true,
  handleMouseEvent: true,
  detectSelectionType: true,
  normalizeSelectionFactory: true
};
var _selection = _interopRequireDefault(__webpack_require__(649));
exports.Selection = _selection.default;
var _mouseEventHandler = __webpack_require__(615);
exports.handleMouseEvent = _mouseEventHandler.handleMouseEvent;
var _utils = __webpack_require__(663);
exports.detectSelectionType = _utils.detectSelectionType;
exports.normalizeSelectionFactory = _utils.normalizeSelectionFactory;
var _highlight = __webpack_require__(650);
Object.keys(_highlight).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _highlight[key]) return;
  exports[key] = _highlight[key];
});

/***/ }),
/* 649 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(329);
__webpack_require__(623);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _highlight = _interopRequireWildcard(__webpack_require__(650));
var _range = _interopRequireDefault(__webpack_require__(661));
var _object = __webpack_require__(499);
var _mixed = __webpack_require__(354);
var _number = __webpack_require__(534);
var _array = __webpack_require__(495);
var _localHooks = _interopRequireDefault(__webpack_require__(599));
var _transformation2 = _interopRequireDefault(__webpack_require__(662));
var _utils = __webpack_require__(663);
var _templateLiteralTag = __webpack_require__(494);
var _a11y = __webpack_require__(496);
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * @class Selection
 * @util
 */
var _transformation = /*#__PURE__*/new WeakMap();
var _focusTransformation = /*#__PURE__*/new WeakMap();
var _isFocusSelectionChanged = /*#__PURE__*/new WeakMap();
var _disableHeadersHighlight = /*#__PURE__*/new WeakMap();
var _selectionSource = /*#__PURE__*/new WeakMap();
var _expectedLayersCount = /*#__PURE__*/new WeakMap();
class Selection {
  constructor(settings, tableProps) {
    var _this = this;
    /**
     * Handsontable settings instance.
     *
     * @type {GridSettings}
     */
    (0, _defineProperty2.default)(this, "settings", void 0);
    /**
     * An additional object with dynamically defined properties which describes table state.
     *
     * @type {object}
     */
    (0, _defineProperty2.default)(this, "tableProps", void 0);
    /**
     * The flag which determines if the selection is in progress.
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "inProgress", false);
    /**
     * Selection data layer (handle visual coordinates).
     *
     * @type {SelectionRange}
     */
    (0, _defineProperty2.default)(this, "selectedRange", new _range.default((highlight, from, to) => {
      return this.tableProps.createCellRange(highlight, from, to);
    }));
    /**
     * Visualization layer.
     *
     * @type {Highlight}
     */
    (0, _defineProperty2.default)(this, "highlight", void 0);
    /**
     * The module for modifying coordinates of the start and end selection.
     *
     * @type {Transformation}
     */
    _classPrivateFieldInitSpec(this, _transformation, void 0);
    /**
     * The module for modifying coordinates of the focus selection.
     *
     * @type {Transformation}
     */
    _classPrivateFieldInitSpec(this, _focusTransformation, void 0);
    /**
     * The collection of the selection layer levels where the whole row was selected using the row header or
     * the corner header.
     *
     * @type {Set<number>}
     */
    (0, _defineProperty2.default)(this, "selectedByRowHeader", new Set());
    /**
     * The collection of the selection layer levels where the whole column was selected using the column header or
     * the corner header.
     *
     * @type {Set<number>}
     */
    (0, _defineProperty2.default)(this, "selectedByColumnHeader", new Set());
    /**
     * The flag which determines if the focus selection was changed.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _isFocusSelectionChanged, false);
    /**
     * When sets disable highlighting the headers even when the logical coordinates points on them.
     *
     * @type {boolean}
     */
    _classPrivateFieldInitSpec(this, _disableHeadersHighlight, false);
    /**
     * The source of the selection. It can be one of the following values: `mouse`, `unknown` or any other string.
     *
     * @type {'mouse' | 'unknown' | string}
     */
    _classPrivateFieldInitSpec(this, _selectionSource, 'unknown');
    /**
     * The number of expected layers. It is used mostly to track when the last selection layer of non-contiguous
     * selection is applied, thus the viewport scroll is triggered.
     *
     * @param {number}
     */
    _classPrivateFieldInitSpec(this, _expectedLayersCount, -1);
    this.settings = settings;
    this.tableProps = tableProps;
    this.highlight = new _highlight.default({
      headerClassName: settings.currentHeaderClassName,
      activeHeaderClassName: settings.activeHeaderClassName,
      rowClassName: settings.currentRowClassName,
      columnClassName: settings.currentColClassName,
      cellAttributes: [(0, _a11y.A11Y_SELECTED)()],
      rowIndexMapper: this.tableProps.rowIndexMapper,
      columnIndexMapper: this.tableProps.columnIndexMapper,
      disabledCellSelection: (row, column) => this.tableProps.isDisabledCellSelection(row, column),
      cellCornerVisible: function () {
        return _this.isCellCornerVisible(...arguments);
      },
      areaCornerVisible: function () {
        return _this.isAreaCornerVisible(...arguments);
      },
      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),
      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),
      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),
      createCellRange: (highlight, from, to) => this.tableProps.createCellRange(highlight, from, to)
    });
    _classPrivateFieldSet(_transformation, this, new _transformation2.default(this.selectedRange, {
      rowIndexMapper: this.tableProps.rowIndexMapper,
      columnIndexMapper: this.tableProps.columnIndexMapper,
      countRenderableRows: () => this.tableProps.countRenderableRows(),
      countRenderableColumns: () => this.tableProps.countRenderableColumns(),
      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),
      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),
      findFirstNonHiddenRenderableRow: function () {
        return _this.tableProps.findFirstNonHiddenRenderableRow(...arguments);
      },
      findFirstNonHiddenRenderableColumn: function () {
        return _this.tableProps.findFirstNonHiddenRenderableColumn(...arguments);
      },
      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),
      fixedRowsBottom: () => settings.fixedRowsBottom,
      minSpareRows: () => settings.minSpareRows,
      minSpareCols: () => settings.minSpareCols,
      autoWrapRow: () => settings.autoWrapRow,
      autoWrapCol: () => settings.autoWrapCol
    }));
    _classPrivateFieldSet(_focusTransformation, this, new _transformation2.default(this.selectedRange, {
      rowIndexMapper: this.tableProps.rowIndexMapper,
      columnIndexMapper: this.tableProps.columnIndexMapper,
      countRenderableRows: () => {
        const range = this.selectedRange.current();
        return this.tableProps.countRenderableRowsInRange(0, range.getOuterBottomEndCorner().row);
      },
      countRenderableColumns: () => {
        const range = this.selectedRange.current();
        return this.tableProps.countRenderableColumnsInRange(0, range.getOuterBottomEndCorner().col);
      },
      visualToRenderableCoords: coords => this.tableProps.visualToRenderableCoords(coords),
      renderableToVisualCoords: coords => this.tableProps.renderableToVisualCoords(coords),
      findFirstNonHiddenRenderableRow: function () {
        return _this.tableProps.findFirstNonHiddenRenderableRow(...arguments);
      },
      findFirstNonHiddenRenderableColumn: function () {
        return _this.tableProps.findFirstNonHiddenRenderableColumn(...arguments);
      },
      createCellCoords: (row, column) => this.tableProps.createCellCoords(row, column),
      fixedRowsBottom: () => 0,
      minSpareRows: () => 0,
      minSpareCols: () => 0,
      autoWrapRow: () => true,
      autoWrapCol: () => true
    }));
    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeTransformStart', function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _this.runLocalHooks('beforeModifyTransformStart', ...args);
    });
    _classPrivateFieldGet(_transformation, this).addLocalHook('afterTransformStart', function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.runLocalHooks('afterModifyTransformStart', ...args);
    });
    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeTransformEnd', function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.runLocalHooks('beforeModifyTransformEnd', ...args);
    });
    _classPrivateFieldGet(_transformation, this).addLocalHook('afterTransformEnd', function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.runLocalHooks('afterModifyTransformEnd', ...args);
    });
    _classPrivateFieldGet(_transformation, this).addLocalHook('insertRowRequire', function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.runLocalHooks('insertRowRequire', ...args);
    });
    _classPrivateFieldGet(_transformation, this).addLocalHook('insertColRequire', function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.runLocalHooks('insertColRequire', ...args);
    });
    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeRowWrap', function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _this.runLocalHooks('beforeRowWrap', ...args);
    });
    _classPrivateFieldGet(_transformation, this).addLocalHook('beforeColumnWrap', function () {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }
      return _this.runLocalHooks('beforeColumnWrap', ...args);
    });
    _classPrivateFieldGet(_focusTransformation, this).addLocalHook('beforeTransformStart', function () {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }
      return _this.runLocalHooks('beforeModifyTransformFocus', ...args);
    });
    _classPrivateFieldGet(_focusTransformation, this).addLocalHook('afterTransformStart', function () {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      }
      return _this.runLocalHooks('afterModifyTransformFocus', ...args);
    });
  }

  /**
   * Get data layer for current selection.
   *
   * @returns {SelectionRange}
   */
  getSelectedRange() {
    return this.selectedRange;
  }

  /**
   * Marks the source of the selection. It can be one of the following values: `mouse`, or any other string.
   *
   * @param {'mouse' | 'unknown' | string} sourceName The source name.
   */
  markSource(sourceName) {
    _classPrivateFieldSet(_selectionSource, this, sourceName);
  }

  /**
   * Marks end of the selection source. It restores the selection source to default value which is 'unknown'.
   */
  markEndSource() {
    _classPrivateFieldSet(_selectionSource, this, 'unknown');
  }

  /**
   * Returns the source of the selection.
   *
   * @returns {'mouse' | 'unknown' | string}
   */
  getSelectionSource() {
    return _classPrivateFieldGet(_selectionSource, this);
  }

  /**
   * Set the number of expected layers. The method is not obligatory to call. It is used mostly internally
   * to determine when the last selection layer of non-contiguous is applied, thus the viewport scroll is triggered.
   *
   * @param {number} layersCount The number of expected layers.
   */
  setExpectedLayers(layersCount) {
    _classPrivateFieldSet(_expectedLayersCount, this, layersCount);
  }

  /**
   * Indicate that selection process began. It sets internally `.inProgress` property to `true`.
   */
  begin() {
    this.inProgress = true;
  }

  /**
   * Indicate that selection process finished. It sets internally `.inProgress` property to `false`.
   */
  finish() {
    this.runLocalHooks('afterSelectionFinished', Array.from(this.selectedRange));
    this.inProgress = false;
    _classPrivateFieldSet(_expectedLayersCount, this, -1);
  }

  /**
   * Check if the process of selecting the cell/cells is in progress.
   *
   * @returns {boolean}
   */
  isInProgress() {
    return this.inProgress;
  }

  /**
   * Starts selection range on given coordinate object.
   *
   * @param {CellCoords} coords Visual coords.
   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works
   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined
   *                                      the default trigger will be used.
   * @param {boolean} [fragment=false] If `true`, the selection will be treated as a partial selection where the
   *                                   `setRangeEnd` method won't be called on every `setRangeStart` call.
   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.
   */
  setRangeStart(coords, multipleSelection) {
    let fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let highlightCoords = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : coords;
    const isMultipleMode = this.settings.selectionMode === 'multiple';
    const isMultipleSelection = (0, _mixed.isUndefined)(multipleSelection) ? this.tableProps.getShortcutManager().isCtrlPressed() : multipleSelection;
    // We are creating copy. We would like to modify just the start of the selection by below hook. Then original coords
    // should be handled by next methods.
    const coordsClone = coords.clone();
    _classPrivateFieldSet(_isFocusSelectionChanged, this, false);
    this.runLocalHooks(`beforeSetRangeStart${fragment ? 'Only' : ''}`, coordsClone);
    if (!isMultipleMode || isMultipleMode && !isMultipleSelection && (0, _mixed.isUndefined)(multipleSelection)) {
      this.selectedRange.clear();
    }
    this.selectedRange.add(coordsClone).current().setHighlight(highlightCoords.clone());
    if (this.getLayerLevel() === 0) {
      this.selectedByRowHeader.clear();
      this.selectedByColumnHeader.clear();
    }
    if (!fragment) {
      this.setRangeEnd(coords);
    }
  }

  /**
   * Starts selection range on given coordinate object.
   *
   * @param {CellCoords} coords Visual coords.
   * @param {boolean} [multipleSelection] If `true`, selection will be worked in 'multiple' mode. This option works
   *                                      only when 'selectionMode' is set as 'multiple'. If the argument is not defined
   *                                      the default trigger will be used.
   * @param {CellCoords} [highlightCoords] If set, allows changing the coordinates of the highlight/focus cell.
   */
  setRangeStartOnly(coords, multipleSelection) {
    let highlightCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coords;
    this.setRangeStart(coords, multipleSelection, true, highlightCoords);
  }

  /**
   * Ends selection range on given coordinate object.
   *
   * @param {CellCoords} coords Visual coords.
   */
  setRangeEnd(coords) {
    if (this.selectedRange.isEmpty()) {
      return;
    }
    const coordsClone = coords.clone();
    const countRows = this.tableProps.countRows();
    const countCols = this.tableProps.countCols();
    const isSingle = this.selectedRange.current().clone().setTo(coords).isSingleHeader();

    // Ignore processing the end range when the header selection starts overlapping the corner and
    // the selection is not a single header highlight.
    if ((countRows > 0 || countCols > 0) && (countRows === 0 && coordsClone.col < 0 && !isSingle || countCols === 0 && coordsClone.row < 0 && !isSingle)) {
      return;
    }
    this.runLocalHooks('beforeSetRangeEnd', coordsClone);
    this.begin();
    const cellRange = this.selectedRange.current();
    if (!this.settings.navigableHeaders) {
      cellRange.highlight.normalize();
    }
    if (this.settings.selectionMode === 'single') {
      cellRange.setFrom(cellRange.highlight);
      cellRange.setTo(cellRange.highlight);
    } else {
      const horizontalDir = cellRange.getHorizontalDirection();
      const verticalDir = cellRange.getVerticalDirection();
      const isMultiple = this.isMultiple();
      cellRange.setTo(coordsClone);
      if (isMultiple && (horizontalDir !== cellRange.getHorizontalDirection() || cellRange.getWidth() === 1 && !cellRange.includes(cellRange.highlight))) {
        cellRange.from.assign({
          col: cellRange.highlight.col
        });
      }
      if (isMultiple && (verticalDir !== cellRange.getVerticalDirection() || cellRange.getHeight() === 1 && !cellRange.includes(cellRange.highlight))) {
        cellRange.from.assign({
          row: cellRange.highlight.row
        });
      }
    }

    // Prevent creating "area" selection that overlaps headers.
    if (countRows > 0 && countCols > 0) {
      if (!this.settings.navigableHeaders || this.settings.navigableHeaders && !cellRange.isSingleHeader()) {
        cellRange.to.normalize();
      }
    }
    this.runLocalHooks('beforeHighlightSet');
    this.setRangeFocus(this.selectedRange.current().highlight);
    this.applyAndCommit();
    const isLastLayer = _classPrivateFieldGet(_expectedLayersCount, this) === -1 || this.selectedRange.size() === _classPrivateFieldGet(_expectedLayersCount, this);
    this.runLocalHooks('afterSetRangeEnd', coords, isLastLayer);
  }

  /**
   * Applies and commits the selection to all layers (using the Walkontable Selection API) based on the selection (CellRanges)
   * collected in the `selectedRange` module.
   *
   * @param {CellRange} [cellRange] The cell range to apply. If not provided, the current selection is used.
   * @param {number} [layerLevel] The layer level to apply. If not provided, the current layer level is used.
   */
  applyAndCommit() {
    let cellRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.selectedRange.current();
    let layerLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLayerLevel();
    const countRows = this.tableProps.countRows();
    const countCols = this.tableProps.countCols();

    // If the next layer level is lower than previous then clear all area and header highlights. This is the
    // indication that the new selection is performing.
    if (layerLevel < this.highlight.layerLevel) {
      (0, _array.arrayEach)(this.highlight.getAreas(), highlight => void highlight.clear());
      (0, _array.arrayEach)(this.highlight.getLayeredAreas(), highlight => void highlight.clear());
      (0, _array.arrayEach)(this.highlight.getRowHeaders(), highlight => void highlight.clear());
      (0, _array.arrayEach)(this.highlight.getColumnHeaders(), highlight => void highlight.clear());
      (0, _array.arrayEach)(this.highlight.getActiveRowHeaders(), highlight => void highlight.clear());
      (0, _array.arrayEach)(this.highlight.getActiveColumnHeaders(), highlight => void highlight.clear());
      (0, _array.arrayEach)(this.highlight.getActiveCornerHeaders(), highlight => void highlight.clear());
      (0, _array.arrayEach)(this.highlight.getRowHighlights(), highlight => void highlight.clear());
      (0, _array.arrayEach)(this.highlight.getColumnHighlights(), highlight => void highlight.clear());
    }
    this.highlight.useLayerLevel(layerLevel);
    const areaHighlight = this.highlight.createArea();
    const layeredAreaHighlight = this.highlight.createLayeredArea();
    const rowHeaderHighlight = this.highlight.createRowHeader();
    const columnHeaderHighlight = this.highlight.createColumnHeader();
    const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();
    const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();
    const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();
    const rowHighlight = this.highlight.createRowHighlight();
    const columnHighlight = this.highlight.createColumnHighlight();
    areaHighlight.clear();
    layeredAreaHighlight.clear();
    rowHeaderHighlight.clear();
    columnHeaderHighlight.clear();
    activeRowHeaderHighlight.clear();
    activeColumnHeaderHighlight.clear();
    activeCornerHeaderHighlight.clear();
    rowHighlight.clear();
    columnHighlight.clear();
    if (this.highlight.isEnabledFor(_highlight.AREA_TYPE, cellRange.highlight) && (this.isMultiple() || layerLevel >= 1)) {
      areaHighlight.add(cellRange.from).add(cellRange.to).commit();
      layeredAreaHighlight.add(cellRange.from).add(cellRange.to).commit();
      if (layerLevel === 1) {
        // For single cell selection in the same layer, we do not create area selection to prevent blue background.
        // When non-consecutive selection is performed we have to add that missing area selection to the previous layer
        // based on previous coordinates. It only occurs when the previous selection wasn't select multiple cells.
        const previousRange = this.selectedRange.previous();
        this.highlight.useLayerLevel(layerLevel - 1);
        this.highlight.createArea().add(previousRange.from).commit()
        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).
        .syncWith(previousRange);
        this.highlight.createLayeredArea().add(previousRange.from).commit()
        // Range may start with hidden indexes. Commit would not found start point (as we add just the `from` coords).
        .syncWith(previousRange);
        this.highlight.useLayerLevel(layerLevel);
      }
    }
    if (this.highlight.isEnabledFor(_highlight.HEADER_TYPE, cellRange.highlight)) {
      if (!cellRange.isSingleHeader()) {
        const rowCoordsFrom = this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), -1);
        const rowCoordsTo = this.tableProps.createCellCoords(cellRange.to.row, -1);
        const columnCoordsFrom = this.tableProps.createCellCoords(-1, Math.max(cellRange.from.col, 0));
        const columnCoordsTo = this.tableProps.createCellCoords(-1, cellRange.to.col);
        if (this.settings.selectionMode === 'single') {
          rowHeaderHighlight.add(rowCoordsFrom).commit();
          columnHeaderHighlight.add(columnCoordsFrom).commit();
          rowHighlight.add(rowCoordsFrom).commit();
          columnHighlight.add(columnCoordsFrom).commit();
        } else {
          rowHeaderHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();
          columnHeaderHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();
          rowHighlight.add(rowCoordsFrom).add(rowCoordsTo).commit();
          columnHighlight.add(columnCoordsFrom).add(columnCoordsTo).commit();
        }
      }
      const highlightRowHeaders = !_classPrivateFieldGet(_disableHeadersHighlight, this) && this.isEntireRowSelected() && (countCols > 0 && countCols === cellRange.getWidth() || countCols === 0 && this.isSelectedByRowHeader());
      const highlightColumnHeaders = !_classPrivateFieldGet(_disableHeadersHighlight, this) && this.isEntireColumnSelected() && (countRows > 0 && countRows === cellRange.getHeight() || countRows === 0 && this.isSelectedByColumnHeader());
      if (highlightRowHeaders) {
        activeRowHeaderHighlight.add(this.tableProps.createCellCoords(Math.max(cellRange.from.row, 0), Math.min(-this.tableProps.countRowHeaders(), -1))).add(this.tableProps.createCellCoords(Math.max(cellRange.to.row, 0), -1)).commit();
      }
      if (highlightColumnHeaders) {
        activeColumnHeaderHighlight.add(this.tableProps.createCellCoords(Math.min(-this.tableProps.countColHeaders(), -1), Math.max(cellRange.from.col, 0))).add(this.tableProps.createCellCoords(-1, Math.max(cellRange.to.col, 0))).commit();
      }
      if (highlightRowHeaders && highlightColumnHeaders) {
        activeCornerHeaderHighlight.add(this.tableProps.createCellCoords(-this.tableProps.countColHeaders(), -this.tableProps.countRowHeaders())).add(this.tableProps.createCellCoords(-1, -1)).commit();
      }
    }
  }

  /**
   * Sets the selection focus position at the specified coordinates.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   */
  setRangeFocus(coords) {
    if (this.selectedRange.isEmpty()) {
      return;
    }
    const cellRange = this.selectedRange.current();
    if (!this.inProgress) {
      this.runLocalHooks('beforeSetFocus', coords);
    }
    const focusHighlight = this.highlight.getFocus();
    focusHighlight.clear();
    cellRange.setHighlight(coords);
    if (!this.inProgress) {
      this.runLocalHooks('beforeHighlightSet');
    }
    if (this.highlight.isEnabledFor(_highlight.FOCUS_TYPE, cellRange.highlight)) {
      focusHighlight.add(cellRange.highlight).commit().syncWith(cellRange);
    }
    if (!this.inProgress) {
      _classPrivateFieldSet(_isFocusSelectionChanged, this, true);
      this.runLocalHooks('afterSetFocus', cellRange.highlight);
    }
  }

  /**
   * Selects cell relative to the current cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary.
   * Otherwise, row/column will be created according to `minSpareRows/minSpareCols` settings of Handsontable.
   */
  transformStart(rowDelta, colDelta) {
    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (this.settings.navigableHeaders) {
      _classPrivateFieldGet(_transformation, this).setOffsetSize({
        x: this.tableProps.countRowHeaders(),
        y: this.tableProps.countColHeaders()
      });
    } else {
      _classPrivateFieldGet(_transformation, this).resetOffsetSize();
    }
    this.setRangeStart(_classPrivateFieldGet(_transformation, this).transformStart(rowDelta, colDelta, createMissingRecords));
  }

  /**
   * Sets selection end cell relative to the current selection end cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   */
  transformEnd(rowDelta, colDelta) {
    if (this.settings.navigableHeaders) {
      _classPrivateFieldGet(_transformation, this).setOffsetSize({
        x: this.tableProps.countRowHeaders(),
        y: this.tableProps.countColHeaders()
      });
    } else {
      _classPrivateFieldGet(_transformation, this).resetOffsetSize();
    }
    this.setRangeEnd(_classPrivateFieldGet(_transformation, this).transformEnd(rowDelta, colDelta));
  }

  /**
   * Transforms the focus cell selection relative to the current focus position.
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   */
  transformFocus(rowDelta, colDelta) {
    const range = this.selectedRange.current();
    const {
      row,
      col
    } = range.getOuterTopStartCorner();
    const columnsInRange = this.tableProps.countRenderableColumnsInRange(0, col - 1);
    const rowsInRange = this.tableProps.countRenderableRowsInRange(0, row - 1);
    if (range.highlight.isHeader()) {
      // for header focus selection calculate the new coords based on the selection including headers
      _classPrivateFieldGet(_focusTransformation, this).setOffsetSize({
        x: col < 0 ? Math.abs(col) : -columnsInRange,
        y: row < 0 ? Math.abs(row) : -rowsInRange
      });
    } else {
      // for focus selection in cells calculate the new coords only based on the selected cells
      _classPrivateFieldGet(_focusTransformation, this).setOffsetSize({
        x: col < 0 ? 0 : -columnsInRange,
        y: row < 0 ? 0 : -rowsInRange
      });
    }
    const focusCoords = _classPrivateFieldGet(_focusTransformation, this).transformStart(rowDelta, colDelta);
    this.setRangeFocus(focusCoords.normalize());
  }

  /**
   * Transforms the last selection layer down or up by the index count.
   *
   * @param {number} visualRowIndex Visual row index from which the selection will be shifted.
   * @param {number} amount The number of rows to shift the selection.
   */
  shiftRows(visualRowIndex, amount) {
    if (!this.isSelected()) {
      return;
    }
    const range = this.selectedRange.current();
    if (this.isSelectedByCorner()) {
      this.selectAll(true, true, {
        disableHeadersHighlight: true
      });
    } else if (this.isSelectedByColumnHeader() || range.getOuterTopStartCorner().row >= visualRowIndex) {
      const {
        from,
        to,
        highlight
      } = range;
      const countRows = this.tableProps.countRows();
      const isSelectedByRowHeader = this.isSelectedByRowHeader();
      const isSelectedByColumnHeader = this.isSelectedByColumnHeader();
      const minRow = isSelectedByColumnHeader ? -1 : 0;
      const coordsStartAmount = isSelectedByColumnHeader ? 0 : amount;

      // Remove from the stack the last added selection as that selection below will be
      // replaced by new transformed selection.
      this.getSelectedRange().pop();
      const coordsStart = this.tableProps.createCellCoords((0, _number.clamp)(from.row + coordsStartAmount, minRow, countRows - 1), from.col);
      const coordsEnd = this.tableProps.createCellCoords((0, _number.clamp)(to.row + amount, minRow, countRows - 1), to.col);
      this.markSource('shift');
      if (highlight.row >= visualRowIndex) {
        this.setRangeStartOnly(coordsStart, true, this.tableProps.createCellCoords((0, _number.clamp)(highlight.row + amount, 0, countRows - 1), highlight.col));
      } else {
        this.setRangeStartOnly(coordsStart, true);
      }
      if (isSelectedByRowHeader) {
        this.selectedByRowHeader.add(this.getLayerLevel());
      }
      if (isSelectedByColumnHeader) {
        this.selectedByColumnHeader.add(this.getLayerLevel());
      }
      this.setRangeEnd(coordsEnd);
      this.markEndSource();
    }
  }

  /**
   * Transforms the last selection layer left or right by the index count.
   *
   * @param {number} visualColumnIndex Visual column index from which the selection will be shifted.
   * @param {number} amount The number of columns to shift the selection.
   */
  shiftColumns(visualColumnIndex, amount) {
    if (!this.isSelected()) {
      return;
    }
    const range = this.selectedRange.current();
    if (this.isSelectedByCorner()) {
      this.selectAll(true, true, {
        disableHeadersHighlight: true
      });
    } else if (this.isSelectedByRowHeader() || range.getOuterTopStartCorner().col >= visualColumnIndex) {
      const {
        from,
        to,
        highlight
      } = range;
      const countCols = this.tableProps.countCols();
      const isSelectedByRowHeader = this.isSelectedByRowHeader();
      const isSelectedByColumnHeader = this.isSelectedByColumnHeader();
      const minColumn = isSelectedByRowHeader ? -1 : 0;
      const coordsStartAmount = isSelectedByRowHeader ? 0 : amount;

      // Remove from the stack the last added selection as that selection below will be
      // replaced by new transformed selection.
      this.getSelectedRange().pop();
      const coordsStart = this.tableProps.createCellCoords(from.row, (0, _number.clamp)(from.col + coordsStartAmount, minColumn, countCols - 1));
      const coordsEnd = this.tableProps.createCellCoords(to.row, (0, _number.clamp)(to.col + amount, minColumn, countCols - 1));
      this.markSource('shift');
      if (highlight.col >= visualColumnIndex) {
        this.setRangeStartOnly(coordsStart, true, this.tableProps.createCellCoords(highlight.row, (0, _number.clamp)(highlight.col + amount, 0, countCols - 1)));
      } else {
        this.setRangeStartOnly(coordsStart, true);
      }
      if (isSelectedByRowHeader) {
        this.selectedByRowHeader.add(this.getLayerLevel());
      }
      if (isSelectedByColumnHeader) {
        this.selectedByColumnHeader.add(this.getLayerLevel());
      }
      this.setRangeEnd(coordsEnd);
      this.markEndSource();
    }
  }

  /**
   * Returns currently used layer level.
   *
   * @returns {number} Returns layer level starting from 0. If no selection was added to the table -1 is returned.
   */
  getLayerLevel() {
    return this.selectedRange.size() - 1;
  }

  /**
   * Returns `true` if currently there is a selection on the screen, `false` otherwise.
   *
   * @returns {boolean}
   */
  isSelected() {
    return !this.selectedRange.isEmpty();
  }

  /**
   * Returns information if we have a multi-selection. This method check multi-selection only on the latest layer of
   * the selection.
   *
   * @returns {boolean}
   */
  isMultiple() {
    if (!this.isSelected()) {
      return false;
    }
    const isMultipleListener = (0, _object.createObjectPropListener)(!this.selectedRange.current().isSingle());
    this.runLocalHooks('afterIsMultipleSelection', isMultipleListener);
    return isMultipleListener.value;
  }

  /**
   * Checks if the last selection involves changing the focus cell position only.
   *
   * @returns {boolean}
   */
  isFocusSelectionChanged() {
    return this.isSelected() && _classPrivateFieldGet(_isFocusSelectionChanged, this);
  }

  /**
   * Returns `true` if the selection was applied by clicking to the row header. If the `layerLevel`
   * argument is passed then only that layer will be checked. Otherwise, it checks if any row header
   * was clicked on any selection layer level.
   *
   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
   * @returns {boolean}
   */
  isSelectedByRowHeader() {
    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();
    return !this.isSelectedByCorner(layerLevel) && (layerLevel === -1 ? this.selectedByRowHeader.size > 0 : this.selectedByRowHeader.has(layerLevel));
  }

  /**
   * Returns `true` if the selection consists of entire rows (including their headers). If the `layerLevel`
   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.
   *
   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
   * @returns {boolean}
   */
  isEntireRowSelected() {
    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();
    const tester = range => {
      const {
        col
      } = range.getOuterTopStartCorner();
      const rowHeaders = this.tableProps.countRowHeaders();
      const countCols = this.tableProps.countCols();
      return (rowHeaders > 0 && col < 0 || rowHeaders === 0) && range.getWidth() === countCols;
    };
    if (layerLevel === -1) {
      return Array.from(this.selectedRange).some(range => tester(range));
    }
    const range = this.selectedRange.peekByIndex(layerLevel);
    return range ? tester(range) : false;
  }

  /**
   * Returns `true` if the selection was applied by clicking to the column header. If the `layerLevel`
   * argument is passed then only that layer will be checked. Otherwise, it checks if any column header
   * was clicked on any selection layer level.
   *
   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
   * @returns {boolean}
   */
  isSelectedByColumnHeader() {
    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();
    return !this.isSelectedByCorner() && (layerLevel === -1 ? this.selectedByColumnHeader.size > 0 : this.selectedByColumnHeader.has(layerLevel));
  }

  /**
   * Returns `true` if the selection consists of entire columns (including their headers). If the `layerLevel`
   * argument is passed then only that layer will be checked. Otherwise, it checks the selection for all layers.
   *
   * @param {number} [layerLevel=this.getLayerLevel()] Selection layer level to check.
   * @returns {boolean}
   */
  isEntireColumnSelected() {
    let layerLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getLayerLevel();
    const tester = range => {
      const {
        row
      } = range.getOuterTopStartCorner();
      const colHeaders = this.tableProps.countColHeaders();
      const countRows = this.tableProps.countRows();
      return (colHeaders > 0 && row < 0 || colHeaders === 0) && range.getHeight() === countRows;
    };
    if (layerLevel === -1) {
      return Array.from(this.selectedRange).some(range => tester(range));
    }
    const range = this.selectedRange.peekByIndex(layerLevel);
    return range ? tester(range) : false;
  }

  /**
   * Returns `true` if the selection was applied by clicking on the row or column header on any layer level.
   *
   * @returns {boolean}
   */
  isSelectedByAnyHeader() {
    return this.isSelectedByRowHeader(-1) || this.isSelectedByColumnHeader(-1) || this.isSelectedByCorner();
  }

  /**
   * Returns `true` if the selection was applied by clicking on the left-top corner overlay.
   *
   * @returns {boolean}
   */
  isSelectedByCorner() {
    return this.selectedByColumnHeader.has(this.getLayerLevel()) && this.selectedByRowHeader.has(this.getLayerLevel());
  }

  /**
   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if
   * the coords object is within selection range.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {boolean}
   */
  inInSelection(coords) {
    return this.selectedRange.includes(coords);
  }

  /**
   * Returns `true` if the cell corner should be visible.
   *
   * @private
   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.
   */
  isCellCornerVisible() {
    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && !this.isMultiple();
  }

  /**
   * Returns `true` if the cell coordinates are visible (renderable).
   *
   * @private
   * @param {CellCoords} coords The cell coordinates to check.
   * @returns {boolean}
   */
  isCellVisible(coords) {
    const renderableCoords = this.tableProps.visualToRenderableCoords(coords);
    return renderableCoords.row !== null && renderableCoords.col !== null;
  }

  /**
   * Returns `true` if the area corner should be visible.
   *
   * @param {number} layerLevel The layer level.
   * @returns {boolean} `true` if the corner element has to be visible, `false` otherwise.
   */
  isAreaCornerVisible(layerLevel) {
    if (Number.isInteger(layerLevel) && layerLevel !== this.getLayerLevel()) {
      return false;
    }
    return this.settings.fillHandle && !this.tableProps.isEditorOpened() && this.isMultiple();
  }

  /**
   * Clear the selection by resetting the collected ranges and highlights.
   */
  clear() {
    // TODO: collections selectedByColumnHeader and selectedByRowHeader should be clear too.
    this.selectedRange.clear();
    this.highlight.clear();
  }

  /**
   * Deselects all selected cells.
   */
  deselect() {
    if (!this.isSelected()) {
      return;
    }
    this.inProgress = false;
    this.clear();
    this.runLocalHooks('afterDeselect');
  }

  /**
   * Selects all cells and headers.
   *
   * @param {boolean} [includeRowHeaders=false] `true` If the selection should include the row headers,
   * `false` otherwise.
   * @param {boolean} [includeColumnHeaders=false] `true` If the selection should include the column
   * headers, `false` otherwise.
   * @param {object} [options] Additional object with options.
   * @param {{row: number, col: number} | boolean} [options.focusPosition] The argument allows changing the cell/header
   * focus position. The value takes an object with a `row` and `col` properties from -N to N, where
   * negative values point to the headers and positive values point to the cell range. If `false`, the focus
   * position won't be changed.
   * @param {boolean} [options.disableHeadersHighlight] If `true`, disables highlighting the headers even when
   * the logical coordinates points on them.
   */
  selectAll() {
    var _this$getSelectedRang;
    let includeRowHeaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    let includeColumnHeaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      focusPosition: false,
      disableHeadersHighlight: false
    };
    const nrOfRows = this.tableProps.countRows();
    const nrOfColumns = this.tableProps.countCols();
    const countRowHeaders = this.tableProps.countRowHeaders();
    const countColHeaders = this.tableProps.countColHeaders();
    const rowFrom = includeColumnHeaders ? -countColHeaders : 0;
    const columnFrom = includeRowHeaders ? -countRowHeaders : 0;

    // We can't select cells when there is no data.
    if (rowFrom === 0 && columnFrom === 0 && (nrOfRows === 0 || nrOfColumns === 0)) {
      return;
    }
    let highlight = (_this$getSelectedRang = this.getSelectedRange().current()) === null || _this$getSelectedRang === void 0 ? void 0 : _this$getSelectedRang.highlight;
    const {
      focusPosition,
      disableHeadersHighlight
    } = options;
    _classPrivateFieldSet(_disableHeadersHighlight, this, disableHeadersHighlight);
    if (focusPosition && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {
      highlight = this.tableProps.createCellCoords((0, _number.clamp)(focusPosition.row, rowFrom, nrOfRows - 1), (0, _number.clamp)(focusPosition.col, columnFrom, nrOfColumns - 1));
    }
    const startCoords = this.tableProps.createCellCoords(rowFrom, columnFrom);
    const endCoords = this.tableProps.createCellCoords(nrOfRows - 1, nrOfColumns - 1);
    this.clear();
    this.setRangeStartOnly(startCoords, undefined, highlight);
    if (columnFrom < 0) {
      this.selectedByRowHeader.add(this.getLayerLevel());
    }
    if (rowFrom < 0) {
      this.selectedByColumnHeader.add(this.getLayerLevel());
    }
    this.setRangeEnd(endCoords);
    this.finish();
    _classPrivateFieldSet(_disableHeadersHighlight, this, false);
  }

  /**
   * Make multiple, non-contiguous selection specified by `row` and `column` values or a range of cells
   * finishing at `endRow`, `endColumn`. The method supports two input formats, first as an array of arrays such
   * as `[[rowStart, columnStart, rowEnd, columnEnd]]` and second format as an array of CellRange objects.
   * If the passed ranges have another format the exception will be thrown.
   *
   * @param {Array[]|CellRange[]} selectionRanges The coordinates which define what the cells should be selected.
   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
   */
  selectCells(selectionRanges) {
    var _this2 = this;
    const selectionType = (0, _utils.detectSelectionType)(selectionRanges);
    if (selectionType === _utils.SELECTION_TYPE_EMPTY) {
      return false;
    } else if (selectionType === _utils.SELECTION_TYPE_UNRECOGNIZED) {
      throw new Error((0, _templateLiteralTag.toSingleLine)`Unsupported format of the selection ranges was passed. To select cells pass\x20
        the coordinates as an array of arrays ([[rowStart, columnStart/columnPropStart, rowEnd,\x20
        columnEnd/columnPropEnd]]) or as an array of CellRange objects.`);
    }
    const selectionSchemaNormalizer = (0, _utils.normalizeSelectionFactory)(selectionType, {
      createCellCoords: function () {
        return _this2.tableProps.createCellCoords(...arguments);
      },
      createCellRange: function () {
        return _this2.tableProps.createCellRange(...arguments);
      },
      propToCol: prop => this.tableProps.propToCol(prop),
      keepDirection: true
    });
    const navigableHeaders = this.settings.navigableHeaders;
    const tableParams = {
      countRows: this.tableProps.countRows(),
      countCols: this.tableProps.countCols(),
      countRowHeaders: navigableHeaders ? this.tableProps.countRowHeaders() : 0,
      countColHeaders: navigableHeaders ? this.tableProps.countColHeaders() : 0
    };

    // Check if every layer of the coordinates are valid.
    const isValid = !selectionRanges.some(selection => {
      const cellRange = selectionSchemaNormalizer(selection);
      const rangeValidity = cellRange.isValid(tableParams);
      return !(rangeValidity && !cellRange.containsHeaders() || rangeValidity && cellRange.containsHeaders() && cellRange.isSingleHeader());
    });
    if (isValid) {
      this.clear();
      this.setExpectedLayers(selectionRanges.length);
      (0, _array.arrayEach)(selectionRanges, selection => {
        const {
          from,
          to
        } = selectionSchemaNormalizer(selection);
        this.setRangeStartOnly(from.clone(), false);
        this.setRangeEnd(to.clone());
      });
      this.finish();
    }
    return isValid;
  }

  /**
   * Select column specified by `startColumn` visual index or column property or a range of columns finishing at
   * `endColumn`.
   *
   * @param {number|string} startColumn Visual column index or column property from which the selection starts.
   * @param {number|string} [endColumn] Visual column index or column property from to the selection finishes.
   * @param {number | { row: number, col: number }} [focusPosition=0] The argument allows changing the cell/header focus
   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive
   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus
   * position horizontally.
   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
   */
  selectColumns(startColumn) {
    let endColumn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startColumn;
    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    const start = typeof startColumn === 'string' ? this.tableProps.propToCol(startColumn) : startColumn;
    const end = typeof endColumn === 'string' ? this.tableProps.propToCol(endColumn) : endColumn;
    const countRows = this.tableProps.countRows();
    const countCols = this.tableProps.countCols();
    const countColHeaders = this.tableProps.countColHeaders();
    const columnHeaderLastIndex = countColHeaders === 0 ? 0 : -countColHeaders;
    const fromCoords = this.tableProps.createCellCoords(columnHeaderLastIndex, start);
    const toCoords = this.tableProps.createCellCoords(countRows - 1, end);
    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({
      countRows,
      countCols,
      countRowHeaders: 0,
      countColHeaders
    });
    if (isValid) {
      let highlightRow = 0;
      let highlightColumn = 0;
      if (Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {
        highlightRow = (0, _number.clamp)(focusPosition.row, columnHeaderLastIndex, countRows - 1);
        highlightColumn = (0, _number.clamp)(focusPosition.col, Math.min(start, end), Math.max(start, end));
      } else {
        highlightRow = (0, _number.clamp)(focusPosition, columnHeaderLastIndex, countRows - 1);
        highlightColumn = start;
      }
      const highlight = this.tableProps.createCellCoords(highlightRow, highlightColumn);
      const fromRow = countColHeaders === 0 ? 0 : (0, _number.clamp)(highlight.row, columnHeaderLastIndex, -1);
      const toRow = countRows - 1;
      const from = this.tableProps.createCellCoords(fromRow, start);
      const to = this.tableProps.createCellCoords(toRow, end);
      this.runLocalHooks('beforeSelectColumns', from, to, highlight);

      // disallow modifying row axis for that hooks
      from.row = fromRow;
      to.row = toRow;
      this.setRangeStartOnly(from, undefined, highlight);
      this.selectedByColumnHeader.add(this.getLayerLevel());
      this.setRangeEnd(to);
      this.runLocalHooks('afterSelectColumns', from, to, highlight);
      this.finish();
    }
    return isValid;
  }

  /**
   * Select row specified by `startRow` visual index or a range of rows finishing at `endRow`.
   *
   * @param {number} startRow Visual row index from which the selection starts.
   * @param {number} [endRow] Visual row index from to the selection finishes.
   * @param {number | { row: number, col: number }} [focusPosition=0] The argument allows changing the cell/header focus
   * position. The value can take visual row index from -N to N, where negative values point to the headers and positive
   * values point to the cell range. An object with `row` and `col` properties also can be passed to change the focus
   * position horizontally.
   * @returns {boolean} Returns `true` if selection was successful, `false` otherwise.
   */
  selectRows(startRow) {
    let endRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : startRow;
    let focusPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    const countRows = this.tableProps.countRows();
    const countCols = this.tableProps.countCols();
    const countRowHeaders = this.tableProps.countRowHeaders();
    const rowHeaderLastIndex = countRowHeaders === 0 ? 0 : -countRowHeaders;
    const fromCoords = this.tableProps.createCellCoords(startRow, rowHeaderLastIndex);
    const toCoords = this.tableProps.createCellCoords(endRow, countCols - 1);
    const isValid = this.tableProps.createCellRange(fromCoords, fromCoords, toCoords).isValid({
      countRows,
      countCols,
      countRowHeaders,
      countColHeaders: 0
    });
    if (isValid) {
      let highlightRow = 0;
      let highlightColumn = 0;
      if (Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.row) && Number.isInteger(focusPosition === null || focusPosition === void 0 ? void 0 : focusPosition.col)) {
        highlightRow = (0, _number.clamp)(focusPosition.row, Math.min(startRow, endRow), Math.max(startRow, endRow));
        highlightColumn = (0, _number.clamp)(focusPosition.col, rowHeaderLastIndex, countCols - 1);
      } else {
        highlightRow = startRow;
        highlightColumn = (0, _number.clamp)(focusPosition, rowHeaderLastIndex, countCols - 1);
      }
      const highlight = this.tableProps.createCellCoords(highlightRow, highlightColumn);
      const fromColumn = countRowHeaders === 0 ? 0 : (0, _number.clamp)(highlight.col, rowHeaderLastIndex, -1);
      const toColumn = countCols - 1;
      const from = this.tableProps.createCellCoords(startRow, fromColumn);
      const to = this.tableProps.createCellCoords(endRow, toColumn);
      this.runLocalHooks('beforeSelectRows', from, to, highlight);

      // disallow modifying column axis for that hooks
      from.col = fromColumn;
      to.col = toColumn;
      this.setRangeStartOnly(from, undefined, highlight);
      this.selectedByRowHeader.add(this.getLayerLevel());
      this.setRangeEnd(to);
      this.runLocalHooks('afterSelectRows', from, to, highlight);
      this.finish();
    }
    return isValid;
  }

  /**
   * Refreshes the whole selection by clearing, reapplying and committing the renderable selection (Walkontable Selection API)
   * by using already added visual ranges.
   */
  refresh() {
    if (!this.isSelected()) {
      return;
    }
    const countRows = this.tableProps.countRows();
    const countColumns = this.tableProps.countCols();
    if (countRows === 0 || countColumns === 0) {
      this.deselect();
      return;
    }
    const range = this.selectedRange.peekByIndex(this.selectedRange.size() - 1);
    const {
      from,
      to,
      highlight
    } = range;
    this.clear();
    highlight.assign({
      row: (0, _number.clamp)(highlight.row, -Infinity, countRows - 1),
      col: (0, _number.clamp)(highlight.col, -Infinity, countColumns - 1)
    });
    from.assign({
      row: (0, _number.clamp)(from.row, -Infinity, countRows - 1),
      col: (0, _number.clamp)(from.col, -Infinity, countColumns - 1)
    });
    to.assign({
      row: (0, _number.clamp)(to.row, 0, countRows - 1),
      col: (0, _number.clamp)(to.col, 0, countColumns - 1)
    });
    this.selectedRange.ranges.push(range);
    this.highlight.getFocus().add(highlight).commit().syncWith(range);
    this.applyAndCommit(range);
  }

  /**
   * Refreshes the whole selection by recommitting (recalculating visual indexes to renderable ones) the renderable selection
   * that was already added.
   */
  commit() {
    const customSelections = this.highlight.getCustomSelections();
    customSelections.forEach(customSelection => {
      customSelection.commit();
    });
    if (!this.isSelected()) {
      return;
    }
    const currentLayer = this.getLayerLevel();
    const cellRange = this.selectedRange.current();
    if (this.highlight.isEnabledFor(_highlight.FOCUS_TYPE, cellRange.highlight)) {
      this.highlight.getFocus().commit().syncWith(cellRange);
    }

    // Rewriting rendered ranges going through all layers.
    for (let layerLevel = 0; layerLevel < this.selectedRange.size(); layerLevel += 1) {
      this.highlight.useLayerLevel(layerLevel);
      const areaHighlight = this.highlight.createArea();
      const areaLayeredHighlight = this.highlight.createLayeredArea();
      const rowHeaderHighlight = this.highlight.createRowHeader();
      const columnHeaderHighlight = this.highlight.createColumnHeader();
      const activeRowHeaderHighlight = this.highlight.createActiveRowHeader();
      const activeColumnHeaderHighlight = this.highlight.createActiveColumnHeader();
      const activeCornerHeaderHighlight = this.highlight.createActiveCornerHeader();
      const rowHighlight = this.highlight.createRowHighlight();
      const columnHighlight = this.highlight.createColumnHighlight();
      areaHighlight.commit();
      areaLayeredHighlight.commit();
      rowHeaderHighlight.commit();
      columnHeaderHighlight.commit();
      activeRowHeaderHighlight.commit();
      activeColumnHeaderHighlight.commit();
      activeCornerHeaderHighlight.commit();
      rowHighlight.commit();
      columnHighlight.commit();
    }

    // Reverting starting layer for the Highlight.
    this.highlight.useLayerLevel(currentLayer);
  }
}
(0, _object.mixin)(Selection, _localHooks.default);
var _default = exports["default"] = Selection;

/***/ }),
/* 650 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _activeHeader = __webpack_require__(651);
var _areaLayered = __webpack_require__(653);
var _area = __webpack_require__(654);
var _column = __webpack_require__(655);
var _focus = __webpack_require__(656);
var _customSelection = __webpack_require__(657);
var _fill = __webpack_require__(658);
var _header = __webpack_require__(659);
var _row = __webpack_require__(660);
var _src = __webpack_require__(540);
exports.ACTIVE_HEADER_TYPE = _src.HIGHLIGHT_ACTIVE_HEADER_TYPE;
exports.AREA_TYPE = _src.HIGHLIGHT_AREA_TYPE;
exports.FOCUS_TYPE = _src.HIGHLIGHT_FOCUS_TYPE;
exports.CUSTOM_SELECTION_TYPE = _src.HIGHLIGHT_CUSTOM_SELECTION_TYPE;
exports.FILL_TYPE = _src.HIGHLIGHT_FILL_TYPE;
exports.HEADER_TYPE = _src.HIGHLIGHT_HEADER_TYPE;
exports.ROW_TYPE = _src.HIGHLIGHT_ROW_TYPE;
exports.COLUMN_TYPE = _src.HIGHLIGHT_COLUMN_TYPE;
var _array = __webpack_require__(495);
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Highlight class responsible for managing Walkontable Selection classes.
 *
 * With Highlight object you can manipulate four different highlight types:
 *  - `cell` can be added only to a single cell at a time and it defines currently selected cell;
 *  - `fill` can occur only once and its highlight defines selection of autofill functionality (managed by the plugin with the same name);
 *  - `areas` can be added to multiple cells at a time. This type highlights selected cell or multiple cells.
 *    The multiple cells have to be defined as an uninterrupted order (regular shape). Otherwise, the new layer of
 *    that type should be created to manage not-consecutive selection;
 *  - `header` can occur multiple times. This type is designed to highlight only headers. Like `area` type it
 *    can appear with multiple highlights (accessed under different level layers).
 *
 * @class Highlight
 * @util
 */
var _Highlight_brand = /*#__PURE__*/new WeakSet();
class Highlight {
  constructor(options) {
    /**
     * Creates (if not exist in the cache) Walkontable Selection instance.
     *
     * @param {Map} cacheMap The map where the instance will be cached.
     * @param {Function} highlightFactory The function factory.
     * @returns {VisualSelection}
     */
    _classPrivateMethodInitSpec(this, _Highlight_brand);
    /**
     * Options consumed by Highlight class and Walkontable Selection classes.
     *
     * @type {object}
     */
    (0, _defineProperty2.default)(this, "options", void 0);
    /**
     * The property which describes which layer level of the visual selection will be modified.
     * This option is valid only for `area` and `header` highlight types which occurs multiple times on
     * the table (as a non-consecutive selection).
     *
     * An order of the layers is the same as the order of added new non-consecutive selections.
     *
     * @type {number}
     * @default 0
     */
    (0, _defineProperty2.default)(this, "layerLevel", 0);
    /**
     * `cell` highlight object which describes attributes for the currently selected cell.
     * It can only occur only once on the table.
     *
     * @type {Selection}
     */
    (0, _defineProperty2.default)(this, "focus", void 0);
    /**
     * `fill` highlight object which describes attributes for the borders for autofill functionality.
     * It can only occur only once on the table.
     *
     * @type {Selection}
     */
    (0, _defineProperty2.default)(this, "fill", void 0);
    /**
     * Collection of the `area` highlights. That objects describes attributes for the borders and selection of
     * the multiple selected cells. It can occur multiple times on the table.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "layeredAreas", new Map());
    /**
     * Collection of the `highlight` highlights. That objects describes attributes for the borders and selection of
     * the multiple selected cells. It can occur multiple times on the table.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "areas", new Map());
    /**
     * Collection of the `header` highlights. That objects describes attributes for the selection of
     * the multiple selected rows in the table header. It can occur multiple times on the table.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "rowHeaders", new Map());
    /**
     * Collection of the `header` highlights. That objects describes attributes for the selection of
     * the multiple selected columns in the table header. It can occur multiple times on the table.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "columnHeaders", new Map());
    /**
     * Collection of the `active-header` highlights. That objects describes attributes for the selection of
     * the multiple selected rows in the table header. The table headers which have selected all items in
     * a row will be marked as `active-header`.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "activeRowHeaders", new Map());
    /**
     * Collection of the `active-header` highlights. That objects describes attributes for the selection of
     * the multiple selected columns in the table header. The table headers which have selected all items in
     * a row will be marked as `active-header`.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "activeColumnHeaders", new Map());
    /**
     * Collection of the `active-header` highlights. That objects describes attributes for the selection of
     * the selected corner in the table header. The table headers which have selected all items in
     * a row will be marked as `active-header`.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "activeCornerHeaders", new Map());
    /**
     * Collection of the `rows` highlights. That objects describes attributes for the selection of
     * the multiple selected cells in a row. It can occur multiple times on the table.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "rowHighlights", new Map());
    /**
     * Collection of the `columns` highlights. That objects describes attributes for the selection of
     * the multiple selected cells in a column. It can occur multiple times on the table.
     *
     * @type {Map.<number, Selection>}
     */
    (0, _defineProperty2.default)(this, "columnHighlights", new Map());
    /**
     * Collection of the `custom-selection`, holder for example borders added through CustomBorders plugin.
     *
     * @type {Selection[]}
     */
    (0, _defineProperty2.default)(this, "customSelections", []);
    this.options = options;
    this.focus = (0, _focus.createHighlight)(options);
    this.fill = (0, _fill.createHighlight)(options);
  }

  /**
   * Check if highlight cell rendering is disabled for specified highlight type.
   *
   * @param {string} highlightType Highlight type. Possible values are: `cell`, `area`, `fill` or `header`.
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {boolean}
   */
  isEnabledFor(highlightType, coords) {
    let type = highlightType;

    // Legacy compatibility.
    if (highlightType === _src.HIGHLIGHT_FOCUS_TYPE) {
      type = 'current'; // One from settings for `disableVisualSelection` up to Handsontable 0.36/Handsontable Pro 1.16.0.
    }
    let disableHighlight = this.options.disabledCellSelection(coords.row, coords.col);
    if (typeof disableHighlight === 'string') {
      disableHighlight = [disableHighlight];
    }
    return disableHighlight === false || Array.isArray(disableHighlight) && !disableHighlight.includes(type);
  }

  /**
   * Set a new layer level to make access to the desire `area` and `header` highlights.
   *
   * @param {number} [level=0] Layer level to use.
   * @returns {Highlight}
   */
  useLayerLevel() {
    let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    this.layerLevel = level;
    return this;
  }

  /**
   * Get Walkontable Selection instance created for controlling highlight of the currently
   * focused cell (or header).
   *
   * @returns {Selection}
   */
  getFocus() {
    return this.focus;
  }

  /**
   * Get Walkontable Selection instance created for controlling highlight of the autofill functionality.
   *
   * @returns {Selection}
   */
  getFill() {
    return this.fill;
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * `area` highlights.
   *
   * @returns {Selection}
   */
  createLayeredArea() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.layeredAreas, _areaLayered.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.
   *
   * @returns {Selection[]}
   */
  getLayeredAreas() {
    return [...this.layeredAreas.values()];
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * `highlight` highlights.
   *
   * @returns {Selection}
   */
  createArea() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.areas, _area.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the cells.
   *
   * @returns {Selection[]}
   */
  getAreas() {
    return [...this.areas.values()];
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * header highlight for rows.
   *
   * @returns {Selection}
   */
  createRowHeader() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.rowHeaders, _header.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.
   *
   * @returns {Selection[]}
   */
  getRowHeaders() {
    return [...this.rowHeaders.values()];
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * header highlight for columns.
   *
   * @returns {Selection}
   */
  createColumnHeader() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.columnHeaders, _header.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers.
   *
   * @returns {Selection[]}
   */
  getColumnHeaders() {
    return [...this.columnHeaders.values()];
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * highlight for active row headers.
   *
   * @returns {Selection}
   */
  createActiveRowHeader() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.activeRowHeaders, _activeHeader.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.
   *
   * @returns {Selection[]}
   */
  getActiveRowHeaders() {
    return [...this.activeRowHeaders.values()];
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * highlight for active column headers.
   *
   * @returns {Selection}
   */
  createActiveColumnHeader() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.activeColumnHeaders, _activeHeader.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the active headers.
   *
   * @returns {Selection[]}
   */
  getActiveColumnHeaders() {
    return [...this.activeColumnHeaders.values()];
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * highlight for the headers corner.
   *
   * @returns {Selection}
   */
  createActiveCornerHeader() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.activeCornerHeaders, _activeHeader.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the visual highlight of the headers corner.
   *
   * @returns {Selection[]}
   */
  getActiveCornerHeaders() {
    return [...this.activeCornerHeaders.values()];
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * highlight cells in a row.
   *
   * @returns {Selection}
   */
  createRowHighlight() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.rowHighlights, _row.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the rows highlighting.
   *
   * @returns {Selection[]}
   */
  getRowHighlights() {
    return [...this.rowHighlights.values()];
  }

  /**
   * Creates (if not exist in the cache) Walkontable Selection instance created for controlling
   * highlight cells in a column.
   *
   * @returns {Selection}
   */
  createColumnHighlight() {
    return _assertClassBrand(_Highlight_brand, this, _createHighlight).call(this, this.columnHighlights, _column.createHighlight);
  }

  /**
   * Get all Walkontable Selection instances which describes the state of the columns highlighting.
   *
   * @returns {Selection[]}
   */
  getColumnHighlights() {
    return [...this.columnHighlights.values()];
  }

  /**
   * Get Walkontable Selection instance created for controlling highlight of the custom selection functionality.
   *
   * @returns {Selection}
   */
  getCustomSelections() {
    return [...this.customSelections.values()];
  }

  /**
   * Add selection to the custom selection instance. The new selection are added to the end of the selection collection.
   *
   * @param {object} selectionInstance The selection instance.
   */
  addCustomSelection(selectionInstance) {
    this.customSelections.push((0, _customSelection.createHighlight)({
      ...this.options,
      ...selectionInstance
    }));
  }

  /**
   * Perform cleaning visual highlights for the whole table.
   */
  clear() {
    this.focus.clear();
    this.fill.clear();
    (0, _array.arrayEach)(this.areas.values(), highlight => void highlight.clear());
    (0, _array.arrayEach)(this.layeredAreas.values(), highlight => void highlight.clear());
    (0, _array.arrayEach)(this.rowHeaders.values(), highlight => void highlight.clear());
    (0, _array.arrayEach)(this.columnHeaders.values(), highlight => void highlight.clear());
    (0, _array.arrayEach)(this.activeRowHeaders.values(), highlight => void highlight.clear());
    (0, _array.arrayEach)(this.activeColumnHeaders.values(), highlight => void highlight.clear());
    (0, _array.arrayEach)(this.activeCornerHeaders.values(), highlight => void highlight.clear());
    (0, _array.arrayEach)(this.rowHighlights.values(), highlight => void highlight.clear());
    (0, _array.arrayEach)(this.columnHighlights.values(), highlight => void highlight.clear());
  }
  /**
   * This object can be iterate over using `for of` syntax or using internal `arrayEach` helper.
   *
   * @returns {Selection[]}
   */
  [Symbol.iterator]() {
    return [this.focus, this.fill, ...this.areas.values(), ...this.layeredAreas.values(), ...this.rowHeaders.values(), ...this.columnHeaders.values(), ...this.activeRowHeaders.values(), ...this.activeColumnHeaders.values(), ...this.activeCornerHeaders.values(), ...this.rowHighlights.values(), ...this.columnHighlights.values(), ...this.customSelections][Symbol.iterator]();
  }
}
function _createHighlight(cacheMap, highlightFactory) {
  const layerLevel = this.layerLevel;
  if (cacheMap.has(layerLevel)) {
    return cacheMap.get(layerLevel);
  }
  const highlight = highlightFactory({
    layerLevel,
    ...this.options
  });
  cacheMap.set(layerLevel, highlight);
  return highlight;
}
var _default = exports["default"] = Highlight;

/***/ }),
/* 651 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
/**
 * Creates the new instance of Selection, responsible for highlighting column or row headers
 * only when the whole column or row is selected.
 * This type of selection can occur multiple times.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @param {string} highlightParams.activeHeaderClassName Highlighted headers' class name.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    activeHeaderClassName,
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    className: activeHeaderClassName,
    ...restOptions,
    selectionType: _src.HIGHLIGHT_ACTIVE_HEADER_TYPE
  });
}

/***/ }),
/* 652 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _src = __webpack_require__(540);
class VisualSelection extends _src.Selection {
  constructor(settings, visualCellRange) {
    super(settings, null);
    /**
     * Range of selection visually. Visual representation may have representation in a rendered selection.
     *
     * @type {null|CellRange}
     */
    (0, _defineProperty2.default)(this, "visualCellRange", null);
    this.visualCellRange = visualCellRange || null;
    this.commit();
  }
  /**
   * Adds a cell coords to the selection.
   *
   * @param {CellCoords} coords Visual coordinates of a cell.
   * @returns {VisualSelection}
   */
  add(coords) {
    if (this.visualCellRange === null) {
      this.visualCellRange = this.settings.createCellRange(coords);
    } else {
      this.visualCellRange.expand(coords);
    }
    return this;
  }

  /**
   * Clears visual and renderable selection.
   *
   * @returns {VisualSelection}
   */
  clear() {
    this.visualCellRange = null;
    return super.clear();
  }

  /**
   * Trims the passed cell range object by removing all coordinates that points to the hidden rows
   * or columns. The result is a new cell range object that points only to the visible indexes or `null`.
   *
   * @private
   * @param {CellRange} cellRange Cells range object to be trimmed.
   * @returns {CellRange} Visual non-hidden cells range coordinates.
   */
  trimToVisibleCellsRangeOnly(_ref) {
    let {
      from,
      to
    } = _ref;
    let visibleFromCoords = this.getNearestNotHiddenCoords(from, 1);
    let visibleToCoords = this.getNearestNotHiddenCoords(to, -1);
    if (visibleFromCoords === null || visibleToCoords === null) {
      return null;
    }
    if (visibleFromCoords.row > visibleToCoords.row || visibleFromCoords.col > visibleToCoords.col) {
      visibleFromCoords = from;
      visibleToCoords = to;
    }
    return this.settings.createCellRange(visibleFromCoords, visibleFromCoords, visibleToCoords);
  }

  /**
   * Gets nearest coordinates that points to the visible row and column indexes. If there are no visible
   * rows and/or columns the `null` value is returned.
   *
   * @private
   * @param {CellCoords} coords The coords object as starting point for finding the nearest visible coordinates.
   * @param {1|-1} rowSearchDirection The search direction. For value 1, it means searching from top to bottom for
   *                                  rows and from left to right for columns. For -1, it is the other way around.
   * @param {1|-1} columnSearchDirection The same as above but for rows.
   * @returns {CellCoords|null} Visual cell coordinates.
   */
  getNearestNotHiddenCoords(coords, rowSearchDirection) {
    let columnSearchDirection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : rowSearchDirection;
    const nextVisibleRow = this.getNearestNotHiddenIndex(this.settings.rowIndexMapper, coords.row, rowSearchDirection);

    // There are no more visual rows in the range.
    if (nextVisibleRow === null) {
      return null;
    }
    const nextVisibleColumn = this.getNearestNotHiddenIndex(this.settings.columnIndexMapper, coords.col, columnSearchDirection);

    // There are no more visual columns in the range.
    if (nextVisibleColumn === null) {
      return null;
    }
    return this.settings.createCellCoords(nextVisibleRow, nextVisibleColumn);
  }

  /**
   * Gets nearest visual index. If there are no visible rows or columns the `null` value is returned.
   *
   * @private
   * @param {IndexMapper} indexMapper The IndexMapper instance for specific axis.
   * @param {number} visualIndex The index as starting point for finding the nearest visible index.
   * @param {1|-1} searchDirection The search direction. For value 1, it means searching from top to bottom for
   *                               rows and from left to right for columns. For -1, it is the other way around.
   * @returns {number|null} Visual row/column index.
   */
  getNearestNotHiddenIndex(indexMapper, visualIndex, searchDirection) {
    if (visualIndex < 0) {
      return visualIndex;
    }
    return indexMapper.getNearestNotHiddenIndex(visualIndex, searchDirection);
  }

  /**
   * Override internally stored visual indexes added by the Selection's `add` function. It should be executed
   * at the end of process of adding visual selection coordinates.
   *
   * @returns {VisualSelection}
   */
  commit() {
    // There is no information about visual ranges, thus no selection may be displayed.
    if (this.visualCellRange === null) {
      return this;
    }
    const trimmedCellRange = this.trimToVisibleCellsRangeOnly(this.visualCellRange);

    // There is no visual start point (and also visual end point) in the range.
    if (trimmedCellRange === null) {
      this.cellRange = null;
    } else {
      this.cellRange = this.createRenderableCellRange(trimmedCellRange.from, trimmedCellRange.to);
    }
    return this;
  }

  /**
   * Some selection may be a part of broader cell range. This function sync coordinates of current selection
   * and the broader cell range when needed (current selection can't be presented visually).
   *
   * @param {CellRange} broaderCellRange Visual range. Actual cell range may be contained in the broader cell range.
   * When there is no way to represent some cell range visually we try to find range containing just the first visible cell.
   *
   * Warn: Please keep in mind that this function may change coordinates of the handled broader range.
   *
   * @returns {VisualSelection}
   */
  syncWith(broaderCellRange) {
    const coordsFrom = broaderCellRange.from.clone().normalize();
    const rowDirection = broaderCellRange.getVerticalDirection() === 'N-S' ? 1 : -1;
    const columnDirection = broaderCellRange.getHorizontalDirection() === 'W-E' ? 1 : -1;
    const renderableHighlight = this.settings.visualToRenderableCoords(this.visualCellRange.highlight);
    let cellCoordsVisual = null;
    if (renderableHighlight === null || renderableHighlight.col === null || renderableHighlight.row === null) {
      cellCoordsVisual = this.getNearestNotHiddenCoords(coordsFrom, rowDirection, columnDirection);
    }
    if (cellCoordsVisual !== null && broaderCellRange.overlaps(cellCoordsVisual)) {
      const currentHighlight = broaderCellRange.highlight.clone();
      if (currentHighlight.row >= 0) {
        currentHighlight.row = cellCoordsVisual.row;
      }
      if (currentHighlight.col >= 0) {
        currentHighlight.col = cellCoordsVisual.col;
      }

      // We can't show selection visually now, but we found first visible range in the broader cell range.
      if (this.cellRange === null) {
        const cellCoordsRenderable = this.settings.visualToRenderableCoords(currentHighlight);
        this.cellRange = this.settings.createCellRange(cellCoordsRenderable);
      }

      // TODO
      // We set new highlight as it might change (for example, when showing/hiding some cells from the broader selection range)
      // TODO: It is also handled by the `MergeCells` plugin while adjusting already modified coordinates. Should it?
      broaderCellRange.setHighlight(currentHighlight);
    }

    // TODO
    // Sync the highlight coords from the visual selection layer with logical coords.
    if (this.settings.selectionType === 'focus' && renderableHighlight !== null && cellCoordsVisual === null) {
      broaderCellRange.setHighlight(this.visualCellRange.highlight);
    }
    return this;
  }

  /**
   * Returns the top left (TL) and bottom right (BR) selection coordinates (renderable indexes).
   * The method overwrites the original method to support header selection for hidden cells.
   * To make the header selection working, the CellCoords and CellRange have to support not
   * complete coordinates (`null` values for example, `row: null`, `col: 2`).
   *
   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.
   */
  getCorners() {
    const {
      from,
      to
    } = this.cellRange;
    return [Math.min(from.row, to.row), Math.min(from.col, to.col), Math.max(from.row, to.row), Math.max(from.col, to.col)];
  }

  /**
   * Returns the top left (or top right in RTL) and bottom right (or bottom left in RTL) selection
   * coordinates (visual indexes).
   *
   * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`.
   */
  getVisualCorners() {
    const topStart = this.settings.renderableToVisualCoords(this.cellRange.getTopStartCorner());
    const bottomEnd = this.settings.renderableToVisualCoords(this.cellRange.getBottomEndCorner());
    return [topStart.row, topStart.col, bottomEnd.row, bottomEnd.col];
  }

  /**
   * Creates a new CellRange object based on visual coordinates which before object creation are
   * translated to renderable indexes.
   *
   * @param {CellCoords} visualFromCoords The CellCoords object which contains coordinates that
   *                                      points to the beginning of the selection.
   * @param {CellCoords} visualToCoords The CellCoords object which contains coordinates that
   *                                    points to the end of the selection.
   * @returns {CellRange|null}
   */
  createRenderableCellRange(visualFromCoords, visualToCoords) {
    const renderableFromCoords = this.settings.visualToRenderableCoords(visualFromCoords);
    const renderableToCoords = this.settings.visualToRenderableCoords(visualToCoords);
    if (renderableFromCoords.row === null || renderableFromCoords.col === null || renderableToCoords.row === null || renderableToCoords.col === null) {
      return null;
    }
    return this.settings.createCellRange(renderableFromCoords, renderableFromCoords, renderableToCoords);
  }
}
var _default = exports["default"] = VisualSelection;

/***/ }),
/* 653 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
/**
 * Creates the new instance of Selection responsible for highlighting area of the selected multiple cells.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @param {object} highlightParams.areaCornerVisible Function to determine if area's corner should be visible.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    areaCornerVisible,
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    className: 'area',
    createLayers: true,
    border: {
      width: 1,
      color: '#4b89ff',
      cornerVisible: areaCornerVisible
    },
    ...restOptions,
    selectionType: _src.HIGHLIGHT_AREA_TYPE
  });
}

/***/ }),
/* 654 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
/**
 * Creates the new instance of Selection responsible for highlighting area of the selected multiple cells.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @param {object} highlightParams.areaCornerVisible Function to determine if area's corner should be visible.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    className: 'highlight',
    ...restOptions,
    selectionType: _src.HIGHLIGHT_AREA_TYPE
  });
}

/***/ }),
/* 655 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
/**
 * Creates the new instance of Selection, responsible for highlighting cells in a columns and
 * column headers.
 * This type of selection can occur multiple times.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @param {string} highlightParams.columnClassName Highlighted column' class name.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    columnClassName,
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    className: columnClassName,
    ...restOptions,
    selectionType: _src.HIGHLIGHT_COLUMN_TYPE
  });
}

/***/ }),
/* 656 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
var _a11y = __webpack_require__(496);
/**
 * Creates the new instance of Selection responsible for highlighting currently selected cell. This type of selection
 * can present on the table only one at the time.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @param {Function} highlightParams.cellCornerVisible Function to determine if cell's corner should be visible.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    cellCornerVisible,
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    className: 'current',
    headerAttributes: [(0, _a11y.A11Y_SELECTED)()],
    border: {
      width: 2,
      color: '#4b89ff',
      cornerVisible: cellCornerVisible
    },
    ...restOptions,
    selectionType: _src.HIGHLIGHT_FOCUS_TYPE
  });
}

/***/ }),
/* 657 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
/**
 * Creates the new instance of Selection responsible for highlighting currently selected cell.
 * This type of selection can present on the table only one at the time.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @param {object} highlightParams.border Border configuration.
 * @param {object} highlightParams.visualCellRange Function to translate visual to renderable coords.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    border,
    visualCellRange,
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    ...border,
    ...restOptions,
    selectionType: _src.HIGHLIGHT_CUSTOM_SELECTION_TYPE
  }, visualCellRange);
}

/***/ }),
/* 658 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
/**
 * Creates the new instance of Selection, responsible for highlighting cells which are covered by fill handle
 * functionality. This type of selection can present on the table only one at the time.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    className: 'fill',
    border: {
      width: 1,
      color: '#ff0000'
    },
    ...restOptions,
    selectionType: _src.HIGHLIGHT_FILL_TYPE
  });
}

/***/ }),
/* 659 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
/**
 * Creates the new instance of Selection, responsible for highlighting column or row headers when
 * any cell is selected.
 * This type of selection can occur multiple times.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @param {string} highlightParams.headerClassName Highlighted headers' class name.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    headerClassName,
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    className: headerClassName,
    ...restOptions,
    selectionType: _src.HIGHLIGHT_HEADER_TYPE
  });
}

/***/ }),
/* 660 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.createHighlight = createHighlight;
var _src = __webpack_require__(540);
var _visualSelection = _interopRequireDefault(__webpack_require__(652));
/**
 * Creates the new instance of Selection, responsible for highlighting cells in a rows and
 * row headers.
 * This type of selection can occur multiple times.
 *
 * @param {object} highlightParams A configuration object to create a highlight.
 * @param {string} highlightParams.rowClassName Highlighted row' class name.
 * @returns {Selection}
 */
function createHighlight(_ref) {
  let {
    rowClassName,
    ...restOptions
  } = _ref;
  return new _visualSelection.default({
    className: rowClassName,
    ...restOptions,
    selectionType: _src.HIGHLIGHT_ROW_TYPE
  });
}

/***/ }),
/* 661 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
__webpack_require__(311);
__webpack_require__(623);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
/**
 * The SelectionRange class is a simple CellRanges collection designed for easy manipulation of the multiple
 * consecutive and non-consecutive selections.
 *
 * @class SelectionRange
 * @util
 */
class SelectionRange {
  constructor(createCellRange) {
    /**
     * List of all CellRanges added to the class instance.
     *
     * @type {CellRange[]}
     */
    (0, _defineProperty2.default)(this, "ranges", []);
    /**
     * @type {function(CellCoords): CellRange}
     */
    (0, _defineProperty2.default)(this, "createCellRange", void 0);
    this.createCellRange = createCellRange;
  }

  /**
   * Check if selected range is empty.
   *
   * @returns {boolean}
   */
  isEmpty() {
    return this.size() === 0;
  }

  /**
   * Set coordinates to the class instance. It clears all previously added coordinates and push `coords`
   * to the collection.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {SelectionRange}
   */
  set(coords) {
    this.clear();
    this.ranges.push(this.createCellRange(coords));
    return this;
  }

  /**
   * Add coordinates to the class instance. The new coordinates are added to the end of the range collection.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {SelectionRange}
   */
  add(coords) {
    this.ranges.push(this.createCellRange(coords));
    return this;
  }

  /**
   * Removes from the stack the last added coordinates.
   *
   * @returns {SelectionRange}
   */
  pop() {
    this.ranges.pop();
    return this;
  }

  /**
   * Get last added coordinates from ranges, it returns a CellRange instance.
   *
   * @returns {CellRange|undefined}
   */
  current() {
    return this.peekByIndex(this.size() - 1);
  }

  /**
   * Get previously added coordinates from ranges, it returns a CellRange instance.
   *
   * @returns {CellRange|undefined}
   */
  previous() {
    return this.peekByIndex(this.size() - 2);
  }

  /**
   * Returns `true` if coords is within selection coords. This method iterates through all selection layers to check if
   * the coords object is within selection range.
   *
   * @param {CellCoords} coords The CellCoords instance with defined visual coordinates.
   * @returns {boolean}
   */
  includes(coords) {
    return this.ranges.some(cellRange => cellRange.includes(coords));
  }

  /**
   * Clear collection.
   *
   * @returns {SelectionRange}
   */
  clear() {
    this.ranges.length = 0;
    return this;
  }

  /**
   * Get count of added all coordinates added to the selection.
   *
   * @returns {number}
   */
  size() {
    return this.ranges.length;
  }

  /**
   * Peek the coordinates based on the index where that coordinate resides in the collection.
   *
   * @param {number} [index=0] An index where the coordinate will be retrieved from. The index '0' gets the
   * latest range.
   * @returns {CellRange|undefined}
   */
  peekByIndex() {
    let index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let cellRange;
    if (index >= 0 && index < this.size()) {
      cellRange = this.ranges[index];
    }
    return cellRange;
  }
  [Symbol.iterator]() {
    return this.ranges[Symbol.iterator]();
  }
}
var _default = exports["default"] = SelectionRange;

/***/ }),
/* 662 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _object = __webpack_require__(499);
var _localHooks = _interopRequireDefault(__webpack_require__(599));
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * The Transformation class implements algorithms for transforming coordinates based on current settings
 * passed to the Handsontable. The class performs the calculations based on the renderable indexes.
 *
 * Transformation is always applied relative to the current selection.
 *
 * The class operates on a table size defined by the renderable indexes. If the `navigableHeaders`
 * option is enabled, the table size is increased by the number of row and/or column headers.
 * Because the headers are treated as cells as part of the table size (indexes always go from 0 to N),
 * the algorithm can be written as simply as possible (without new if's that distinguish the headers
 * logic).
 *
 * @class Transformation
 * @util
 */
var _range = /*#__PURE__*/new WeakMap();
var _options = /*#__PURE__*/new WeakMap();
var _offset = /*#__PURE__*/new WeakMap();
var _Transformation_brand = /*#__PURE__*/new WeakSet();
class Transformation {
  constructor(range, options) {
    /**
     * Clamps the coords to make sure they points to the cell (or header) in the table range.
     *
     * @param {CellCoords} zeroBasedCoords The coords object to clamp.
     * @returns {{rowDir: 1|0|-1, colDir: 1|0|-1}}
     */
    _classPrivateMethodInitSpec(this, _Transformation_brand);
    /**
     * Instance of the SelectionRange, holder for visual coordinates applied to the table.
     *
     * @type {SelectionRange}
     */
    _classPrivateFieldInitSpec(this, _range, void 0);
    /**
     * Additional options which define the state of the settings which can infer transformation and
     * give the possibility to translate indexes.
     *
     * @type {object}
     */
    _classPrivateFieldInitSpec(this, _options, void 0);
    /**
     * Increases the table size by applying the offsets. The option is used by the `navigableHeaders`
     * option.
     *
     * @type {{ x: number, y: number }}
     */
    _classPrivateFieldInitSpec(this, _offset, {
      x: 0,
      y: 0
    });
    _classPrivateFieldSet(_range, this, range);
    _classPrivateFieldSet(_options, this, options);
  }

  /**
   * Selects cell relative to the current cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   * @param {boolean} [createMissingRecords=false] If `true` the new rows/columns will be created if necessary. Otherwise, row/column will
   *                        be created according to `minSpareRows/minSpareCols` settings of Handsontable.
   * @returns {CellCoords} Visual coordinates after transformation.
   */
  transformStart(rowDelta, colDelta) {
    let createMissingRecords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    const delta = _classPrivateFieldGet(_options, this).createCellCoords(rowDelta, colDelta);
    let visualCoords = _classPrivateFieldGet(_range, this).current().highlight;
    const highlightRenderableCoords = _classPrivateFieldGet(_options, this).visualToRenderableCoords(visualCoords);
    let rowTransformDir = 0;
    let colTransformDir = 0;
    this.runLocalHooks('beforeTransformStart', delta);
    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null) {
      const {
        width,
        height
      } = _assertClassBrand(_Transformation_brand, this, _getTableSize).call(this);
      const {
        row,
        col
      } = _assertClassBrand(_Transformation_brand, this, _visualToZeroBasedCoords).call(this, visualCoords);
      const fixedRowsBottom = _classPrivateFieldGet(_options, this).fixedRowsBottom();
      const minSpareRows = _classPrivateFieldGet(_options, this).minSpareRows();
      const minSpareCols = _classPrivateFieldGet(_options, this).minSpareCols();
      const autoWrapRow = _classPrivateFieldGet(_options, this).autoWrapRow();
      const autoWrapCol = _classPrivateFieldGet(_options, this).autoWrapCol();
      const zeroBasedCoords = _classPrivateFieldGet(_options, this).createCellCoords(row + delta.row, col + delta.col);
      if (zeroBasedCoords.row >= height) {
        const isActionInterrupted = (0, _object.createObjectPropListener)(createMissingRecords && minSpareRows > 0 && fixedRowsBottom === 0);
        const nextColumn = zeroBasedCoords.col + 1;
        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(zeroBasedCoords.row - height, nextColumn >= width ? nextColumn - width : nextColumn);
        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), nextColumn >= width);
        if (isActionInterrupted.value) {
          this.runLocalHooks('insertRowRequire', _classPrivateFieldGet(_options, this).countRenderableRows());
        } else if (autoWrapCol) {
          zeroBasedCoords.assign(newCoords);
        }
      } else if (zeroBasedCoords.row < 0) {
        const isActionInterrupted = (0, _object.createObjectPropListener)(autoWrapCol);
        const previousColumn = zeroBasedCoords.col - 1;
        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(height + zeroBasedCoords.row, previousColumn < 0 ? width + previousColumn : previousColumn);
        this.runLocalHooks('beforeColumnWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), previousColumn < 0);
        if (autoWrapCol) {
          zeroBasedCoords.assign(newCoords);
        }
      }
      if (zeroBasedCoords.col >= width) {
        const isActionInterrupted = (0, _object.createObjectPropListener)(createMissingRecords && minSpareCols > 0);
        const nextRow = zeroBasedCoords.row + 1;
        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(nextRow >= height ? nextRow - height : nextRow, zeroBasedCoords.col - width);
        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), nextRow >= height);
        if (isActionInterrupted.value) {
          this.runLocalHooks('insertColRequire', _classPrivateFieldGet(_options, this).countRenderableColumns());
        } else if (autoWrapRow) {
          zeroBasedCoords.assign(newCoords);
        }
      } else if (zeroBasedCoords.col < 0) {
        const isActionInterrupted = (0, _object.createObjectPropListener)(autoWrapRow);
        const previousRow = zeroBasedCoords.row - 1;
        const newCoords = _classPrivateFieldGet(_options, this).createCellCoords(previousRow < 0 ? height + previousRow : previousRow, width + zeroBasedCoords.col);
        this.runLocalHooks('beforeRowWrap', isActionInterrupted, _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, newCoords), previousRow < 0);
        if (autoWrapRow) {
          zeroBasedCoords.assign(newCoords);
        }
      }
      const {
        rowDir,
        colDir
      } = _assertClassBrand(_Transformation_brand, this, _clampCoords).call(this, zeroBasedCoords);
      rowTransformDir = rowDir;
      colTransformDir = colDir;
      visualCoords = _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, zeroBasedCoords);
    }
    this.runLocalHooks('afterTransformStart', visualCoords, rowTransformDir, colTransformDir);
    return visualCoords;
  }

  /**
   * Sets selection end cell relative to the current selection end cell (if possible).
   *
   * @param {number} rowDelta Rows number to move, value can be passed as negative number.
   * @param {number} colDelta Columns number to move, value can be passed as negative number.
   * @returns {CellCoords} Visual coordinates after transformation.
   */
  transformEnd(rowDelta, colDelta) {
    const delta = _classPrivateFieldGet(_options, this).createCellCoords(rowDelta, colDelta);
    const cellRange = _classPrivateFieldGet(_range, this).current();
    const highlightRenderableCoords = _classPrivateFieldGet(_options, this).visualToRenderableCoords(cellRange.highlight);
    const toRow = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, cellRange.to.row, cellRange.from.row);
    const toColumn = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, cellRange.to.col, cellRange.from.col);
    const visualCoords = cellRange.to.clone();
    let rowTransformDir = 0;
    let colTransformDir = 0;
    this.runLocalHooks('beforeTransformEnd', delta);
    if (highlightRenderableCoords.row !== null && highlightRenderableCoords.col !== null && toRow !== null && toColumn !== null) {
      const {
        row: highlightRow,
        col: highlightColumn
      } = _assertClassBrand(_Transformation_brand, this, _visualToZeroBasedCoords).call(this, cellRange.highlight);
      const coords = _classPrivateFieldGet(_options, this).createCellCoords(toRow + delta.row, toColumn + delta.col);
      const topStartCorner = cellRange.getTopStartCorner();
      const topEndCorner = cellRange.getTopEndCorner();
      const bottomEndCorner = cellRange.getBottomEndCorner();
      if (delta.col < 0 && toColumn >= highlightColumn && coords.col < highlightColumn) {
        const columnRestDelta = coords.col - highlightColumn;
        coords.col = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, topStartCorner.col, topEndCorner.col) + columnRestDelta;
      } else if (delta.col > 0 && toColumn <= highlightColumn && coords.col > highlightColumn) {
        const endColumnIndex = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedColumn).call(this, topEndCorner.col, topStartCorner.col);
        const columnRestDelta = Math.max(coords.col - endColumnIndex, 1);
        coords.col = endColumnIndex + columnRestDelta;
      }
      if (delta.row < 0 && toRow >= highlightRow && coords.row < highlightRow) {
        const rowRestDelta = coords.row - highlightRow;
        coords.row = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, topStartCorner.row, bottomEndCorner.row) + rowRestDelta;
      } else if (delta.row > 0 && toRow <= highlightRow && coords.row > highlightRow) {
        const bottomRowIndex = _assertClassBrand(_Transformation_brand, this, _findFirstNonHiddenZeroBasedRow).call(this, bottomEndCorner.row, topStartCorner.row);
        const rowRestDelta = Math.max(coords.row - bottomRowIndex, 1);
        coords.row = bottomRowIndex + rowRestDelta;
      }
      const {
        rowDir,
        colDir
      } = _assertClassBrand(_Transformation_brand, this, _clampCoords).call(this, coords);
      rowTransformDir = rowDir;
      colTransformDir = colDir;
      const newVisualCoords = _assertClassBrand(_Transformation_brand, this, _zeroBasedToVisualCoords).call(this, coords);
      if (delta.row === 0 && delta.col !== 0) {
        visualCoords.col = newVisualCoords.col;
      } else if (delta.row !== 0 && delta.col === 0) {
        visualCoords.row = newVisualCoords.row;
      } else {
        visualCoords.row = newVisualCoords.row;
        visualCoords.col = newVisualCoords.col;
      }
    }
    this.runLocalHooks('afterTransformEnd', visualCoords, rowTransformDir, colTransformDir);
    return visualCoords;
  }

  /**
   * Sets the additional offset in table size that may occur when the `navigableHeaders` option
   * is enabled.
   *
   * @param {{x: number, y: number}} offset Offset as x and y properties.
   */
  setOffsetSize(_ref) {
    let {
      x,
      y
    } = _ref;
    _classPrivateFieldSet(_offset, this, {
      x,
      y
    });
  }

  /**
   * Resets the offset size to the default values.
   */
  resetOffsetSize() {
    _classPrivateFieldSet(_offset, this, {
      x: 0,
      y: 0
    });
  }
}
function _clampCoords(zeroBasedCoords) {
  const {
    width,
    height
  } = _assertClassBrand(_Transformation_brand, this, _getTableSize).call(this);
  let rowDir = 0;
  let colDir = 0;
  if (zeroBasedCoords.row < 0) {
    rowDir = -1;
    zeroBasedCoords.row = 0;
  } else if (zeroBasedCoords.row > 0 && zeroBasedCoords.row >= height) {
    rowDir = 1;
    zeroBasedCoords.row = height - 1;
  }
  if (zeroBasedCoords.col < 0) {
    colDir = -1;
    zeroBasedCoords.col = 0;
  } else if (zeroBasedCoords.col > 0 && zeroBasedCoords.col >= width) {
    colDir = 1;
    zeroBasedCoords.col = width - 1;
  }
  return {
    rowDir,
    colDir
  };
}
/**
 * Gets the table size in number of rows with headers as "height" and number of columns with
 * headers as "width".
 *
 * @returns {{width: number, height: number}}
 */
function _getTableSize() {
  return {
    width: _classPrivateFieldGet(_offset, this).x + _classPrivateFieldGet(_options, this).countRenderableColumns(),
    height: _classPrivateFieldGet(_offset, this).y + _classPrivateFieldGet(_options, this).countRenderableRows()
  };
}
/**
 * Finds the first non-hidden zero-based row in the table range.
 *
 * @param {number} visualRowFrom The visual row from which the search should start.
 * @param {number} visualRowTo The visual row to which the search should end.
 * @returns {number | null}
 */
function _findFirstNonHiddenZeroBasedRow(visualRowFrom, visualRowTo) {
  const row = _classPrivateFieldGet(_options, this).findFirstNonHiddenRenderableRow(visualRowFrom, visualRowTo);
  if (row === null) {
    return null;
  }
  return _classPrivateFieldGet(_offset, this).y + row;
}
/**
 * Finds the first non-hidden zero-based column in the table range.
 *
 * @param {number} visualColumnFrom The visual column from which the search should start.
 * @param {number} visualColumnTo The visual column to which the search should end.
 * @returns {number | null}
 */
function _findFirstNonHiddenZeroBasedColumn(visualColumnFrom, visualColumnTo) {
  const column = _classPrivateFieldGet(_options, this).findFirstNonHiddenRenderableColumn(visualColumnFrom, visualColumnTo);
  if (column === null) {
    return null;
  }
  return _classPrivateFieldGet(_offset, this).x + column;
}
/**
 * Translates the visual coordinates to zero-based ones.
 *
 * @param {CellCoords} visualCoords The visual coords to process.
 * @returns {CellCoords}
 */
function _visualToZeroBasedCoords(visualCoords) {
  const {
    row,
    col
  } = _classPrivateFieldGet(_options, this).visualToRenderableCoords(visualCoords);
  if (row === null || col === null) {
    throw new Error('Renderable coords are not visible.');
  }
  return _classPrivateFieldGet(_options, this).createCellCoords(_classPrivateFieldGet(_offset, this).y + row, _classPrivateFieldGet(_offset, this).x + col);
}
/**
 * Translates the zero-based coordinates to visual ones.
 *
 * @param {CellCoords} zeroBasedCoords The coordinates to process.
 * @returns {CellCoords}
 */
function _zeroBasedToVisualCoords(zeroBasedCoords) {
  const coords = zeroBasedCoords.clone();
  coords.col = zeroBasedCoords.col - _classPrivateFieldGet(_offset, this).x;
  coords.row = zeroBasedCoords.row - _classPrivateFieldGet(_offset, this).y;
  return _classPrivateFieldGet(_options, this).renderableToVisualCoords(coords);
}
(0, _object.mixin)(Transformation, _localHooks.default);
var _default = exports["default"] = Transformation;

/***/ }),
/* 663 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.detectSelectionType = detectSelectionType;
exports.normalizeSelectionFactory = normalizeSelectionFactory;
exports.transformSelectionToColumnDistance = transformSelectionToColumnDistance;
exports.transformSelectionToRowDistance = transformSelectionToRowDistance;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(623);
var _src = __webpack_require__(540);
var _array = __webpack_require__(495);
var _mixed = __webpack_require__(354);
const SELECTION_TYPE_UNRECOGNIZED = exports.SELECTION_TYPE_UNRECOGNIZED = 0;
const SELECTION_TYPE_EMPTY = exports.SELECTION_TYPE_EMPTY = 1;
const SELECTION_TYPE_ARRAY = exports.SELECTION_TYPE_ARRAY = 2;
const SELECTION_TYPE_OBJECT = exports.SELECTION_TYPE_OBJECT = 3;
const SELECTION_TYPES = exports.SELECTION_TYPES = [SELECTION_TYPE_OBJECT, SELECTION_TYPE_ARRAY];
const ARRAY_TYPE_PATTERN = [['number'], ['number', 'string'], ['number', 'undefined'], ['number', 'string', 'undefined']];
const rootCall = Symbol('root');
const childCall = Symbol('child');

/**
 * Detect selection schema structure.
 *
 * @param {*} selectionRanges The selected range or and array of selected ranges. This type of data is produced by
 * `hot.getSelected()`, `hot.getSelectedLast()`, `hot.getSelectedRange()`
 * and `hot.getSelectedRangeLast()` methods.
 * @param {symbol} _callSymbol The symbol object which indicates source of the helper invocation.
 * @returns {number} Returns a number that specifies the type of detected selection schema. If selection schema type
 * is unrecognized than it returns `0`.
 */
function detectSelectionType(selectionRanges) {
  let _callSymbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rootCall;
  if (_callSymbol !== rootCall && _callSymbol !== childCall) {
    throw new Error('The second argument is used internally only and cannot be overwritten.');
  }
  const isArray = Array.isArray(selectionRanges);
  const isRootCall = _callSymbol === rootCall;
  let result = SELECTION_TYPE_UNRECOGNIZED;
  if (isArray) {
    const firstItem = selectionRanges[0];
    if (selectionRanges.length === 0) {
      result = SELECTION_TYPE_EMPTY;
    } else if (isRootCall && firstItem instanceof _src.CellRange) {
      result = SELECTION_TYPE_OBJECT;
    } else if (isRootCall && Array.isArray(firstItem)) {
      result = detectSelectionType(firstItem, childCall);
    } else if (selectionRanges.length >= 2 && selectionRanges.length <= 4) {
      const isArrayType = !selectionRanges.some((value, index) => !ARRAY_TYPE_PATTERN[index].includes(typeof value));
      if (isArrayType) {
        result = SELECTION_TYPE_ARRAY;
      }
    }
  }
  return result;
}

/**
 * Factory function designed for normalization data schema from different data structures of the selection ranges.
 *
 * @param {number} type Selection type which will be processed.
 * @param {object} options The normalization options.
 * @param {function(number, number): CellCoords} options.createCellCoords The factory function that returns an instance of the `CellCoords` class.
 * @param {function(CellCoords, CellCoords, CellCoords): CellRange} options.createCellRange The factory function that returns an instance of the `CellRange` class.
 * @param {boolean} [options.keepDirection=false] If `true`, the coordinates which contain the direction of the
 *                                                selected cells won't be changed. Otherwise, the selection will be
 *                                                normalized to values starting from top-left to bottom-right.
 * @param {Function} [options.propToCol] Pass the converting function (usually `datamap.propToCol`) if the column
 *                                       defined as props should be normalized to the numeric values.
 * @returns {number[]} Returns normalized data about selected range as an array (`[rowStart, columnStart, rowEnd, columnEnd]`).
 */
function normalizeSelectionFactory(type) {
  let {
    createCellCoords,
    createCellRange,
    keepDirection = false,
    propToCol
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!SELECTION_TYPES.includes(type)) {
    throw new Error('Unsupported selection ranges schema type was provided.');
  }
  return function (selection) {
    const isObjectType = type === SELECTION_TYPE_OBJECT;
    let rowStart = isObjectType ? selection.from.row : selection[0];
    let columnStart = isObjectType ? selection.from.col : selection[1];
    let rowEnd = isObjectType ? selection.to.row : selection[2];
    let columnEnd = isObjectType ? selection.to.col : selection[3];
    if (typeof propToCol === 'function') {
      if (typeof columnStart === 'string') {
        columnStart = propToCol(columnStart);
      }
      if (typeof columnEnd === 'string') {
        columnEnd = propToCol(columnEnd);
      }
    }
    if ((0, _mixed.isUndefined)(rowEnd)) {
      rowEnd = rowStart;
    }
    if ((0, _mixed.isUndefined)(columnEnd)) {
      columnEnd = columnStart;
    }
    if (!keepDirection) {
      const origRowStart = rowStart;
      const origColumnStart = columnStart;
      const origRowEnd = rowEnd;
      const origColumnEnd = columnEnd;
      rowStart = Math.min(origRowStart, origRowEnd);
      columnStart = Math.min(origColumnStart, origColumnEnd);
      rowEnd = Math.max(origRowStart, origRowEnd);
      columnEnd = Math.max(origColumnStart, origColumnEnd);
    }
    const from = createCellCoords(rowStart, columnStart);
    const to = createCellCoords(rowEnd, columnEnd);
    return createCellRange(from, from, to);
  };
}

/**
 * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized
 * data structure. It merges repeated ranges into consecutive coordinates. The returned structure
 * contains an array of arrays. The single item contains at index 0 visual column index from the selection was
 * started and at index 1 distance as a count of selected columns.
 *
 * @param {Core} hotInstance The Handsontable instance.
 * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:
 *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.
 *                   The column distances are always created starting from the left (zero index) to the
 *                   right (the latest column index).
 */
function transformSelectionToColumnDistance(hotInstance) {
  const selectionType = detectSelectionType(hotInstance.getSelected());
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {
    createCellCoords: hotInstance._createCellCoords.bind(hotInstance),
    createCellRange: hotInstance._createCellRange.bind(hotInstance)
  });
  const unorderedIndexes = new Set();

  // Iterate through all ranges and collect all column indexes which are not saved yet.
  (0, _array.arrayEach)(hotInstance.getSelected(), selection => {
    const {
      from,
      to
    } = selectionSchemaNormalizer(selection);
    const columnNonHeaderStart = Math.max(from.col, 0);
    const amount = to.col - columnNonHeaderStart + 1;
    (0, _array.arrayEach)(Array.from(new Array(amount), (_, i) => columnNonHeaderStart + i), index => {
      if (!unorderedIndexes.has(index)) {
        unorderedIndexes.add(index);
      }
    });
  });

  // Sort indexes in ascending order to easily detecting non-consecutive columns.
  const orderedIndexes = Array.from(unorderedIndexes).sort((a, b) => a - b);
  const normalizedColumnRanges = (0, _array.arrayReduce)(orderedIndexes, (acc, visualColumnIndex, index, array) => {
    if (index !== 0 && visualColumnIndex === array[index - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([visualColumnIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedColumnRanges;
}

/**
 * Function transform selection ranges (produced by `hot.getSelected()` and `hot.getSelectedRange()`) to normalized
 * data structure. It merges repeated ranges into consecutive coordinates. The returned structure
 * contains an array of arrays. The single item contains at index 0 visual column index from the selection was
 * started and at index 1 distance as a count of selected columns.
 *
 * @param {Core} hotInstance The Handsontable instance.
 * @returns {Array[]} Returns an array of arrays with ranges defines in that schema:
 *                   `[[visualColumnStart, distance], [visualColumnStart, distance], ...]`.
 *                   The column distances are always created starting from the left (zero index) to the
 *                   right (the latest column index).
 */
function transformSelectionToRowDistance(hotInstance) {
  const selectionType = detectSelectionType(hotInstance.getSelected());
  if (selectionType === SELECTION_TYPE_UNRECOGNIZED || selectionType === SELECTION_TYPE_EMPTY) {
    return [];
  }
  const selectionSchemaNormalizer = normalizeSelectionFactory(selectionType, {
    createCellCoords: hotInstance._createCellCoords.bind(hotInstance),
    createCellRange: hotInstance._createCellRange.bind(hotInstance)
  });
  const unorderedIndexes = new Set();

  // Iterate through all ranges and collect all column indexes which are not saved yet.
  (0, _array.arrayEach)(hotInstance.getSelected(), selection => {
    const {
      from,
      to
    } = selectionSchemaNormalizer(selection);
    const rowNonHeaderStart = Math.max(from.row, 0);
    const amount = to.row - rowNonHeaderStart + 1;
    (0, _array.arrayEach)(Array.from(new Array(amount), (_, i) => rowNonHeaderStart + i), index => {
      if (!unorderedIndexes.has(index)) {
        unorderedIndexes.add(index);
      }
    });
  });

  // Sort indexes in ascending order to easily detecting non-consecutive columns.
  const orderedIndexes = Array.from(unorderedIndexes).sort((a, b) => a - b);
  const normalizedRowRanges = (0, _array.arrayReduce)(orderedIndexes, (acc, rowIndex, index, array) => {
    if (index !== 0 && rowIndex === array[index - 1] + 1) {
      acc[acc.length - 1][1] += 1;
    } else {
      acc.push([rowIndex, 1]);
    }
    return acc;
  }, []);
  return normalizedRowRanges;
}

/***/ }),
/* 664 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _dataMap = _interopRequireDefault(__webpack_require__(665));
exports.DataMap = _dataMap.default;
var _metaManager = _interopRequireDefault(__webpack_require__(668));
exports.MetaManager = _metaManager.default;
var _metaSchema = _interopRequireDefault(__webpack_require__(672));
exports.metaSchemaFactory = _metaSchema.default;
var _replaceData = __webpack_require__(677);
exports.replaceData = _replaceData.replaceData;
var _dynamicCellMeta = __webpack_require__(678);
exports.DynamicCellMetaMod = _dynamicCellMeta.DynamicCellMetaMod;
var _extendMetaProperties = __webpack_require__(679);
exports.ExtendMetaPropertiesMod = _extendMetaProperties.ExtendMetaPropertiesMod;

/***/ }),
/* 665 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(311);
__webpack_require__(323);
__webpack_require__(329);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _SheetClip = __webpack_require__(666);
var _data = __webpack_require__(618);
var _object = __webpack_require__(499);
var _array = __webpack_require__(495);
var _number = __webpack_require__(534);
var _mixed = __webpack_require__(354);
/*
This class contains open-source contributions covered by the MIT license.

1) In the `createRow` method: Row creation using functional `dataSchema` value
2) In the `set` method: Data setting using functional `prop` value
3) in the `get` method: Data getting using functional `prop` value

The remaining part of this code comment contains the full license text of these contributions.

======

The MIT License

Copyright 2013 Nicholas Bollweg

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names.
 *
 * @todo Refactor arguments of methods getRange, getText to be numbers (not objects).
 * @todo Remove priv, GridSettings from object constructor.
 *
 * @class DataMap
 * @private
 */
class DataMap {
  /**
   * @type {number}
   */
  static get DESTINATION_RENDERER() {
    return 1;
  }

  /**
   * @type {number}
   */
  static get DESTINATION_CLIPBOARD_GENERATOR() {
    return 2;
  }

  /**
   * Instance of {@link Handsontable}.
   *
   * @private
   * @type {Handsontable}
   */

  /**
   * @param {object} hotInstance Instance of Handsontable.
   * @param {Array} data Array of arrays or array of objects containing data.
   * @param {MetaManager} metaManager The meta manager instance.
   */
  constructor(hotInstance, data, metaManager) {
    (0, _defineProperty2.default)(this, "hot", void 0);
    /**
     * Instance of {@link MetaManager}.
     *
     * @private
     * @type {MetaManager}
     */
    (0, _defineProperty2.default)(this, "metaManager", void 0);
    /**
     * Instance of {@link TableMeta}.
     *
     * @private
     * @type {TableMeta}
     */
    (0, _defineProperty2.default)(this, "tableMeta", void 0);
    /**
     * Reference to the original dataset.
     *
     * @type {*}
     */
    (0, _defineProperty2.default)(this, "dataSource", void 0);
    /**
     * Generated schema based on the first row from the source data.
     *
     * @type {object}
     */
    (0, _defineProperty2.default)(this, "duckSchema", void 0);
    /**
     * Cached array of properties to columns.
     *
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "colToPropCache", void 0);
    /**
     * Cached map of properties to columns.
     *
     * @type {Map}
     */
    (0, _defineProperty2.default)(this, "propToColCache", void 0);
    this.hot = hotInstance;
    this.metaManager = metaManager;
    this.tableMeta = metaManager.getTableMeta();
    this.dataSource = data;
    this.duckSchema = this.createDuckSchema();
    this.createMap();
  }

  /**
   * Generates cache for property to and from column addressation.
   */
  createMap() {
    const schema = this.getSchema();
    if (typeof schema === 'undefined') {
      throw new Error('trying to create `columns` definition but you didn\'t provide `schema` nor `data`');
    }
    const columns = this.tableMeta.columns;
    let i;
    this.colToPropCache = [];
    this.propToColCache = new Map();
    if (columns) {
      let columnsLen = 0;
      let filteredIndex = 0;
      let columnsAsFunc = false;
      if (typeof columns === 'function') {
        const schemaLen = (0, _object.deepObjectSize)(schema);
        columnsLen = schemaLen > 0 ? schemaLen : this.countFirstRowKeys();
        columnsAsFunc = true;
      } else {
        const maxCols = this.tableMeta.maxCols;
        columnsLen = Math.min(maxCols, columns.length);
      }
      for (i = 0; i < columnsLen; i++) {
        const column = columnsAsFunc ? columns(i) : columns[i];
        if ((0, _object.isObject)(column)) {
          if (typeof column.data !== 'undefined') {
            const index = columnsAsFunc ? filteredIndex : i;
            this.colToPropCache[index] = column.data;
            this.propToColCache.set(column.data, index);
          }
          filteredIndex += 1;
        }
      }
    } else {
      this.recursiveDuckColumns(schema);
    }
  }

  /**
   * Get the amount of physical columns in the first data row.
   *
   * @returns {number} Amount of physical columns in the first data row.
   */
  countFirstRowKeys() {
    return (0, _data.countFirstRowKeys)(this.dataSource);
  }

  /**
   * Generates columns' translation cache.
   *
   * @param {object} schema An object to generate schema from.
   * @param {number} lastCol The column index.
   * @param {number} parent The property cache for recursive calls.
   * @returns {number}
   */
  recursiveDuckColumns(schema, lastCol, parent) {
    let lastColumn = lastCol;
    let propertyParent = parent;
    let prop;
    if (typeof lastColumn === 'undefined') {
      lastColumn = 0;
      propertyParent = '';
    }
    if (typeof schema === 'object' && !Array.isArray(schema)) {
      (0, _object.objectEach)(schema, (value, key) => {
        if (value === null) {
          prop = propertyParent + key;
          this.colToPropCache.push(prop);
          this.propToColCache.set(prop, lastColumn);
          lastColumn += 1;
        } else {
          lastColumn = this.recursiveDuckColumns(value, lastColumn, `${key}.`);
        }
      });
    }
    return lastColumn;
  }

  /**
   * Returns property name that corresponds with the given column index.
   *
   * @param {string|number} column Visual column index or another passed argument.
   * @returns {string|number} Column property, physical column index or passed argument.
   */
  colToProp(column) {
    // TODO: Should it work? Please, look at the test:
    // "it should return the provided property name, when the user passes a property name as a column number".
    if (Number.isInteger(column) === false) {
      return column;
    }
    const physicalColumn = this.hot.toPhysicalColumn(column);

    // Out of range, not visible column index.
    if (physicalColumn === null) {
      return column;
    }

    // Cached property.
    if (this.colToPropCache && (0, _mixed.isDefined)(this.colToPropCache[physicalColumn])) {
      return this.colToPropCache[physicalColumn];
    }
    return physicalColumn;
  }

  /**
   * Translates property into visual column index.
   *
   * @param {string|number} prop Column property which may be also a physical column index.
   * @returns {string|number} Visual column index or passed argument.
   */
  propToCol(prop) {
    const cachedPhysicalIndex = this.propToColCache.get(prop);
    if ((0, _mixed.isDefined)(cachedPhysicalIndex)) {
      return this.hot.toVisualColumn(cachedPhysicalIndex);
    }

    // Property may be a physical column index.
    const visualColumn = this.hot.toVisualColumn(prop);
    if (visualColumn === null) {
      return prop;
    }
    return visualColumn;
  }

  /**
   * Returns data's schema.
   *
   * @returns {object}
   */
  getSchema() {
    const schema = this.tableMeta.dataSchema;
    if (schema) {
      if (typeof schema === 'function') {
        return schema();
      }
      return schema;
    }
    return this.duckSchema;
  }

  /**
   * Creates the duck schema based on the current dataset.
   *
   * @returns {Array|object}
   */
  createDuckSchema() {
    return this.dataSource && this.dataSource[0] ? (0, _object.duckSchema)(this.dataSource[0]) : {};
  }

  /**
   * Refresh the data schema.
   */
  refreshDuckSchema() {
    this.duckSchema = this.createDuckSchema();
  }

  /**
   * Creates row at the bottom of the data array.
   *
   * @param {number} [index] Physical index of the row before which the new row will be inserted.
   * @param {number} [amount=1] An amount of rows to add.
   * @param {object} [options] Additional options for created rows.
   * @param {string} [options.source] Source of method call.
   * @param {'above'|'below'} [options.mode] Sets where the row is inserted: above or below the passed index.
   * @fires Hooks#afterCreateRow
   * @returns {number} Returns number of created rows.
   */
  createRow(index) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let {
      source,
      mode = 'above'
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const sourceRowsCount = this.hot.countSourceRows();
    let physicalRowIndex = sourceRowsCount;
    let numberOfCreatedRows = 0;
    let rowIndex = index;
    if (typeof rowIndex !== 'number' || rowIndex >= sourceRowsCount) {
      rowIndex = sourceRowsCount;
    }
    if (rowIndex < this.hot.countRows()) {
      physicalRowIndex = this.hot.toPhysicalRow(rowIndex);
    }
    const continueProcess = this.hot.runHooks('beforeCreateRow', rowIndex, amount, source);
    if (continueProcess === false || physicalRowIndex === null) {
      return {
        delta: 0
      };
    }
    const maxRows = this.tableMeta.maxRows;
    const columnCount = this.getSchema().length;
    const rowsToAdd = [];
    while (numberOfCreatedRows < amount && sourceRowsCount + numberOfCreatedRows < maxRows) {
      let row = null;
      if (this.hot.dataType === 'array') {
        if (this.tableMeta.dataSchema) {
          // Clone template array
          row = (0, _object.deepClone)(this.getSchema());
        } else {
          row = [];
          /* eslint-disable no-loop-func */
          (0, _number.rangeEach)(columnCount - 1, () => row.push(null));
        }
      } else if (this.hot.dataType === 'function') {
        row = this.tableMeta.dataSchema(rowIndex + numberOfCreatedRows);
      } else {
        row = {};
        (0, _object.deepExtend)(row, this.getSchema());
      }
      rowsToAdd.push(row);
      numberOfCreatedRows += 1;
    }
    this.hot.rowIndexMapper.insertIndexes(rowIndex, numberOfCreatedRows);
    if (mode === 'below') {
      physicalRowIndex = Math.min(physicalRowIndex + 1, sourceRowsCount);
    }
    this.spliceData(physicalRowIndex, 0, rowsToAdd);
    const newVisualRowIndex = this.hot.toVisualRow(physicalRowIndex);

    // In case the created rows are the only ones in the table, the column index mappers need to be rebuilt based on
    // the number of columns created in the row or the schema.
    if (this.hot.countSourceRows() === rowsToAdd.length) {
      this.hot.columnIndexMapper.initToLength(this.hot.getInitialColumnCount());
    }
    if (numberOfCreatedRows > 0) {
      if (index === undefined || index === null) {
        // Creates the meta rows at the end of the rows collection without shifting the cells
        // that were defined out of the range of the dataset.
        this.metaManager.createRow(null, numberOfCreatedRows);
      } else if (source !== 'auto') {
        this.metaManager.createRow(physicalRowIndex, amount);
      }
    }
    this.hot.runHooks('afterCreateRow', newVisualRowIndex, numberOfCreatedRows, source);
    this.hot.forceFullRender = true; // used when data was changed

    return {
      delta: numberOfCreatedRows,
      startPhysicalIndex: physicalRowIndex
    };
  }

  /**
   * Creates column at the right of the data array.
   *
   * @param {number} [index] Visual index of the column before which the new column will be inserted.
   * @param {number} [amount=1] An amount of columns to add.
   * @param {object} [options] Additional options for created columns.
   * @param {string} [options.source] Source of method call.
   * @param {'start'|'end'} [options.mode] Sets where the column is inserted: at the start (left in [LTR](@/api/options.md#layoutdirection), right in [RTL](@/api/options.md#layoutdirection)) or at the end (right in LTR, left in LTR)
   * the passed index.
   * @fires Hooks#afterCreateCol
   * @returns {number} Returns number of created columns.
   */
  createCol(index) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let {
      source,
      mode = 'start'
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (!this.hot.isColumnModificationAllowed()) {
      throw new Error('Cannot create new column. When data source in an object, ' + 'you can only have as much columns as defined in first data row, data schema or in the \'columns\' setting.' + 'If you want to be able to add new columns, you have to use array datasource.');
    }
    const dataSource = this.dataSource;
    const maxCols = this.tableMeta.maxCols;
    const countSourceCols = this.hot.countSourceCols();
    let columnIndex = index;
    if (typeof columnIndex !== 'number' || columnIndex >= countSourceCols) {
      columnIndex = countSourceCols;
    }
    const continueProcess = this.hot.runHooks('beforeCreateCol', columnIndex, amount, source);
    if (continueProcess === false) {
      return {
        delta: 0
      };
    }
    let physicalColumnIndex = countSourceCols;
    if (columnIndex < this.hot.countCols()) {
      physicalColumnIndex = this.hot.toPhysicalColumn(columnIndex);
    }
    const numberOfSourceRows = this.hot.countSourceRows();
    let nrOfColumns = this.hot.countCols();
    let numberOfCreatedCols = 0;
    let currentIndex = physicalColumnIndex;
    if (mode === 'end') {
      currentIndex = Math.min(currentIndex + 1, countSourceCols);
    }
    const startPhysicalIndex = currentIndex;
    while (numberOfCreatedCols < amount && nrOfColumns < maxCols) {
      if (typeof columnIndex !== 'number' || columnIndex >= nrOfColumns) {
        if (numberOfSourceRows > 0) {
          for (let row = 0; row < numberOfSourceRows; row += 1) {
            if (typeof dataSource[row] === 'undefined') {
              dataSource[row] = [];
            }
            dataSource[row].push(null);
          }
        } else {
          dataSource.push([null]);
        }
      } else {
        for (let row = 0; row < numberOfSourceRows; row++) {
          dataSource[row].splice(currentIndex, 0, null);
        }
      }
      numberOfCreatedCols += 1;
      currentIndex += 1;
      nrOfColumns += 1;
    }
    this.hot.columnIndexMapper.insertIndexes(columnIndex, numberOfCreatedCols);
    if (numberOfCreatedCols > 0) {
      if (index === undefined || index === null) {
        // Creates the meta columns at the end of the columns collection without shifting the cells
        // that were defined out of the range of the dataset.
        this.metaManager.createColumn(null, numberOfCreatedCols);
      } else if (source !== 'auto') {
        this.metaManager.createColumn(startPhysicalIndex, amount);
      }
    }
    const newVisualColumnIndex = this.hot.toVisualColumn(startPhysicalIndex);
    this.hot.runHooks('afterCreateCol', newVisualColumnIndex, numberOfCreatedCols, source);
    this.hot.forceFullRender = true; // used when data was changed

    this.refreshDuckSchema();
    return {
      delta: numberOfCreatedCols,
      startPhysicalIndex
    };
  }

  /**
   * Removes row from the data array.
   *
   * @fires Hooks#beforeRemoveRow
   * @fires Hooks#afterRemoveRow
   * @param {number} [index] Visual index of the row to be removed. If not provided, the last row will be removed.
   * @param {number} [amount=1] Amount of the rows to be removed. If not provided, one row will be removed.
   * @param {string} [source] Source of method call.
   * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.
   */
  removeRow(index) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let source = arguments.length > 2 ? arguments[2] : undefined;
    let rowIndex = Number.isInteger(index) ? index : -amount; // -amount = taking indexes from the end.
    const removedPhysicalIndexes = this.visualRowsToPhysical(rowIndex, amount);
    const sourceRowsLength = this.hot.countSourceRows();
    rowIndex = (sourceRowsLength + rowIndex) % sourceRowsLength;

    // It handle also callback from the `NestedRows` plugin. Removing parent node has effect in removing children nodes.
    const actionWasNotCancelled = this.hot.runHooks('beforeRemoveRow', rowIndex, removedPhysicalIndexes.length, removedPhysicalIndexes, source);
    if (actionWasNotCancelled === false) {
      return false;
    }

    // List of removed indexes might be changed in the `beforeRemoveRow` hook. There may be new values.
    const numberOfRemovedIndexes = removedPhysicalIndexes.length;
    this.filterData(rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes);

    // TODO: Function `removeRow` should validate fully, probably above.
    if (rowIndex < this.hot.countRows()) {
      this.hot.rowIndexMapper.removeIndexes(removedPhysicalIndexes);
      const customDefinedColumns = (0, _mixed.isDefined)(this.tableMeta.columns) || (0, _mixed.isDefined)(this.tableMeta.dataSchema);

      // All rows have been removed. There shouldn't be any columns.
      if (this.hot.rowIndexMapper.getNotTrimmedIndexesLength() === 0 && customDefinedColumns === false) {
        this.hot.columnIndexMapper.setIndexesSequence([]);
      }
    }
    const descendingPhysicalRows = removedPhysicalIndexes.slice(0).sort((a, b) => b - a);
    descendingPhysicalRows.forEach(rowPhysicalIndex => {
      this.metaManager.removeRow(rowPhysicalIndex, 1);
    });
    this.hot.runHooks('afterRemoveRow', rowIndex, numberOfRemovedIndexes, removedPhysicalIndexes, source);
    this.hot.forceFullRender = true; // used when data was changed

    return true;
  }

  /**
   * Removes column from the data array.
   *
   * @fires Hooks#beforeRemoveCol
   * @fires Hooks#afterRemoveCol
   * @param {number} [index] Visual index of the column to be removed. If not provided, the last column will be removed.
   * @param {number} [amount=1] Amount of the columns to be removed. If not provided, one column will be removed.
   * @param {string} [source] Source of method call.
   * @returns {boolean} Returns `false` when action was cancelled, otherwise `true`.
   */
  removeCol(index) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    let source = arguments.length > 2 ? arguments[2] : undefined;
    if (this.hot.dataType === 'object' || this.tableMeta.columns) {
      throw new Error('cannot remove column with object data source or columns option specified');
    }
    let columnIndex = typeof index !== 'number' ? -amount : index;
    columnIndex = (this.hot.countCols() + columnIndex) % this.hot.countCols();
    const removedPhysicalIndexes = this.visualColumnsToPhysical(columnIndex, amount);
    const descendingPhysicalColumns = removedPhysicalIndexes.slice(0).sort((a, b) => b - a);
    const actionWasNotCancelled = this.hot.runHooks('beforeRemoveCol', columnIndex, amount, removedPhysicalIndexes, source);
    if (actionWasNotCancelled === false) {
      return false;
    }
    let isTableUniform = true;
    const removedColumnsCount = descendingPhysicalColumns.length;
    const data = this.dataSource;
    for (let c = 0; c < removedColumnsCount; c++) {
      if (isTableUniform && removedPhysicalIndexes[0] !== removedPhysicalIndexes[c] - c) {
        isTableUniform = false;
      }
    }
    if (isTableUniform) {
      for (let r = 0, rlen = this.hot.countSourceRows(); r < rlen; r++) {
        data[r].splice(removedPhysicalIndexes[0], amount);
        if (r === 0) {
          this.metaManager.removeColumn(removedPhysicalIndexes[0], amount);
        }
      }
    } else {
      for (let r = 0, rlen = this.hot.countSourceRows(); r < rlen; r++) {
        for (let c = 0; c < removedColumnsCount; c++) {
          data[r].splice(descendingPhysicalColumns[c], 1);
          if (r === 0) {
            this.metaManager.removeColumn(descendingPhysicalColumns[c], 1);
          }
        }
      }
    }

    // TODO: Function `removeCol` should validate fully, probably above.
    if (columnIndex < this.hot.countCols()) {
      this.hot.columnIndexMapper.removeIndexes(removedPhysicalIndexes);

      // All columns have been removed. There shouldn't be any rows.
      if (this.hot.columnIndexMapper.getNotTrimmedIndexesLength() === 0) {
        this.hot.rowIndexMapper.setIndexesSequence([]);
      }
    }
    this.hot.runHooks('afterRemoveCol', columnIndex, amount, removedPhysicalIndexes, source);
    this.hot.forceFullRender = true; // used when data was changed
    this.refreshDuckSchema();
    return true;
  }

  /**
   * Add/Removes data from the column.
   *
   * @param {number} col Physical index of column in which do you want to do splice.
   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.
   * @param {Array} [elements] The new columns to add.
   * @returns {Array} Returns removed portion of columns.
   */
  spliceCol(col, index, amount) {
    const colData = this.hot.getDataAtCol(col);
    const removed = colData.slice(index, index + amount);
    const after = colData.slice(index + amount);
    for (var _len = arguments.length, elements = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      elements[_key - 3] = arguments[_key];
    }
    (0, _array.extendArray)(elements, after);
    let i = 0;
    while (i < amount) {
      elements.push(null); // add null in place of removed elements
      i += 1;
    }
    (0, _array.to2dArray)(elements);
    this.hot.populateFromArray(index, col, elements, null, null, 'spliceCol');
    return removed;
  }

  /**
   * Add/Removes data from the row.
   *
   * @param {number} row Physical index of row in which do you want to do splice.
   * @param {number} index Index at which to start changing the array. If negative, will begin that many elements from the end.
   * @param {number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed.
   * @param {Array} [elements] The new rows to add.
   * @returns {Array} Returns removed portion of rows.
   */
  spliceRow(row, index, amount) {
    const rowData = this.hot.getSourceDataAtRow(row);
    const removed = rowData.slice(index, index + amount);
    const after = rowData.slice(index + amount);
    for (var _len2 = arguments.length, elements = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      elements[_key2 - 3] = arguments[_key2];
    }
    (0, _array.extendArray)(elements, after);
    let i = 0;
    while (i < amount) {
      elements.push(null); // add null in place of removed elements
      i += 1;
    }
    this.hot.populateFromArray(row, index, [elements], null, null, 'spliceRow');
    return removed;
  }

  /**
   * Add/remove row(s) to/from the data source.
   *
   * @param {number} index Physical index of the element to add/remove.
   * @param {number} deleteCount Number of rows to remove.
   * @param {Array<object>} elements Row elements to be added.
   */
  spliceData(index, deleteCount, elements) {
    const continueSplicing = this.hot.runHooks('beforeDataSplice', index, deleteCount, elements);
    if (continueSplicing !== false) {
      const newData = [...this.dataSource.slice(0, index), ...elements, ...this.dataSource.slice(index)];

      // We try not to change the reference.
      this.dataSource.length = 0;

      // Pushing to array instead of using `splice`, because Babel changes the code to one that uses the `apply` method.
      // The used method was cause of the problem described within #7840.
      newData.forEach(row => this.dataSource.push(row));
    }
  }

  /**
   * Filter unwanted data elements from the data source.
   *
   * @param {number} index Visual index of the element to remove.
   * @param {number} amount Number of rows to add/remove.
   * @param {number} physicalRows Physical row indexes.
   */
  filterData(index, amount, physicalRows) {
    // Custom data filtering (run as a consequence of calling the below hook) provide an array containing new data.
    let data = this.hot.runHooks('filterData', index, amount, physicalRows);

    // Hooks by default returns first argument (when there is no callback changing execution result).
    if (Array.isArray(data) === false) {
      data = this.dataSource.filter((row, rowIndex) => physicalRows.indexOf(rowIndex) === -1);
    }
    this.dataSource.length = 0;
    Array.prototype.push.apply(this.dataSource, data);
  }

  /**
   * Returns single value from the data array.
   *
   * @param {number} row Visual row index.
   * @param {number} prop The column property.
   * @returns {*}
   */
  get(row, prop) {
    const physicalRow = this.hot.toPhysicalRow(row);
    let dataRow = this.dataSource[physicalRow];
    // TODO: To remove, use 'modifyData' hook instead (see below)
    const modifiedRowData = this.hot.runHooks('modifyRowData', physicalRow);
    dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
    //

    const {
      dataDotNotation
    } = this.hot.getSettings();
    let value = null;

    // try to get value under property `prop` (includes dot)
    if (dataRow && dataRow.hasOwnProperty && (0, _object.hasOwnProperty)(dataRow, prop)) {
      value = dataRow[prop];
    } else if (dataDotNotation && typeof prop === 'string' && prop.indexOf('.') > -1) {
      let out = dataRow;
      if (!out) {
        return null;
      }
      const sliced = prop.split('.');
      for (let i = 0, ilen = sliced.length; i < ilen; i++) {
        out = out[sliced[i]];
        if (typeof out === 'undefined') {
          return null;
        }
      }
      value = out;
    } else if (typeof prop === 'function') {
      value = prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0]);
    }
    if (this.hot.hasHook('modifyData')) {
      const valueHolder = (0, _object.createObjectPropListener)(value);
      this.hot.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'get');
      if (valueHolder.isTouched()) {
        value = valueHolder.value;
      }
    }
    return value;
  }

  /**
   * Returns single value from the data array (intended for clipboard copy to an external application).
   *
   * @param {number} row Physical row index.
   * @param {number} prop The column property.
   * @returns {string}
   */
  getCopyable(row, prop) {
    if (this.hot.getCellMeta(row, this.propToCol(prop)).copyable) {
      return this.get(row, prop);
    }
    return '';
  }

  /**
   * Saves single value to the data array.
   *
   * @param {number} row Visual row index.
   * @param {number} prop The column property.
   * @param {string} value The value to set.
   */
  set(row, prop, value) {
    const physicalRow = this.hot.toPhysicalRow(row);
    let newValue = value;
    let dataRow = this.dataSource[physicalRow];
    // TODO: To remove, use 'modifyData' hook instead (see below)
    const modifiedRowData = this.hot.runHooks('modifyRowData', physicalRow);
    dataRow = isNaN(modifiedRowData) ? modifiedRowData : dataRow;
    //

    if (this.hot.hasHook('modifyData')) {
      const valueHolder = (0, _object.createObjectPropListener)(newValue);
      this.hot.runHooks('modifyData', physicalRow, this.propToCol(prop), valueHolder, 'set');
      if (valueHolder.isTouched()) {
        newValue = valueHolder.value;
      }
    }
    const {
      dataDotNotation
    } = this.hot.getSettings();

    // try to set value under property `prop` (includes dot)
    if (dataRow && dataRow.hasOwnProperty && (0, _object.hasOwnProperty)(dataRow, prop)) {
      dataRow[prop] = newValue;
    } else if (dataDotNotation && typeof prop === 'string' && prop.indexOf('.') > -1) {
      let out = dataRow;
      let i = 0;
      let ilen;
      const sliced = prop.split('.');
      for (i = 0, ilen = sliced.length - 1; i < ilen; i++) {
        if (typeof out[sliced[i]] === 'undefined') {
          out[sliced[i]] = {};
        }
        out = out[sliced[i]];
      }
      out[sliced[i]] = newValue;
    } else if (typeof prop === 'function') {
      prop(this.dataSource.slice(physicalRow, physicalRow + 1)[0], newValue);
    } else {
      dataRow[prop] = newValue;
    }
  }

  /**
   * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.
   * The trick is, the physical row id (stored in settings.data) is not necessary the same
   * as the visual (displayed) row id (e.g. When sorting is applied).
   *
   * @param {number} index Visual row index.
   * @param {number} amount An amount of rows to translate.
   * @returns {number}
   */
  visualRowsToPhysical(index, amount) {
    const totalRows = this.hot.countSourceRows();
    const logicRows = [];
    let physicRow = (totalRows + index) % totalRows;
    let rowsToRemove = amount;
    let row;
    while (physicRow < totalRows && rowsToRemove) {
      row = this.hot.toPhysicalRow(physicRow);
      logicRows.push(row);
      rowsToRemove -= 1;
      physicRow += 1;
    }
    return logicRows;
  }

  /**
   *
   * @param {number} index Visual column index.
   * @param {number} amount An amount of rows to translate.
   * @returns {Array}
   */
  visualColumnsToPhysical(index, amount) {
    const totalCols = this.hot.countCols();
    const visualCols = [];
    let physicalCol = (totalCols + index) % totalCols;
    let colsToRemove = amount;
    while (physicalCol < totalCols && colsToRemove) {
      const col = this.hot.toPhysicalColumn(physicalCol);
      visualCols.push(col);
      colsToRemove -= 1;
      physicalCol += 1;
    }
    return visualCols;
  }

  /**
   * Clears the data array.
   */
  clear() {
    for (let r = 0; r < this.hot.countSourceRows(); r++) {
      for (let c = 0; c < this.hot.countCols(); c++) {
        this.set(r, this.colToProp(c), '');
      }
    }
  }

  /**
   * Get data length.
   *
   * @returns {number}
   */
  getLength() {
    const maxRowsFromSettings = this.tableMeta.maxRows;
    let maxRows;
    if (maxRowsFromSettings < 0 || maxRowsFromSettings === 0) {
      maxRows = 0;
    } else {
      maxRows = maxRowsFromSettings || Infinity;
    }
    const length = this.hot.rowIndexMapper.getNotTrimmedIndexesLength();
    return Math.min(length, maxRows);
  }

  /**
   * Returns the data array.
   *
   * @returns {Array}
   */
  getAll() {
    const start = {
      row: 0,
      col: 0
    };
    const end = {
      row: Math.max(this.hot.countRows() - 1, 0),
      col: Math.max(this.hot.countCols() - 1, 0)
    };
    if (start.row - end.row === 0 && !this.hot.countSourceRows()) {
      return [];
    }
    return this.getRange(start, end, DataMap.DESTINATION_RENDERER);
  }

  /**
   * Count the number of columns cached in the `colToProp` cache.
   *
   * @returns {number} Amount of cached columns.
   */
  countCachedColumns() {
    return this.colToPropCache.length;
  }

  /**
   * Returns data range as array.
   *
   * @param {object} [start] Start selection position. Visual indexes.
   * @param {object} [end] End selection position. Visual indexes.
   * @param {number} destination Destination of datamap.get.
   * @returns {Array}
   */
  getRange(start, end, destination) {
    const output = [];
    let r;
    let c;
    let row;
    const maxRows = this.tableMeta.maxRows;
    const maxCols = this.tableMeta.maxCols;
    if (maxRows === 0 || maxCols === 0) {
      return [];
    }
    const getFn = destination === DataMap.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;
    const rlen = Math.min(Math.max(maxRows - 1, 0), Math.max(start.row, end.row));
    const clen = Math.min(Math.max(maxCols - 1, 0), Math.max(start.col, end.col));
    for (r = Math.min(start.row, end.row); r <= rlen; r++) {
      row = [];
      // We just store indexes for rows without headers.
      const physicalRow = r >= 0 ? this.hot.toPhysicalRow(r) : r;
      for (c = Math.min(start.col, end.col); c <= clen; c++) {
        if (physicalRow === null) {
          break;
        }
        row.push(getFn.call(this, r, this.colToProp(c)));
      }
      if (physicalRow !== null) {
        output.push(row);
      }
    }
    return output;
  }

  /**
   * Return data as text (tab separated columns).
   *
   * @param {object} [start] Start selection position. Visual indexes.
   * @param {object} [end] End selection position. Visual indexes.
   * @returns {string}
   */
  getText(start, end) {
    return (0, _SheetClip.stringify)(this.getRange(start, end, DataMap.DESTINATION_RENDERER));
  }

  /**
   * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).
   *
   * @param {object} [start] Start selection position. Visual indexes.
   * @param {object} [end] End selection position. Visual indexes.
   * @returns {string}
   */
  getCopyableText(start, end) {
    return (0, _SheetClip.stringify)(this.getRange(start, end, DataMap.DESTINATION_CLIPBOARD_GENERATOR));
  }

  /**
   * Destroy instance.
   */
  destroy() {
    this.hot = null;
    this.metaManager = null;
    this.dataSource = null;
    this.duckSchema = null;
    this.colToPropCache.length = 0;
    this.propToColCache.clear();
    this.propToColCache = undefined;
  }
}
var _default = exports["default"] = DataMap;

/***/ }),
/* 666 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _SheetClip = __webpack_require__(667);
exports.parse = _SheetClip.parse;
exports.stringify = _SheetClip.stringify;

/***/ }),
/* 667 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
exports.parse = parse;
exports.stringify = stringify;
/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * SheetClip - Spreadsheet Clipboard Parser.
 * version 0.2
 *
 * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,
 * Google Docs and Microsoft Excel.
 *
 * Copyright 2012, Marcin Warpechowski
 * Licensed under the MIT license.
 * http://github.com/warpech/sheetclip/
 */

const regUniversalNewLine = /^(\r\n|\n\r|\r|\n)/;
const regNextCellNoQuotes = /^[^\t\r\n]+/;
const regNextEmptyCell = /^\t/;

/**
 * Decode spreadsheet string into array.
 *
 * @param {string} str The string to parse.
 * @returns {Array}
 */
function parse(str) {
  const arr = [['']];
  if (str.length === 0) {
    return arr;
  }
  let column = 0;
  let row = 0;
  let lastLength;
  while (str.length > 0) {
    if (lastLength === str.length) {
      // In the case If in last cycle we didn't match anything, we have to leave the infinite loop
      break;
    }
    lastLength = str.length;
    if (str.match(regNextEmptyCell)) {
      str = str.replace(regNextEmptyCell, '');
      column += 1;
      arr[row][column] = '';
    } else if (str.match(regUniversalNewLine)) {
      str = str.replace(regUniversalNewLine, '');
      column = 0;
      row += 1;
      arr[row] = [''];
    } else {
      let nextCell = '';
      if (str.startsWith('"')) {
        let quoteNo = 0;
        let isStillCell = true;
        while (isStillCell) {
          const nextChar = str.slice(0, 1);
          if (nextChar === '"') {
            quoteNo += 1;
          }
          nextCell += nextChar;
          str = str.slice(1);
          if (str.length === 0 || str.match(/^[\t\r\n]/) && quoteNo % 2 === 0) {
            isStillCell = false;
          }
        }
        nextCell = nextCell.replace(/^"/, '').replace(/"$/, '').replace(/["]*/g, match => new Array(Math.floor(match.length / 2)).fill('"').join(''));
      } else {
        const matchedText = str.match(regNextCellNoQuotes);
        nextCell = matchedText ? matchedText[0] : '';
        str = str.slice(nextCell.length);
      }
      arr[row][column] = nextCell;
    }
  }
  return arr;
}

/**
 * Encode array into valid spreadsheet string.
 *
 * @param {Array} arr An array of arrays to stringify.
 * @returns {string}
 */
function stringify(arr) {
  let r;
  let rLen;
  let c;
  let cLen;
  let str = '';
  let val;
  for (r = 0, rLen = arr.length; r < rLen; r += 1) {
    cLen = arr[r].length;
    for (c = 0; c < cLen; c += 1) {
      if (c > 0) {
        str += '\t';
      }
      val = arr[r][c];
      if (typeof val === 'string') {
        if (val.indexOf('\n') > -1) {
          str += `"${val.replace(/"/g, '""')}"`;
        } else {
          str += val;
        }
      } else if (val === null || val === undefined) {
        // undefined resolves to undefined
        str += '';
      } else {
        str += val;
      }
    }
    if (r !== rLen - 1) {
      str += '\n';
    }
  }
  return str;
}

/***/ }),
/* 668 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(311);
__webpack_require__(329);
var _globalMeta = _interopRequireDefault(__webpack_require__(669));
var _tableMeta = _interopRequireDefault(__webpack_require__(673));
var _columnMeta = _interopRequireDefault(__webpack_require__(674));
var _cellMeta = _interopRequireDefault(__webpack_require__(676));
var _localHooks = _interopRequireDefault(__webpack_require__(599));
var _object = __webpack_require__(499);
/**
 * With the Meta Manager class, it can be possible to manage with meta objects for different layers in
 * one place. All coordinates used to fetch, updating, removing, or creating rows or columns have to
 * be passed as physical values.
 *
 * The diagram of the meta layers:
 * +-------------+.
 * │ GlobalMeta  │
 * │ (prototype) │
 * +-------------+\
 *       │         \
 *       │          \
 *      \│/         _\|
 * +-------------+    +-------------+.
 * │ TableMeta   │    │ ColumnMeta  │
 * │ (instance)  │    │ (prototype) │
 * +-------------+    +-------------+.
 *                         │
 *                         │
 *                        \│/
 *                    +-------------+.
 *                    │  CellMeta   │
 *                    │ (instance)  │
 *                    +-------------+.
 *
 * A more detailed description of the specific layers can be found in the "metaLayers/" modules description.
 */
class MetaManager {
  constructor(hot) {
    let customSettings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let metaMods = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    /**
     * @type {Handsontable}
     */
    this.hot = hot;
    /**
     * @type {GlobalMeta}
     */
    this.globalMeta = new _globalMeta.default(hot);
    /**
     * @type {TableMeta}
     */
    this.tableMeta = new _tableMeta.default(this.globalMeta);
    /**
     * @type {ColumnMeta}
     */
    this.columnMeta = new _columnMeta.default(this.globalMeta);
    /**
     * @type {CellMeta}
     */
    this.cellMeta = new _cellMeta.default(this.columnMeta);
    metaMods.forEach(ModifierClass => new ModifierClass(this));
    this.globalMeta.updateMeta(customSettings);
  }

  /**
   * Gets the global meta object that is a root of all default settings, which are recognizable by Handsontable.
   * Other layers inherites all properties from this. Adding, removing, or changing property in that
   * object has a direct reflection to all layers.
   *
   * @returns {object}
   */
  getGlobalMeta() {
    return this.globalMeta.getMeta();
  }

  /**
   * Updates global settings object by merging settings with the current state.
   *
   * @param {object} settings An object to merge with.
   */
  updateGlobalMeta(settings) {
    this.globalMeta.updateMeta(settings);
  }

  /**
   * Gets settings object that was passed in the Handsontable constructor. That layer contains all
   * default settings inherited from the GlobalMeta layer merged with settings passed by the developer.
   * Adding, removing, or changing property in that object has no direct reflection on any other layers.
   *
   * @returns {TableMeta}
   */
  getTableMeta() {
    return this.tableMeta.getMeta();
  }

  /**
   * Updates table settings object by merging settings with the current state.
   *
   * @param {object} settings An object to merge with.
   */
  updateTableMeta(settings) {
    this.tableMeta.updateMeta(settings);
  }

  /**
   * Gets column meta object that is a root of all settings defined in the column property of the Handsontable
   * settings. Each column in the Handsontable is associated with a unique meta object which identified by
   * the physical column index. Adding, removing, or changing property in that object has a direct reflection
   * only for the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower
   * layers (prototype lookup).
   *
   * @param {number} physicalColumn The physical column index.
   * @returns {object}
   */
  getColumnMeta(physicalColumn) {
    return this.columnMeta.getMeta(physicalColumn);
  }

  /**
   * Updates column meta object by merging settings with the current state.
   *
   * @param {number} physicalColumn The physical column index which points what column meta object is updated.
   * @param {object} settings An object to merge with.
   */
  updateColumnMeta(physicalColumn, settings) {
    this.columnMeta.updateMeta(physicalColumn, settings);
  }

  /**
   * Gets the cell meta object that is a root of all settings defined for the specific cell rendered by
   * the Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't
   * exist in that layer, it is looked up through a prototype to the highest layer. Starting
   * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,
   * removing, or changing property in that object has no direct reflection on any other layers.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {object} options Additional options that are used to extend the cell meta object.
   * @param {number} options.visualRow The visual row index of the currently requested cell meta object.
   * @param {number} options.visualColumn The visual column index of the currently requested cell meta object.
   * @returns {object}
   */
  getCellMeta(physicalRow, physicalColumn, _ref) {
    let {
      visualRow,
      visualColumn
    } = _ref;
    const cellMeta = this.cellMeta.getMeta(physicalRow, physicalColumn);
    cellMeta.visualRow = visualRow;
    cellMeta.visualCol = visualColumn;
    cellMeta.row = physicalRow;
    cellMeta.col = physicalColumn;
    this.runLocalHooks('afterGetCellMeta', cellMeta);
    return cellMeta;
  }

  /**
   * Gets a value (defined by the `key` property) from the cell meta object.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key Defines the value that will be returned from the cell meta object.
   * @returns {*}
   */
  getCellMetaKeyValue(physicalRow, physicalColumn, key) {
    if (typeof key !== 'string') {
      throw new Error('The passed cell meta object key is not a string');
    }
    return this.cellMeta.getMeta(physicalRow, physicalColumn, key);
  }

  /**
   * Sets settings object for cell meta object defined by "key" property.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key The property name to set.
   * @param {*} value Value to save.
   */
  setCellMeta(physicalRow, physicalColumn, key, value) {
    this.cellMeta.setMeta(physicalRow, physicalColumn, key, value);
  }

  /**
   * Updates cell meta object by merging settings with the current state.
   *
   * @param {number} physicalRow The physical row index which points what cell meta object is updated.
   * @param {number} physicalColumn The physical column index which points what cell meta object is updated.
   * @param {object} settings An object to merge with.
   */
  updateCellMeta(physicalRow, physicalColumn, settings) {
    this.cellMeta.updateMeta(physicalRow, physicalColumn, settings);
  }

  /**
   * Removes a property defined by the "key" argument from the cell meta object.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key The property name to remove.
   */
  removeCellMeta(physicalRow, physicalColumn, key) {
    this.cellMeta.removeMeta(physicalRow, physicalColumn, key);
  }

  /**
   * Returns all cell meta objects that were created during the Handsontable operation. As cell meta
   * objects are created lazy, the length of the returned collection depends on how and when the
   * table has asked for access to that meta objects.
   *
   * @returns {object[]}
   */
  getCellsMeta() {
    return this.cellMeta.getMetas();
  }

  /**
   * Returns all cell meta objects that were created during the Handsontable operation but for
   * specific row index.
   *
   * @param {number} physicalRow The physical row index.
   * @returns {object[]}
   */
  getCellsMetaAtRow(physicalRow) {
    return this.cellMeta.getMetasAtRow(physicalRow);
  }

  /**
   * Creates one or more rows at specific position.
   *
   * @param {number} physicalRow The physical row index which points from what position the row is added.
   * @param {number} [amount=1] An amount of rows to add.
   */
  createRow(physicalRow) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    this.cellMeta.createRow(physicalRow, amount);
  }

  /**
   * Removes one or more rows from the collection.
   *
   * @param {number} physicalRow The physical row index which points from what position the row is removed.
   * @param {number} [amount=1] An amount rows to remove.
   */
  removeRow(physicalRow) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    this.cellMeta.removeRow(physicalRow, amount);
  }

  /**
   * Creates one or more columns at specific position.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is added.
   * @param {number} [amount=1] An amount of columns to add.
   */
  createColumn(physicalColumn) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    this.cellMeta.createColumn(physicalColumn, amount);
    this.columnMeta.createColumn(physicalColumn, amount);
  }

  /**
   * Removes one or more columns from the collection.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is removed.
   * @param {number} [amount=1] An amount of columns to remove.
   */
  removeColumn(physicalColumn) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    this.cellMeta.removeColumn(physicalColumn, amount);
    this.columnMeta.removeColumn(physicalColumn, amount);
  }

  /**
   * Clears all saved cell meta objects. It keeps column meta, table meta, and global meta intact.
   */
  clearCellsCache() {
    this.cellMeta.clearCache();
  }

  /**
   * Clears all saved cell and columns meta objects.
   */
  clearCache() {
    this.cellMeta.clearCache();
    this.columnMeta.clearCache();
  }
}
exports["default"] = MetaManager;
(0, _object.mixin)(MetaManager, _localHooks.default);

/***/ }),
/* 669 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _object = __webpack_require__(499);
var _utils = __webpack_require__(670);
var _metaSchema = _interopRequireDefault(__webpack_require__(672));
/**
 * @typedef {Options} TableMeta
 */
/**
 * @returns {TableMeta} Returns an empty object. The holder for global meta object.
 */
function createTableMetaEmptyClass() {
  return class TableMeta {};
}

/**
 * The global meta object is a root of all default settings, which are recognizable by Handsontable.
 * Other layers are inherited from this object. Adding, removing, or changing property in that
 * object has a direct reflection to all layers such as: TableMeta, ColumnMeta, or CellMeta layers.
 *
 * +-------------+.
 * │ GlobalMeta  │
 * │ (prototype) │
 * +-------------+\
 *       │         \
 *       │          \
 *      \│/         _\|
 * +-------------+    +-------------+.
 * │ TableMeta   │    │ ColumnMeta  │
 * │ (instance)  │    │ (prototype) │
 * +-------------+    +-------------+.
 *                         │
 *                         │
 *                        \│/
 *                    +-------------+.
 *                    │  CellMeta   │
 *                    │ (instance)  │
 *                    +-------------+.
 */
class GlobalMeta {
  constructor(hot) {
    /**
     * An alias for the constructor. Necessary for inheritance for creating new layers.
     *
     * @type {TableMeta}
     */
    (0, _defineProperty2.default)(this, "metaCtor", createTableMetaEmptyClass());
    /**
     * Main object (prototype of the internal TableMeta class), holder for all default settings.
     *
     * @type {object}
     */
    (0, _defineProperty2.default)(this, "meta", void 0);
    this.meta = this.metaCtor.prototype;
    (0, _object.extend)(this.meta, (0, _metaSchema.default)());
    this.meta.instance = hot;
  }

  /**
   * Gets constructor of the global meta object. Necessary for inheritance for creating the next meta layers.
   *
   * @returns {Function}
   */
  getMetaConstructor() {
    return this.metaCtor;
  }

  /**
   * Gets settings object for this layer.
   *
   * @returns {object}
   */
  getMeta() {
    return this.meta;
  }

  /**
   * Updates global settings object by merging settings with the current state.
   *
   * @param {object} settings An object to merge with.
   */
  updateMeta(settings) {
    var _settings$type;
    (0, _object.extend)(this.meta, settings);
    (0, _utils.extendByMetaType)(this.meta, {
      ...settings,
      type: (_settings$type = settings.type) !== null && _settings$type !== void 0 ? _settings$type : this.meta.type
    }, settings);
  }
}
exports["default"] = GlobalMeta;

/***/ }),
/* 670 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.assert = assert;
exports.columnFactory = columnFactory;
exports.extendByMetaType = extendByMetaType;
exports.isNullish = isNullish;
exports.isUnsignedNumber = isUnsignedNumber;
__webpack_require__(201);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
var _object = __webpack_require__(499);
var _registry = __webpack_require__(671);
/**
 * Checks if the given property can be overwritten.
 *
 * @param {string} propertyName The property name to check.
 * @param {object} metaObject The current object meta settings.
 * @returns {boolean}
 */
function canBeOverwritten(propertyName, metaObject) {
  var _metaObject$_automati;
  if (propertyName === 'CELL_TYPE') {
    return false;
  }
  return ((_metaObject$_automati = metaObject._automaticallyAssignedMetaProps) === null || _metaObject$_automati === void 0 ? void 0 : _metaObject$_automati.has(propertyName)) || !(0, _object.hasOwnProperty)(metaObject, propertyName);
}

/**
 * Expands "type" property of the meta object to single values. For example `type: 'numeric'` sets
 * "renderer", "editor", "validator" properties to specific functions designed for numeric values.
 * If "type" is passed as an object that object will be returned, excluding properties that
 * already exist in the "metaObject".
 *
 * The function utilizes `_automaticallyAssignedMetaProps` meta property that allows tracking what
 * properties are changed by the "type" expanding feature. That properties can be always overwritten by
 * the user.
 *
 * @param {object} metaObject The meta object.
 * @param {object} settings The settings object with the "type" setting.
 * @param {object} settingsToCompareWith The object to compare which properties need to be updated.
 */
function extendByMetaType(metaObject, settings) {
  let settingsToCompareWith = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : metaObject;
  const validType = typeof settings.type === 'string' ? (0, _registry.getCellType)(settings.type) : settings.type;
  if (metaObject._automaticallyAssignedMetaProps) {
    (0, _object.objectEach)(settings, (value, key) => void metaObject._automaticallyAssignedMetaProps.delete(key));
  }
  if (!(0, _object.isObject)(validType)) {
    return;
  }
  if (settingsToCompareWith === metaObject && !metaObject._automaticallyAssignedMetaProps) {
    metaObject._automaticallyAssignedMetaProps = new Set();
  }
  const expandedType = {};
  (0, _object.objectEach)(validType, (value, property) => {
    if (canBeOverwritten(property, settingsToCompareWith)) {
      var _metaObject$_automati2;
      expandedType[property] = value;
      (_metaObject$_automati2 = metaObject._automaticallyAssignedMetaProps) === null || _metaObject$_automati2 === void 0 || _metaObject$_automati2.add(property);
    }
  });
  (0, _object.extend)(metaObject, expandedType);
}

/**
 * Creates new class which extends properties from TableMeta layer class.
 *
 * @param {TableMeta} TableMeta The TableMeta which the new ColumnMeta is created from.
 * @param {string[]} [conflictList] List of the properties which are conflicted with the column meta layer.
 *                                  Conflicted properties are overwritten by `undefined` value, to separate them
 *                                  from the TableMeta layer.
 * @returns {ColumnMeta} Returns constructor ready to initialize with `new` operator.
 */
function columnFactory(TableMeta) {
  let conflictList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  // Do not use ES6 "class extends" syntax here. It seems that the babel produces code
  // which drastically decreases the performance of the ColumnMeta class creation.

  /**
   * Base "class" for column meta.
   */
  function ColumnMeta() {}
  (0, _object.inherit)(ColumnMeta, TableMeta);

  // Clear conflict settings
  for (let i = 0; i < conflictList.length; i++) {
    ColumnMeta.prototype[conflictList[i]] = undefined;
  }
  return ColumnMeta;
}

/**
 * Helper which checks if the provided argument is an unsigned number.
 *
 * @param {*} value Value to check.
 * @returns {boolean}
 */
function isUnsignedNumber(value) {
  return Number.isInteger(value) && value >= 0;
}

/**
 * Function which makes assertion by custom condition. Function throws an error when assertion doesn't meet the spec.
 *
 * @param {Function} condition Function with custom logic. The condition has to return boolean values.
 * @param {string} errorMessage String which describes assertion error.
 */
function assert(condition, errorMessage) {
  if (!condition()) {
    throw new Error(`Assertion failed: ${errorMessage}`);
  }
}

/**
 * Check if given variable is null or undefined.
 *
 * @param {*} variable Variable to check.
 * @returns {boolean}
 */
function isNullish(variable) {
  return variable === null || variable === undefined;
}

/***/ }),
/* 671 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.getCellType = _getItem;
exports.registerCellType = _register;
__webpack_require__(201);
var _staticRegister = _interopRequireDefault(__webpack_require__(521));
var _registry = __webpack_require__(510);
var _registry2 = __webpack_require__(537);
var _registry3 = __webpack_require__(538);
const {
  register,
  getItem,
  hasItem,
  getNames,
  getValues
} = (0, _staticRegister.default)('cellTypes');

/**
 * Retrieve cell type object.
 *
 * @param {string} name Cell type identification.
 * @returns {object} Returns cell type object.
 */
exports.getRegisteredCellTypes = getValues;
exports.getRegisteredCellTypeNames = getNames;
exports.hasCellType = hasItem;
function _getItem(name) {
  if (!hasItem(name)) {
    throw Error(`You declared cell type "${name}" as a string that is not mapped to a known object.
                 Cell type must be an object or a string mapped to an object registered by
                 "Handsontable.cellTypes.registerCellType" method`);
  }
  return getItem(name);
}

/**
 * Register cell type under specified name.
 *
 * @param {string} name Cell type identification.
 * @param {object} type An object with contains keys (eq: `editor`, `renderer`, `validator`) which describes specified behaviour of the cell.
 */
function _register(name, type) {
  if (typeof name !== 'string') {
    type = name;
    name = type.CELL_TYPE;
  }
  const {
    editor,
    renderer,
    validator
  } = type;
  if (editor) {
    (0, _registry.registerEditor)(name, editor);
  }
  if (renderer) {
    (0, _registry2.registerRenderer)(name, renderer);
  }
  if (validator) {
    (0, _registry3.registerValidator)(name, validator);
  }
  register(name, type);
}

/***/ }),
/* 672 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _mixed = __webpack_require__(354);
var _object = __webpack_require__(499);
/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * @alias Options
 * @class Options
 * @description
 *
 * [Configuration options](@/guides/getting-started/configuration-options/configuration-options.md) let you heavily customize your Handsontable instance. For example, you can:
 *
 * - Enable and disable built-in features
 * - Enable and configure additional [plugins](@/api/plugins.md)
 * - Personalize Handsontable's look
 * - Adjust Handsontable's behavior
 * - Implement your own custom features
 *
 * ::: only-for javascript
 *
 * To apply [configuration options](@/guides/getting-started/configuration-options/configuration-options.md), pass them as
 * a second argument of the [Handsontable constructor](@/guides/getting-started/installation/installation.md#initialize-handsontable),
 * using the [object literal notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer):
 *
 * Read more on the [Configuration options](@/guides/getting-started/configuration-options/configuration-options.md) page.
 *
 * ```js
 * const container = document.getElementById('example');
 *
 * const hot = new Handsontable(container, {
 *   // configuration options, in the object literal notation
 *   licenseKey: 'non-commercial-and-evaluation',
 *   data: [
 *     ['A1', 'B1', 'C1', 'D1', 'E1'],
 *     ['A2', 'B2', 'C2', 'D2', 'E2'],
 *     ['A3', 'B3', 'C3', 'D3', 'E3'],
 *     ['A4', 'B4', 'C4', 'D4', 'E4'],
 *     ['A5', 'B5', 'C5', 'D5', 'E5'],
 *   ],
 *   width: 400,
 *   height: 300,
 *   colHeaders: true,
 *   rowHeaders: true,
 *   customBorders: true,
 *   dropdownMenu: true,
 *   multiColumnSorting: true,
 *   filters: true,
 *   manualRowMove: true,
 * });
 * ```
 * :::
 *
 * ::: only-for react
 *
 * To apply configuration options, pass them as individual props
 * of the [`HotTable`](@/guides/getting-started/installation/installation.md#_4-use-the-hottable-component)
 * or [`HotColumn`](@/guides/columns/react-hot-column/react-hot-column.md) components.
 *
 * Read more on the [Configuration options](@/guides/getting-started/configuration-options/configuration-options.md) page.
 *
 * ```jsx
 * <HotTable
 *   // configuration options, in the object literal notation
 *   licenseKey='non-commercial-and-evaluation'
 *   data={[
 *     ['A1', 'B1', 'C1', 'D1', 'E1'],
 *     ['A2', 'B2', 'C2', 'D2', 'E2'],
 *     ['A3', 'B3', 'C3', 'D3', 'E3'],
 *     ['A4', 'B4', 'C4', 'D4', 'E4'],
 *     ['A5', 'B5', 'C5', 'D5', 'E5'],
 *   ]}
 *   width={400}
 *   height={300}
 *   colHeaders={true}
 *   rowHeaders={true}
 *   customBorders={true}
 *   dropdownMenu={true}
 *   multiColumnSorting={true}
 *   filters={true}
 *   manualRowMove={true}
 * />
 * ```
 * :::
 *
 * Depending on your needs, you can apply [configuration options](@/api/options.md) to different elements of your grid:
 * - [The entire grid](@/guides/getting-started/configuration-options/configuration-options.md#set-grid-options)
 * - [Individual columns](@/guides/getting-started/configuration-options/configuration-options.md#set-column-options)
 * - [Individual rows](@/guides/getting-started/configuration-options/configuration-options.md#set-row-options)
 * - [Individual cells](@/guides/getting-started/configuration-options/configuration-options.md#set-cell-options)
 * - [Individual grid elements, based on any logic you implement](@/guides/getting-started/configuration-options/configuration-options.md#implementing-custom-logic)
 *
 * Read more:
 * - [Configuration options](@/guides/getting-started/configuration-options/configuration-options.md)
 */
var _default = () => {
  return {
    /* eslint-disable jsdoc/require-description-complete-sentence */

    /**
     * Information on which of the meta properties were added automatically.
     * For example: setting the `renderer` property directly won't extend the `_automaticallyAssignedMetaProps`
     * entry, but setting a `type` will modify it to `Set(3) {'renderer', 'editor', 'validator', ...}`.
     *
     * @private
     * @type {Set}
     * @default undefined
     */
    _automaticallyAssignedMetaProps: undefined,
    /**
     * The `activeHeaderClassName` option lets you add a CSS class name
     * to every currently-active, currently-selected header (when a whole column or row is selected).
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @since 0.38.2
     * @default 'ht__active_highlight'
     * @category Core
     *
     * @example
     * ```js
     * // add an `ht__active_highlight` CSS class name
     * // to every currently-active, currently-selected header
     * activeHeaderClassName: 'ht__active_highlight',
     * ```
     */
    activeHeaderClassName: 'ht__active_highlight',
    /**
     * The `allowEmpty` option determines whether Handsontable accepts the following values:
     * - `null`
     * - `undefined`
     * - `''`
     *
     * You can set the `allowEmpty` option to one of the following:
     *
     * | Setting          | Description                                                                                                                          |
     * | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
     * | `true` (default) | - Accept `null`, `undefined` and `''` values<br>- Mark cells that contain `null`, `undefined` or `''` values as `valid`              |
     * | `false`          | - Don't accept `null`, `undefined` and `''` values<br>- Mark cells that contain `null`, `undefined` or `''` values with as `invalid` |
     *
     * ::: tip
     * To use the [`allowEmpty`](#allowempty) option, you need to set the [`validator`](#validator) option (or the [`type`](#type) option).
     * :::
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // allow empty values in each cell of the entire grid
     * allowEmpty: true,
     *
     * // or
     * columns: [
     *   {
     *     type: 'date',
     *     dateFormat: 'DD/MM/YYYY',
     *     // allow empty values in each cell of the 'date' column
     *     allowEmpty: true
     *   }
     * ],
     * ```
     */
    allowEmpty: true,
    /**
     * The `allowHtml` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md) cells' [`source`](#source) data
     * is treated as HTML.
     *
     * You can set the `allowHtml` option to one of the following:
     *
     * | Setting           | Description                                         |
     * | ----------------- | --------------------------------------------------- |
     * | `false` (default) | The [`source`](#source) data is not treated as HTML |
     * | `true`            | The [`source`](#source) data is treated as HTML     |
     *
     * __Warning:__ Setting the `allowHtml` option to `true` can cause serious XSS vulnerabilities.
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md)
     * - [`source`](#source)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['<strong>foo</strong>', '<strong>bar</strong>']
     *   // use HTML in the `source` list
     *   allowHtml: true,
     *   },
     * ],
     * ```
     */
    allowHtml: false,
    /**
     * If set to `true`, the `allowInsertColumn` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu/context-menu.md):
     * - **Insert column left**
     * - **Insert column right**
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Insert column left' and 'Insert column right' menu items from the context menu
     * allowInsertColumn: false,
     * ```
     */
    allowInsertColumn: true,
    /**
     * If set to `true`, the `allowInsertRow` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu/context-menu.md):
     * - **Insert row above**
     * - **Insert row below**
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Insert row above' and 'Insert row below' menu items from the context menu
     * allowInsertRow: false,
     * ```
     */
    allowInsertRow: true,
    /**
     * The `allowInvalid` option determines whether Handsontable accepts values
     * that were marked as `invalid` by the [cell validator](@/guides/cell-functions/cell-validator/cell-validator.md).
     *
     * You can set the `allowInvalid` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                        |
     * | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | - Accept `invalid` values<br>- Allow the user to close the [cell editor](@/guides/cell-functions/cell-editor/cell-editor.md) with `invalid` values<br>- Save `invalid` values into the data source                   |
     * | `false`          | - Don't accept `invalid` values<br>- Don't allow the user to close the [cell editor](@/guides/cell-functions/cell-editor/cell-editor.md) with `invalid` values<br>- Don't save `invalid` values into the data source |
     *
     * Setting the `allowInvalid` option to `false` can be useful when used with the [Autocomplete strict mode](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md#autocomplete-strict-mode).
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator/cell-validator.md)
     * - [Cell editor](@/guides/cell-functions/cell-editor/cell-editor.md)
     * - [Autocomplete strict mode](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md#autocomplete-strict-mode)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // don't accept `invalid` values
     * // don't allow the user to close the cell editor
     * // don't save `invalid` values into the data source
     * allowInvalid: false,
     * ```
     */
    allowInvalid: true,
    /**
     * If set to `true`, the `allowRemoveColumn` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu/context-menu.md):
     * - **Remove column**
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Remove column' menu item from the context menu
     * allowRemoveColumn: false,
     * ```
     */
    allowRemoveColumn: true,
    /**
     * If set to `true`, the `allowRemoveRow` option adds the following menu items to the [context menu](@/guides/accessories-and-menus/context-menu/context-menu.md):
     * - **Remove row**
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // hide the 'Remove row' menu item from the context menu
     * allowRemoveRow: false,
     * ```
     */
    allowRemoveRow: true,
    /**
     * If set to `true`, the accessibility-related ARIA tags will be added to the table. If set to `false`, they
     * will be omitted.
     * Defaults to `true`.
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     * @since 14.0.0
     */
    ariaTags: true,
    /**
     * The `autoColumnSize` option configures the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin.
     *
     * You can set the `autoColumnSize` option to one of the following:
     *
     * | Setting   | Description                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin                               |
     * | `true`    | Enable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin with the default configuration |
     * | An object | Enable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin and modify the plugin options  |
     *
     * If you set the `autoColumnSize` option to an object, you can set the following [`AutoColumnSize`](@/api/autoColumnSize.md) plugin options:
     *
     * | Property                | Possible values                 | Description                                                                                                    |
     * | ----------------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------- |
     * | `syncLimit`             | A number \| A percentage string | The number/percentage of columns to keep in sync<br>(default: `50`)                                            |
     * | `useHeaders`            | `true` \| `false`               | When calculating column widths:<br>`true`: use column headers<br>`false`: don't use column headers          |
     * | `samplingRatio`         | A number                        | The number of samples of the same length to be used in column width calculations                               |
     * | `allowSampleDuplicates` | `true` \| `false`               | When calculating column widths:<br>`true`: Allow duplicate samples<br>`false`: Don't allow duplicate samples |
     *
     * By default, the `autoColumnSize` option is set to `undefined`,
     * but the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin acts as enabled.
     * To disable the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin completely,
     * set the `autoColumnSize` option to `false`.
     *
     * Using the [`colWidths`](#colWidths) option forcibly disables the [`AutoColumnSize`](@/api/autoColumnSize.md) plugin.
     *
     * Read more:
     * - [Plugins: `AutoColumnSize`](@/api/autoColumnSize.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default undefined
     * @category AutoColumnSize
     *
     * @example
     * ```js
     * autoColumnSize: {
     *   // keep 40% of columns in sync (the rest of columns: async)
     *   syncLimit: '40%',
     *   // when calculating column widths, use column headers
     *   useHeaders: true,
     *   // when calculating column widths, use 10 samples of the same length
     *   samplingRatio: 10,
     *   // when calculating column widths, allow duplicate samples
     *   allowSampleDuplicates: true
     * },
     * ```
     */
    autoColumnSize: undefined,
    /**
     * The `autoRowSize` option configures the [`AutoRowSize`](@/api/autoRowSize.md) plugin.
     *
     * You can set the `autoRowSize` option to one of the following:
     *
     * | Setting   | Description                                                                            |
     * | --------- | -------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`AutoRowSize`](@/api/autoRowSize.md) plugin                               |
     * | `true`    | Enable the [`AutoRowSize`](@/api/autoRowSize.md) plugin with the default configuration |
     * | An object | Enable the [`AutoRowSize`](@/api/autoRowSize.md) plugin and modify the plugin options  |
     *
     * To give Handsontable's scrollbar a proper size, set the `autoRowSize` option to `true`.
     *
     * If you set the `autoRowSize` option to an object, you can set the following [`AutoRowSize`](@/api/autoRowSize.md) plugin options:
     *
     * | Property    | Possible values                 | Description                                                       |
     * | ----------- | ------------------------------- | ----------------------------------------------------------------- |
     * | `syncLimit` | A number \| A percentage string | The number/percentage of rows to keep in sync<br>(default: `500`) |
     *
     * Using the [`rowHeights`](#rowHeights) option forcibly disables the [`AutoRowSize`](@/api/autoRowSize.md) plugin.
     *
     * Read more:
     * - [Plugins: `AutoRowSize`](@/api/autoRowSize.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default undefined
     * @category AutoRowSize
     *
     * @example
     * ```js
     * autoRowSize: {
     *   // keep 40% of rows in sync (the rest of rows: async)
     *   syncLimit: '40%'
     * },
     * ```
     */
    autoRowSize: undefined,
    /**
     * | Setting           | Description                                                                                                                                                                                                                                  |
     * | ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | When you select a bottom-most cell, pressing <kbd>**↓**</kbd> doesn't do anything.<br><br>When you select a top-most cell, pressing <kbd>**↑**</kbd> doesn't do anything.                                                                    |
     * | `true`            | When you select a bottom-most cell, pressing <kbd>**↓**</kbd> takes you to the top-most cell of the next column.<br><br>When you select a top-most cell, pressing <kbd>**↑**</kbd> takes you to the bottom-most cell of the previous column. |
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // when you select a bottom-most cell, pressing ⬇ doesn't do anything
     * // when you select a top-most cell, pressing ⬆ doesn't do anything
     * autoWrapCol: false, // default setting
     *
     * // when you select a bottom-most cell, pressing ⬇ takes you to the top-most cell of the next column
     * // when you select a top-most cell, pressing ⬆ takes you to the bottom-most cell of the previous column
     * autoWrapCol: true,
     * ```
     */
    autoWrapCol: false,
    /**
     * | Setting           | Description                                                                                                                                                                                                                                                                                                        |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `false` (default) | When you select the first cell of a row, pressing <kbd>**←**</kbd>* (or <kbd>**Shift**</kbd>+<kbd>**Tab**</kbd>\*\*) doesn't do anything.<br><br>When you select the last cell of a row, pressing <kbd>**→**</kbd>* (or <kbd>**Tab**</kbd>**) doesn't do anything.                                                  |
     * | `true`            | When you select the first cell of a row, pressing <kbd>**←**</kbd>* (or <kbd>**Shift**</kbd>+<kbd>**Tab**</kbd>\*\*) takes you to the last cell of the row above.<br><br>When you select the last cell of a row, pressing <kbd>**→**</kbd>* (or <kbd>**Tab**</kbd>**) takes you to the first cell of the row below. |
     *
     * \* The exact key depends on your [`layoutDirection`](#layoutdirection) configuration.<br>
     * \*\* Unless [`tabNavigation`](#tabnavigation) is set to `false`.
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // when you select the first cell of a row, pressing ⬅ (or Shift+Tab) doesn't do anything
     * // when you select the last cell of a row, pressing ➡ (or Tab) doesn't do anything
     * autoWrapRow: false, // default setting
     *
     * // when you select the first cell of a row, pressing ⬅ (or Shift+Tab) takes you to the last cell of the row above
     * // when you select the last cell of a row, pressing ➡ (or Tab) takes you to the first cell of the row below
     * autoWrapRow: true,
     * ```
     */
    autoWrapRow: false,
    /**
     * @description
     * The `bindRowsWithHeaders` option configures the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin.
     *
     * You can set the `bindRowsWithHeaders` option to one of the following:
     *
     * | Setting | Description                                                                  |
     * | ------- | ---------------------------------------------------------------------------- |
     * | `false` | Disable the the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin |
     * | `true`  | Enable the the [`BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md) plugin  |
     *
     * Read more:
     * - [Plugins: `BindRowsWithHeaders`](@/api/bindRowsWithHeaders.md)
     *
     * @memberof Options#
     * @type {boolean|string}
     * @default undefined
     * @category BindRowsWithHeaders
     *
     * @example
     * ```js
     * // enable the `BindRowsWithHeaders` plugin
     * bindRowsWithHeaders: true
     * ```
     */
    bindRowsWithHeaders: undefined,
    /**
     * The `cell` option lets you apply [configuration options](@/guides/getting-started/configuration-options/configuration-options.md) to individual cells.
     *
     * The `cell` option overwrites the [top-level grid options](@/guides/getting-started/configuration-options/configuration-options.md#set-grid-options),
     * and the [`columns`](#columns) options.
     *
     * Read more:
     * - [Configuration options: Setting cell options](@/guides/getting-started/configuration-options/configuration-options.md#set-cell-options)
     * - [`columns`](#columns)
     *
     * @memberof Options#
     * @type {Array[]}
     * @default []
     * @category Core
     *
     * @example
     * ```js
     * // set the `cell` option to an array of objects
     * cell: [
     *   // make the cell with coordinates (0, 0) read-only
     *   {
     *     row: 0,
     *     col: 0,
     *     readOnly: true
     *   }
     * ],
     * ```
     */
    cell: [],
    /**
     * @description
     * The `cells` option lets you apply any other [configuration options](@/guides/getting-started/configuration-options/configuration-options.md) to
     * individual grid elements (columns, rows, cells), based on any logic you implement.
     *
     * The `cells` option overwrites all other options (including options set by [`columns`](#columns) and [`cell`](#cell)).
     * It takes the following parameters:
     *
     * | Parameter | Required | Type             | Description                                                                                                                                                                                                                                                                                                                             |
     * | --------- | -------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `row`     | Yes      | Number           | A physical row index                                                                                                                                                                                                                                                                                                                    |
     * | `column`  | Yes      | Number           | A physical column index                                                                                                                                                                                                                                                                                                                 |
     * | `prop`    | No       | String \| Number | If [`data`](#data) is set to an [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays), `prop` is the same number as `column`.<br><br>If [`data`](#data) is set to an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects), `prop` is a property name for the column's data object. |
     *
     * Read more:
     * - [Configuration options: Implementing custom logic](@/guides/getting-started/configuration-options/configuration-options.md#implement-custom-logic)
     * - [Configuration options: Setting row options](@/guides/getting-started/configuration-options/configuration-options.md#set-row-options)
     * - [`columns`](#columns)
     * - [`cell`](#cell)
     *
     * @memberof Options#
     * @type {Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the `cells` option to your custom function
     * cells(row, column, prop) {
     *   const cellProperties = { readOnly: false };
     *   const visualRowIndex = this.instance.toVisualRow(row);
     *   const visualColIndex = this.instance.toVisualColumn(column);
     *
     *   if (visualRowIndex === 0 && visualColIndex === 0) {
     *     cellProperties.readOnly = true;
     *   }
     *
     *   return cellProperties;
     * },
     * ```
     */
    cells: undefined,
    /**
     * The `checkedTemplate` option lets you configure what value
     * a checked [`checkbox`](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md) cell has.
     *
     * You can set the `checkedTemplate` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                              |
     * | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md) cell is checked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns `true`                  |
     * | A string         | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md) cell is checked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns a string of your choice |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox template](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md#checkbox-template)
     * - [`getDataAtCell()`](@/api/core.md#getDataAtCell)
     * - [`uncheckedTemplate`](#uncheckedTemplate)
     *
     * @memberof Options#
     * @type {boolean|string|number}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when checked, the cell's value is `true`
     *     // when unchecked, the cell's value is `false`
     *     type: 'checkbox',
     *   },
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     type: 'checkbox',
     *     // when checked, the cell's value is `'Yes'`
     *     checkedTemplate: 'Yes',
     *     // when unchecked, the cell's value is `'No'`
     *     uncheckedTemplate: 'No'
     *  }
     * ],
     * ```
     */
    checkedTemplate: undefined,
    /**
     * The `className` option lets you add CSS class names to every currently-selected element.
     *
     * You can set the `className` option to one of the following:
     *
     * | Setting             | Description                                                      |
     * | ------------------- | ---------------------------------------------------------------- |
     * | A string            | Add a single CSS class name to every currently-selected element  |
     * | An array of strings | Add multiple CSS class names to every currently-selected element |
     *
     * ::: tip
     * Don't change the `className` metadata of the [column summary](@/guides/columns/column-summary/column-summary.md) row.
     * To style the summary row, use the class name assigned automatically by the [`ColumnSummary`](@/api/columnSummary.md) plugin: `columnSummaryResult`.
     * :::
     *
     * To apply different CSS class names on different levels, use Handsontable's [cascading configuration](@/guides/getting-started/configuration-options/configuration-options.md#cascading-configuration).
     *
     * Read more:
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options/configuration-options.md#cascading-configuration)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`TableClassName`](#TableClassName)
     *
     * @memberof Options#
     * @type {string|string[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to every currently-selected element
     * className: 'your-class-name',
     *
     * // add `first-class-name` and `second-class-name` CSS class names
     * // to every currently-selected element
     * className: ['first-class-name', 'second-class-name'],
     * ```
     */
    className: undefined,
    /**
     * The `colHeaders` option configures your grid's column headers.
     *
     * You can set the `colHeaders` option to one of the following:
     *
     * | Setting  | Description                                                          |
     * | -------- | -------------------------------------------------------------------- |
     * | `true`   | Enable the default column headers ('A', 'B', 'C', ...)               |
     * | `false`  | Disable column headers                                               |
     * | An array | Define your own column headers (e.g. `['One', 'Two', 'Three', ...]`) |
     * | A function | Define your own column headers, using a function                     |
     *
     * Read more:
     * - [Column header](@/guides/columns/column-header/column-header.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|Function}
     * @default null
     * @category Core
     *
     * @example
     * ```js
     * // enable the default column headers
     * colHeaders: true,
     *
     * // set your own column headers
     * colHeaders: ['One', 'Two', 'Three'],
     *
     * // set your own column headers, using a function
     * colHeaders: function(visualColumnIndex) {
     *   return `${visualColumnIndex} + : AB`;
     * },
     * ```
     */
    colHeaders: null,
    /**
     * @description
     * The `collapsibleColumns` option configures the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin.
     *
     * You can set the `collapsibleColumns` option to one of the following:
     *
     * | Setting              | Description                                                                                       |
     * | -------------------- | ------------------------------------------------------------------------------------------------- |
     * | `false`              | Disable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin                            |
     * | `true`               | Enable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin                             |
     * | An array of objects  | Enable the [`CollapsibleColumns`](@/api/collapsibleColumns.md) plugin for selected column headers |
     *
     * Read more:
     * - [Plugins: `CollapsibleColumns`](@/api/collapsibleColumns.md)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default undefined
     * @category CollapsibleColumns
     *
     * @example
     * ```js
     * // enable column collapsing for all headers
     * collapsibleColumns: true,
     *
     * // enable column collapsing for selected headers
     * collapsibleColumns: [
     *   {row: -4, col: 1, collapsible: true},
     *   {row: -3, col: 5, collapsible: true}
     * ],
     * ```
     */
    collapsibleColumns: undefined,
    /**
     * @description
     * The `columnHeaderHeight` option configures the height of column headers.
     *
     * You can set the `columnHeaderHeight` option to one of the following:
     *
     * | Setting  | Description                                         |
     * | -------- | --------------------------------------------------- |
     * | A number | Set the same height for every column header         |
     * | An array | Set different heights for individual column headers |
     *
     * @memberof Options#
     * @type {number|number[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the same height for every column header
     * columnHeaderHeight: 25,
     *
     * // set different heights for individual column headers
     * columnHeaderHeight: [25, 30, 55],
     * ```
     */
    columnHeaderHeight: undefined,
    /**
     * @description
     * The `columns` option lets you apply any other [configuration options](@/guides/getting-started/configuration-options/configuration-options.md) to individual columns (or ranges of columns).
     *
     * You can set the `columns` option to one of the following:
     * - An array of objects (each object represents one column)
     * - A function that returns an array of objects
     *
     * The `columns` option overwrites the [top-level grid options](@/guides/getting-started/configuration-options/configuration-options.md#set-grid-options).
     *
     * When you use `columns`, the [`startCols`](#startCols), [`minCols`](#minCols), and [`maxCols`](#maxCols) options are ignored.
     *
     * Read more:
     * - [Configuration options: Setting column options](@/guides/getting-started/configuration-options/configuration-options.md#set-column-options)
     * - [`startCols`](#startCols)
     * - [`minCols`](#minCols)
     * - [`maxCols`](#maxCols)
     * - [`data`](#data)
     *
     * @memberof Options#
     * @type {object[]|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the `columns` option to an array of objects
     * // each object represents one column
     * columns: [
     *   {
     *     // column options for the first (by physical index) column
     *     type: 'numeric',
     *     numericFormat: {
     *       pattern: '0,0.00 $'
     *     }
     *   },
     *   {
     *     // column options for the second (by physical index) column
     *     type: 'text',
     *     readOnly: true
     *   }
     * ],
     *
     * // or set the `columns` option to a function, based on physical indexes
     * columns(index) {
     *   return {
     *     type: index > 0 ? 'numeric' : 'text',
     *     readOnly: index < 1
     *   }
     * }
     * ```
     */
    columns: undefined,
    /**
     * @description
     * The `columnSorting` option configures the [`ColumnSorting`](@/api/columnSorting.md) plugin.
     *
     * You can set the `columnSorting` option to one of the following:
     *
     * | Setting    | Description                                                                                                                            |
     * | ---------- | -------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`     | Enable the [`ColumnSorting`](@/api/columnSorting.md) plugin with the default configuration                                             |
     * | `false`    | Disable the [`ColumnSorting`](@/api/columnSorting.md) plugin                                                                           |
     * | An object  | - Enable the [`ColumnSorting`](@/api/columnSorting.md) plugin<br>- Modify the [`ColumnSorting`](@/api/columnSorting.md) plugin options |
     *
     * If you set the `columnSorting` option to an object,
     * you can set the following [`ColumnSorting`](@/api/columnSorting.md) plugin options:
     *
     * | Option                   | Possible settings                                                                                                                                |
     * | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `indicator`              | `true`: Display the arrow icon in the column header, to indicate a sortable column<br>`false`: Don't display the arrow icon in the column header  |
     * | `headerAction`           | `true`: Enable clicking on the column header to sort the column<br>`false`: Disable clicking on the column header to sort the column             |
     * | `sortEmptyCells`         | `true`: Sort empty cells as well<br>`false`: Place empty cells at the end                                                                        |
     * | `compareFunctionFactory` | A [custom compare function](@/guides/rows/rows-sorting/rows-sorting.md#add-a-custom-comparator)                                                                |
     *
     * If you set the `columnSorting` option to an object,
     * you can also sort individual columns at Handsontable's initialization.
     * In the `columnSorting` object, add an object named `initialConfig`,
     * with the following properties:
     *
     * | Option      | Possible settings   | Description                                                      |
     * | ----------- | ------------------- | ---------------------------------------------------------------- |
     * | `column`    | A number            | The index of the column that you want to sort at initialization  |
     * | `sortOrder` | `'asc'` \| `'desc'` | The sorting order:<br>`'asc'`: ascending<br>`'desc'`: descending |
     *
     * Read more:
     * - [Rows sorting](@/guides/rows/rows-sorting/rows-sorting.md)
     * - [Rows sorting: Custom compare functions](@/guides/rows/rows-sorting/rows-sorting.md#add-a-custom-comparator)
     * - [`multiColumnSorting`](#multiColumnSorting)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category ColumnSorting
     *
     * @example
     * ```js
     * // enable the `ColumnSorting` plugin
     * columnSorting: true
     *
     * // enable the `ColumnSorting` plugin with custom configuration
     * columnSorting: {
     *   // sort empty cells as well
     *   sortEmptyCells: true,
     *   // display the arrow icon in the column header
     *   indicator: true,
     *   // disable clicking on the column header to sort the column
     *   headerAction: false,
     *   // add a custom compare function
     *   compareFunctionFactory(sortOrder, columnMeta) {
     *     return function(value, nextValue) {
     *       // some value comparisons which will return -1, 0 or 1...
     *     }
     *   }
     * }
     *
     * // enable the `ColumnSorting` plugin
     * columnSorting: {
     *   // at initialization, sort column 1 in ascending order
     *   initialConfig: {
     *     column: 1,
     *     sortOrder: 'asc'
     *   },
     *   // at initialization, sort column 2 in descending order
     *   initialConfig: {
     *     column: 2,
     *     sortOrder: 'desc'
     *   }
     * }
     * ```
     */
    columnSorting: undefined,
    /**
     * @description
     * The `columnSummary` option configures the [`ColumnSummary`](@/api/columnSummary.md) plugin.
     *
     * You can set the `columnSummary` option to an array of objects.
     * Each object configures a single column summary, using the following properties:
     *
     * | Property                 | Possible values                                                         | Description                                                                                                                  |
     * | ------------------------ | ----------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
     * | `sourceColumn`           | A number                                                                | [Column to summarize](@/guides/columns/column-summary/column-summary.md#step-2-select-cells-that-you-want-to-summarize)                     |
     * | `ranges`                 | An array                                                                | [Ranges of rows to summarize](@/guides/columns/column-summary/column-summary.md#step-2-select-cells-that-you-want-to-summarize)             |
     * | `type`                   | `'sum'` \| `'min'` \| `'max'` \| `'count'` \| `'average'` \| `'custom'` | [Summary function](@/guides/columns/column-summary/column-summary.md#step-3-calculate-your-summary)                                         |
     * | `destinationRow`         | A number                                                                | [Destination cell's row coordinate](@/guides/columns/column-summary/column-summary.md#step-4-provide-the-destination-cell-s-coordinates)    |
     * | `destinationColumn`      | A number                                                                | [Destination cell's column coordinate](@/guides/columns/column-summary/column-summary.md#step-4-provide-the-destination-cell-s-coordinates) |
     * | `forceNumeric`           | `true`  \| `false`                                                      | [Treat non-numerics as numerics](@/guides/columns/column-summary/column-summary.md#force-numeric-values)                                  |
     * | `reversedRowCoords`      | `true`  \| `false`                                                      | [Reverse row coordinates](@/guides/columns/column-summary/column-summary.md#step-5-make-room-for-the-destination-cell)                      |
     * | `suppressDataTypeErrors` | `true`  \| `false`                                                      | [Suppress data type errors](@/guides/columns/column-summary/column-summary.md#throw-data-type-errors)                                    |
     * | `readOnly`               | `true`  \| `false`                                                      | Make summary cell read-only                                                                                                  |
     * | `roundFloat`             | `true`  \| `false`  \| A number                                         | [Round summary result](@/guides/columns/column-summary/column-summary.md#round-a-column-summary-result)                                  |
     * | `customFunction`         | A function                                                              | [Custom summary function](@/guides/columns/column-summary/column-summary.md#implement-a-custom-summary-function)                         |
     *
     * Read more:
     * - [Column summary](@/guides/columns/column-summary/column-summary.md)
     * - [Plugins: `ColumnSummary`](@/api/columnSummary.md)
     *
     * @memberof Options#
     * @type {object[]|Function}
     * @default undefined
     * @category ColumnSummary
     *
     * @example
     * ```js
     * columnSummary: [
     *   {
     *     sourceColumn: 0,
     *     ranges: [
     *       [0, 2], [4], [6, 8]
     *     ],
     *     type: 'custom',
     *     destinationRow: 4,
     *     destinationColumn: 1,
     *     forceNumeric: true,
     *     reversedRowCoords: true,
     *     suppressDataTypeErrors: false,
     *     readOnly: true,
     *     roundFloat: false,
     *     customFunction(endpoint) {
     *        return 100;
     *     }
     *   }
     * ],
     * ```
     */
    columnSummary: undefined,
    /**
     * The `colWidths` option sets columns' widths, in pixels.
     *
     * The default column width is 50px. To change it, set the `colWidths` option to one of the following:
     *
     * | Setting     | Description                                                                                          | Example                                                           |
     * | ----------- | ---------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
     * | A number    | Set the same width for every column                                                                  | `colWidths: 100`                                                  |
     * | A string    | Set the same width for every column                                                                  | `colWidths: '100px'`                                              |
     * | An array    | Set widths separately for each column                                                                | `colWidths: [100, 120, undefined]`                                |
     * | A function  | Set column widths dynamically,<br>on each render                                                     | `colWidths(visualColumnIndex) { return visualColumnIndex * 10; }` |
     * | `undefined` | Used by the [modifyColWidth](@/api/hooks.md#modifyColWidth) hook,<br>to detect column width changes. | `colWidths: undefined`                                            |
     *
     * Setting `colWidths` even for a single column disables the {@link AutoColumnSize} plugin
     * for all columns. For this reason, if you use `colWidths`, we recommend you set a width for each one
     * of your columns. Otherwise, every column with an undefined width defaults back to 50px,
     * which may cut longer columns names.
     *
     * Read more:
     * - [Column width](@/guides/columns/column-width/column-width.md)
     * - [Hooks: `modifyColWidth`](@/api/hooks.md#modifyColWidth)
     * - [`autoColumnSize`](#autoColumnSize)
     *
     * @memberof Options#
     * @type {number|number[]|string|string[]|Array<undefined>|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set every column's width to 100px
     * colWidths: 100,
     *
     * // set every column's width to 100px
     * colWidths: '100px',
     *
     * // set the first (by visual index) column's width to 100
     * // set the second (by visual index) column's width to 120
     * // set the third (by visual index) column's width to `undefined`, so that it defaults to 50px
     * // set any other column's width to the default 50px (note that longer cell values and column names can get cut)
     * colWidths: [100, 120, undefined],
     *
     * // set each column's width individually, using a function
     * colWidths(visualColumnIndex) {
     *   return visualColumnIndex * 10;
     * },
     * ```
     */
    colWidths: undefined,
    /**
     * The `commentedCellClassName` option lets you add a CSS class name to cells
     * that have comments.
     *
     * Read more:
     * - [Comments](@/guides/cell-features/comments/comments.md)
     * - [`comments`](#comments)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htCommentCell'
     * @category Core
     *
     * @example
     * ```js
     * // add a `has-comment` CSS class name
     * // to each cell that has a comment
     * commentedCellClassName: 'has-comment',
     * ```
     */
    commentedCellClassName: 'htCommentCell',
    /**
     * @description
     * The `comments` option configures the [`Comments`](@/api/comments.md) plugin.
     *
     * You can set the `comments` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                           |
     * | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`    | - Enable the [`Comments`](@/api/comments.md) plugin<br>- Add comment menu items to the [context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)                                 |
     * | `false`   | Disable the [`Comments`](@/api/comments.md) plugin                                                                                                                                    |
     * | An object | - Enable the [`Comments`](@/api/comments.md) plugin<br>- Add comment menu items to the [context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)<br>- Configure comment settings |
     *
     * If you set the `comments` option to an object, you can configure the following comment options:
     *
     * | Option         | Possible settings           | Description                                         |
     * | -------------- | --------------------------- | --------------------------------------------------- |
     * | `displayDelay` | A number (default: `250`)   | Display comments after a delay (in milliseconds)    |
     * | `readOnly`     | `true` \| `false` (default) | `true`: Make comments read-only                     |
     * | `style`        | An object                   | Set comment boxes' `width` and `height` (in pixels) |
     *
     * Read more:
     * - [Comments](@/guides/cell-features/comments/comments.md)
     * - [Context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)
     * - [`width`](#width)
     * - [`height`](#height)
     * - [`readOnly`](#readOnly)
     * - [`commentedCellClassName`](#commentedCellClassName)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category Comments
     *
     * @example
     * ```js
     * // enable the `Comments` plugin
     * comments: true,
     *
     * // enable the `Comments` plugin
     * // and configure its settings
     * comments: {
     *   // display all comments with a 1-second delay
     *   displayDelay: 1000,
     *   // make all comments read-only
     *   readOnly: true,
     *   // set the default size of all comment boxes
     *   style: {
     *     width: 300,
     *     height: 100
     *   }
     * }
     * ```
     */
    comments: false,
    /**
     * @description
     * The `contextMenu` option configures the [`ContextMenu`](@/api/contextMenu.md) plugin.
     *
     * You can set the `contextMenu` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                                             |
     * | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`ContextMenu`](@/api/contextMenu.md) plugin                                                                                                                                                |
     * | `true`    | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Use the [default context menu options](@/guides/accessories-and-menus/context-menu/context-menu.md#context-menu-with-default-options)                 |
     * | An array  | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Modify [individual context menu options](@/guides/accessories-and-menus/context-menu/context-menu.md#context-menu-with-specific-options)              |
     * | An object | - Enable the [`ContextMenu`](@/api/contextMenu.md) plugin<br>- Apply a [custom context menu configuration](@/guides/accessories-and-menus/context-menu/context-menu.md#context-menu-with-a-fully-custom-configuration) |
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)
     * - [Context menu: Context menu with default options](@/guides/accessories-and-menus/context-menu/context-menu.md#context-menu-with-default-options)
     * - [Context menu: Context menu with specific options](@/guides/accessories-and-menus/context-menu/context-menu.md#context-menu-with-specific-options)
     * - [Context menu: Context menu with fully custom configuration options](@/guides/accessories-and-menus/context-menu/context-menu.md#context-menu-with-a-fully-custom-configuration)
     * - [Plugins: `ContextMenu`](@/api/contextMenu.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|object}
     * @default undefined
     * @category ContextMenu
     *
     * @example
     * ```js
     * // enable the `ContextMenu` plugin
     * // use the default context menu options
     * contextMenu: true,
     *
     * // enable the `ContextMenu` plugin
     * // and modify individual context menu options
     * contextMenu: ['row_above', 'row_below', '---------', 'undo', 'redo'],
     *
     * // enable the `ContextMenu` plugin
     * // and apply a custom context menu configuration
     * contextMenu: {
     *   items: {
     *     'option1': {
     *       name: 'Option 1'
     *     },
     *     'option2': {
     *       name: 'Option 2',
     *       submenu: {
     *         items: [
     *           {
     *             key: 'option2:suboption1',
     *             name: 'Suboption 1',
     *             callback: function(key, options) {
     *               ...
     *             }
     *           },
     *           ...
     *         ]
     *       }
     *     }
     *   }
     * },
     * ```
     */
    contextMenu: undefined,
    /**
     * @description
     * The `copyable` option determines whether a cell's value can be copied to the clipboard or not.
     *
     * You can set the `copyable` option to one of the following:
     *
     * | Setting                                                                                                        | Description                                                                                                            |
     * | -------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default)                                                                                               | - On pressing <kbd>**Ctrl**</kbd>/<kbd>**Cmd**</kbd>+<kbd>**C**</kbd>, add the cell's value to the clipboard         |
     * | `false`<br>(default for the [`password`](@/guides/cell-types/password-cell-type/password-cell-type.md) [cell type](#type))        | - On pressing <kbd>**Ctrl**</kbd>/<kbd>**Cmd**</kbd>+<kbd>**C**</kbd>, add an empty string (`""`) to the clipboard   |
     *
     * Read more:
     * - [Clipboard](@/guides/cell-features/clipboard/clipboard.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options/configuration-options.md#cascading-configuration)
     * - [Password cell type](@/guides/cell-types/password-cell-type/password-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // enable copying for each cell of the entire grid
     * copyable: true,
     *
     * // enable copying for individual columns
     * columns: [
     *   {
     *     // enable copying for each cell of this column
     *     copyable: true
     *   },
     *   {
     *     // disable copying for each cell of this column
     *     copyable: false
     *   }
     * ]
     *
     * // enable copying for specific cells
     * cell: [
     *   {
     *     col: 0,
     *     row: 0,
     *     // disable copying for cell (0, 0)
     *     copyable: false,
     *   }
     * ],
     * ```
     */
    copyable: true,
    /**
     * The `copyPaste` option configures the [`CopyPaste`](@/api/copyPaste.md) plugin.
     *
     * You can set the `copyPaste` option to one of the following:
     *
     * | Setting           | Description                                                                                                            |
     * | ----------------- | ---------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default)  | Enable the [`CopyPaste`](@/api/copyPaste.md) plugin with the default configuration                                     |
     * | `false`           | Disable the [`CopyPaste`](@/api/copyPaste.md) plugin                                                                   |
     * | An object         | - Enable the [`CopyPaste`](@/api/copyPaste.md) plugin<br>- Modify the [`CopyPaste`](@/api/copyPaste.md) plugin options |
     *
     * ##### copyPaste: Additional options
     *
     * If you set the `copyPaste` option to an object, you can set the following `CopyPaste` plugin options:
     *
     * | Option                   | Possible settings                                  | Description                                                                                                                                                                                         |
     * | ------------------------ | -------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `columnsLimit`           | A number (default: `Infinity`)                     | The maximum number of columns that can be copied                                                                                                                                                    |
     * | `rowsLimit`              | A number (default: `Infinity`)                     | The maximum number of columns that can be copied                                                                                                                                                    |
     * | `pasteMode`              | `'overwrite'` \| `'shift_down'` \| `'shift_right'` | When pasting:<br>`'overwrite'`: overwrite the currently-selected cells<br>`'shift_down'`: move the currently-selected cells down<br>`'shift_right'`: move the currently-selected cells to the right |
     * | `copyColumnHeaders`      | Boolean (default: `false`)                         | `true`: add a context menu option for copying cells along with their nearest column headers                                                                                                         |
     * | `copyColumnGroupHeaders` | Boolean (default: `false`)                         | `true`: add a context menu option for copying cells along with all their related columns headers                                                                                                    |
     * | `copyColumnHeadersOnly`  | Boolean (default: `false`)                         | `true`: add a context menu option for copying column headers nearest to the selected cells (without copying cells)                                                                    |
     * | `uiContainer`            | An HTML element                                    | The UI container for the secondary focusable element                                                                                                                                                |
     *
     * Read more:
     * - [Plugins: `CopyPaste`](@/api/copyPaste.md)
     * - [Guides: Clipboard](@/guides/cell-features/clipboard/clipboard.md)
     *
     * @memberof Options#
     * @type {object|boolean}
     * @default true
     * @category CopyPaste
     *
     * @example
     * ```js
     * // enable the plugin with the default configuration
     * copyPaste: true // set by default
     *
     * // disable the plugin
     * copyPaste: false,
     *
     * // enable the plugin with a custom configuration
     * copyPaste: {
     *   // set a maximum number of columns that can be copied
     *   columnsLimit: 25,
     *
     *   // set a maximum number of rows that can be copied
     *   rowsLimit: 50,
     *
     *   // set the paste behavior
     *   pasteMode: 'shift_down',
     *
     *   // add the option to copy cells along with their nearest column headers
     *   copyColumnHeaders: true,
     *
     *   // add the option to copy cells along with all their related columns headers
     *   copyColumnGroupHeaders: true,
     *
     *   // add the option to copy just column headers (without copying cells)
     *   copyColumnHeadersOnly: true,
     *
     *   // set a UI container
     *   uiContainer: document.body,
     * },
     * ```
     */
    copyPaste: true,
    /**
     * The `correctFormat` option configures whether incorrectly-formatted times and dates are amended or not.
     *
     * When the user enters dates and times, Handsontable can automatically adjust their format
     * to match the [`dateFormat`](#dateFormat) and [`timeFormat`](@/guides/cell-types/time-cell-type/time-cell-type.md) settings.
     *
     * You can set the `correctFormat` option to one of the following:
     *
     * | Setting           | Description                                                                                                                                               |
     * | ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Don't correct the format of the entered date or time (treat the entered date or time as invalid)                                                          |
     * | `true`            | Correct the format of the entered date or time to match the [`dateFormat`](#dateFormat) or [`timeFormat`](@/guides/cell-types/time-cell-type/time-cell-type.md) settings |
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type/date-cell-type.md)
     * - [Time cell type](@/guides/cell-types/time-cell-type/time-cell-type.md)
     * - [`dateFormat`](#dateFormat)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `date`
     *   type: 'date',
     *   // for every `date` cell of this column, set the date format to `YYYY-MM-DD`
     *   dateFormat: 'YYYY-MM-DD',
     *   // enforce the `YYYY-MM-DD` date format
     *   correctFormat: true
     *   },
     *
     *   {
     *   // set the `type` of each cell in this column to `time`
     *   type: 'time',
     *   // for every `time` cell of this column, set the time format to `h:mm:ss a`
     *   timeFormat: 'h:mm:ss a',
     *   // enforce the `h:mm:ss a` time format
     *   correctFormat: true
     *   },
     * ],
     * ```
     */
    correctFormat: false,
    /**
     * The `currentColClassName` option lets you add a CSS class name
     * to each cell of the currently-visible, currently-selected columns.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to each cell of the currently-visible, currently-selected columns
     * currentColClassName: 'your-class-name',
     * ```
     */
    currentColClassName: undefined,
    /**
     * The `currentHeaderClassName` option lets you add a CSS class name
     * to every currently-visible, currently-selected header.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'ht__highlight'
     * @category Core
     *
     * @example
     * ```js
     * // add an `ht__highlight` CSS class name
     * // to every currently-visible, currently-selected header
     * currentHeaderClassName: 'ht__highlight',
     * ```
     */
    currentHeaderClassName: 'ht__highlight',
    /**
     * The `currentRowClassName` option lets you add a CSS class name
     * to each cell of the currently-visible, currently-selected rows.
     *
     * Read more:
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to each cell of the currently-visible, currently-selected rows
     * currentRowClassName: 'your-class-name',
     * ```
     */
    currentRowClassName: undefined,
    /**
     * @description
     * The `customBorders` option configures the [`CustomBorders`](@/api/customBorders.md) plugin.
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * (and add its menu items to the [context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)),
     * set the `customBorders` option to `true`.
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * and add a predefined border around a particular cell,
     * set the `customBorders` option to an array of objects.
     * Each object represents a border configuration for one cell, and has the following properties:
     *
     * | Property | Sub-properties     | Types                              | Description                                                       |
     * | -------- | ------------------ | ---------------------------------- | ----------------------------------------------------------------- |
     * | `row`    | -                  | `row`: Number                      | The cell's row coordinate.                                        |
     * | `col`    | -                  | `col`: Number                      | The cell's column coordinate.                                     |
     * | `start`  | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is LTR (default): `start` sets the width (`width`) and color (`color`) of the left-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is RTL: `start` sets the width (`width`) and color (`color`) of the right-hand border. |
     * | `end`    | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is LTR (default): `end` sets the width (`width`) and color (`color`) of the right-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is RTL: `end` sets the width (`width`) and color (`color`) of the left-hand border. |
     * | `top`    | `width`<br>`color` | `width`: Number<br>`color`: String | Sets the width (`width`) and color (`color`) of the top border. |
     * | `bottom` | `width`<br>`color` | `width`: Number<br>`color`: String | Sets the width (`width`) and color (`color`) of the bottom border. |
     *
     * To enable the [`CustomBorders`](@/api/customBorders.md) plugin
     * and add a predefined border around a range of cells,
     * set the `customBorders` option to an array of objects.
     * Each object represents a border configuration for a single range of cells, and has the following properties:
     *
     * | Property | Sub-properties                               | Types                                                            | Description                                                                                  |
     * | -------- | -------------------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------- |
     * | `range`  | `from` {`row`, `col`}<br>`to` {`row`, `col`} | `from`: Object<br>`to`: Object<br>`row`: Number<br>`col`: Number | If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is LTR (default):<br>- `from` selects the range's top-left corner.<br>- `to` selects the range's bottom-right corner.<br><br>If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is RTL: <br>- `from` selects the range's top-right corner.<br>- `to` selects the range's bottom-left corner. |
     * | `start`  | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is LTR (default): `start` sets the width (`width`) and color (`color`) of the left-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is RTL: `start` sets the width (`width`) and color (`color`) of the right-hand border. |
     * | `end`    | `width`<br>`color` | `width`: Number<br>`color`: String | If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is LTR (default): `end` sets the width (`width`) and color (`color`) of the right-hand border.<br><br>If the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is RTL: `end` sets the width (`width`) and color (`color`) of the left-hand border. |
     * | `top`    | `width`<br>`color`                           | `width`: Number<br>`color`: String                               | Sets the width (`width`) and color (`color`) of the top border. |
     * | `bottom` | `width`<br>`color`                           | `width`: Number<br>`color`: String                               | Sets the width (`width`) and color (`color`) of the bottom border. |
     *
     * Read more:
     * - [Formatting cells: Custom cell borders](@/guides/cell-features/formatting-cells/formatting-cells.md#custom-cell-borders)
     * - [Context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)
     * - [Plugins: `CustomBorders`](@/api/customBorders.md)
     * - [Layout direction](@/guides/internationalization/layout-direction/layout-direction.md)
     * - [`layoutDirection`](#layoutDirection)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category CustomBorders
     *
     * @example
     * ```js
     * // enable the `CustomBorders` plugin
     * customBorders: true,
     *
     * // enable the `CustomBorders` plugin
     * // and add a predefined border for a particular cell
     * customBorders: [
     *   // add an object with a border configuration for one cell
     *   {
     *     // set the cell's row coordinate
     *     row: 2,
     *     // set the cell's column coordinate
     *     col: 2,
     *     // set the left/right border's width and color
     *     start: {
     *       width: 2,
     *       color: 'red'
     *     },
     *     // set the right/left border's width and color
     *     end: {
     *       width: 1,
     *       color: 'green'
     *     },
     *     // set the top border's width and color
     *     top: '',
     *     // set the bottom border's width and color
     *     bottom: ''
     *   }
     * ],
     *
     * // enable the `CustomBorders` plugin
     * // and add a predefined border for a range of cells
     * customBorders: [
     *   // add an object with a border configuration for one range of cells
     *   {
     *     // select a range of cells
     *     range: {
     *       // set the range's top-left corner
     *       from: {
     *         row: 1,
     *         col: 1
     *       },
     *       // set the range's bottom-right corner
     *       to: {
     *         row: 3,
     *         col: 4
     *       }
     *     },
     *     // set the left/right border's width and color
     *     start: {
     *       width: 2,
     *       color: 'red'
     *     },
     *     // set the right/left border's width and color
     *     end: {},
     *     // set the top border's width and color
     *     top: {},
     *     // set the bottom border's width and color
     *     bottom: {}
     *   }
     * ],
     * ```
     */
    customBorders: false,
    /**
     * @description
     * The `data` option sets the initial [data](@/guides/getting-started/binding-to-data/binding-to-data.md) of your Handsontable instance.
     *
     * Handsontable's data is bound to your source data by reference (i.e. when you edit Handsontable's data, your source data alters as well).
     *
     * You can set the `data` option:
     * - Either to an [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays).
     * - Or to an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects).
     *
     * If you don't set the `data` option (or set it to `null`), Handsontable renders as an empty 5x5 grid by default.
     *
     * Read more:
     * - [Binding to data](@/guides/getting-started/binding-to-data/binding-to-data.md)
     * - [`dataSchema`](#dataSchema)
     * - [`startRows`](#startRows)
     * - [`startCols`](#startCols)
     *
     * @memberof Options#
     * @type {Array[]|object[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // as an array of arrays
     * data: [
     *   ['A', 'B', 'C'],
     *   ['D', 'E', 'F'],
     *   ['G', 'H', 'J']
     * ]
     *
     * // as an array of objects
     * data: [
     *   {id: 1, name: 'Ted Right'},
     *   {id: 2, name: 'Frank Honest'},
     *   {id: 3, name: 'Joan Well'},
     *   {id: 4, name: 'Gail Polite'},
     *   {id: 5, name: 'Michael Fair'},
     * ]
     * ```
     */
    data: undefined,
    /**
     * @description
     * If `true`, Handsontable will interpret the dots in the columns mapping as a nested object path. If your dataset contains
     * the dots in the object keys and you don't want Handsontable to interpret them as a nested object path, set this option to `false`.
     *
     * The option only works when defined in the global table settings.
     *
     * @since 14.4.0
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // All dots are interpreted as nested object paths
     * dataDotNotation: true,
     * data: [
     *   { id: 1, name: { first: 'Ted', last: 'Right' }, user: { address: '1234 Any Street' } },
     * ],
     * columns={[
     *   { data: 'name.first' },
     *   { data: 'user.address' },
     * ]},
     * ```
     * ```js
     * // All dots are interpreted as simple object keys
     * dataDotNotation: false,
     * data: [
     *   { id: 1, 'name.first': 'Ted', 'user.address': '1234 Any Street' },
     * ],
     * columns={[
     *   { data: 'name.first' },
     *   { data: 'user.address' },
     * ]},
     * ```
     */
    dataDotNotation: true,
    /**
     * @description
     * When the [`data`](#data) option is set to an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects)
     * (or is empty), the `dataSchema` option defines the structure of new rows.
     *
     * Using the `dataSchema` option, you can start out with an empty grid.
     *
     * You can set the `dataSchema` option to one of the following:
     * - An object
     * - A function
     *
     * Read more:
     * - [Binding to data: Array of objects with custom data schema](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects-with-custom-data-schema)
     * - [Binding to data: Function data source and schema](@/guides/getting-started/binding-to-data/binding-to-data.md#function-data-source-and-schema)
     * - [`data`](#data)
     *
     * @memberof Options#
     * @type {object|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // with `dataSchema`, you can start with an empty grid
     * data: null,
     * dataSchema: {id: null, name: {first: null, last: null}, address: null},
     * colHeaders: ['ID', 'First Name', 'Last Name', 'Address'],
     * columns: [
     *   {data: 'id'},
     *   {data: 'name.first'},
     *   {data: 'name.last'},
     *   {data: 'address'}
     * ],
     * startRows: 5,
     * minSpareRows: 1
     * ```
     */
    dataSchema: undefined,
    /**
     * The `dateFormat` option configures the date format accepted by [`date`](@/guides/cell-types/date-cell-type/date-cell-type.md) cells.
     *
     * You can set the `dateFormat` option to a string with a proper date format. The default value is: `'DD/MM/YYYY'`.
     *
     * To automatically correct dates whose format doesn't match the `dateFormat` setting, use the [`correctFormat`](#correctFormat) option.
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type/date-cell-type.md)
     * - [`correctFormat`](#correctFormat)
     * - [`defaultDate`](#defaultDate)
     *
     * @memberof Options#
     * @type {string}
     * @default 'DD/MM/YYYY'
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `date`
     *   type: 'date',
     *   // for every `date` cell of this column, set the date format to `YYYY-MM-DD`
     *   dateFormat: 'YYYY-MM-DD',
     *   },
     * ],
     * ```
     */
    dateFormat: 'DD/MM/YYYY',
    /**
     * The `timeFormat` option configures the time format accepted by [`time`](@/guides/cell-types/time-cell-type/time-cell-type.md) cells.
     *
     * You can set the `timeFormat` option to a string with a proper time format. The default value is: `'h:mm:ss a'`.
     *
     * To automatically correct times whose format doesn't match the `timeFormat` setting, use the [`correctFormat`](#correctFormat) option.
     *
     * Read more:
     * - [Time cell type](@/guides/cell-types/time-cell-type/time-cell-type.md)
     * - [`correctFormat`](#correctFormat)
     *
     * @memberof Options#
     * @type {string}
     * @default 'h:mm:ss a'
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `time`
     *   type: 'time',
     *   // for every `time` cell of this column, set the time format to `h:mm:ss a`
     *   timeFormat: 'h:mm:ss a',
     *   },
     * ],
     * ```
     */
    timeFormat: 'h:mm:ss a',
    /**
     * The `datePickerConfig` option configures the `date` [cell editor](@/guides/cell-functions/cell-editor/cell-editor.md)'s date picker, which uses an external dependency: [Pikaday](https://github.com/Pikaday/Pikaday/tree/1.8.2).
     *
     * You can set the `datePickerConfig` option to an object with any of the available [Pikaday options](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration),
     * except for the following, which are always overwritten by the `date` [cell editor](@/guides/cell-functions/cell-editor/cell-editor.md):
     * - `bound`
     * - `container`
     * - `field`
     * - `trigger`
     *
     * If the `datePickerConfig` option is not defined, the `date` [cell editor](@/guides/cell-functions/cell-editor/cell-editor.md) overwrites the following [Pikaday options](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration) as well:
     *
     * | Pikaday option       | Handsontable's setting |
     * | -------------------- | ---------------------- |
     * | `format`             | `'DD/MM/YYYY'`         |
     * | `reposition`         | `false`                |
     *
     * Read more:
     * - [`editor`](#editor)
     * - [`dateFormat`](#dateFormat)
     * - [Cell editor](@/guides/cell-functions/cell-editor/cell-editor.md)
     * - [All Pikaday options &#8594;](https://github.com/Pikaday/Pikaday/tree/1.8.2#configuration)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Core
     */
    datePickerConfig: undefined,
    /**
     * The `defaultDate` option configures the date displayed
     * in empty [`date`](@/guides/cell-types/date-cell-type/date-cell-type.md) cells.
     *
     * You can set the `defaultDate` option to a string.
     *
     * Read more:
     * - [Date cell type](@/guides/cell-types/date-cell-type/date-cell-type.md)
     * - [`dateFormat`](#dateFormat)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `date`
     *     type: 'date',
     *     // in every empty `date` cell of this column, display `2015-02-02`
     *     defaultDate: '2015-02-02'
     *   }
     * ],
     * ```
     */
    defaultDate: undefined,
    /**
     * @description
     * The `disableVisualSelection` option configures how
     * [selection](@/guides/cell-features/selection/selection.md) is shown.
     *
     * You can set the `disableVisualSelection` option to one of the following:
     *
     * | Setting           | Description                                                                                         |
     * | ----------------- | --------------------------------------------------------------------------------------------------- |
     * | `false` (default) | - Show single-cell selection<br>- Show range selection<br>- Show header selection                   |
     * | `true`            | - Don't show single-cell selection<br>- Don't show range selection<br>- Don't show header selection |
     * | `'current'`       | - Don't show single-cell selection<br>- Show range selection<br>- Show header selection             |
     * | `'area'`          | - Show single-cell selection<br>- Don't show range selection<br>- Show header selection             |
     * | `'header'`        | - Show single-cell selection<br>- Show range selection<br>- Don't show header selection             |
     * | An array          | A combination of `'current'`, `'area'`, and/or `'header'`                                           |
     *
     * Read more:
     * - [Selection](@/guides/cell-features/selection/selection.md)
     *
     * @memberof Options#
     * @type {boolean|string|string[]}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // don't show single-cell selection
     * // don't show range selection
     * // don't show header selection
     * disableVisualSelection: true,
     *
     * // don't show single-cell selection
     * // show range selection
     * // show header selection
     * disableVisualSelection: 'current',
     *
     * // don't show single-cell selection
     * // don't show range selection
     * // show header selection
     * disableVisualSelection: ['current', 'area'],
     * ```
     */
    disableVisualSelection: false,
    /**
     * @description
     * The `dragToScroll` option configures the [`DragToScroll`](@/api/dragToScroll.md) plugin.
     *
     * You can set the `dragToScroll` option to one of the following:
     *
     * | Setting          | Description                                                                 |
     * | ---------------- | --------------------------------------------------------------------------- |
     * | `true` (default) | When selection reaches the edge of the grid's viewport, scroll the viewport |
     * | `false`          | Don't scroll the viewport                                                   |
     *
     * Read more:
     * - [Plugins: `DragToScroll`](@/api/dragToScroll.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category DragToScroll
     *
     * @example
     * ```js
     * // when selection reaches the edge of the grid's viewport, scroll the viewport
     * dragToScroll: true,
     * ```
     */
    dragToScroll: true,
    /**
     * The `dropdownMenu` option configures the [`DropdownMenu`](@/api/dropdownMenu.md) plugin.
     *
     * You can set the `dropdownMenu` option to one of the following:
     *
     * | Setting   | Description                                                                                                                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin                                                                                                                                   |
     * | `true`    | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Use the [default context menu options](@/guides/accessories-and-menus/context-menu/context-menu.md#context-menu-with-default-options)    |
     * | An array  | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Modify [individual context menu options](@/guides/accessories-and-menus/context-menu/context-menu.md#context-menu-with-specific-options) |
     * | An object | - Enable the [`DropdownMenu`](@/api/dropdownMenu.md) plugin<br>- Apply a custom dropdown menu configuration                                                                                  |
     *
     * Read more:
     * - [Context menu](@/guides/accessories-and-menus/context-menu/context-menu.md)
     * - [Plugins: `DropdownMenu`](@/api/dropdownMenu.md)
     *
     * @memberof Options#
     * @type {boolean|object|string[]}
     * @default undefined
     * @category DropdownMenu
     *
     * @example
     * ```js
     * // enable the `DropdownMenu` plugin
     * // use the default context menu options
     * dropdownMenu: true,
     *
     * // enable the `DropdownMenu` plugin
     * // and modify individual context menu options
     * dropdownMenu: ['---------', 'undo', 'redo'],
     *
     * // enable the `DropdownMenu` plugin
     * // and apply a custom dropdown menu configuration
     * dropdownMenu: {
     *   items: {
     *     'option1': {
     *       name: 'Option 1'
     *     },
     *     'option2': {
     *       name: 'Option 2',
     *       submenu: {
     *         items: [
     *           {
     *             key: 'option2:suboption1',
     *             name: 'Suboption 1',
     *             callback(key, options) {
     *               ...
     *             }
     *           },
     *           ...
     *         ]
     *       }
     *     }
     *   }
     * },
     * ```
     */
    dropdownMenu: undefined,
    /**
     * The `editor` option sets a [cell editor](@/guides/cell-functions/cell-editor/cell-editor.md) for a cell.
     *
     * You can set the `editor` option to one of the following [cell editor aliases](@/guides/cell-functions/cell-editor/cell-editor.md):
     *
     * | Alias               | Cell editor function                                                       |
     * | ------------------- | -------------------------------------------------------------------------- |
     * | A custom alias      | Your [custom cell editor](@/guides/cell-functions/cell-editor/cell-editor.md) function |
     * | `'autocomplete'`    | `AutocompleteEditor`                                                       |
     * | `'base'`            | `BaseEditor`                                                               |
     * | `'checkbox'`        | `CheckboxEditor`                                                           |
     * | `'date'`            | `DateEditor`                                                               |
     * | `'dropdown'`        | `DropdownEditor`                                                           |
     * | `'handsontable'`    | `HandsontableEditor`                                                       |
     * | `'numeric'`         | `NumericEditor`                                                            |
     * | `'password'`        | `PasswordEditor`                                                           |
     * | `'select'`          | `SelectEditor`                                                             |
     * | `'text'`            | `TextEditor`                                                               |
     * | `'time'`            | `TimeEditor`                                                               |
     *
     * To disable editing cells through cell editors,
     * set the `editor` option to `false`.
     * You'll still be able to change cells' content through Handsontable's API
     * or through plugins (e.g. [`CopyPaste`](@/api/copyPaste.md)), though.
     *
     * To set the [`editor`](#editor), [`renderer`](#renderer), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell editor](@/guides/cell-functions/cell-editor/cell-editor.md)
     * - [Cell type](@/guides/cell-types/cell-type/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options/configuration-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {string|Function|boolean}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // use the `numeric` editor for each cell of the entire grid
     * editor: 'numeric',
     *
     * // apply the `editor` option to individual columns
     * columns: [
     *   {
     *     // use the `autocomplete` editor for each cell of this column
     *     editor: 'autocomplete'
     *   },
     *   {
     *     // disable editing cells through cell editors for each cell of this column
     *     editor: false
     *   }
     * ]
     * ```
     */
    editor: undefined,
    /**
     * The `enterBeginsEditing` option configures the action of the <kbd>**Enter**</kbd> key.
     *
     * You can set the `enterBeginsEditing` option to one of the following:
     *
     * | Setting          | Description                                                                                                                                                                                               |
     * | ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | - On pressing <kbd>**Enter**</kbd> once, enter the editing mode of the active cell<br>- On pressing <kbd>**Enter**</kbd> twice, move to another cell,<br>as configured by the [`enterMoves`](#enterMoves) setting |
     * | `false`          | - On pressing <kbd>**Enter**</kbd> once, move to another cell,<br>as configured by the [`enterMoves`](#enterMoves) setting                                                                                    |
     *
     * Read more:
     * - [`enterMoves`](#enterMoves)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // press Enter once to start editing
     * // press Enter twice to move to another cell
     * enterBeginsEditing: true,
     *
     * // press Enter once to move to another cell
     * enterBeginsEditing: false,
     * ```
     */
    enterBeginsEditing: true,
    /**
     * The `enterMoves` option configures the action of the <kbd>**Enter**</kbd> key.
     *
     * If the [`enterBeginsEditing`](#enterBeginsEditing) option is set to `true`,
     * the `enterMoves` setting applies to the **second** pressing of the <kbd>**Enter**</kbd> key.
     *
     * If the [`enterBeginsEditing`](#enterBeginsEditing) option is set to `false`,
     * the `enterMoves` setting applies to the **first** pressing of the <kbd>**Enter**</kbd> key.
     *
     * You can set the `enterMoves` option to an object with the following properties
     * (or to a function that returns such an object):
     *
     * | Property | Type   | Description                                                                                                                                              |
     * | -------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `col`    | Number | - On pressing <kbd>**Enter**</kbd>, move selection `col` columns right<br>- On pressing <kbd>**Shift**</kbd>+<kbd>**Enter**</kbd>, move selection `col` columns left |
     * | `row`    | Number | - On pressing <kbd>**Enter**</kbd>, move selection `row` rows down<br>- On pressing <kbd>**Shift**</kbd>+<kbd>**Enter**</kbd>, move selection `row` rows up          |
     *
     * Read more:
     * - [`enterBeginsEditing`](#enterBeginsEditing)
     *
     * @memberof Options#
     * @type {object|Function}
     * @default {col: 0, row: 1}
     * @category Core
     *
     * @example
     * ```js
     * // on pressing Enter, move selection 1 column right and 1 row down
     * // on pressing Shift+Enter, move selection 1 column left and 1 row up
     * enterMoves: {col: 1, row: 1},
     *
     * // the same setting, as a function
     * // `event` is a DOM Event object received on pressing Enter
     * // you can use it to check whether the user pressed Enter or Shift+Enter
     * enterMoves(event) {
     *   return {col: 1, row: 1};
     * },
     * ```
     */
    enterMoves: {
      col: 0,
      row: 1
    },
    /**
     * The `fillHandle` option configures the [Autofill](@/api/autofill.md) plugin.
     *
     * You can set the `fillHandle` option to one the following:
     *
     * | Setting        | Description                                                                |
     * | -------------- | -------------------------------------------------------------------------- |
     * | `true`         | - Enable autofill in all directions<br>- Add the fill handle               |
     * | `false`        | Disable autofill                                                           |
     * | `'vertical'`   | - Enable vertical autofill<br>- Add the fill handle                        |
     * | `'horizontal'` | - Enable horizontal autofill<br>- Add the fill handle                      |
     * | An object      | - Enable autofill<br>- Add the fill handle<br>- Configure autofill options |
     *
     * If you set the `fillHandle` option to an object, you can configure the following autofill options:
     *
     * | Option          | Possible settings              | Description                                                                                               |
     * | --------------- | ------------------------------ | --------------------------------------------------------------------------------------------------------- |
     * | `autoInsertRow` | `true` (default) \| `false`    | `true`: When you reach the grid's bottom, add new rows<br>`false`: When you reach the grid's bottom, stop |
     * | `direction`     | `'vertical'` \| `'horizontal'` | `'vertical'`: Enable vertical autofill<br>`'horizontal'`: Enable horizontal autofill                      |
     *
     * Read more:
     * - [AutoFill values](@/guides/cell-features/autofill-values/autofill-values.md)
     *
     * @memberof Options#
     * @type {boolean|string|object}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // enable autofill in all directions
     * // with `autoInsertRow` enabled
     * fillHandle: true,
     *
     * // enable vertical autofill
     * // with `autoInsertRow` enabled
     * fillHandle: 'vertical',
     *
     * // enable horizontal autofill
     * // with `autoInsertRow` enabled
     * fillHandle: 'horizontal',
     *
     * // enable autofill in all directions
     * // with `autoInsertRow` disabled
     * fillHandle: {
     *   autoInsertRow: false,
     * },
     *
     * // enable vertical autofill
     * // with `autoInsertRow` disabled
     * fillHandle: {
     *   autoInsertRow: false,
     *   direction: 'vertical'
     * },
     * ```
     */
    fillHandle: {
      autoInsertRow: false
    },
    /**
     * The `filter` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md) cells'
     * lists are updated by the end user's input.
     *
     * You can set the `filter` option to one of the following:
     *
     * | Setting          | Description                                                                                                           |
     * | ---------------- | --------------------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | When the end user types into the input area, only options matching the input are displayed                            |
     * | `false`          | When the end user types into the input area, all options are displayed<br>(options matching the input are put in bold |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * - [`source`](#source)
     * - [`filteringCaseSensitive`](#filteringCaseSensitive)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C'],
     *   // when the end user types in `A`, display only the A option
     *   // when the end user types in `B`, display only the B option
     *   // when the end user types in `C`, display only the C option
     *   filter: true
     * }],
     * ```
     */
    filter: true,
    /**
     * The `filteringCaseSensitive` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md) cells'
     * input is case-sensitive.
     *
     * You can set the `filteringCaseSensitive` option to one of the following:
     *
     * | Setting           | Description                                                                                        |
     * | ----------------- | -------------------------------------------------------------------------------------------------- |
     * | `false` (default) | [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md) cells' input is not case-sensitive |
     * | `true`            | [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md) cells' input is case-sensitive     |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * - [`source`](#source)
     * - [`filter`](#filter)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     source: [ ... ],
     *     // match case while searching autocomplete options
     *     filteringCaseSensitive: true
     *   }
     * ],
     * ```
     */
    filteringCaseSensitive: false,
    /**
     * The `filters` option configures the [`Filters`](@/api/filters.md) plugin.
     *
     * You can set the `filters` option to one of the following:
     *
     * | Setting | Description                                      |
     * | ------- | ------------------------------------------------ |
     * | `false` | Disable the [`Filters`](@/api/filters.md) plugin |
     * | `true`  | Enable the [`Filters`](@/api/filters.md) plugin  |
     *
     * Read more:
     * - [Column filter](@/guides/columns/column-filter/column-filter.md)
     * - [Plugins: `Filters`](@/api/filters.md)
     * - [`dropdownMenu`](#dropdownMenu)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category Filters
     *
     * @example
     * ```js
     * // enable the `Filters` plugin
     * filters: true,
     * ```
     */
    filters: undefined,
    /**
     * `fixedColumnsLeft` is a legacy option.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is LTR (default), `fixedColumnsLeft` acts like the [`fixedColumnsStart`](#fixedColumnsStart) option.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is RTL, using `fixedColumnsLeft` throws an error.
     *
     * Use [`fixedColumnsStart`](#fixedColumnsStart), which works in any layout direction.
     *
     * Read more:
     * - [`fixedColumnsStart`](#fixedcolumnsstart)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the first 3 columns from the left
     * fixedColumnsLeft: 3,
     * ```
     */
    fixedColumnsLeft: 0,
    /**
     * If your grid's [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is LTR (default), the `fixedColumnsStart` option sets the number of [frozen columns](@/guides/columns/column-freezing/column-freezing.md) at the left-hand edge of the grid.
     *
     * If your grid's [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) is RTL, the `fixedColumnsStart` option sets the number of [frozen columns](@/guides/columns/column-freezing/column-freezing.md) at the right-hand edge of the grid.
     *
     * Read more:
     * - [Column freezing](@/guides/columns/column-freezing/column-freezing.md)
     * - [Layout direction](@/guides/internationalization/layout-direction/layout-direction.md)
     * - [`fixedColumnsLeft`](#fixedcolumnsleft)
     * - [`layoutDirection`](#layoutDirection)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // when `layoutDirection` is set to `inherit` (default)
     * // freeze the first 3 columns from the left or from the right
     * // depending on your HTML document's `dir` attribute
     * layoutDirection: 'inherit',
     * fixedColumnsStart: 3,
     *
     * // when `layoutDirection` is set to `rtl`
     * // freeze the first 3 columns from the right
     * // regardless of your HTML document's `dir` attribute
     * layoutDirection: 'rtl',
     * fixedColumnsStart: 3,
     *
     * // when `layoutDirection` is set to `ltr`
     * // freeze the first 3 columns from the left
     * // regardless of your HTML document's `dir` attribute
     * layoutDirection: 'ltr',
     * fixedColumnsStart: 3,
     * ```
     */
    fixedColumnsStart: 0,
    /**
     * The `fixedRowsBottom` option sets the number of [frozen rows](@/guides/rows/row-freezing/row-freezing.md)
     * at the bottom of the grid.
     *
     * Read more:
     * - [Row freezing](@/guides/rows/row-freezing/row-freezing.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the bottom 3 rows
     * fixedRowsBottom: 3,
     * ```
     */
    fixedRowsBottom: 0,
    /**
     * The `fixedRowsTop` option sets the number of [frozen rows](@/guides/rows/row-freezing/row-freezing.md) at the top of the grid.
     *
     * Read more:
     * - [Row freezing](@/guides/rows/row-freezing/row-freezing.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // freeze the top 3 rows
     * fixedRowsTop: 3,
     * ```
     */
    fixedRowsTop: 0,
    /**
     * The `formulas` option configures the [`Formulas`](@/api/formulas.md) plugin.
     *
     * The [`Formulas`](@/api/formulas.md) plugin uses the [HyperFormula](https://handsontable.github.io/hyperformula/) calculation engine.
     * To install [HyperFormula](https://handsontable.github.io/hyperformula/), read the following:
     * - [Formula calculation: Initialization methods](@/guides/formulas/formula-calculation/formula-calculation.md#initialization-methods)
     *
     * You can set the `formulas` option to an object with the following properties:
     *
     * | Property    | Possible values                                                                                                                                                                                                        |
     * | ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `engine`    | `HyperFormula` \|<br>A [HyperFormula](https://handsontable.github.io/hyperformula/) instance \|<br>A [HyperFormula configuration](https://handsontable.github.io/hyperformula/api/interfaces/configparams.html) object |
     * | `sheetId`   | A number                                                                                                                                                                                                               |
     * | `sheetName` | A string                                                                                                                                                                                                               |
     *
     * Read more:
     * - [Plugins: `Formulas`](@/api/formulas.md)
     * - [Formula calculation](@/guides/formulas/formula-calculation/formula-calculation.md)
     * - [HyperFormula documentation: Client-side installation](https://handsontable.github.io/hyperformula/guide/client-side-installation)
     * - [HyperFormula documentation: Configuration options](https://handsontable.github.io/hyperformula/api/interfaces/configparams.html)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Formulas
     *
     * @example
     * ```js
     * // either add the `HyperFormula` class
     * formulas: {
     *   // set `engine` to `HyperFormula`
     *   engine: HyperFormula,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // or, add a HyperFormula instance
     * // initialized with the `'internal-use-in-handsontable'` license key
     * const hyperformulaInstance = HyperFormula.buildEmpty({
     *   licenseKey: 'internal-use-in-handsontable',
     * });
     *
     * formulas: {
     *   // set `engine` to a HyperFormula instance
     *   engine: hyperformulaInstance,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // or, add a HyperFormula configuration object
     * formulas: {
     *   // set `engine` to a HyperFormula configuration object
     *   engine: {
     *     hyperformula: HyperFormula // or `engine: hyperformulaInstance`
     *     leapYear1900: false,       // this option comes from HyperFormula
     *     // add more HyperFormula configuration options
     *   },
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // use the same HyperFormula instance in multiple Handsontable instances
     *
     * // a Handsontable instance `hot1`
     * formulas: {
     *   engine: HyperFormula,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     *
     * // a Handsontable instance `hot2`
     * formulas: {
     *   engine: hot1.getPlugin('formulas').engine,
     *   sheetId: 1,
     *   sheetName: 'Sheet 1'
     * }
     * ```
     */
    formulas: undefined,
    /**
     * The `fragmentSelection` option configures text selection settings.
     *
     * You can set the `fragmentSelection` option to one of the following:
     *
     * | Setting           | Description                                        |
     * | ----------------- | ------------------------------------------------- |
     * | `false` (default) | Disable text selection                            |
     * | `true`            | Enable text selection in multiple cells at a time |
     * | `'cell'`          | Enable text selection in one cell at a time       |
     *
     * @memberof Options#
     * @type {boolean|string}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // enable text selection in multiple cells at a time
     * fragmentSelection: true,
     *
     * // enable text selection in one cell a time
     * fragmentSelection: 'cell',
     * ```
     */
    fragmentSelection: false,
    /**
     * The `headerClassName` option allows adding one or more class names to the column headers' inner `div` element.
     * It can be used to align the labels in the column headers to left, center or right by setting this option to
     * `htLeft`, `htCenter`, or `htRight` respectively.
     *
     * @since 14.5.0
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // Adding class names to all column headers
     * headerClassName: 'htRight my-class',
     *
     * columns: [
     *  {
     *    // Adding class names to the column header of a single column
     *    headerClassName: 'htRight my-class',
     *  }
     * ]
     * ```
     */
    headerClassName: undefined,
    /**
     * The `height` option configures the height of your grid.
     *
     * You can set `height` option to one of the following:
     *
     * | Setting                                                                    | Example                    |
     * | -------------------------------------------------------------------------- | -------------------------- |
     * | A number of pixels                                                         | `height: 500`              |
     * | A string with a [CSS unit](https://www.w3schools.com/cssref/css_units.asp) | `height: '75vw'`           |
     * | A function that returns a valid number or string                           | `height() { return 500; }` |
     *
     * Read more:
     * - [Grid size](@/guides/getting-started/grid-size/grid-size.md)
     *
     * @memberof Options#
     * @type {number|string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the grid's height to 500px
     * height: 500,
     *
     * // set the grid's height to 75vh
     * height: '75vh',
     *
     * // set the grid's height to 500px, using a function
     * height() {
     *   return 500;
     * },
     * ```
     */
    height: undefined,
    /**
     * The `hiddenColumns` option configures the [`HiddenColumns`](@/api/hiddenColumns.md) plugin.
     *
     * You can set the `hiddenColumns` option to one of the following:
     *
     * | Setting   | Description                                                                                  |
     * | --------- | -------------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin                                 |
     * | `true`    | Enable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin with the default plugin options  |
     * | An object | - Enable the [`HiddenColumns`](@/api/hiddenColumns.md) plugin<br>- Modify the plugin options |
     *
     * If you set the `hiddenColumns` to an object, you can set the following [`HiddenColumns`](@/api/hiddenColumns.md) plugin options:
     *
     * | Property           | Possible values     | Description                                                                                                                                             |
     * | ------------------ | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `columns`          | An array of indexes | An array of indexes of columns that are hidden at initialization                                                                                        |
     * | `copyPasteEnabled` | `true` \| `false`   | `true`: when copying or pasting data, take hidden columns into account<br>`false`: when copying or pasting data, don't take hidden columns into account |
     * | `indicators`       | `true` \| `false`   | `true`: display UI markers to indicate the presence of hidden columns<br>`false`: display UI markers                                                    |
     *
     * Read more:
     * - [Plugins: `HiddenColumns`](@/api/hiddenColumns.md)
     * - [Column hiding](@/guides/columns/column-hiding/column-hiding.md)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category HiddenColumns
     *
     * @example
     * ```js
     * // enable the `HiddenColumns` plugin
     * hiddenColumns: true,
     *
     * // enable `HiddenColumns` plugin, and modify the plugin options
     * hiddenColumns: {
     *   // set columns that are hidden by default
     *   columns: [5, 10, 15],
     *   // when copying or pasting data, take hidden columns into account
     *   copyPasteEnabled: true,
     *   // show where hidden columns are
     *   indicators: true
     * }
     * ```
     */
    hiddenColumns: undefined,
    /**
     * The `hiddenRows` option configures the [`HiddenRows`](@/api/hiddenRows.md) plugin.
     *
     * You can set the `hiddenRows` option to one of the following:
     *
     * | Setting   | Description                                                                            |
     * | --------- | -------------------------------------------------------------------------------------- |
     * | `false`   | Disable the [`HiddenRows`](@/api/hiddenRows.md) plugin                                 |
     * | `true`    | Enable the [`HiddenRows`](@/api/hiddenRows.md) plugin with the default plugin options  |
     * | An object | - Enable the [`HiddenRows`](@/api/hiddenRows.md) plugin<br>- Modify the plugin options |
     *
     * If you set the `hiddenRows` to an object, you can set the following [`HiddenRows`](@/api/hiddenRows.md) plugin options:
     *
     * | Property           | Possible values     | Description                                                                                                                                       |
     * | ------------------ | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `rows   `          | An array of indexes | An array of indexes of rows that are hidden at initialization                                                                                     |
     * | `copyPasteEnabled` | `true` \| `false`   | `true`: when copying or pasting data, take hidden rows into account<br>`false`: when copying or pasting data, don't take hidden rows into account |
     * | `indicators`       | `true` \| `false`   | `true`: display UI markers to indicate the presence of hidden rows<br>`false`: display UI markers                                                 |
     *
     * Read more:
     * - [Plugins: `HiddenRows`](@/api/hiddenRows.md)
     * - [Row hiding](@/guides/rows/row-hiding/row-hiding.md)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category HiddenRows
     *
     * @example
     * ```js
     * // enable the `HiddenRows` plugin
     * hiddenRows: true,
     *
     * // enable `HiddenRows` plugin, and modify the plugin options
     * hiddenRows: {
     *   // set rows that are hidden by default
     *   rows: [5, 10, 15],
     *   // when copying or pasting data, take hidden rows into account
     *   copyPasteEnabled: true,
     *   // show where hidden rows are
     *   indicators: true
     * }
     * ```
     */
    hiddenRows: undefined,
    /**
     * The `invalidCellClassName` option lets you add a CSS class name to cells
     * that were marked as `invalid` by the [cell validator](@/guides/cell-functions/cell-validator/cell-validator.md).
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator/cell-validator.md)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htInvalid'
     * @category Core
     *
     * @example
     * ```js
     * // add a `highlight-error` CSS class name
     * // to every `invalid` cell`
     * invalidCellClassName: 'highlight-error',
     * ```
     */
    invalidCellClassName: 'htInvalid',
    /**
     * The `imeFastEdit` option allows using the "fast edit" feature for the IME users. It's disabled by default
     * because of its incompatibility with some of the accessibility features.
     *
     * Enabling this option can make a negative impact on how some screen readers handle reading the table cells.
     *
     * @since 14.0.0
     * @memberof Options#
     * @type {boolean}
     * @category Core
     */
    imeFastEdit: false,
    /**
     * The `isEmptyCol` option lets you define your own custom method
     * for checking if a column at a given visual index is empty.
     *
     * The `isEmptyCol` setting overwrites the built-in [`isEmptyCol`](@/api/core.md#isEmptyCol) method.
     *
     * @memberof Options#
     * @type {Function}
     * @param {number} col Visual column index.
     * @returns {boolean}
     * @category Core
     *
     * @example
     * ```js
     * // overwrite the built-in `isEmptyCol` method
     * isEmptyCol(visualColumnIndex) {
     *    // your custom method
     *    ...
     * },
     * ```
     */
    isEmptyCol(col) {
      let row;
      let rowLen;
      let value;
      for (row = 0, rowLen = this.countRows(); row < rowLen; row++) {
        value = this.getDataAtCell(row, col);
        if ((0, _mixed.isEmpty)(value) === false) {
          return false;
        }
      }
      return true;
    },
    /**
     * The `isEmptyRow` option lets you define your own custom method
     * for checking if a row at a given visual index is empty.
     *
     * The `isEmptyRow` setting overwrites the built-in [`isEmptyRow`](@/api/core.md#isEmptyRow) method.
     *
     * @memberof Options#
     * @type {Function}
     * @param {number} row Visual row index.
     * @returns {boolean}
     * @category Core
     *
     * @example
     * ```js
     * // overwrite the built-in `isEmptyRow` method
     * isEmptyRow(visualRowIndex) {
     *    // your custom method
     *    ...
     * },
     * ```
     */
    isEmptyRow(row) {
      let col;
      let colLen;
      let value;
      let meta;
      for (col = 0, colLen = this.countCols(); col < colLen; col++) {
        value = this.getDataAtCell(row, col);
        if ((0, _mixed.isEmpty)(value) === false) {
          if (typeof value === 'object') {
            meta = this.getCellMeta(row, col);
            return (0, _object.isObjectEqual)(this.getSchema()[meta.prop], value);
          }
          return false;
        }
      }
      return true;
    },
    /**
     * @description
     * The `label` option configures [`checkbox`](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md) cells` labels.
     *
     * You can set the `label` option to an object with the following properties:
     *
     * | Property    | Possible values                   | Description                                                                                                                                                                                                             |
     * | ----------- | --------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `position`  | `'after'` (default) \| `'before'` | `'after'`: place the label to the right of the checkbox<br>`'before'`: place the label to the left of the checkbox                                                                                                      |
     * | `value`     | A string \| A function            | The label's text                                                                                                                                                                                                        |
     * | `separated` | `false` (default) \| `true`       | `false`: don't separate the label from the checkbox<br>`true`: separate the label from the checkbox                                                                                                                     |
     * | `property`  | A string                          | - A [`data`](#data) object property name that's used as the label's text <br>- Works only when the [`data`](#data) option is set to an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects) |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox labels](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md#checkbox-labels)
     *
     * @memberof Options#
     * @type {object}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   type: 'checkbox',
     *   // add 'My label:' after the checkbox
     *   label: { position: 'after', value: 'My label: ', separated: true }
     * }],
     * ```
     */
    label: undefined,
    /**
     * The `language` option configures Handsontable's [language](@/guides/internationalization/language/language.md) settings.
     *
     * You can set the `language` option to one of the following:
     *
     * | Setting             | Description                 |
     * | ------------------- | --------------------------- |
     * | `'en-US'` (default) | English - United States     |
     * | `'ar-AR'`           | Arabic - Global<br><br>To properly render this language, set the [layout direction](@/guides/internationalization/layout-direction/layout-direction.md) to RTL. |
     * | `'cs-CZ'`           | Czech - Czech Republic      |
     * | `'de-CH'`           | German - Switzerland        |
     * | `'de-DE'`           | German - Germany            |
     * | `'es-MX'`           | Spanish - Mexico            |
     * | `'fr-FR'`           | French - France             |
     * | `'hr-HR'`           | Croatian - Croatia          |
     * | `'it-IT'`           | Italian - Italy             |
     * | `'ja-JP'`           | Japanese - Japan            |
     * | `'ko-KR'`           | Korean - Korea              |
     * | `'lv-LV'`           | Latvian - Latvia            |
     * | `'nb-NO'`           | Norwegian (Bokmål) - Norway |
     * | `'nl-NL'`           | Dutch - Netherlands         |
     * | `'pl-PL'`           | Polish - Poland             |
     * | `'pt-BR'`           | Portuguese - Brazil         |
     * | `'ru-RU'`           | Russian - Russia            |
     * | `'sr-SP'`           | Serbian (Latin) - Serbia    |
     * | `'zh-CN'`           | Chinese - China             |
     * | `'zh-TW'`           | Chinese - Taiwan            |
     *
     * Read more:
     * - [Language](@/guides/internationalization/language/language.md)
     * - [`locale`](#locale)
     * - [`layoutDirection`](#layoutdirection)
     *
     * @memberof Options#
     * @type {string}
     * @default 'en-US'
     * @category Core
     *
     * @example
     * ```js
     * // set Handsontable's language to Polish
     * language: 'pl-PL',
     * ```
     */
    language: 'en-US',
    /**
     * The `layoutDirection` option configures whether Handsontable renders from the left to the right, or from the right to the left.
     *
     * You can set the layout direction only at Handsontable's [initialization](@/guides/getting-started/installation/installation.md#initialize-handsontable). Any change of the `layoutDirection` option after the initialization (e.g. using the [`updateSettings()`](@/api/core.md#updatesettings) method) is ignored.
     *
     * You can set the `layoutDirection` option only [for the entire grid](@/guides/getting-started/configuration-options/configuration-options.md#set-grid-options).
     * You can't set it for individual columns, rows, or cells.
     *
     * You can set the `layoutDirection` option to one of the following strings:
     *
     * | Setting             | Description                                                                                                                                                                                  |
     * | ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `inherit` (default) | Set Handsontable's layout direction automatically,<br>based on the value of your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute  |
     * | `rtl`               | Render Handsontable from the right to the left,<br>even when your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute is set to `ltr` |
     * | `ltr`               | Render Handsontable from the left to the right,<br>even when your HTML document's [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir) attribute is set to `rtl` |
     *
     * Read more:
     * - [Layout direction](@/guides/internationalization/layout-direction/layout-direction.md)
     * - [Language](@/guides/internationalization/language/language.md)
     * - [`language`](#language)
     * - [`locale`](#locale)
     * - [`fixedColumnsStart`](#fixedcolumnsstart)
     * - [`customBorders`](#customBorders)
     *
     * @memberof Options#
     * @type {string}
     * @default 'inherit'
     * @category Core
     *
     * @example
     * ```js
     * // inherit Handsontable's layout direction
     * // from the value of your HTML document's `dir` attribute
     * layoutDirection: 'inherit',
     *
     * // render Handsontable from the right to the left
     * // regardless of your HTML document's `dir`
     * layoutDirection: 'rtl',
     *
     * // render Handsontable from the left to the right
     * // regardless of your HTML document's `dir`
     * layoutDirection: 'ltr',
     * ```
     */
    layoutDirection: 'inherit',
    /**
     * The `licenseKey` option sets your Handsontable license key.
     *
     * You can set the `licenseKey` option to one of the following:
     *
     * | Setting                                                                                                 | Description                                                                                       |
     * | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- |
     * | A string with your [commercial license key](@/guides/getting-started/license-key/license-key.md#commercial-license) | For [commercial use](@/guides/technical-specification/software-license/software-license.md#commercial-use)         |
     * | `'non-commercial-and-evaluation'`                                                                       | For [non-commercial use](@/guides/technical-specification/software-license/software-license.md#non-commercial-use) |
     *
     * Read more:
     * - [License key](@/guides/getting-started/license-key/license-key.md)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // for commercial use
     * licenseKey: 'xxxxx-xxxxx-xxxxx-xxxxx-xxxxx', // your commercial license key
     *
     * // for non-commercial use
     * licenseKey: 'non-commercial-and-evaluation',
     * ```
     */
    licenseKey: undefined,
    /**
     * The `locale` option configures Handsontable's [locale](@/guides/internationalization/locale/locale.md) settings.
     *
     * You can set the `locale` option to any valid and canonicalized Unicode BCP 47 locale tag,
     * both for the [entire grid](@/guides/internationalization/locale/locale.md#set-the-grid-s-locale),
     * and for [individual columns](@/guides/internationalization/locale/locale.md#set-a-column-s-locale).
     *
     * Read more:
     * - [Locale](@/guides/internationalization/locale/locale.md)
     * - [`language`](#language)
     * - [`layoutDirection`](#layoutdirection)
     *
     * @memberof Options#
     * @type {string}
     * @default 'en-US'
     * @category Core
     *
     * @example
     * ```js
     * // set the entire grid's locale to Polish
     * locale: 'pl-PL',
     *
     * // set individual columns' locales
     * columns: [
     *   {
     *     // set the first column's locale to Polish
     *     locale: 'pl-PL',
     *   },
     *   {
     *     // set the second column's locale to German
     *     locale: 'de-DE',
     *   },
     * ],
     * ```
     */
    locale: 'en-US',
    /**
     * The `manualColumnFreeze` option configures the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin.
     *
     * You can set the `manualColumnFreeze` option to one of the following:
     *
     * | Setting  | Description                                                            |
     * | -------- | ---------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin  |
     * | `false`  | Disable the [`ManualColumnFreeze`](@/api/manualColumnFreeze.md) plugin |
     *
     * Read more:
     * - [Column freezing](@/guides/columns/column-freezing/column-freezing.md#user-triggered-freeze)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category ManualColumnFreeze
     *
     * @example
     * ```js
     * // enable the `ManualColumnFreeze` plugin
     * manualColumnFreeze: true,
     * ```
     */
    manualColumnFreeze: undefined,
    /**
     * The `manualColumnMove` option configures the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin.
     *
     * You can set the `manualColumnMove` option to one of the following:
     *
     * | Setting  | Description                                                                                                        |
     * | -------- | ------------------------------------------------------------------------------------------------------------------ |
     * | `true`   | Enable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin                                                  |
     * | `false`  | Disable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin                                                 |
     * | An array | - Enable the [`ManualColumnMove`](@/api/manualColumnMove.md) plugin<br>- Move individual columns at initialization |
     *
     * Read more:
     * - [Column moving](@/guides/columns/column-moving/column-moving.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualColumnMove
     *
     * @example
     * ```js
     * // enable the `ManualColumnMove` plugin
     * manualColumnMove: true,
     *
     * // enable the `ManualColumnMove` plugin
     * // at initialization, move column 0 to 1
     * // at initialization, move column 1 to 4
     * // at initialization, move column 2 to 6
     * manualColumnMove: [1, 4, 6],
     * ```
     */
    manualColumnMove: undefined,
    /**
     * @description
     * The `manualColumnResize` option configures the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin.
     *
     * You can set the `manualColumnResize` option to one of the following:
     *
     * | Setting  | Description                                                                                                           |
     * | -------- | --------------------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin                                                 |
     * | `false`  | Disable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin                                                |
     * | An array | - Enable the [`ManualColumnResize`](@/api/manualColumnResize.md) plugin<br>- Set initial widths of individual columns |
     *
     * Read more:
     * - [Column width: Column stretching](@/guides/columns/column-width/column-width.md#column-stretching)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualColumnResize
     *
     * @example
     * ```js
     * // enable the `manualColumnResize` plugin
     * manualColumnResize: true,
     *
     * // enable the `manualColumnResize` plugin
     * // set the initial width of column 0 to 40 pixels
     * // set the initial width of column 1 to 50 pixels
     * // set the initial width of column 2 to 60 pixels
     * manualColumnResize: [40, 50, 60],
     * ```
     */
    manualColumnResize: undefined,
    /**
     * @description
     * The `manualRowMove` option configures the [`ManualRowMove`](@/api/manualRowMove.md) plugin.
     *
     * You can set the `manualRowMove` option to one of the following:
     *
     * | Setting  | Description                                                                                               |
     * | -------- | --------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualRowMove`](@/api/manualRowMove.md) plugin                                               |
     * | `false`  | Disable the [`ManualRowMove`](@/api/manualRowMove.md) plugin                                              |
     * | An array | - Enable the [`ManualRowMove`](@/api/manualRowMove.md) plugin<br>- Move individual rows at initialization |
     *
     * Read more:
     * - [Row moving](@/guides/rows/row-moving/row-moving.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualRowMove
     *
     * @example
     * ```js
     * // enable the `ManualRowMove` plugin
     * manualRowMove: true,
     *
     * // enable the `ManualRowMove` plugin
     * // at initialization, move row 1 to 0
     * // at initialization, move row 4 to 1
     * // at initialization, move row 6 to 2
     * manualRowMove: [1, 4, 6],
     * ```
     */
    manualRowMove: undefined,
    /**
     * @description
     * The `manualRowResize` option configures the [`ManualRowResize`](@/api/manualRowResize.md) plugin.
     *
     * You can set the `manualRowResize` option to one of the following:
     *
     * | Setting  | Description                                                                                                   |
     * | -------- | ------------------------------------------------------------------------------------------------------------- |
     * | `true`   | Enable the [`ManualRowResize`](@/api/manualRowResize.md) plugin                                               |
     * | `false`  | Disable the [`ManualRowResize`](@/api/manualRowResize.md) plugin                                              |
     * | An array | - Enable the [`ManualRowResize`](@/api/manualRowResize.md) plugin<br>- Set initial heights of individual rows |
     *
     * Read more:
     * - [Row height: Adjust the row height manually](@/guides/rows/row-height/row-height.md#adjust-the-row-height-manually)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category ManualRowResize
     *
     * @example
     * ```js
     * // enable the `ManualRowResize` plugin
     * manualRowResize: true,
     *
     * // enable the `ManualRowResize` plugin
     * // set the initial height of row 0 to 40 pixels
     * // set the initial height of row 1 to 50 pixels
     * // set the initial height of row 2 to 60 pixels
     * manualRowResize: [40, 50, 60],
     * ```
     */
    manualRowResize: undefined,
    /**
     * The `maxCols` option sets a maximum number of columns.
     *
     * The `maxCols` option is used:
     * - At initialization: if the `maxCols` value is lower than the initial number of columns,
     * Handsontable trims columns from the right.
     * - At runtime: for example, when inserting columns.
     *
     * @memberof Options#
     * @type {number}
     * @default Infinity
     * @category Core
     *
     * @example
     * ```js
     * // set the maximum number of columns to 300
     * maxCols: 300,
     * ```
     */
    maxCols: Infinity,
    /**
     * The `maxRows` option sets a maximum number of rows.
     *
     * The `maxRows` option is used:
     * - At initialization: if the `maxRows` value is lower than the initial number of rows,
     * Handsontable trims rows from the bottom.
     * - At runtime: for example, when inserting rows.
     *
     * @memberof Options#
     * @type {number}
     * @default Infinity
     * @category Core
     *
     * @example
     * ```js
     * // set the maximum number of rows to 300
     * maxRows: 300,
     * ```
     */
    maxRows: Infinity,
    /**
     * @description
     * The `mergeCells` option configures the [`MergeCells`](@/api/mergeCells.md) plugin.
     *
     * You can set the `mergeCells` option to one of the following:
     *
     * | Setting             | Description                                                                                         |
     * | ------------------- | --------------------------------------------------------------------------------------------------- |
     * | `true`              | Enable the [`MergeCells`](@/api/mergeCells.md) plugin                                               |
     * | `false`             | Disable the [`MergeCells`](@/api/mergeCells.md) plugin                                              |
     * | An array of objects | - Enable the [`MergeCells`](@/api/mergeCells.md) plugin<br>- Merge specific cells at initialization |
     *
     * To merge specific cells at Handsontable's initialization,
     * set the `mergeCells` option to an array of objects, with the following properties:
     *
     * | Property  | Description                                                |
     * | --------- | ---------------------------------------------------------- |
     * | `row`     | The row index of the merged section's beginning            |
     * | `col`     | The column index of the merged section's beginning         |
     * | `rowspan` | The width (as a number of rows) of the merged section      |
     * | `colspan` | The height (as a number of columns ) of the merged section |
     *
     * Read more:
     * - [Merge cells](@/guides/cell-features/merge-cells/merge-cells.md)
     *
     * @memberof Options#
     * @type {boolean|object[]}
     * @default false
     * @category MergeCells
     *
     * @example
     * ```js
     * // enable the `MergeCells` plugin
     * mergeCells: true,
     *
     * // enable the `MergeCells` plugin
     * // and merge specific cells at initialization
     * mergeCells: [
     *   // merge cells from cell (1,1) to cell (3,3)
     *   {row: 1, col: 1, rowspan: 3, colspan: 3},
     *   // merge cells from cell (3,4) to cell (2,2)
     *   {row: 3, col: 4, rowspan: 2, colspan: 2},
     *   // merge cells from cell (5,6) to cell (3,3)
     *   {row: 5, col: 6, rowspan: 3, colspan: 3}
     * ],
     * ```
     */
    mergeCells: false,
    /**
     * The `minCols` option sets a minimum number of columns.
     *
     * The `minCols` option is used:
     * - At initialization: if the `minCols` value is higher than the initial number of columns,
     * Handsontable adds empty columns to the right.
     * - At runtime: for example, when removing columns.
     *
     * The `minCols` option works only when your [`data`](#data) is an [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays).
     * When your [`data`](#data) is an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects),
     * you can only have as many columns as defined in:
     * - The first data row
     * - The [`dataSchema`](#dataSchema) option
     * - The [`columns`](#columns) option
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // set the minimum number of columns to 10
     * minCols: 10,
     * ```
     */
    minCols: 0,
    /**
     * The `minRows` option sets a minimum number of rows.
     *
     * The `minRows` option is used:
     * - At initialization: if the `minRows` value is higher than the initial number of rows,
     * Handsontable adds empty rows at the bottom.
     * - At runtime: for example, when removing rows.
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // set the minimum number of rows to 10
     * minRows: 10,
     * ```
     */
    minRows: 0,
    /**
     * The `minSpareCols` option sets a minimum number of empty columns
     * at the grid's right-hand end.
     *
     * If there already are other empty columns at the grid's right-hand end,
     * they are counted into the `minSpareCols` value.
     *
     * The total number of columns can't exceed the [`maxCols`](#maxCols) value.
     *
     * The `minSpareCols` option works only when your [`data`](#data) is an [array of arrays](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-arrays).
     * When your [`data`](#data) is an [array of objects](@/guides/getting-started/binding-to-data/binding-to-data.md#array-of-objects),
     * you can only have as many columns as defined in:
     * - The first data row
     * - The [`dataSchema`](#dataSchema) option
     * - The [`columns`](#columns) option
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // at Handsontable's initialization, add at least 3 empty columns on the right
     * minSpareCols: 3,
     * ```
     */
    minSpareCols: 0,
    /**
     * The `minSpareRows` option sets a minimum number of empty rows
     * at the bottom of the grid.
     *
     * If there already are other empty rows at the bottom,
     * they are counted into the `minSpareRows` value.
     *
     * The total number of rows can't exceed the [`maxRows`](#maxRows) value.
     *
     * @memberof Options#
     * @type {number}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // at Handsontable's initialization, add at least 3 empty rows at the bottom
     * minSpareRows: 3,
     * ```
     */
    minSpareRows: 0,
    /**
     * @description
     * The `multiColumnSorting` option configures the [`MultiColumnSorting`](@/api/columnSorting.md) plugin.
     *
     * You can set the `multiColumnSorting` option to one of the following:
     *
     * | Setting    | Description                                                                                                                                                |
     * | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `true`     | Enable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin with the default configuration                                                       |
     * | `false`    | Disable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin                                                                                     |
     * | An object  | - Enable the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin<br>- Modify the [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin options |
     *
     * If you set the `multiColumnSorting` option to an object,
     * you can set the following [`MultiColumnSorting`](@/api/multiColumnSorting.md) plugin options:
     *
     * | Option                   | Possible settings                                                                                                                                |
     * | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `indicator`              | `true`: Display the arrow icon in the column header, to indicate a sortable column<br>`false`: Don't display the arrow icon in the column header |
     * | `headerAction`           | `true`: Enable clicking on the column header to sort the column<br>`false`: Disable clicking on the column header to sort the column             |
     * | `sortEmptyCells`         | `true`: Sort empty cells as well<br>`false`: Place empty cells at the end                                                                        |
     * | `compareFunctionFactory` | A [custom compare function](@/guides/rows/rows-sorting/rows-sorting.md#add-a-custom-comparator)                                                               |
     *
     * If you set the `multiColumnSorting` option to an object,
     * you can also sort individual columns at Handsontable's initialization.
     * In the `multiColumnSorting` object, add an object named `initialConfig`,
     * with the following properties:
     *
     * | Option      | Possible settings   | Description                                                      |
     * | ----------- | ------------------- | ---------------------------------------------------------------- |
     * | `column`    | A number            | The index of the column that you want to sort at initialization  |
     * | `sortOrder` | `'asc'` \| `'desc'` | The sorting order:<br>`'asc'`: ascending<br>`'desc'`: descending |
     *
     * Read more:
     * - [Rows sorting](@/guides/rows/rows-sorting/rows-sorting.md)
     * - [`columnSorting`](#columnSorting)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default undefined
     * @category MultiColumnSorting
     *
     * @example
     * ```js
     * // enable the `MultiColumnSorting` plugin
     * multiColumnSorting: true
     *
     * // enable the `MultiColumnSorting` plugin with custom configuration
     * multiColumnSorting: {
     *   // sort empty cells as well
     *   sortEmptyCells: true,
     *   // display the arrow icon in the column header
     *   indicator: true,
     *   // disable clicking on the column header to sort the column
     *   headerAction: false,
     *   // add a custom compare function
     *   compareFunctionFactory(sortOrder, columnMeta) {
     *     return function(value, nextValue) {
     *       // some value comparisons which will return -1, 0 or 1...
     *     }
     *   }
     * }
     *
     * // enable the `MultiColumnSorting` plugin
     * multiColumnSorting: {
     *   // at initialization, sort column 1 in ascending order
     *   initialConfig: {
     *     column: 1,
     *     sortOrder: 'asc'
     *   },
     *   // at initialization, sort column 2 in descending order
     *   initialConfig: {
     *     column: 2,
     *     sortOrder: 'desc'
     *   }
     * }
     * ```
     */
    multiColumnSorting: undefined,
    /**
     * When set to `true`, the `navigableHeaders` option lets you navigate [row headers](@/guides/rows/row-header/row-header.md) and [column headers](@/guides/columns/column-header/column-header.md), using the arrow keys or the <kbd>**Tab**</kbd> key (if the [`tabNavigation`](#tabNavigation) option is set to `true`).
     *
     * @since 14.0.0
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // you can navigate row and column headers with the keyboard
     * navigableHeaders: true,
     *
     * // default behavior: you can't navigate row and column headers with the keyboard
     * navigableHeaders: false,
     * ```
     */
    navigableHeaders: false,
    /**
     * When set to `false`, the `tabNavigation` option changes the behavior of the
     * <kbd>Tab</kbd> and <kbd>Shift</kbd>+<kbd>Tab</kbd> keyboard shortcuts. The Handsontable
     * no more captures that shortcuts to make the grid navigation available (`tabNavigation: true`)
     * but returns control to the browser so the native page navigation is possible.
     *
     * @since 14.0.0
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // you can't navigate row and column headers using <kbd>Tab</kbd> or <kbd>Shift</kbd>+<kbd>Tab</kbd> keyboard shortcuts
     * tabNavigation: false,
     *
     * // default behavior: you can navigate row and column headers using <kbd>Tab</kbd> or <kbd>Shift</kbd>+<kbd>Tab</kbd> keyboard shortcuts
     * tabNavigation: true,
     * ```
     */
    tabNavigation: true,
    /**
     * @description
     * The `nestedHeaders` option configures the [`NestedHeaders`](@/api/nestedHeaders.md) plugin.
     *
     * You can set the `nestedHeaders` option to one of the following:
     *
     * | Setting           | Description                                                                                                                           |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Disable the [`NestedHeaders`](@/api/nestedHeaders.md) plugin                                                                          |
     * | `true`            | - Enable the [`NestedHeaders`](@/api/nestedHeaders.md) plugin<br>- Don't configure any nested headers                                 |
     * | Array of arrays   | - Enable the [`NestedHeaders`](@/api/nestedHeaders.md) plugin<br>- Configure headers that are nested on Handsontable's initialization |
     *
     * If you set the `nestedHeaders` option to an array of arrays, each array configures one set of nested headers.
     *
     * Each array element configures one header, and can be one of the following:
     *
     * | Array element | Description                                                                                  |
     * | ------------- | -------------------------------------------------------------------------------------------- |
     * | A string      | The header's label                                                                           |
     * | An object     | Properties:<br>`label` (string): the header's label<br>`colspan` (integer): the column width |
     *
     * Read more:
     * - [Plugins: `NestedHeaders`](@/api/nestedHeaders.md)
     * - [Column groups: Nested headers](@/guides/columns/column-groups/column-groups.md#nested-headers)
     *
     * @memberof Options#
     * @type {boolean|Array[]}
     * @default undefined
     * @category NestedHeaders
     *
     * @example
     * ```js
     * nestedHeaders: [
     *   ['A', {label: 'B', colspan: 8}, 'C'],
     *   ['D', {label: 'E', colspan: 4}, {label: 'F', colspan: 4}, 'G'],
     *   ['H', 'I', 'J', 'K', 'L', 'M', 'N', 'R', 'S', 'T']
     * ],
     * ```
     */
    nestedHeaders: undefined,
    /**
     * @description
     * The `nestedRows` option configures the [`NestedRows`](@/api/nestedRows.md) plugin.
     *
     * You can set the `nestedRows` option to one of the following:
     *
     * | Setting           | Description                                            |
     * | ----------------- | ------------------------------------------------------ |
     * | `false` (default) | Disable the [`NestedRows`](@/api/nestedRows.md) plugin |
     * | `true`            | Enable the [`NestedRows`](@/api/nestedRows.md) plugin  |
     *
     * Read more:
     * - [Plugins: `NestedRows`](@/guides/rows/row-parent-child/row-parent-child.md)
     *
     * @example
     * ```js
     * // enable the `NestedRows` plugin
     * nestedRows: true,
     * ```
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category NestedRows
     */
    nestedRows: undefined,
    /**
     * The `noWordWrapClassName` option lets you add a CSS class name
     * to each cell that has the [`wordWrap`](#wordWrap) option set to `false`.
     *
     * Read more:
     * - [`wordWrap`](#wordWrap)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htNoWrap'
     * @category Core
     *
     * @example
     * ```js
     * // add an `is-noWrapCell` CSS class name
     * // to each cell that doesn't wrap content
     * noWordWrapClassName: 'is-noWrapCell',
     * ```
     */
    noWordWrapClassName: 'htNoWrap',
    /**
     * The `numericFormat` option configures the number format and the currency format
     * of [`numeric`](@/guides/cell-types/numeric-cell-type/numeric-cell-type.md) cells` displayed output
     * in the numeric cell renderer.
     *
     * You can set the `numericFormat` option to an object with the following properties:
     *
     * | Property    | Possible values                                                               | Description     |
     * | ----------- | ----------------------------------------------------------------------------- | --------------- |
     * | `pattern`   | All [`numbro.js` number formats](https://numbrojs.com/format.html#numbers)    | Number format   |
     * | `culture`   | All [`numbro.js` currency formats](https://numbrojs.com/format.html#currency) | Currency format |
     *
     * The `numericFormat` option as no effect on the numeric cell editor.
     *
     * In the source data, numeric data is stored as JavaScript numbers.
     *
     * Read more:
     * - [Numeric cell type](@/guides/cell-types/numeric-cell-type/numeric-cell-type.md)
     * - [Third-party licenses](@/guides/technical-specification/third-party-licenses/third-party-licenses.md)
     *
     * @memberof Options#
     * @since 0.35.0
     * @type {object}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `numeric`
     *     type: 'numeric',
     *     // set the `numericFormat` option for every `numeric` cell of this column
     *     numericFormat: {
     *       // set the number format
     *       pattern: '0,00',
     *       // set the currency format
     *       culture: 'en-US'
     *     }
     *   }
     * ],
     * ```
     */
    numericFormat: undefined,
    /**
     * If the `observeDOMVisibility` option is set to `true`,
     * Handsontable rerenders every time it detects that the grid was made visible in the DOM.
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // don't rerender the grid on visibility changes
     * observeDOMVisibility: false,
     * ```
     */
    observeDOMVisibility: true,
    /**
     * The `outsideClickDeselects` option determines what happens to the current [selection](@/guides/cell-features/selection/selection.md)
     * when you click outside of the grid.
     *
     * You can set the `outsideClickDeselects` option to one of the following:
     *
     * | Setting          | Description                                                                                              |
     * | ---------------- | -------------------------------------------------------------------------------------------------------- |
     * | `true` (default) | On a mouse click outside of the grid, clear the current [selection](@/guides/cell-features/selection/selection.md) |
     * | `false`          | On a mouse click outside of the grid, keep the current [selection](@/guides/cell-features/selection/selection.md)  |
     * | A function       | A function that takes the click event target and returns a boolean                                       |
     *
     * @memberof Options#
     * @type {boolean|Function}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // on a mouse click outside of the grid, clear the current selection
     * outsideClickDeselects: true,
     *
     * // on a mouse click outside of the grid, keep the current selection
     * outsideClickDeselects: false,
     *
     * // take the click event target and return `false`
     * outsideClickDeselects(event) {
     *   return false;
     * }
     *
     * // take the click event target and return `true`
     * outsideClickDeselects(event) {
     *   return false;
     * }
     * ```
     */
    outsideClickDeselects: true,
    /**
     * @description
     * The `persistentState` option configures the [`PersistentState`](@/api/persistentState.md) plugin.
     *
     * You can set the `persistentState` to one of the following:
     *
     * | Setting           | Description                                                      |
     * | ----------------- | ---------------------------------------------------------------- |
     * | `false` (default) | Disable the [`PersistentState`](@/api/persistentState.md) plugin |
     * | `true`            | Enable the [`PersistentState`](@/api/persistentState.md) plugin  |
     *
     * Read more:
     * - [Saving data: Saving data locally](@/guides/getting-started/saving-data/saving-data.md#save-data-locally)
     * - [Plugins: `PersistentState`](@/api/persistentState.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category PersistentState
     *
     * @example
     * ```js
     * // enable the `PersistentState` plugin
     * persistentState: true,
     * ```
     */
    persistentState: undefined,
    /**
     * The `placeholder` option lets you display placeholder text in every empty cell.
     *
     * You can set the `placeholder` option to one of the following:
     *
     * | Setting            | Example        | Description                                                           |
     * | ------------------ | -------------- | --------------------------------------------------------------------- |
     * | A non-empty string | `'Empty cell'` | Display `Empty cell` text in empty cells                              |
     * | A non-string value | `000`          | Display `000` text in empty cells (non-string values get stringified) |
     *
     * Read more:
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // display 'Empty cell' text
     * // in every empty cell of the entire grid
     * placeholder: 'Empty cell',
     *
     * // or
     * columns: [
     *   {
     *     data: 'date',
     *     dateFormat: 'DD/MM/YYYY',
     *     // display 'Empty date cell' text
     *     // in every empty cell of the `date` column
     *     placeholder: 'Empty date cell'
     *   }
     * ],
     * ```
     */
    placeholder: undefined,
    /**
     * The `placeholderCellClassName` option lets you add a CSS class name to cells
     * that contain [`placeholder`](#placeholder) text.
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator/cell-validator.md)
     * - [`placeholder`](#placeholder)
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`TableClassName`](#TableClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htPlaceholder'
     * @category Core
     *
     * @example
     * ```js
     * // add a `has-placeholder` CSS class name
     * // to each cell that contains `placeholder` text
     * placeholderCellClassName: 'has-placeholder',
     * ```
     */
    placeholderCellClassName: 'htPlaceholder',
    /**
     * The `preventOverflow` option configures preventing Handsontable
     * from overflowing outside of its parent element.
     *
     * You can set the `preventOverflow` option to one of the following:
     *
     * | Setting           | Description                      |
     * | ----------------- | -------------------------------- |
     * | `false` (default) | Don't prevent overflowing        |
     * | `'horizontal'`      | Prevent horizontal overflowing |
     * | `'vertical'`        | Prevent vertical overflowing   |
     *
     * @memberof Options#
     * @type {string|boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // prevent horizontal overflowing
     * preventOverflow: 'horizontal',
     * ```
     */
    preventOverflow: false,
    /**
     * The `preventWheel` option configures preventing the `wheel` event's default action
     * on overlays.
     *
     * You can set the `preventWheel` option to one of the following:
     *
     * | Setting           | Description                                      |
     * | ----------------- | ------------------------------------------------ |
     * | `false` (default) | Don't prevent the `wheel` event's default action |
     * | `true`            | Prevent the `wheel` event's default action       |
     *
     * @memberof Options#
     * @private
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // don't prevent the `wheel` event's default action
     * preventWheel: false,
     * ```
     */
    preventWheel: false,
    /**
     * @description
     * The `readOnly` option determines whether a [cell](@/guides/cell-features/disabled-cells/disabled-cells.md#read-only-specific-cells),
     * [comment](@/guides/cell-features/comments/comments.md#make-a-comment-read-only), [column](@/guides/cell-features/disabled-cells/disabled-cells.md#read-only-columns)
     * or the [entire grid](@/guides/cell-features/disabled-cells/disabled-cells.md#read-only-grid) is editable or not. You can configure it as follows:
     *
     * | Setting           | Description                                                                                                                |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Set as editable                                                                                                           |
     * | `true`            | - Set as read-only<br>- Add the [`readOnlyCellClassName`](#readOnlyCellClassName) CSS class name (by default: `htDimmed`) |
     *
     * `readOnly` cells can't be changed by the [`populateFromArray()`](@/api/core.md#populatefromarray) method.
     *
     * Read more:
     * - [Disabled cells](@/guides/cell-features/disabled-cells/disabled-cells.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options/configuration-options.md#cascading-configuration)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // make the entire grid read-only
     * const configurationOptions = {
     *   columnSorting: true,
     * };
     *
     * // make the third column read-only
     * const configurationOptions = {
     *   columns: [
     *     {},
     *     {},
     *     {
     *       readOnly: true,
     *     },
     *   ],
     * };
     *
     * // make a specific cell read-only
     * const configurationOptions = {
     *   cell: [
     *     {
     *       row: 0,
     *       col: 0,
     *       readOnly: true,
     *     },
     * };
     * ```
     */
    readOnly: false,
    /**
     * The `readOnlyCellClassName` option lets you add a CSS class name to [read-only](#readOnly) cells.
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`TableClassName`](#TableClassName)
     *
     * @memberof Options#
     * @type {string}
     * @default 'htDimmed'
     * @category Core
     *
     * @example
     * ```js
     * // add a `is-readOnly` CSS class name
     * // to every read-only cell
     * readOnlyCellClassName: 'is-readOnly',
     * ```
     */
    readOnlyCellClassName: 'htDimmed',
    /**
     * The `renderAllRows` option controls Handsontable's [row virtualization](@/guides/rows/row-virtualization/row-virtualization.md).
     * You can configure it as follows:
     *
     * | Setting           | Description                                                                                                                                                                                     |
     * | ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Enable [row virtualization](@/guides/rows/row-virtualization/row-virtualization.md), rendering only the visible rows for optimal performance with large datasets.                                                  |
     * | `true`            | Disable [row virtualization](@/guides/rows/row-virtualization/row-virtualization.md)<br>(render all rows of the grid), rendering all rows in the dataset for consistent rendering and screen reader accessibility. |
     *
     * Setting `renderAllRows` to `true` overwrites the [`viewportRowRenderingOffset`](#viewportRowRenderingOffset) setting.
     *
     * Read more:
     * - [Row virtualization](@/guides/rows/row-virtualization/row-virtualization.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // disable row virtualization
     * renderAllRows: true,
     * ```
     */
    renderAllRows: false,
    /**
     * The `renderAllColumns` option configures Handsontable's [column virtualization](@/guides/columns/column-virtualization/column-virtualization.md).
     *
     * You can set the `renderAllColumns` option to one of the following:
     *
     * | Setting           | Description                                                                                                                                                                                                                      |
     * | ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Enable [column virtualization](@/guides/columns/column-virtualization/column-virtualization.md), rendering only visible columns for better performance with many columns.                                                                              |
     * | `true`            | Disable [column virtualization](@/guides/columns/column-virtualization/column-virtualization.md)<br>(render all columns of the grid), rendering all columns in the dataset, and ensuring all columns are available regardless of horizontal scrolling. |
     *
     * Setting `renderAllColumns` to `true` overwrites the [`viewportColumnRenderingOffset`](#viewportColumnRenderingOffset) setting.
     *
     * Read more:
     * - [Column virtualization](@/guides/columns/column-virtualization/column-virtualization.md)
     *
     * @since 14.1.0
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * // disable column virtualization
     * renderAllColumns: true,
     * ```
     */
    renderAllColumns: false,
    /**
     * @description
     * The `renderer` option sets a [cell renderer](@/guides/cell-functions/cell-renderer/cell-renderer.md) for a cell.
     *
     * You can set the `renderer` option to one of the following:
     * - A custom renderer function
     * - One of the following [cell renderer aliases](@/guides/cell-functions/cell-renderer/cell-renderer.md):
     *
     * | Alias               | Cell renderer function                                                         |
     * | ------------------- | ------------------------------------------------------------------------------ |
     * | A custom alias      | Your [custom cell renderer](@/guides/cell-functions/cell-renderer/cell-renderer.md) function |
     * | `'autocomplete'`    | `AutocompleteRenderer`                                                         |
     * | `'base'`            | `BaseRenderer`                                                                 |
     * | `'checkbox'`        | `CheckboxRenderer`                                                             |
     * | `'date'`            | `DateRenderer`                                                                 |
     * | `'dropdown'`        | `DropdownRenderer`                                                             |
     * | `'html'`            | `HtmlRenderer`                                                                 |
     * | `'numeric'`         | `NumericRenderer`                                                              |
     * | `'password'`        | `PasswordRenderer`                                                             |
     * | `'text'`            | `TextRenderer`                                                                 |
     * | `'time'`            | `TimeRenderer`                                                                 |
     *
     * To set the [`renderer`](#renderer), [`editor`](#editor), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell renderer](@/guides/cell-functions/cell-renderer/cell-renderer.md)
     * - [Cell type](@/guides/cell-types/cell-type/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options/configuration-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // use the `numeric` renderer for each cell of the entire grid
     * renderer: `'numeric'`,
     *
     * // add a custom renderer function
     * renderer(hotInstance, td, row, column, prop, value, cellProperties) {
     *   // your custom renderer's logic
     *   ...
     * }
     *
     * // apply the `renderer` option to individual columns
     * columns: [
     *   {
     *     // use the `autocomplete` renderer for each cell of this column
     *     renderer: 'autocomplete'
     *   },
     *   {
     *     // use the `myCustomRenderer` renderer for each cell of this column
     *     renderer: 'myCustomRenderer'
     *   }
     * ]
     * ```
     */
    renderer: undefined,
    /**
     * The `rowHeaders` option configures your grid's row headers.
     *
     * You can set the `rowHeaders` option to one of the following:
     *
     * | Setting    | Description                                                       |
     * | ---------- | ----------------------------------------------------------------- |
     * | `true`     | Enable the default row headers ('1', '2', '3', ...)               |
     * | `false`    | Disable row headers                                               |
     * | An array   | Define your own row headers (e.g. `['One', 'Two', 'Three', ...]`) |
     * | A function | Define your own row headers, using a function                     |
     *
     * Read more:
     * - [Row header](@/guides/rows/row-header/row-header.md)
     *
     * @memberof Options#
     * @type {boolean|string[]|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // enable the default row headers
     * rowHeaders: true,
     *
     * // set your own row headers
     * rowHeaders: ['One', 'Two', 'Three'],
     *
     * // set your own row headers, using a function
     * rowHeaders: function(visualRowIndex) {
     *   return `${visualRowIndex}: AB`;
     * },
     * ```
     */
    rowHeaders: undefined,
    /**
     * @description
     * The `rowHeaderWidth` option configures the width of row headers.
     *
     * You can set the `rowHeaderWidth` option to one of the following:
     *
     * | Setting  | Description                                     |
     * | -------- | ----------------------------------------------- |
     * | A number | Set the same width for every row header         |
     * | An array | Set different widths for individual row headers |
     *
     * @memberof Options#
     * @type {number|number[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the same width for every row header
     * rowHeaderWidth: 25,
     *
     * // set different widths for individual row headers
     * rowHeaderWidth: [25, 30, 55],
     * ```
     */
    rowHeaderWidth: undefined,
    /**
     * The `rowHeights` option sets rows' heights, in pixels.
     *
     * In the rendering process, the default row height is 23 px (in the classic theme: 22 px + 1 px of the row's bottom border) or whatever is defined in the used theme (based on the line height, vertical padding and cell borders).
     * You can change it to equal or greater than the defautl value, by setting the `rowHeights` option to one of the following:
     *
     * | Setting     | Description                                                                                         | Example                                                      |
     * | ----------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |
     * | A number    | Set the same height for every row                                                                   | `rowHeights: 100`                                            |
     * | A string    | Set the same height for every row                                                                   | `rowHeights: '100px'`                                        |
     * | An array    | Set heights separately for each row                                                                 | `rowHeights: [100, 120, undefined]`                          |
     * | A function  | Set row heights dynamically,<br>on each render                                                      | `rowHeights(visualRowIndex) { return visualRowIndex * 10; }` |
     * | `undefined` | Used by the [modifyRowHeight](@/api/hooks.md#modifyRowHeight) hook,<br>to detect row height changes | `rowHeights: undefined`                                      |
     *
     * The `rowHeights` option also sets the minimum row height that can be set
     * via the {@link ManualRowResize} and {@link AutoRowSize} plugins (if they are enabled).
     *
     * Read more:
     * - [Row height](@/guides/rows/row-height/row-height.md)
     *
     * @memberof Options#
     * @type {number|number[]|string|string[]|Array<undefined>|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set every row's height to 100px
     * rowHeights: 100,
     *
     * // set every row's height to 100px
     * rowHeights: '100px',
     *
     * // set the first (by visual index) row's height to 100
     * // set the second (by visual index) row's height to 120
     * // set the third (by visual index) row's height to `undefined`
     * // set any other row's height to the default height value
     * rowHeights: [100, 120, undefined],
     *
     * // set each row's height individually, using a function
     * rowHeights(visualRowIndex) {
     *   return visualRowIndex * 10;
     * },
     * ```
     */
    rowHeights: undefined,
    /**
     * @description
     * The `search` option configures the [`Search`](@/api/search.md) plugin.
     *
     * You can set the `search` option to one of the following:
     *
     * | Setting           | Description                                                                          |
     * | ----------------- | ------------------------------------------------------------------------------------ |
     * | `false` (default) | Disable the [`Search`](@/api/search.md) plugin                                       |
     * | `true`            | Enable the [`Search`](@/api/search.md) plugin with the default configuration         |
     * | An object         | - Enable the [`Search`](@/api/search.md) plugin<br>- Apply your custom configuration |
     *
     * If you set the `search` option to an object, you can configure the following search options:
     *
     * | Option              | Possible settings | Description                                                                                          |
     * | ------------------- | ----------------- | ---------------------------------------------------------------------------------------------------- |
     * | `searchResultClass` | A string          | Add a custom CSS class name to search results                                                        |
     * | `queryMethod`       | A function        | Add a [custom query method](@/guides/navigation/searching-values/searching-values.md#custom-query-method)  |
     * | `callback`          | A function        | Add a [custom callback function](@/guides/navigation/searching-values/searching-values.md#custom-callback) |
     *
     * Read more:
     * - [Searching values](@/guides/navigation/searching-values/searching-values.md)
     * - [Searching values: Custom query method](@/guides/navigation/searching-values/searching-values.md#custom-query-method)
     * - [Searching values: Custom callback](@/guides/navigation/searching-values/searching-values.md#custom-callback)
     *
     * @memberof Options#
     * @type {boolean|object}
     * @default false
     * @category Search
     *
     * @example
     * ```js
     * // enable the `Search` plugin with the default configuration
     * search: true,
     *
     * // enable the `Search` plugin with a custom configuration
     * search: {
     *   // add a `customClass` CSS class name to search results
     *   searchResultClass: 'customClass',
     *   // add a custom query method
     *   queryMethod(queryStr, value) {
     *     ...
     *   },
     *   // add a custom callback function
     *   callback(instance, row, column, value, result) {
     *     ...
     *   }
     * }
     * ```
     */
    search: false,
    /**
     * @description
     * The `selectionMode` option configures how [selection](@/guides/cell-features/selection/selection.md) works.
     *
     * You can set the `selectionMode` option to one of the following:
     *
     * | Setting      | Description                                                  |
     * | ------------ | ------------------------------------------------------------ |
     * | `'single'`   | Allow the user to select only one cell at a time.            |
     * | `'range'`    | Allow the user to select one range of cells at a time.       |
     * | `'multiple'` | Allow the user to select multiple ranges of cells at a time. |
     *
     * Read more:
     * - [Selection: Selecting ranges](@/guides/cell-features/selection/selection.md#select-ranges)
     *
     * @memberof Options#
     * @type {string}
     * @default 'multiple'
     * @category Core
     *
     * @example
     * ```js
     * // you can only select one cell at at a time
     * selectionMode: 'single',
     *
     * // you can select one range of cells at a time
     * selectionMode: 'range',
     *
     * // you can select multiple ranges of cells at a time
     * selectionMode: 'multiple',
     * ```
     */
    selectionMode: 'multiple',
    /**
     * The `selectOptions` option configures options that the end user can choose from in [`select`](@/guides/cell-types/select-cell-type/select-cell-type.md) cells.
     *
     * You can set the `selectOptions` option to one of the following:
     *
     * | Setting                         | Description                                                                   |
     * | ------------------------------- | ----------------------------------------------------------------------------- |
     * | An array of strings             | Each string is one option's value and label                                   |
     * | An object with key-string pairs | - Each key is one option's value<br>- The key's string is that option's label |
     * | A function                      | A function that returns an object with key-string pairs                       |
     *
     * Read more:
     * - [Select cell type](@/guides/cell-types/select-cell-type/select-cell-type.md)
     *
     * @memberof Options#
     * @type {string[]|object|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     // set the first option's value and label to `A`
     *     // set the second option's value and label to `B`
     *     // set the third option's value and label to `C`
     *     selectOptions: ['A', 'B', 'C'],
     *   },
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     selectOptions: {
     *       // set the first option's value to `value1` and label to `Label 1`
     *       value1: 'Label 1',
     *       // set the second option's value to `value2` and label to `Label 2`
     *       value2: 'Label 2',
     *       // set the third option's value to `value3` and label to `Label 3`
     *       value3: 'Label 3',
     *     },
     *   },
     *   {
     *     // set the `type` of each cell in this column to `select`
     *     type: 'select',
     *     // set `selectOption` to a function that returns available options as an object
     *     selectOptions(visualRow, visualColumn, prop) {
     *       return {
     *         value1: 'Label 1',
     *         value2: 'Label 2',
     *         value3: 'Label 3',
     *       };
     *   },
     * ],
     * ```
     */
    selectOptions: undefined,
    /**
     * @description
     * The `skipColumnOnPaste` option determines whether you can paste data into a given column.
     *
     * You can only apply the `skipColumnOnPaste` option to an entire column, using the [`columns`](#columns) option.
     *
     * You can set the `skipColumnOnPaste` option to one of the following:
     *
     * | Setting           | Description                                                                                           |
     * | ----------------- | ----------------------------------------------------------------------------------------------------- |
     * | `false` (default) | Enable pasting data into this column                                                                  |
     * | `true`            | - Disable pasting data into this column<br>- On pasting, paste data into the next column to the right |
     *
     * Read more:
     * - [Configuration options: Setting column options](@/guides/getting-started/configuration-options/configuration-options.md#set-column-options)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // disable pasting data into this column
     *     skipColumnOnPaste: true
     *   }
     * ],
     * ```
     */
    skipColumnOnPaste: false,
    /**
     * @description
     *
     * The `skipRowOnPaste` option determines whether you can paste data into a given row.
     *
     * You can only apply the `skipRowOnPaste` option to an entire row, using the [`cells`](#cells) option.
     *
     * You can set the `skipRowOnPaste` option to one of the following:
     *
     * | Setting           | Description                                                                         |
     * | ----------------- | ----------------------------------------------------------------------------------- |
     * | `false` (default) | Enable pasting data into this row                                                   |
     * | `true`            | - Disable pasting data into this row<br>- On pasting, paste data into the row below |
     *
     * Read more:
     * - [Configuration options: Setting row options](@/guides/getting-started/configuration-options/configuration-options.md#set-row-options)
     *
     * @memberof Options#
     * @type {boolean}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * cells(row, column) {
     *  const cellProperties = {};
     *
     *  // disable pasting data into row 1
     *  if (row === 1) {
     *    cellProperties.skipRowOnPaste = true;
     *  }
     *
     *  return cellProperties;
     * }
     * ```
     */
    skipRowOnPaste: false,
    /**
     * The `sortByRelevance` option configures whether [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md) cells'
     * lists are sorted in the same order as provided in the [`source`](#source) option.
     *
     * You can set the `sortByRelevance` option to one of the following:
     *
     * | Setting          | Description                                                                  |
     * | ---------------- | ---------------------------------------------------------------------------- |
     * | `true` (default) | Sort options in the same order as provided in the [`source`](#source) option |
     * | `false`          | Sort options alphabetically                                                  |
     *
     * Read more:
     * - [`source`](#source)
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['D', 'C', 'B', 'A'],
     *   // sort the `autocomplete` option in this order: D, C, B, A
     *   sortByRelevance: true
     * }],
     * ```
     */
    sortByRelevance: true,
    /**
     * The `source` option sets options available in [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md) cells.
     *
     * You can set the `source` option to one of the following:
     *
     * - An array
     * - A function
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md)
     * - [`strict`](#strict)
     * - [`allowHtml`](#allowHtml)
     * - [`filter`](#filter)
     * - [`sortByRelevance`](#sortByRelevance)
     *
     * @memberof Options#
     * @type {Array|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set `source` to an array
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C', 'D']
     * }],
     *
     * // set `source` to a function
     * columns: [{
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // for every `autocomplete` cell in this column, fetch data from an external source
     *   source(query, callback) {
     *     fetch('https://example.com/query?q=' + query, function(response) {
     *       callback(response.items);
     *     })
     *   }
     * }],
     * ```
     */
    source: undefined,
    /**
     * @description
     * If the [`data`](#data) option is not set, the `startCols` option sets the initial number of empty columns.
     *
     * The `startCols` option works only in Handsontable's constructor.
     *
     * @memberof Options#
     * @type {number}
     * @default 5
     * @category Core
     *
     * @example
     * ```js
     * // start with 15 empty columns
     * startCols: 15,
     * ```
     */
    startCols: 5,
    /**
     * @description
     * If the [`data`](#data) option is not set, the `startRows` option sets the initial number of empty rows.
     *
     * The `startRows` option works only in Handsontable's constructor.
     *
     * @memberof Options#
     * @type {number}
     * @default 5
     * @category Core
     *
     * @example
     * ```js
     * // start with 15 empty rows
     * startRows: 15,
     * ```
     */
    startRows: 5,
    /**
     * @description
     * The `stretchH` option determines what happens when the declared grid width
     * is different from the calculated sum of all column widths.
     *
     * You can set the `stretchH` option to one of the following:
     *
     * | Setting            | Description                                                       |
     * | ------------------ | ----------------------------------------------------------------- |
     * | `'none'` (default) | Don't fit the grid to the container (disable column stretching)   |
     * | `'last'`           | Fit the grid to the container, by stretching only the last column |
     * | `'all'`            | Fit the grid to the container, by stretching all columns evenly   |
     *
     * Read more:
     * - [Column width: Column stretching](@/guides/columns/column-width/column-width.md#column-stretching)
     *
     * @memberof Options#
     * @type {string}
     * @default 'none'
     * @category Core
     *
     * @example
     * ```js
     * // fit the grid to the container
     * // by stretching all columns evenly
     * stretchH: 'all',
     * ```
     */
    stretchH: 'none',
    /**
     * The `strict` option configures the behavior of [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md) cells.
     *
     * You can set the `strict` option to one of the following:
     *
     * | Setting | Mode                                                                                          | Description                                                                                |
     * | ------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
     * | `true`  | [Strict mode](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md#autocomplete-strict-mode)         | The end user:<br>- Can only choose one of suggested values<br>- Can't enter a custom value |
     * | `false` | [Flexible mode](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md#autocomplete-flexible-mode)     | The end user:<br>- Can choose one of suggested values<br>- Can enter a custom value        |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * - [`source`](#source)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *   // set the `type` of each cell in this column to `autocomplete`
     *   type: 'autocomplete',
     *   // set options available in every `autocomplete` cell of this column
     *   source: ['A', 'B', 'C'],
     *   // values entered must match `A`, `B`, or `C`
     *   strict: true
     *   },
     * ],
     * ```
     */
    strict: undefined,
    /**
     * The `tableClassName` option lets you add CSS class names
     * to every Handsontable instance inside the `container` element.
     *
     * You can set the `tableClassName` option to one of the following:
     *
     * | Setting             | Description                                                                                |
     * | ------------------- | ------------------------------------------------------------------------------------------ |
     * | A string            | Add a single CSS class name to every Handsontable instance inside the `container` element  |
     * | An array of strings | Add multiple CSS class names to every Handsontable instance inside the `container` element |
     *
     * Read more:
     * - [`currentRowClassName`](#currentRowClassName)
     * - [`currentColClassName`](#currentColClassName)
     * - [`currentHeaderClassName`](#currentHeaderClassName)
     * - [`activeHeaderClassName`](#activeHeaderClassName)
     * - [`invalidCellClassName`](#invalidCellClassName)
     * - [`placeholderCellClassName`](#placeholderCellClassName)
     * - [`readOnlyCellClassName`](#readOnlyCellClassName)
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     * - [`commentedCellClassName`](#commentedCellClassName)
     * - [`className`](#className)
     *
     * @memberof Options#
     * @type {string|string[]}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // add a `your-class-name` CSS class name
     * // to every Handsontable instance inside the `container` element
     * tableClassName: 'your-class-name',
     *
     * // add `first-class-name` and `second-class-name` CSS class names
     * // to every Handsontable instance inside the `container` element
     * tableClassName: ['first-class-name', 'second-class-name'],
     * ```
     */
    tableClassName: undefined,
    /**
     * The `themeName` option allows enabling a theme by that name.
     *
     * If no `themeName` is provided, the table will use the classic theme (if the correct CSS files are imported).
     *
     * Read more:
     * - [Themes](@/guides/styling/themes/themes.md)
     *
     * @memberof Options#
     * @type {string|boolean|undefined}
     * @default undefined
     * @category Core
     * @since 15.0.0
     *
     * @example
     * ```js
     * themeName: 'ht-theme-name',
     * ```
     */
    themeName: undefined,
    /**
     * The `tabMoves` option configures the action of the <kbd>**Tab**</kbd> key.
     *
     * You can set the `tabMoves` option to an object with the following properties
     * (or to a function that returns such an object):
     *
     * | Property | Type   | Description                                                                                                                                              |
     * | -------- | ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | `row`    | Number | - On pressing <kbd>**Tab**</kbd>, move selection `row` rows down<br>- On pressing <kbd>**Shift**</kbd>+<kbd>**Tab**</kbd>, move selection `row` rows up              |
     * | `col`    | Number | - On pressing <kbd>**Tab**</kbd>, move selection `col` columns right<br>- On pressing <kbd>**Shift**</kbd>+<kbd>**Tab**</kbd>, move selection `col` columns left     |
     *
     * @memberof Options#
     * @type {object|Function}
     * @default {row: 0, col: 1}
     * @category Core
     *
     * @example
     * ```js
     * // on pressing Tab, move selection 2 rows down and 2 columns right
     * // on pressing Shift+Tab, move selection 2 rows up and 2 columns left
     * tabMoves: {row: 2, col: 2},
     *
     * // the same setting, as a function
     * // `event` is a DOM Event object received on pressing Tab
     * // you can use it to check whether the user pressed Tab or Shift+Tab
     * tabMoves(event) {
     *   return {row: 2, col: 2};
     * },
     * ```
     */
    tabMoves: {
      row: 0,
      col: 1
    },
    /**
     * @description
     * The `title` option configures [column header](@/guides/columns/column-header/column-header.md) names.
     *
     * You can set the `title` option to a string.
     *
     * Read more:
     * - [Column header](@/guides/columns/column-header/column-header.md)
     * - [`columns`](#columns)
     *
     * @memberof Options#
     * @type {string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the first column header name to `First name`
     *     title: 'First name',
     *     type: 'text',
     *   },
     *   {
     *     // set the second column header name to `Last name`
     *     title: 'Last name',
     *     type: 'text',
     *   }
     * ],
     * ```
     */
    title: undefined,
    /**
     * The `trimDropdown` option configures the width of the [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md) lists.
     *
     * You can set the `trimDropdown` option to one of the following:
     *
     * | Setting          | Description                                                                     |
     * | ---------------- | ------------------------------------------------------------------------------- |
     * | `true` (default) | Make the dropdown/autocomplete list's width the same as the edited cell's width |
     * | `false`          | Scale the dropdown/autocomplete list's width to the list's content              |
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     // for each cell of this column
     *     // make the `autocomplete` list's width the same as the edited cell's width
     *     trimDropdown: true,
     *   },
     *   {
     *     type: 'dropdown',
     *     // for each cell of this column
     *     // scale the `dropdown` list's width to the list's content
     *     trimDropdown: false,
     *   }
     * ],
     * ```
     */
    trimDropdown: true,
    /**
     * @description
     * The `trimRows` option configures the [`TrimRows`](@/api/trimRows.md) plugin.
     *
     * You can set the `trimRows` option to one of the following:
     *
     * | Setting                          | Description                                                                                   |
     * | -------------------------------- | --------------------------------------------------------------------------------------------- |
     * | `false`                          | Disable the [`TrimRows`](@/api/trimRows.md) plugin                                            |
     * | `true`                           | Enable the [`TrimRows`](@/api/trimRows.md) plugin                                             |
     * | An array of physical row indexes | - Enable the [`TrimRows`](@/api/trimRows.md) plugin<br>- Trim selected rows at initialization |
     *
     * Read more:
     * - [Plugins: `TrimRows`](@/api/trimRows.md)
     * - [Row trimming](@/guides/rows/row-trimming/row-trimming.md)
     *
     * @memberof Options#
     * @type {boolean|number[]}
     * @default undefined
     * @category TrimRows
     *
     * @example
     * ```js
     * // enable the `TrimRows` plugin
     * trimRows: true,
     *
     * // enable the `TrimRows` plugin
     * // at Handsontable's initialization, trim rows 5, 10, and 15
     * trimRows: [5, 10, 15],
     * ```
     */
    trimRows: undefined,
    /**
     * The `trimWhitespace` option configures automatic whitespace removal. This option
     * affects the cell renderer and the cell editor.
     *
     * You can set the `trimWhitespace` option to one of the following:
     *
     * | Setting          | Description                                                     |
     * | ---------------- | --------------------------------------------------------------- |
     * | `true` (default) | Remove whitespace at the beginning and at the end of each cell |
     * | `false`          | Don't remove whitespace                                         |
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // don't remove whitespace
     *     // from any cell of this column
     *     trimWhitespace: false
     *   }
     * ]
     * ```
     */
    trimWhitespace: true,
    /**
     * @description
     * The `type` option lets you set the [`renderer`](#renderer), [`editor`](#editor), and [`validator`](#validator)
     * options all at once, by selecting a [cell type](@/guides/cell-types/cell-type/cell-type.md).
     *
     * You can set the `type` option to one of the following:
     *
     * | Cell type                                                         | Renderer, editor & validator                                                                                                                                                                                                                       |
     * | ----------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
     * | A [custom cell type](@/guides/cell-types/cell-type/cell-type.md)            | Renderer: your [custom cell renderer](@/guides/cell-functions/cell-renderer/cell-renderer.md)<br>Editor: your [custom cell editor](@/guides/cell-functions/cell-editor/cell-editor.md)<br>Validator: your [custom cell validator](@/guides/cell-functions/cell-validator/cell-validator.md) |
     * | [`'autocomplete'`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md) | Renderer: `AutocompleteRenderer`<br>Editor: `AutocompleteEditor`<br>Validator: `AutocompleteValidator`                                                                         |
     * | [`'checkbox'`](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md)         | Renderer: `CheckboxRenderer`<br>Editor: `CheckboxEditor`<br>Validator: -                                                                                                                               |
     * | [`'date'`](@/guides/cell-types/date-cell-type/date-cell-type.md)                 | Renderer: `DateRenderer`<br>Editor: `DateEditor`<br>Validator: `DateValidator`                                                                                                 |
     * | [`'dropdown'`](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md)         | Renderer: `DropdownRenderer`<br>Editor: `DropdownEditor`<br>Validator: `DropdownValidator`                                                                                     |
     * | [`'handsontable'`](@/guides/cell-types/handsontable-cell-type/handsontable-cell-type.md) | Renderer: `AutocompleteRenderer`<br>Editor: `HandsontableEditor`<br>Validator: -                                                                                                                       |
     * | [`'numeric'`](@/guides/cell-types/numeric-cell-type/numeric-cell-type.md)           | Renderer: `NumericRenderer`<br>Editor: `NumericEditor`<br>Validator: `NumericValidator`                                                                                        |
     * | [`'password'`](@/guides/cell-types/password-cell-type/password-cell-type.md)         | Renderer: `PasswordRenderer`<br>Editor: `PasswordEditor`<br>Validator: -                                                                                                                               |
     * | `'text'`                                                          | Renderer: `TextRenderer`<br>Editor: `TextEditor`<br>Validator: -                                                                                                                                       |
     * | [`'time`'](@/guides/cell-types/time-cell-type/time-cell-type.md)                 | Renderer: `TimeRenderer`<br>Editor: `TimeEditor`<br>Validator: `TimeValidator`                                                                                                 |
     *
     * Read more:
     * - [Cell type](@/guides/cell-types/cell-type/cell-type.md)
     * - [Cell renderer](@/guides/cell-functions/cell-renderer/cell-renderer.md)
     * - [Cell editor](@/guides/cell-functions/cell-editor/cell-editor.md)
     * - [Cell validator](@/guides/cell-functions/cell-validator/cell-validator.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options/configuration-options.md#cascading-configuration)
     * - [`renderer`](#renderer)
     * - [`editor`](#editor)
     * - [`validator`](#validator)
     *
     * @memberof Options#
     * @type {string}
     * @default 'text'
     * @category Core
     *
     * @example
     * ```js
     * // set the `numeric` cell type for each cell of the entire grid
     * type: `'numeric'`,
     *
     * // apply the `type` option to individual columns
     * columns: [
     *   {
     *     // set the `autocomplete` cell type for each cell of this column
     *     type: 'autocomplete'
     *   },
     *   {
     *     // set the `myCustomCellType` cell type for each cell of this column
     *     type: 'myCustomCellType'
     *   }
     * ]
     * ```
     */
    type: 'text',
    /**
     * The `uncheckedTemplate` option lets you configure what value
     * an unchecked [`checkbox`](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md) cell has.
     *
     * You can set the `uncheckedTemplate` option to one of the following:
     *
     * | Setting           | Description                                                                                                                                                                                |
     * | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
     * | `false` (default) | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md) cell is unchecked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns `false`                 |
     * | A string          | If a [`checkbox`](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md) cell is unchecked,<br>the [`getDataAtCell`](@/api/core.md#getDataAtCell) method for this cell returns a string of your choice |
     *
     * Read more:
     * - [Checkbox cell type: Checkbox template](@/guides/cell-types/checkbox-cell-type/checkbox-cell-type.md#checkbox-template)
     * - [`getDataAtCell()`](@/api/core.md#getDataAtCell)
     * - [`checkedTemplate`](#checkedTemplate)
     *
     * @memberof Options#
     * @type {boolean|string|number}
     * @default false
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when unchecked, the cell's value is `false`
     *     // when checked, the cell's value is `true`
     *     type: 'checkbox',
     *   },
     *   {
     *     // set the `type` of each cell in this column to `checkbox`
     *     // when unchecked, the cell's value is `'No'`
     *     // when checked, the cell's value is `'Yes'`
     *     type: 'checkbox',
     *     uncheckedTemplate: 'No'
     *     checkedTemplate: 'Yes',
     *  }
     * ],
     * ```
     */
    uncheckedTemplate: undefined,
    /**
     * The `undo` option configures the [`UndoRedo`](@/api/undoRedo.md) plugin.
     *
     * You can set the `undo` option to one of the following:
     *
     * | Setting | Description                                        |
     * | ------- | -------------------------------------------------- |
     * | `true`  | Enable the [`UndoRedo`](@/api/undoRedo.md) plugin  |
     * | `false` | Disable the [`UndoRedo`](@/api/undoRedo.md) plugin |
     *
     * By default, the `undo` option is set to `undefined`,
     * but the [`UndoRedo`](@/api/undoRedo.md) plugin acts as enabled.
     * To disable the [`UndoRedo`](@/api/undoRedo.md) plugin completely,
     * set the `undo` option to `false`.
     *
     * Read more:
     * - [Undo and redo](@/guides/accessories-and-menus/undo-redo/undo-redo.md)
     *
     * @memberof Options#
     * @type {boolean}
     * @default undefined
     * @category UndoRedo
     *
     * @example
     * ```js
     * // enable the `UndoRedo` plugin
     * undo: true,
     * ```
     */
    undo: undefined,
    /**
     * @description
     * The `validator` option sets a [cell validator](@/guides/cell-functions/cell-validator/cell-validator.md) for a cell.
     *
     * You can set the `validator` option to one of the following:
     *
     * | Setting              | Description                                                                      |
     * | -------------------- | -------------------------------------------------------------------------------- |
     * | A string             | A [cell validator alias](@/guides/cell-functions/cell-validator/cell-validator.md)              |
     * | A function           | Your [custom cell validator function](@/guides/cell-functions/cell-validator/cell-validator.md) |
     * | A regular expression | A regular expression used for cell validation                                    |
     *
     * By setting the `validator` option to a string,
     * you can use one of the following [cell validator aliases](@/guides/cell-functions/cell-validator/cell-validator.md):
     *
     * | Alias               | Cell validator function                                                 |
     * | ------------------- | ----------------------------------------------------------------------- |
     * | A custom alias      | Your [custom cell validator](@/guides/cell-functions/cell-validator/cell-validator.md) |
     * | `'autocomplete'`    | `AutocompleteValidator`                                                 |
     * | `'date'`            | `DateValidator`                                                         |
     * | `'dropdown'`        | `DropdownValidator`                                                     |
     * | `'numeric'`         | `NumericValidator`                                                      |
     * | `'time'`            | `TimeValidator`                                                         |
     *
     * To set the [`editor`](#editor), [`renderer`](#renderer), and [`validator`](#validator)
     * options all at once, use the [`type`](#type) option.
     *
     * Read more:
     * - [Cell validator](@/guides/cell-functions/cell-validator/cell-validator.md)
     * - [Cell type](@/guides/cell-types/cell-type/cell-type.md)
     * - [Configuration options: Cascading configuration](@/guides/getting-started/configuration-options/configuration-options.md#cascading-configuration)
     * - [`type`](#type)
     *
     * @memberof Options#
     * @type {Function|RegExp|string}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *    {
     *      // use a built-in `numeric` cell validator
     *      validator: 'numeric'
     *    },
     *    {
     *      // validate against a regular expression
     *      validator: /^[0-9]$/
     *    },
     *    {
     *      // add a custom cell validator function
     *      validator(value, callback) {
     *          ...
     *      }
     *    },
     * ],
     * ```
     */
    validator: undefined,
    /**
     * @description
     * The `viewportColumnRenderingOffset` option configures the number of columns
     * to be rendered outside of the grid's viewport.
     *
     * You can set the `viewportColumnRenderingOffset` option to one of the following:
     *
     * | Setting            | Description                                             |
     * | ------------------ | ------------------------------------------------------- |
     * | `auto` (default)   | Use the offset calculated automatically by Handsontable |
     * | A number           | Set the offset manually                                 |
     *
     * The `viewportColumnRenderingOffset` setting is ignored when [`renderAllColumns`](#renderAllColumns) is set to `true`.
     *
     * Read more:
     * - [Performance: Define the number of pre-rendered rows and columns](@/guides/optimization/performance/performance.md#define-the-number-of-pre-rendered-rows-and-columns)
     *
     * @memberof Options#
     * @type {number|'auto'}
     * @default 'auto'
     * @category Core
     *
     * @example
     * ```js
     * // render 70 columns outside of the grid's viewport
     * viewportColumnRenderingOffset: 70,
     * ```
     */
    viewportColumnRenderingOffset: 'auto',
    /**
     * @description
     * The `viewportRowRenderingOffset` option configures the number of rows
     * to be rendered outside of the grid's viewport.
     *
     * You can set the `viewportRowRenderingOffset` option to one of the following:
     *
     * | Setting            | Description                                             |
     * | ------------------ | ------------------------------------------------------- |
     * | `auto` (default)   | Use the offset calculated automatically by Handsontable |
     * | A number           | Set the offset manually                                 |
     *
     * The `viewportRowRenderingOffset` setting is ignored when [`renderAllRows`](#renderAllRows) is set to `true`.
     *
     * Read more:
     * - [Performance: Define the number of pre-rendered rows and columns](@/guides/optimization/performance/performance.md#define-the-number-of-pre-rendered-rows-and-columns)
     * - [Column virtualization](@/guides/columns/column-virtualization/column-virtualization.md)
     *
     * @memberof Options#
     * @type {number|'auto'}
     * @default 'auto'
     * @category Core
     *
     * @example
     * ```js
     * // render 70 rows outside of the grid's viewport
     * viewportRowRenderingOffset: 70,
     * ```
     */
    viewportRowRenderingOffset: 'auto',
    /**
     * @description
     * The `viewportColumnRenderingThreshold` option configures what column number starting from the left or right
     * (depends on the scroll direction) should trigger the rendering of columns outside of the grid's viewport.
     *
     * You can set the `viewportColumnRenderingThreshold` option to one of the following:
     *
     * | Setting            | Description                                             |
     * | ------------------ | ------------------------------------------------------- |
     * | `auto`             | Triggers rendering at half the offset defined by [`viewportColumnRenderingOffset`](#viewportColumnRenderingOffset) option |
     * | A number           | Sets the offset manually (`0` is a default)             |
     *
     * The `viewportColumnRenderingThreshold` setting is ignored when [`renderAllColumn`](#renderAllColumn) is set to `true`.
     *
     * Read more:
     * - [Performance: Define the number of pre-rendered rows and columns](@/guides/optimization/performance/performance.md#define-the-number-of-pre-rendered-rows-and-columns)
     * - [Column virtualization](@/guides/columns/column-virtualization/column-virtualization.md)
     *
     * @memberof Options#
     * @since 1.14.7
     * @type {number|'auto'}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // render 12 columns outside of the grid's viewport
     * viewportColumnRenderingOffset: 12,
     * // the columns outside of the viewport will be rendered when the user scrolls to the 8th column from/to
     * viewportColumnRenderingThreshold: 8,
     * ```
     */
    viewportColumnRenderingThreshold: 0,
    /**
     * @description
     * The `viewportRowRenderingThreshold` option configures what row number starting from the top or bottom
     * (depends on the scroll direction) should trigger the rendering of rows outside of the grid's viewport.
     *
     * You can set the `viewportRowRenderingThreshold` option to one of the following:
     *
     * | Setting            | Description                                             |
     * | ------------------ | ------------------------------------------------------- |
     * | `auto`             | Triggers rendering at half the offset defined by [`viewportRowRenderingOffset`](#viewportRowRenderingOffset) option |
     * | A number           | Sets the offset manually (`0` is a default)             |
     *
     * The `viewportRowRenderingThreshold` setting is ignored when [`renderAllRows`](#renderAllRows) is set to `true`.
     *
     * Read more:
     * - [Performance: Define the number of pre-rendered rows and columns](@/guides/optimization/performance/performance.md#define-the-number-of-pre-rendered-rows-and-columns)
     * - [Row virtualization](@/guides/rows/row-virtualization/row-virtualization.md)
     *
     * @memberof Options#
     * @since 1.14.7
     * @type {number|'auto'}
     * @default 0
     * @category Core
     *
     * @example
     * ```js
     * // render 12 rows outside of the grid's viewport
     * viewportRowRenderingOffset: 12,
     * // the rows outside of the viewport will be rendered when the user scrolls to the 8th row from/to
     * viewportRowRenderingThreshold: 8,
     * ```
     */
    viewportRowRenderingThreshold: 0,
    /**
     * The `visibleRows` option sets the height of the [`autocomplete`](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * and [`dropdown`](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md) lists.
     *
     * When the number of list options exceeds the `visibleRows` number, a scrollbar appears.
     *
     * Read more:
     * - [Autocomplete cell type](@/guides/cell-types/autocomplete-cell-type/autocomplete-cell-type.md)
     * - [Dropdown cell type](@/guides/cell-types/dropdown-cell-type/dropdown-cell-type.md)
     *
     * @memberof Options#
     * @type {number}
     * @default 10
     * @category Core
     *
     * @example
     * ```js
     * columns: [
     *   {
     *     type: 'autocomplete',
     *     // set the `autocomplete` list's height to 15 options
     *     // for each cell of this column
     *     visibleRows: 15,
     *   },
     *   {
     *     type: 'dropdown',
     *     // set the `dropdown` list's height to 5 options
     *     // for each cell of this column
     *     visibleRows: 5,
     *   }
     * ],
     * ```
     */
    visibleRows: 10,
    /**
     * The `width` option configures the width of your grid.
     *
     * You can set the `width` option to one of the following:
     *
     * | Setting                                                                    | Example                   |
     * | -------------------------------------------------------------------------- | ------------------------- |
     * | A number of pixels                                                         | `width: 500`              |
     * | A string with a [CSS unit](https://www.w3schools.com/cssref/css_units.asp) | `width: '75vw'`           |
     * | A function that returns a valid number or string                           | `width() { return 500; }` |
     *
     * Read more:
     * - [Grid size](@/guides/getting-started/grid-size/grid-size.md)
     *
     * @memberof Options#
     * @type {number|string|Function}
     * @default undefined
     * @category Core
     *
     * @example
     * ```js
     * // set the grid's width to 500px
     * width: 500,
     *
     * // set the grid's width to 75vw
     * width: '75vw',
     *
     * // set the grid's width to 500px, using a function
     * width() {
     *   return 500;
     * },
     * ```
     */
    width: undefined,
    /**
     * The `wordWrap` option configures whether content that exceeds a column's width is wrapped or not.
     *
     * You can set the `wordWrap` option to one of the following:
     *
     * | Setting          | Description                                             |
     * | ---------------- | ------------------------------------------------------- |
     * | `true` (default) | If content exceeds the column's width, wrap the content |
     * | `false`          | Don't wrap content                                      |
     *
     * To style cells that don't wrap content, use the [`noWordWrapClassName`](#noWordWrapClassName) option.
     *
     * Read more:
     * - [`noWordWrapClassName`](#noWordWrapClassName)
     *
     * @memberof Options#
     * @type {boolean}
     * @default true
     * @category Core
     *
     * @example
     * ```js
     * // set column width for every column of the entire grid
     * colWidths: 100,
     *
     * columns: [
     *   {
     *     // don't wrap content in this column
     *     wordWrap: false,
     *   },
     *   {
     *     // if content exceeds this column's width, wrap the content
     *     wordWrap: true,
     *   }
     * ],
     * ```
     */
    wordWrap: true

    /* eslint-enable jsdoc/require-description-complete-sentence */
  };
};
exports["default"] = _default;

/***/ }),
/* 673 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _object = __webpack_require__(499);
var _utils = __webpack_require__(670);
/**
 * The table meta object is a layer that keeps all settings of the Handsontable that was passed in
 * the constructor. That layer contains all default settings inherited from the GlobalMeta layer
 * merged with settings passed by the developer. Adding, removing, or changing property in that
 * object has no direct reflection on any other layers.
 *
 * +-------------+.
 * │ GlobalMeta  │
 * │ (prototype) │
 * +-------------+\
 *       │         \
 *       │          \
 *      \│/         _\|
 * +-------------+    +-------------+.
 * │ TableMeta   │    │ ColumnMeta  │
 * │ (instance)  │    │ (prototype) │
 * +-------------+    +-------------+.
 *                         │
 *                         │
 *                        \│/
 *                    +-------------+.
 *                    │  CellMeta   │
 *                    │ (instance)  │
 *                    +-------------+.
 */
class TableMeta {
  constructor(globalMeta) {
    /**
     * Main object (instance of the internal TableMeta class from GlobalMeta), holder for all settings defined in the table scope.
     *
     * @type {TableMeta}
     */
    (0, _defineProperty2.default)(this, "meta", void 0);
    const MetaCtor = globalMeta.getMetaConstructor();
    this.meta = new MetaCtor();
  }

  /**
   * Gets settings object for this layer.
   *
   * @returns {TableMeta}
   */
  getMeta() {
    return this.meta;
  }

  /**
   * Updates table settings object by merging settings with the current state.
   *
   * @param {object} settings An object to merge with.
   */
  updateMeta(settings) {
    (0, _object.extend)(this.meta, settings);
    (0, _utils.extendByMetaType)(this.meta, settings, settings);
  }
}
exports["default"] = TableMeta;

/***/ }),
/* 674 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _object = __webpack_require__(499);
var _utils = __webpack_require__(670);
var _lazyFactoryMap = _interopRequireDefault(__webpack_require__(675));
/**
 * List of props which have to be cleared in the column meta-layer. That props have a
 * different meaning when using in column meta.
 *
 * @type {string[]}
 */
const COLUMNS_PROPS_CONFLICTS = ['data', 'width'];

/**
 * The column meta object is a root of all settings defined in the column property of the Handsontable
 * settings. Each column in the Handsontable is associated with a unique meta object which is managed by
 * this layer. Adding, removing, or changing property in that object has a direct reflection only for
 * the CellMeta layer. The reflection will be visible only if the property doesn't exist in the lower
 * layers (prototype lookup).
 *
 * +-------------+.
 * │ GlobalMeta  │
 * │ (prototype) │
 * +-------------+\
 *       │         \
 *       │          \
 *      \│/         _\|
 * +-------------+    +-------------+.
 * │ TableMeta   │    │ ColumnMeta  │
 * │ (instance)  │    │ (prototype) │
 * +-------------+    +-------------+.
 *                         │
 *                         │
 *                        \│/
 *                    +-------------+.
 *                    │  CellMeta   │
 *                    │ (instance)  │
 *                    +-------------+.
 */
class ColumnMeta {
  constructor(globalMeta) {
    /**
     * Reference to the GlobalMeta layer. While creating new column meta objects, all new objects
     * inherit properties from the GlobalMeta layer.
     *
     * @type {GlobalMeta}
     */
    (0, _defineProperty2.default)(this, "globalMeta", void 0);
    /**
     * The LazyFactoryMap structure, holder for column meta objects where each column meta is
     * stored under the physical column index.
     *
     * @type {LazyFactoryMap}
     */
    (0, _defineProperty2.default)(this, "metas", new _lazyFactoryMap.default(() => this._createMeta()));
    this.globalMeta = globalMeta;
    this.metas = new _lazyFactoryMap.default(() => this._createMeta());
  }

  /**
   * Updates column meta object by merging settings with the current state.
   *
   * @param {number} physicalColumn The physical column index which points what column meta object is updated.
   * @param {object} settings An object to merge with.
   */
  updateMeta(physicalColumn, settings) {
    const meta = this.getMeta(physicalColumn);
    (0, _object.extend)(meta, settings);
    (0, _utils.extendByMetaType)(meta, settings);
  }

  /**
   * Creates one or more columns at specific position.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is added.
   * @param {number} amount An amount of columns to add.
   */
  createColumn(physicalColumn, amount) {
    this.metas.insert(physicalColumn, amount);
  }

  /**
   * Removes one or more columns from the collection.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is removed.
   * @param {number} amount An amount columns to remove.
   */
  removeColumn(physicalColumn, amount) {
    this.metas.remove(physicalColumn, amount);
  }

  /**
   * Gets settings object for this layer.
   *
   * @param {number} physicalColumn The physical column index.
   * @returns {object}
   */
  getMeta(physicalColumn) {
    return this.metas.obtain(physicalColumn);
  }

  /**
   * Gets constructor of the column meta object. Necessary for inheritance - creating the next meta layers.
   *
   * @param {number} physicalColumn The physical column index.
   * @returns {Function}
   */
  getMetaConstructor(physicalColumn) {
    return this.metas.obtain(physicalColumn).constructor;
  }

  /**
   * Clears all saved column meta objects.
   */
  clearCache() {
    this.metas.clear();
  }

  /**
   * Creates and returns new column meta object with properties inherited from the global meta layer.
   *
   * @private
   * @returns {object}
   */
  _createMeta() {
    return (0, _utils.columnFactory)(this.globalMeta.getMetaConstructor(), COLUMNS_PROPS_CONFLICTS).prototype;
  }
}
exports["default"] = ColumnMeta;

/***/ }),
/* 675 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _array = __webpack_require__(495);
var _utils = __webpack_require__(670);
/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * @class LazyFactoryMap
 *
 * The LazyFactoryMap object holds key-value pairs in the structure similar to the
 * regular Map. Once created, items can be moved around a grid depending on the operations
 * performed on that grid - adding or removing rows. The collection requires "key"
 * to be a zero-based index.
 *
 * It's essential to notice that the "key" index under which the item was created
 * is volatile. After altering the grid, the "key" index can change.
 *
 * Having created N items with corresponding example data where the data has 10
 * holes (`undefined` values) within (that's why internal storage index counts from 10).
 * +------+------+------+------+------+.
 * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys (volatile zero-based index / internal storage index)
 * +------+------+------+------+------+.
 *    │      │      │      │      │
 * +------+------+------+------+------+.
 * | AAA  | BBB  | CCC  | DDD  | EEE  |  Data
 * +------+------+------+------+------+.
 *
 * Map.obtain(0) // returns "AAA"
 * map.obtain(2) // returns "CCC".
 *
 * After inserting 2 new rows, keys that hold the data positioned after the place
 * where the new rows are added are upshifted by 2.
 *               │
 *               │ Insert 2 rows
 *              \│/
 * +------+------+------+------+------+.
 * | 0/10 | 1/11 | 2/12 | 3/13 | 4/14 |  Keys before
 * +------+------+------+------+------+.
 *
 *                / 2 new rows \
 * +------+------+------+------+------+------+------+.
 * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after
 * +------+------+------+------+------+------+------+.
 *    │       │      │      │      │      │     │
 *    │       │      └──────┼──────┼──────┼┐    │
 *    │       │             └──────┼──────┼┼────┼┐
 *    │       │      ┌─────────────┘      ││    ││
 *    │       │      │      ┌─────────────┘│    ││
 *    │       │      │      │      ┌───────┼────┘│
 *    │       │      │      │      │       │     │
 * +------+------+------+------+------+------+------+.
 * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data
 * +------+------+------+------+------+------+------+
 *
 * Now at index 2 and 3 we have access to new items.
 *
 * map.obtain(2) // returns new value "FFF" for newly created row.
 * map.obtain(4) // index shifted by 2 has access to the old "CCC" value, as before inserting.
 *
 * after removing 4 rows, keys that hold the data positioned after the place where the
 * rows are removed are downshifted by 4.
 *        │
 *        │ Remove 4 rows
 *        ├───────────────────────────┐
 *       \│/                          │
 * +------+------+------+------+------+------+------+
 * | 0/10 | 1/11 | 2/15 | 3/16 | 4/12 | 5/13 | 6/14 |  Keys after
 * +------+------+------+------+------+------+------+
 *    │       │      │      │      │      │     │
 *    │       │      └──────┼──────┼──────┼┐    │
 *    │       │             └──────┼──────┼┼────┼┐
 *    │       │      ┌─────────────┘      ││    ││
 *    │       │      │      ┌─────────────┘│    ││
 *    │       │      │      │      ┌───────┼────┘│
 *    │       │      │      │      │       │     │
 * +------+------+------+------+------+------+------+
 * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data
 * +------+------+------+------+------+------+------+
 *
 * +------+------+------+
 * | 0/10 | 1/13 | 2/14 |  Keys after
 * +------+------+------+
 *    │       │      │
 *    │       │      └─────────────┐
 *    │       └────────────┐       │
 *    │                    │       │
 *    │                    │       │
 *    │                    │       │
 *    │                    │       │
 * +------+------+------+------+------+------+------+
 * | AAA  | BBB  | CCC  | DDD  | EEE  | FFF  | GGG  |  Data
 * +------+------+------+------+------+------+------+
 *           /│\   /│\                   /│\   /│\
 *            └──┬──┘                     └──┬──┘
 *           This data is marked as "hole" which
 *           means that can be replaced by new item
 *           when that will be created.
 *
 * map.obtain(2) // returns the value ("EEE") as it should. Access to the value is
 *               // changed (the key was downshifted). However, the internal index has not changed,
 *               // which means that the data does not need to be changed (spliced) too.
 *
 * After previous remove operation which creates some "holes" obtaining new
 * items replaces that "holes" as follows:
 *
 * // Obtains new item
 * map.obtain(90) // Returns "NEW" value
 *
 * +------+------+------+...+------+
 * | 0/10 | 1/13 | 2/14 |   | 90/0 |  Keys after
 * +------+------+------+...+------+
 *    │       │      │          │
 *    │       │      └──────────┼────────────┐
 *    │       └─────────────────┼─────┐      │
 *    └──────────┐              │     │      │
 *               │              │     │      │
 *    ┌──────────┼──────────────┘     │      │
 *    │          │                    │      │
 * +------+...+------+------+------+------+------+-----+
 * | NEW  |   | AAA  | BBB  | CCC  | DDD  | EEE  | FFF |  Data
 * +------+...+------+------+------+------+------+-----+
 *   /│\
 *    │
 * The first "hole" (at index 0) item is permanently removed and replaced by a new item.
 * The hole index is taken from the hole collection which act as FIFO (First In First Out).
 */
/* eslint-enable jsdoc/require-description-complete-sentence */
class LazyFactoryMap {
  constructor(valueFactory) {
    /**
     * The data factory function.
     *
     * @type {Function}
     */
    (0, _defineProperty2.default)(this, "valueFactory", void 0);
    /**
     * An array which contains data.
     *
     * @type {Array}
     */
    (0, _defineProperty2.default)(this, "data", []);
    /**
     * An array of indexes where the key of the array is mapped to the value which points to the
     * specific position of the data array.
     *
     * @type {number[]}
     */
    (0, _defineProperty2.default)(this, "index", []);
    /**
     * The collection of indexes that points to the data items which can be replaced by obtaining new
     * ones. The "holes" are an intended effect of deleting entries.
     *
     * The idea of "holes" generally allows us to not modify the "data" structure while removing
     * items from the collection.
     *
     * @type {Set<number>}
     */
    (0, _defineProperty2.default)(this, "holes", new Set());
    this.valueFactory = valueFactory;
  }

  /**
   * Gets or if data not exist creates and returns new data.
   *
   * @param {number} key The item key as zero-based index.
   * @returns {*}
   */
  obtain(key) {
    (0, _utils.assert)(() => (0, _utils.isUnsignedNumber)(key), 'Expecting an unsigned number.');
    const dataIndex = this._getStorageIndexByKey(key);
    let result;
    if (dataIndex >= 0) {
      result = this.data[dataIndex];
      if (result === undefined) {
        result = this.valueFactory(key);
        this.data[dataIndex] = result;
      }
    } else {
      result = this.valueFactory(key);
      if (this.holes.size > 0) {
        const reuseIndex = this.holes.values().next().value; // Gets first item from the collection

        this.holes.delete(reuseIndex);
        this.data[reuseIndex] = result;
        this.index[key] = reuseIndex;
      } else {
        this.data.push(result);
        this.index[key] = this.data.length - 1;
      }
    }
    return result;
  }

  /**
   * Inserts an empty data to the map. This method creates an empty space for obtaining
   * new data.
   *
   * @param {number} key The key as volatile zero-based index at which to begin inserting space for new data.
   * @param {number} [amount=1] Ammount of data to insert.
   */
  insert(key) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    (0, _utils.assert)(() => (0, _utils.isUnsignedNumber)(key) || (0, _utils.isNullish)(key), 'Expecting an unsigned number or null/undefined argument.');
    const newIndexes = [];
    const dataLength = this.data.length;
    for (let i = 0; i < amount; i++) {
      newIndexes.push(dataLength + i);
      this.data.push(undefined);
    }
    const insertionIndex = (0, _utils.isNullish)(key) ? this.index.length : key;
    this.index = [...this.index.slice(0, insertionIndex), ...newIndexes, ...this.index.slice(insertionIndex)];
  }

  /**
   * Removes (soft remove) data from "index" and according to the amount of data.
   *
   * @param {number} key The key as volatile zero-based index at which to begin removing the data.
   * @param {number} [amount=1] Ammount data to remove.
   */
  remove(key) {
    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    (0, _utils.assert)(() => (0, _utils.isUnsignedNumber)(key) || (0, _utils.isNullish)(key), 'Expecting an unsigned number or null/undefined argument.');
    const removed = this.index.splice((0, _utils.isNullish)(key) ? this.index.length - amount : key, amount);
    for (let i = 0; i < removed.length; i++) {
      const removedIndex = removed[i];
      if (typeof removedIndex === 'number') {
        this.holes.add(removedIndex);
      }
    }
  }

  /**
   * Returns the size of the data which this map holds.
   *
   * @returns {number}
   */
  size() {
    return this.data.length - this.holes.size;
  }

  /**
   * Returns a new Iterator object that contains the values for each item in the LazyMap object.
   *
   * @returns {Iterator}
   */
  values() {
    return (0, _array.arrayFilter)(this.data, (_, index) => !this.holes.has(index))[Symbol.iterator]();
  }

  /**
   * Returns a new Iterator object that contains an array of `[index, value]` for each item in the LazyMap object.
   *
   * @returns {Iterator}
   */
  entries() {
    const validEntries = [];
    for (let i = 0; i < this.data.length; i++) {
      const keyIndex = this._getKeyByStorageIndex(i);
      if (keyIndex !== -1) {
        validEntries.push([keyIndex, this.data[i]]);
      }
    }
    let dataIndex = 0;
    return {
      next: () => {
        if (dataIndex < validEntries.length) {
          const value = validEntries[dataIndex];
          dataIndex += 1;
          return {
            value,
            done: false
          };
        }
        return {
          done: true
        };
      }
    };
  }

  /**
   * Clears the map.
   */
  clear() {
    this.data = [];
    this.index = [];
    this.holes.clear();
  }

  /**
   * Gets storage index calculated from the key associated with the specified value.
   *
   * @param {number} key Volatile zero-based index.
   * @returns {number} Returns index 0-N or -1 if no storage index found.
   */
  _getStorageIndexByKey(key) {
    return this.index.length > key ? this.index[key] : -1;
  }

  /**
   * Gets the key associated with the specified value calculated from storage index.
   *
   * @param {number} dataIndex Zero-based storage index.
   * @returns {number} Returns index 0-N or -1 if no key found.
   */
  _getKeyByStorageIndex(dataIndex) {
    return this.index.indexOf(dataIndex);
  }

  /**
   * Makes this object iterable.
   *
   * @returns {Iterator}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
}
exports["default"] = LazyFactoryMap;

/***/ }),
/* 676 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(283);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _object = __webpack_require__(499);
var _utils = __webpack_require__(670);
var _lazyFactoryMap = _interopRequireDefault(__webpack_require__(675));
var _mixed = __webpack_require__(354);
/* eslint-disable jsdoc/require-description-complete-sentence */
/**
 * @class CellMeta
 *
 * The cell meta object is a root of all settings defined for the specific cell rendered by the
 * Handsontable. Each cell meta inherits settings from higher layers. When a property doesn't
 * exist in that layer, it is looked up through a prototype to the highest layer. Starting
 * from CellMeta -> ColumnMeta and ending to GlobalMeta, which stores default settings. Adding,
 * removing, or changing property in that object has no direct reflection on any other layers.
 *
 * +-------------+
 * │ GlobalMeta  │
 * │ (prototype) │
 * +-------------+\
 *       │         \
 *       │          \
 *      \│/         _\|
 * +-------------+    +-------------+
 * │ TableMeta   │    │ ColumnMeta  │
 * │ (instance)  │    │ (prototype) │
 * +-------------+    +-------------+
 *                         │
 *                         │
 *                        \│/
 *                    +-------------+
 *                    │  CellMeta   │
 *                    │ (instance)  │
 *                    +-------------+
 */
/* eslint-enable jsdoc/require-description-complete-sentence */
class CellMeta {
  constructor(columnMeta) {
    /**
     * Reference to the ColumnMeta layer. While creating new cell meta objects, all new objects
     * inherit properties from the ColumnMeta layer.
     *
     * @type {ColumnMeta}
     */
    (0, _defineProperty2.default)(this, "columnMeta", void 0);
    /**
     * Holder for cell meta objects, organized as a grid of LazyFactoryMap of LazyFactoryMaps.
     * The access to the cell meta object is done through access to the row defined by the physical
     * row index and then by accessing the second LazyFactory Map under the physical column index.
     *
     * @type {LazyFactoryMap<number, LazyFactoryMap<number, object>>}
     */
    (0, _defineProperty2.default)(this, "metas", new _lazyFactoryMap.default(() => this._createRow()));
    this.columnMeta = columnMeta;
  }

  /**
   * Updates cell meta object by merging settings with the current state.
   *
   * @param {number} physicalRow The physical row index which points what cell meta object is updated.
   * @param {number} physicalColumn The physical column index which points what cell meta object is updated.
   * @param {object} settings An object to merge with.
   */
  updateMeta(physicalRow, physicalColumn, settings) {
    const meta = this.getMeta(physicalRow, physicalColumn);
    (0, _object.extend)(meta, settings);
    (0, _utils.extendByMetaType)(meta, settings);
  }

  /**
   * Creates one or more rows at specific position.
   *
   * @param {number} physicalRow The physical row index which points from what position the row is added.
   * @param {number} amount An amount of rows to add.
   */
  createRow(physicalRow, amount) {
    this.metas.insert(physicalRow, amount);
  }

  /**
   * Creates one or more columns at specific position.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is added.
   * @param {number} amount An amount of columns to add.
   */
  createColumn(physicalColumn, amount) {
    for (let i = 0; i < this.metas.size(); i++) {
      this.metas.obtain(i).insert(physicalColumn, amount);
    }
  }

  /**
   * Removes one or more rows from the collection.
   *
   * @param {number} physicalRow The physical row index which points from what position the row is removed.
   * @param {number} amount An amount of rows to remove.
   */
  removeRow(physicalRow, amount) {
    this.metas.remove(physicalRow, amount);
  }

  /**
   * Removes one or more columns from the collection.
   *
   * @param {number} physicalColumn The physical column index which points from what position the column is removed.
   * @param {number} amount An amount of columns to remove.
   */
  removeColumn(physicalColumn, amount) {
    for (let i = 0; i < this.metas.size(); i++) {
      this.metas.obtain(i).remove(physicalColumn, amount);
    }
  }

  /**
   * Gets settings object for this layer.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} [key] If the key exists its value will be returned, otherwise the whole cell meta object.
   * @returns {object}
   */
  getMeta(physicalRow, physicalColumn, key) {
    const cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
    if (key === undefined) {
      return cellMeta;
    }
    return cellMeta[key];
  }

  /**
   * Sets settings object for this layer defined by "key" property.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key The property name to set.
   * @param {*} value Value to save.
   */
  setMeta(physicalRow, physicalColumn, key, value) {
    var _cellMeta$_automatica;
    const cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
    (_cellMeta$_automatica = cellMeta._automaticallyAssignedMetaProps) === null || _cellMeta$_automatica === void 0 || _cellMeta$_automatica.delete(key);
    cellMeta[key] = value;
  }

  /**
   * Removes a property defined by the "key" argument from the cell meta object.
   *
   * @param {number} physicalRow The physical row index.
   * @param {number} physicalColumn The physical column index.
   * @param {string} key The property name to remove.
   */
  removeMeta(physicalRow, physicalColumn, key) {
    const cellMeta = this.metas.obtain(physicalRow).obtain(physicalColumn);
    delete cellMeta[key];
  }

  /**
   * Returns all cell meta objects that were created during the Handsontable operation. As cell meta
   * objects are created lazy, the length of the returned collection depends on how and when the
   * table has asked for access to that meta objects.
   *
   * @returns {object[]}
   */
  getMetas() {
    const metas = [];
    const rows = Array.from(this.metas.values());
    for (let row = 0; row < rows.length; row++) {
      // Getting a meta for already added row (new row already exist - it has been added using `createRow` method).
      // However, is not ready until the first `getMeta` call (lazy loading).
      if ((0, _mixed.isDefined)(rows[row])) {
        metas.push(...rows[row].values());
      }
    }
    return metas;
  }

  /**
   * Returns all cell meta objects that were created during the Handsontable operation but for
   * specific row index.
   *
   * @param {number} physicalRow The physical row index.
   * @returns {object[]}
   */
  getMetasAtRow(physicalRow) {
    (0, _utils.assert)(() => (0, _utils.isUnsignedNumber)(physicalRow), 'Expecting an unsigned number.');
    const rowsMeta = new Map(this.metas);
    return rowsMeta.has(physicalRow) ? Array.from(rowsMeta.get(physicalRow).values()) : [];
  }

  /**
   * Clears all saved cell meta objects.
   */
  clearCache() {
    this.metas.clear();
  }

  /**
   * Creates and returns new structure for cell meta objects stored in columnar axis.
   *
   * @private
   * @returns {object}
   */
  _createRow() {
    return new _lazyFactoryMap.default(physicalColumn => this._createMeta(physicalColumn));
  }

  /**
   * Creates and returns new cell meta object with properties inherited from the column meta layer.
   *
   * @private
   * @param {number} physicalColumn The physical column index.
   * @returns {object}
   */
  _createMeta(physicalColumn) {
    const ColumnMeta = this.columnMeta.getMetaConstructor(physicalColumn);
    return new ColumnMeta();
  }
}
exports["default"] = CellMeta;

/***/ }),
/* 677 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
exports.replaceData = replaceData;
__webpack_require__(201);
__webpack_require__(283);
var _string = __webpack_require__(352);
var _function = __webpack_require__(497);
var _dataMap = _interopRequireDefault(__webpack_require__(665));
var _object = __webpack_require__(499);
var _element = __webpack_require__(351);
var _a11y = __webpack_require__(496);
/**
 * Loads new data to Handsontable.
 *
 * @private
 * @param {Array} data Array of arrays or array of objects containing data.
 * @param {Function} setDataMapFunction Function that updates the datamap instance.
 * @param {Function} callbackFunction Function that takes care of updating Handsontable to the new dataset. Called
 * right before the `after-` hooks.
 * @param {object} config The configuration object containing all the needed dependency references and information.
 * @param {Handsontable.Core} config.hotInstance The Handsontable instance.
 * @param {DataMap} config.dataMap The current `dataMap` instance.
 * @param {DataSource} config.dataSource The current `dataSource` instance.
 * @param {string} config.internalSource The immediate internal source of the `replaceData` call.
 * @param {string} config.source The source of the call.
 * @param {boolean} config.firstRun `true` if it's a first call in the Handsontable lifecycle, `false` otherwise.
 * @fires Hooks#beforeLoadData
 * @fires Hooks#beforeUpdateData
 * @fires Hooks#afterLoadData
 * @fires Hooks#afterUpdateData
 * @fires Hooks#afterChange
 */
function replaceData(data, setDataMapFunction, callbackFunction, config) {
  const {
    hotInstance,
    dataMap,
    dataSource,
    internalSource,
    source,
    metaManager,
    firstRun
  } = config;
  const capitalizedInternalSource = (0, _string.toUpperCaseFirst)(internalSource);
  const tableMeta = hotInstance.getSettings();
  if (Array.isArray(tableMeta.dataSchema)) {
    hotInstance.dataType = 'array';
  } else if ((0, _function.isFunction)(tableMeta.dataSchema)) {
    hotInstance.dataType = 'function';
  } else {
    hotInstance.dataType = 'object';
  }
  if (dataMap) {
    dataMap.destroy();
  }
  data = hotInstance.runHooks(`before${capitalizedInternalSource}`, data, firstRun, source);
  const newDataMap = new _dataMap.default(hotInstance, data, metaManager);

  // We need to apply the new dataMap immediately, because of some asynchronous logic in the
  // `autoRowSize`/`autoColumnSize` plugins.
  setDataMapFunction(newDataMap);
  if (typeof data === 'object' && data !== null) {
    if (!(data.push && data.splice)) {
      // check if data is array. Must use duck-type check so Backbone Collections also pass it
      // when data is not an array, attempt to make a single-row array of it
      // eslint-disable-next-line no-param-reassign
      data = [data];
    }
  } else if (data === null) {
    const dataSchema = newDataMap.getSchema();

    // eslint-disable-next-line no-param-reassign
    data = [];
    let row;
    let r = 0;
    let rlen = 0;
    for (r = 0, rlen = tableMeta.startRows; r < rlen; r++) {
      if ((hotInstance.dataType === 'object' || hotInstance.dataType === 'function') && tableMeta.dataSchema) {
        row = (0, _object.deepClone)(dataSchema);
        data.push(row);
      } else if (hotInstance.dataType === 'array') {
        row = (0, _object.deepClone)(dataSchema[0]);
        data.push(row);
      } else {
        row = [];
        for (let c = 0, clen = tableMeta.startCols; c < clen; c++) {
          row.push(null);
        }
        data.push(row);
      }
    }
  } else {
    throw new Error(`${internalSource} only accepts array of objects or array of arrays (${typeof data} given)`);
  }
  if (Array.isArray(data[0])) {
    hotInstance.dataType = 'array';
  }
  tableMeta.data = data;
  newDataMap.dataSource = data;
  dataSource.data = data;
  dataSource.dataType = hotInstance.dataType;
  dataSource.colToProp = newDataMap.colToProp.bind(newDataMap);
  dataSource.propToCol = newDataMap.propToCol.bind(newDataMap);
  dataSource.countCachedColumns = newDataMap.countCachedColumns.bind(newDataMap);

  // Run the logic for reassuring that the table structure fits the new dataset.
  callbackFunction(newDataMap);
  hotInstance.runHooks(`after${capitalizedInternalSource}`, data, firstRun, source);

  // TODO: rethink the way the `afterChange` hook is being run here in the core `init` method.
  if (!firstRun) {
    hotInstance.runHooks('afterChange', null, internalSource);
    hotInstance.render();
  }
  if (hotInstance.getSettings().ariaTags) {
    (0, _element.setAttribute)(hotInstance.rootElement, [(0, _a11y.A11Y_ROWCOUNT)(-1),
    // If run after initialization, add the number of row headers.
    (0, _a11y.A11Y_COLCOUNT)(hotInstance.countCols() + (hotInstance.view ? hotInstance.countRowHeaders() : 0))]);
  }
}

/***/ }),
/* 678 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _hooks = __webpack_require__(511);
var _object = __webpack_require__(499);
var _function = __webpack_require__(497);
/**
 * @class DynamicCellMetaMod
 *
 * The `DynamicCellMetaMod` modifier allows for extending cell meta objects
 * (returned by `getCellMeta()` from `MetaManager`)
 * by user-specific properties.
 *
 * The user-specific properties can be added and changed dynamically,
 * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),
 * or by Handsontable's `cells` option.
 *
 * The `getCellMeta()` method is used widely throughout the source code.
 * To boost the method's execution time,
 * the logic is triggered only once per one Handsontable slow render cycle.
 */
class DynamicCellMetaMod {
  constructor(metaManager) {
    /**
     * @type {MetaManager}
     */
    (0, _defineProperty2.default)(this, "metaManager", void 0);
    /**
     * @type {Map}
     */
    (0, _defineProperty2.default)(this, "metaSyncMemo", new Map());
    this.metaManager = metaManager;
    metaManager.addLocalHook('afterGetCellMeta', cellMeta => this.extendCellMeta(cellMeta));
    _hooks.Hooks.getSingleton().add('beforeRender', forceFullRender => {
      if (forceFullRender) {
        this.metaSyncMemo.clear();
      }
    }, this.metaManager.hot);
  }

  /**
   * Extends the cell meta object by user-specific properties.
   *
   * The cell meta object can be extended dynamically,
   * either by Handsontable's hooks (`beforeGetCellMeta` and`afterGetCellMeta`),
   * or by Handsontable's `cells` option.
   *
   * To boost performance, the extending process is triggered only once per one slow Handsontable render cycle.
   *
   * @param {object} cellMeta The cell meta object.
   */
  extendCellMeta(cellMeta) {
    var _this$metaSyncMemo$ge;
    const {
      row: physicalRow,
      col: physicalColumn
    } = cellMeta;
    if ((_this$metaSyncMemo$ge = this.metaSyncMemo.get(physicalRow)) !== null && _this$metaSyncMemo$ge !== void 0 && _this$metaSyncMemo$ge.has(physicalColumn)) {
      return;
    }
    const {
      visualRow,
      visualCol
    } = cellMeta;
    const hot = this.metaManager.hot;
    const prop = hot.colToProp(visualCol);
    cellMeta.prop = prop;
    hot.runHooks('beforeGetCellMeta', visualRow, visualCol, cellMeta);

    // extend a `type` value, added or changed in the `beforeGetCellMeta` hook
    const cellType = (0, _object.hasOwnProperty)(cellMeta, 'type') ? cellMeta.type : null;
    let cellSettings = (0, _function.isFunction)(cellMeta.cells) ? cellMeta.cells(physicalRow, physicalColumn, prop) : null;
    if (cellType) {
      if (cellSettings) {
        var _cellSettings$type;
        cellSettings.type = (_cellSettings$type = cellSettings.type) !== null && _cellSettings$type !== void 0 ? _cellSettings$type : cellType;
      } else {
        cellSettings = {
          type: cellType
        };
      }
    }
    if (cellSettings) {
      this.metaManager.updateCellMeta(physicalRow, physicalColumn, cellSettings);
    }
    hot.runHooks('afterGetCellMeta', visualRow, visualCol, cellMeta);
    if (!this.metaSyncMemo.has(physicalRow)) {
      this.metaSyncMemo.set(physicalRow, new Set());
    }
    this.metaSyncMemo.get(physicalRow).add(physicalColumn);
  }
}
exports.DynamicCellMetaMod = DynamicCellMetaMod;

/***/ }),
/* 679 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
__webpack_require__(283);
__webpack_require__(287);
__webpack_require__(298);
__webpack_require__(300);
__webpack_require__(303);
__webpack_require__(305);
__webpack_require__(307);
__webpack_require__(309);
__webpack_require__(311);
__webpack_require__(329);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
var _initOnlyCallback = /*#__PURE__*/new WeakMap();
/**
 * @class ExtendMetaPropertiesMod
 */
class ExtendMetaPropertiesMod {
  constructor(metaManager) {
    /**
     * @type {MetaManager}
     */
    (0, _defineProperty2.default)(this, "metaManager", void 0);
    /**
     * @type {Set}
     */
    (0, _defineProperty2.default)(this, "usageTracker", new Set());
    /**
     * @type {Map}
     */
    (0, _defineProperty2.default)(this, "propDescriptors", new Map([['ariaTags', {
      initOnly: true
    }], ['fixedColumnsLeft', {
      target: 'fixedColumnsStart',
      onChange(propName) {
        const isRtl = this.metaManager.hot.isRtl();
        if (isRtl && propName === 'fixedColumnsLeft') {
          throw new Error('The `fixedColumnsLeft` is not supported for RTL. Please use option `fixedColumnsStart`.');
        }
        if (this.usageTracker.has('fixedColumnsLeft') && this.usageTracker.has('fixedColumnsStart')) {
          throw new Error('The `fixedColumnsLeft` and `fixedColumnsStart` should not be used together. ' + 'Please use only the option `fixedColumnsStart`.');
        }
      }
    }], ['layoutDirection', {
      initOnly: true
    }], ['renderAllColumns', {
      initOnly: true
    }], ['renderAllRows', {
      initOnly: true
    }]]));
    /**
     * Callback called when the prop is marked as `initOnly`.
     *
     * @param {string} propName The property name.
     * @param {*} value The new value.
     * @param {boolean} isInitialChange Is the change initial.
     */
    _classPrivateFieldInitSpec(this, _initOnlyCallback, (propName, value, isInitialChange) => {
      if (!isInitialChange) {
        throw new Error(`The \`${propName}\` option can not be updated after the Handsontable is initialized.`);
      }
    });
    this.metaManager = metaManager;
    this.extendMetaProps();
  }
  /**
   * Extends the meta options based on the object descriptors from the `propDescriptors` list.
   */
  extendMetaProps() {
    this.propDescriptors.forEach((descriptor, alias) => {
      const {
        initOnly,
        target,
        onChange
      } = descriptor;
      const hasTarget = typeof target === 'string';
      const targetProp = hasTarget ? target : alias;
      const origProp = `_${targetProp}`;
      this.metaManager.globalMeta.meta[origProp] = this.metaManager.globalMeta.meta[targetProp];
      if (onChange) {
        this.installPropWatcher(alias, origProp, onChange);
        if (hasTarget) {
          this.installPropWatcher(target, origProp, onChange);
        }
      } else if (initOnly) {
        this.installPropWatcher(alias, origProp, _classPrivateFieldGet(_initOnlyCallback, this));
        if (!this.metaManager.globalMeta.meta._initOnlySettings) {
          this.metaManager.globalMeta.meta._initOnlySettings = [];
        }
        this.metaManager.globalMeta.meta._initOnlySettings.push(alias);
      }
    });
  }

  /**
   * Installs the property watcher to the `propName` option and forwards getter and setter to
   * the new one.
   *
   * @param {string} propName The property to watch.
   * @param {string} origProp The property from/to the value is forwarded.
   * @param {Function} onChange The callback.
   */
  installPropWatcher(propName, origProp, onChange) {
    const self = this;
    Object.defineProperty(this.metaManager.globalMeta.meta, propName, {
      get() {
        return this[origProp];
      },
      set(value) {
        const isInitialChange = !self.usageTracker.has(propName);
        self.usageTracker.add(propName);
        onChange.call(self, propName, value, isInitialChange);
        this[origProp] = value;
      },
      enumerable: true,
      configurable: true
    });
  }
}
exports.ExtendMetaPropertiesMod = ExtendMetaPropertiesMod;

/***/ }),
/* 680 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


__webpack_require__(311);
__webpack_require__(329);
exports.__esModule = true;
var _focusCatcher = __webpack_require__(681);
Object.keys(_focusCatcher).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _focusCatcher[key]) return;
  exports[key] = _focusCatcher[key];
});
var _viewportScroll = __webpack_require__(735);
Object.keys(_viewportScroll).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _viewportScroll[key]) return;
  exports[key] = _viewportScroll[key];
});

/***/ }),
/* 681 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.installFocusCatcher = installFocusCatcher;
var _shortcutContexts = __webpack_require__(682);
var _focusDetector = __webpack_require__(734);
/**
 * Installs a focus catcher module. The module observes when the table is focused and depending on
 * from the which side it was focused on it selects a specified cell or releases the TAB navigation
 * to the browser.
 *
 * @param {Core} hot The Handsontable instance.
 */
function installFocusCatcher(hot) {
  const clampCoordsIfNeeded = normalizeCoordsIfNeeded(hot);
  let recentlyAddedFocusCoords;
  const {
    activate,
    deactivate
  } = (0, _focusDetector.installFocusDetector)(hot, {
    onFocusFromTop() {
      var _clampCoordsIfNeeded;
      const mostTopStartCoords = (_clampCoordsIfNeeded = clampCoordsIfNeeded(recentlyAddedFocusCoords)) !== null && _clampCoordsIfNeeded !== void 0 ? _clampCoordsIfNeeded : getMostTopStartPosition(hot);
      if (mostTopStartCoords) {
        hot.runHooks('modifyFocusOnTabNavigation', 'from_above', mostTopStartCoords);
        hot.selectCell(mostTopStartCoords.row, mostTopStartCoords.col);
      }
      hot.listen();
    },
    onFocusFromBottom() {
      var _clampCoordsIfNeeded2;
      const mostBottomEndCoords = (_clampCoordsIfNeeded2 = clampCoordsIfNeeded(recentlyAddedFocusCoords)) !== null && _clampCoordsIfNeeded2 !== void 0 ? _clampCoordsIfNeeded2 : getMostBottomEndPosition(hot);
      if (mostBottomEndCoords) {
        hot.runHooks('modifyFocusOnTabNavigation', 'from_below', mostBottomEndCoords);
        hot.selectCell(mostBottomEndCoords.row, mostBottomEndCoords.col);
      }
      hot.listen();
    }
  });
  const rowWrapState = {
    wrapped: false,
    flipped: false
  };
  let isSavingCoordsEnabled = true;
  let isTabOrShiftTabPressed = false;
  let preventViewportScroll = false;
  hot.addHook('afterListen', () => deactivate());
  hot.addHook('afterUnlisten', () => activate());
  hot.addHook('afterSelection', (row, column, row2, column2, preventScrolling) => {
    if (isTabOrShiftTabPressed && (rowWrapState.wrapped && rowWrapState.flipped || preventViewportScroll)) {
      preventViewportScroll = false;
      preventScrolling.value = true;
    }
    if (isSavingCoordsEnabled) {
      var _hot$getSelectedRange;
      recentlyAddedFocusCoords = (_hot$getSelectedRange = hot.getSelectedRangeLast()) === null || _hot$getSelectedRange === void 0 ? void 0 : _hot$getSelectedRange.highlight;
    }
  });
  hot.addHook('beforeRowWrap', (interruptedByAutoInsertMode, newCoords, isFlipped) => {
    rowWrapState.wrapped = true;
    rowWrapState.flipped = isFlipped;
  });

  /**
   * Unselects the cell and deactivates the table.
   */
  function deactivateTable() {
    rowWrapState.wrapped = false;
    rowWrapState.flipped = false;
    hot.deselectCell();
    hot.unlisten();
  }
  const shortcutOptions = {
    keys: [['Tab'], ['Shift', 'Tab']],
    preventDefault: false,
    stopPropagation: false,
    relativeToGroup: _shortcutContexts.GRID_GROUP,
    group: 'focusCatcher'
  };
  hot.getShortcutManager().getContext('grid').addShortcuts([{
    ...shortcutOptions,
    callback: () => {
      const {
        tabNavigation
      } = hot.getSettings();
      isTabOrShiftTabPressed = true;
      if (hot.getSelectedRangeLast() && !tabNavigation) {
        isSavingCoordsEnabled = false;
      }
      if (!tabNavigation) {
        preventViewportScroll = true;
      }
    },
    position: 'before'
  }, {
    ...shortcutOptions,
    callback: event => {
      const {
        tabNavigation,
        autoWrapRow
      } = hot.getSettings();
      isTabOrShiftTabPressed = false;
      isSavingCoordsEnabled = true;
      if (!tabNavigation || !hot.selection.isSelected() || autoWrapRow && rowWrapState.wrapped && rowWrapState.flipped || !autoWrapRow && rowWrapState.wrapped) {
        if (autoWrapRow && rowWrapState.wrapped && rowWrapState.flipped) {
          recentlyAddedFocusCoords = event.shiftKey ? getMostTopStartPosition(hot) : getMostBottomEndPosition(hot);
        }
        deactivateTable();
        return false;
      }

      // if the selection is still within the table's range then prevent default action
      event.preventDefault();
    },
    position: 'after'
  }]);
}

/**
 * Gets the coordinates of the most top-start cell or header (depends on the table settings and its size).
 *
 * @param {Core} hot The Handsontable instance.
 * @returns {CellCoords|null}
 */
function getMostTopStartPosition(hot) {
  const {
    rowIndexMapper,
    columnIndexMapper
  } = hot;
  const {
    navigableHeaders
  } = hot.getSettings();
  let topRow = navigableHeaders && hot.countColHeaders() > 0 ? -hot.countColHeaders() : 0;
  let startColumn = navigableHeaders && hot.countRowHeaders() > 0 ? -hot.countRowHeaders() : 0;
  if (topRow === 0) {
    topRow = rowIndexMapper.getVisualFromRenderableIndex(topRow);
  }
  if (startColumn === 0) {
    startColumn = columnIndexMapper.getVisualFromRenderableIndex(startColumn);
  }
  if (topRow === null || startColumn === null) {
    return null;
  }
  return hot._createCellCoords(topRow, startColumn);
}

/**
 * Gets the coordinates of the most bottom-end cell or header (depends on the table settings and its size).
 *
 * @param {Core} hot The Handsontable instance.
 * @returns {CellCoords|null}
 */
function getMostBottomEndPosition(hot) {
  var _rowIndexMapper$getVi, _columnIndexMapper$ge;
  const {
    rowIndexMapper,
    columnIndexMapper
  } = hot;
  const {
    navigableHeaders
  } = hot.getSettings();
  let bottomRow = rowIndexMapper.getRenderableIndexesLength() - 1;
  let endColumn = columnIndexMapper.getRenderableIndexesLength() - 1;
  if (bottomRow < 0) {
    if (!navigableHeaders || hot.countColHeaders() === 0) {
      return null;
    }
    bottomRow = -1;
  }
  if (endColumn < 0) {
    if (!navigableHeaders || hot.countColHeaders() === 0) {
      return null;
    }
    endColumn = -1;
  }
  return hot._createCellCoords((_rowIndexMapper$getVi = rowIndexMapper.getVisualFromRenderableIndex(bottomRow)) !== null && _rowIndexMapper$getVi !== void 0 ? _rowIndexMapper$getVi : bottomRow, (_columnIndexMapper$ge = columnIndexMapper.getVisualFromRenderableIndex(endColumn)) !== null && _columnIndexMapper$ge !== void 0 ? _columnIndexMapper$ge : endColumn);
}

/**
 * Normalizes the coordinates (clamps to nearest visible cell position within dataset range).
 *
 * @param {Core} hot The Handsontable instance.
 * @returns {function(Coords | undefined): Coords | null}
 */
function normalizeCoordsIfNeeded(hot) {
  return coords => {
    if (!coords) {
      return null;
    }
    const mostTopStartCoords = getMostTopStartPosition(hot);
    const mostBottomEndCoords = getMostBottomEndPosition(hot);
    if (coords.col < mostTopStartCoords.col) {
      coords.col = mostTopStartCoords.col;
    }
    if (coords.col > mostBottomEndCoords.col) {
      coords.col = mostBottomEndCoords.col;
    }
    if (coords.row < mostTopStartCoords.row) {
      coords.row = mostTopStartCoords.row;
    }
    if (coords.row > mostBottomEndCoords.row) {
      coords.row = mostBottomEndCoords.row;
    }
    return coords;
  };
}

/***/ }),
/* 682 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _exportNames = {
  registerAllShortcutContexts: true
};
exports.registerAllShortcutContexts = registerAllShortcutContexts;
__webpack_require__(311);
__webpack_require__(329);
var _editor = __webpack_require__(683);
var _grid = __webpack_require__(733);
var _constants = __webpack_require__(684);
Object.keys(_constants).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _constants[key]) return;
  exports[key] = _constants[key];
});
/**
 * Register all shortcut contexts.
 *
 * @param {Handsontable} hotInstance The Handsontable instance.
 */
function registerAllShortcutContexts(hotInstance) {
  [_grid.shortcutsGridContext, _editor.shortcutsEditorContext].forEach(context => context(hotInstance));
}

/***/ }),
/* 683 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.shortcutsEditorContext = shortcutsEditorContext;
var _constants = __webpack_require__(684);
var _commands = __webpack_require__(685);
/**
 * The context that defines a base shortcut list available for cells editors.
 *
 * @param {Handsontable} hot The Handsontable instance.
 */
function shortcutsEditorContext(hot) {
  const context = hot.getShortcutManager().addContext('editor');
  const commandsPool = (0, _commands.createKeyboardShortcutCommandsPool)(hot);
  const config = {
    group: _constants.EDITOR_EDIT_GROUP
  };
  context.addShortcuts([{
    keys: [['Enter'], ['Enter', 'Shift']],
    callback: (event, keys) => commandsPool.editorCloseAndSaveByEnter(event, keys)
  }, {
    keys: [['Enter', 'Control/Meta'], ['Enter', 'Control/Meta', 'Shift']],
    captureCtrl: true,
    callback: (event, keys) => commandsPool.editorCloseAndSaveByEnter(event, keys)
  }, {
    keys: [['Tab'], ['Tab', 'Shift'], ['PageDown'], ['PageUp']],
    forwardToContext: hot.getShortcutManager().getContext('grid'),
    callback: (event, keys) => commandsPool.editorCloseAndSave(event, keys)
  }, {
    keys: [['ArrowDown'], ['ArrowUp'], ['ArrowLeft'], ['ArrowRight']],
    preventDefault: false,
    callback: (event, keys) => commandsPool.editorCloseAndSaveByArrowKeys(event, keys)
  }, {
    keys: [['Escape'], ['Escape', 'Control/Meta']],
    callback: () => commandsPool.editorCloseWithoutSaving()
  }], config);
}

/***/ }),
/* 684 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
/**
 * Group name for keyboard shortcuts that are active when the cell is selected.
 */
const GRID_GROUP = exports.GRID_GROUP = 'gridDefault';
/**
 * Group name for keyboard shortcuts that are active when the cell editor is active.
 */
const EDITOR_EDIT_GROUP = exports.EDITOR_EDIT_GROUP = 'editorManager.handlingEditor';

/***/ }),
/* 685 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.createKeyboardShortcutCommandsPool = createKeyboardShortcutCommandsPool;
__webpack_require__(311);
__webpack_require__(329);
var _editor = __webpack_require__(686);
var _extendCellsSelection = __webpack_require__(696);
var _moveCellSelection = __webpack_require__(711);
var _emptySelectedCells = __webpack_require__(728);
var _scrollToFocusedCell = __webpack_require__(729);
var _selectAllCells = __webpack_require__(730);
var _selectAllCellsAndHeaders = __webpack_require__(731);
var _populateSelectedCellsData = __webpack_require__(732);
const allCommands = [...(0, _editor.getAllCommands)(), ...(0, _extendCellsSelection.getAllCommands)(), ...(0, _moveCellSelection.getAllCommands)(), _emptySelectedCells.command, _scrollToFocusedCell.command, _selectAllCells.command, _selectAllCellsAndHeaders.command, _populateSelectedCellsData.command];

/**
 * Prepares and creates an object with all available commands to trigger.
 *
 * @param {Handsontable} hot The Handsontable instance.
 * @returns {object}
 */
function createKeyboardShortcutCommandsPool(hot) {
  const commands = {};
  allCommands.forEach(_ref => {
    let {
      name,
      callback
    } = _ref;
    commands[name] = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return callback(hot, ...args);
    };
  });
  return commands;
}

/***/ }),
/* 686 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
exports.getAllCommands = getAllCommands;
var _closeAndSave = __webpack_require__(687);
var _closeAndSaveByArrowKeys = __webpack_require__(688);
var _closeAndSaveByEnter = __webpack_require__(692);
var _closeWithoutSaving = __webpack_require__(693);
var _fastOpen = __webpack_require__(694);
var _open = __webpack_require__(695);
/**
 * Returns complete list of the shortcut commands for the cells editing feature.
 *
 * @returns {Function[]}
 */
function getAllCommands() {
  return [_closeAndSave.command, _closeAndSaveByArrowKeys.command, _closeAndSaveByEnter.command, _closeWithoutSaving.command, _fastOpen.command, _open.command];
}

/***/ }),
/* 687 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.__esModule = true;
const command = exports.command = {
  name: 'editorCloseAndSave',
  callback(hot) {
    const editorManager = hot._getEditorManager();
    editorManager.closeEditorAndSaveChanges();
  }
};

/***/ }),
/* 688 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _baseEditor = __webpack_require__(689);
const command = exports.command = {
  name: 'editorCloseAndSaveByArrowKeys',
  callback(hot, event, keys) {
    const editorManager = hot._getEditorManager();
    const activeEditor = editorManager.getActiveEditor();
    if (activeEditor.isInFullEditMode() && activeEditor.state === _baseEditor.EDITOR_STATE.EDITING) {
      return;
    }
    editorManager.closeEditorAndSaveChanges();
    if (hot.getSelected()) {
      if (keys.includes('arrowdown')) {
        hot.selection.transformStart(1, 0);
      } else if (keys.includes('arrowup')) {
        hot.selection.transformStart(-1, 0);
      } else if (keys.includes('arrowleft')) {
        hot.selection.transformStart(0, -1 * hot.getDirectionFactor());
      } else if (keys.includes('arrowright')) {
        hot.selection.transformStart(0, hot.getDirectionFactor());
      }
    }
    event.preventDefault();
  }
};

/***/ }),
/* 689 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.__esModule = true;
var _baseEditor = __webpack_require__(690);
exports.EDITOR_STATE = _baseEditor.EDITOR_STATE;
exports.EDITOR_TYPE = _baseEditor.EDITOR_TYPE;
exports.BaseEditor = _baseEditor.BaseEditor;

/***/ }),
/* 690 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var _interopRequireDefault = __webpack_require__(197);
exports.__esModule = true;
__webpack_require__(201);
var _defineProperty2 = _interopRequireDefault(__webpack_require__(504));
var _mixed = __webpack_require__(354);
var _object = __webpack_require__(499);
var _hooksRefRegisterer = _interopRequireDefault(__webpack_require__(691));
var _element = __webpack_require__(351);
const EDITOR_TYPE = exports.EDITOR_TYPE = 'base';
const EDITOR_STATE = exports.EDITOR_STATE = Object.freeze({
  VIRGIN: 'STATE_VIRGIN',
  // before editing
  EDITING: 'STATE_EDITING',
  WAITING: 'STATE_WAITING',
  // waiting for async validation
  FINISHED: 'STATE_FINISHED'
});

/**
 * @class BaseEditor
 */
class BaseEditor {
  static get EDITOR_TYPE() {
    return EDITOR_TYPE;
  }

  /**
   * A reference to the source instance of the Handsontable.
   *
   * @type {Handsontable}
   */

  /**
   * @param {Handsontable} hotInstance A reference to the source instance of the Handsontable.
   */
  constructor(hotInstance) {
    (0, _defineProperty2.default)(this, "hot", void 0);
    /**
     * Editor's state.
     *
     * @type {string}
     */
    (0, _defineProperty2.default)(this, "state", EDITOR_STATE.VIRGIN);
    /**
     * Flag to store information about editor's opening status.
     *
     * @private
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "_opened", false);
    /**
     * Defines the editor's editing mode. When false, then an editor works in fast editing mode.
     *
     * @private
     *
     * @type {boolean}
     */
    (0, _defineProperty2.default)(this, "_fullEditMode", false);
    /**
     * Callback to call after closing editor.
     *
     * @type {Function}
     */
    (0, _defineProperty2.default)(this, "_closeCallback", null);
    /**
     * Currently rendered cell's TD element.
     *
     * @type {HTMLTableCellElement}
     */
    (0, _defineProperty2.default)(this, "TD", null);
    /**
     * Visual row index.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "row", null);
    /**
     * Visual column index.
     *
     * @type {number}
     */
    (0, _defineProperty2.default)(this, "col", null);
    /**
     * Column property name or a column index, if datasource is an array of arrays.
     *
     * @type {number|string}
     */
    (0, _defineProperty2.default)(this, "prop", null);
    /**
     * Original cell's value.
     *
     * @type {*}
     */
    (0, _defineProperty2.default)(this, "originalValue", null);
    /**
     * Object containing the cell's properties.
     *
     * @type {object}
     */
    (0, _defineProperty2.default)(this, "cellProperties", null);
    this.hot = hotInstance;
    this.init();
  }

  /**
   * Fires callback after closing editor.
   *
   * @private
   * @param {boolean} result The editor value.
   */
  _fireCallbacks(result) {
    if (this._closeCallback) {
      this._closeCallback(result);
      this._closeCallback = null;
    }
  }

  /**
   * Initializes an editor's intance.
   */
  init() {}

  /**
   * Required method to get current value from editable element.
   */
  getValue() {
    throw Error('Editor getValue() method unimplemented');
  }

  /**
   * Required method to set new value into editable element.
   */
  setValue() {
    throw Error('Editor setValue() method unimplemented');
  }

  /**
   * Required method to open editor.
   */
  open() {
    throw Error('Editor open() method unimplemented');
  }

  /**
   * Required method to close editor.
   */
  close() {
    throw Error('Editor close() method unimplemented');
  }

  /**
   * Prepares editor's meta data.
   *
   * @param {number} row The visual row index.
   * @param {number} col The visual column index.
   * @param {number|string} prop The column property (passed when datasource is an array of objects).
   * @param {HTMLTableCellElement} td The rendered cell element.
   * @param {*} value The rendered value.
   * @param {object} cellProperties The cell meta object (see {@link Core#getCellMeta}).
   */
  prepare(row, col, prop, td, value, cellProperties) {
    this.TD = td;
    this.row = row;
    this.col = col;
    this.prop = prop;
    this.originalValue = value;
    this.cellProperties = cellProperties;
    this.state = this.isOpened() ? this.state : EDITOR_STATE.VIRGIN;
  }

  /**
   * Fallback method to provide extendable editors in ES5.
   *
   * @returns {Function}
   */
  extend() {
    return class Editor extends this.constructor {};
  }

  /**
   * Saves value from editor into data storage.
   *
   * @param {*} value The editor value.
   * @param {boolean} ctrlDown If `true`, applies value to each cell in the last selected range.
   */
  saveValue(value, ctrlDown) {
    let visualRowFrom;
    let visualColumnFrom;
    let visualRowTo;
    let visualColumnTo;

    // if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)
    if (ctrlDown) {
      const selectedLast = this.hot.getSelectedLast();
      visualRowFrom = Math.max(Math.min(selectedLast[0], selectedLast[2]), 0); // Math.max eliminate headers coords.
      visualColumnFrom = Math.max(Math.min(selectedLast[1], selectedLast[3]), 0); // Math.max eliminate headers coords.
      visualRowTo = Math.max(selectedLast[0], selectedLast[2]);
      visualColumnTo = Math.max(selectedLast[1], selectedLast[3]);
    } else {
      [visualRowFrom, visualColumnFrom, visualRowTo, visualColumnTo] = [this.row, this.col, null, null];
    }
    const modifiedCellCoords = this.hot.runHooks('modifyGetCellCoords', visualRowFrom, visualColumnFrom, false, 'meta');
    if (Array.isArray(modifiedCellCoords)) {
      [visualRowFrom, visualColumnFrom] = modifiedCellCoords;
    }

    // Saving values using the modified coordinates.
    this.hot.populateFromArray(visualRowFrom, visualColumnFrom, value, visualRowTo, visualColumnTo, 'edit');
  }

  /**
   * Begins editing on a highlighted cell and hides fillHandle corner if was present.
   *
   * @param {*} newInitialValue The initial editor value.
   * @param {Event} event The keyboard event object.
   */
  beginEditing(newInitialValue, event) {
    if (this.state !== EDITOR_STATE.VIRGIN) {
      return;
    }
    const hotInstance = this.hot;
    // We have to convert visual indexes into renderable indexes
    // due to hidden columns don't participate in the rendering process
    const renderableRowIndex = hotInstance.rowIndexMapper.getRenderableFromVisualIndex(this.row);
    const renderableColumnIndex = hotInstance.columnIndexMapper.getRenderableFromVisualIndex(this.col);
    const openEditor = () => {
      this.state = EDITOR_STATE.EDITING;

      // Set the editor value only in the full edit mode. In other mode the focusable element has to be empty,
      // otherwise IME (editor for Asia users) doesn't work.
      if (this.isInFullEditMode()) {
        const stringifiedInitialValue = typeof newInitialValue === 'string' ? newInitialValue : (0, _mixed.stringify)(this.originalValue);
        this.setValue(stringifiedInitialValue);
      }
      this.open(event);
      this._opened = true;
      this.focus();

      // only rerender the selections (FillHandle should disappear when beginEditing is triggered)
      hotInstance.view.render();
      hotInstance.runHooks('afterBeginEditing', this.row, this.col);
    };
    this.hot.addHookOnce('afterScroll', openEditor);
    const wasScroll = hotInstance.view.scrollViewport(hotInstance._createCellCoords(renderableRowIndex, renderableColumnIndex));
    if (!wasScroll) {
      this.hot.removeHook('afterScroll', openEditor);
      openEditor();
    }
  }

  /**
   * Finishes editing and start saving or restoring process for editing cell or last selected range.
   *
   * @param {boolean} restoreOriginalValue If true, then closes editor without saving value from the editor into a cell.
   * @param {boolean} ctrlDown If true, then saveValue will save editor's value to each cell in the last selected range.
   * @param {Function} callback The callback function, fired after editor closing.
   */
  finishEditing(restoreOriginalValue, ctrlDown, callback) {
    let val;
    if (callback) {
      const previousCloseCallback = this._closeCallback;
      this._closeCallback = result => {
        if (previousCloseCallback) {
          previousCloseCallback(result);
        }
        callback(result);
        this.hot.view.render();
      };
    }
    if (this.isWaiting()) {
      return;
    }
    if (this.state === EDITOR_STATE.VIRGIN) {
      this.hot._registerTimeout(() => {
        this._fireCallbacks(true);
      });
      return;
    }
    if (this.state === EDITOR_STATE.EDITING) {
      if (restoreOriginalValue) {
        this.cancelChanges();
        this.hot.view.render();
        return;
      }
      const value = this.getValue();
      if (this.cellProperties.trimWhitespace) {
        // We trim only string values
        val = [[typeof value === 'string' ? String.prototype.trim.call(value || '') : value]];
      } else {
        val = [[value]];
      }
      this.state = EDITOR_STATE.WAITING;
      this.saveValue(val, ctrlDown);
      if (this.hot.getCellValidator(this.cellProperties)) {
        this.hot.addHookOnce('postAfterValidate', result => {
          this.state = EDITOR_STATE.FINISHED;
          this.discardEditor(result);
        });
      } else {
        this.state = EDITOR_STATE.FINISHED;
        this.discardEditor(true);
      }
    }
  }

  /**
   * Finishes editing without singout saving value.
   */
  cancelChanges() {
    this.state = EDITOR_STATE.FINISHED;
    this.discardEditor();
  }

  /**
   * Verifies result of validation or closes editor if user's cancelled changes.
   *
   * @param {boolean|undefined} result If `false` and the cell using allowInvalid option,
   *                                   then an editor won't be closed until validation is passed.
   */
  discardEditor(result) {
    if (this.state !== EDITOR_STATE.FINISHED) {
      return;
    }

    // validator was defined and failed
    if (result === false && this.cellProperties.allowInvalid !== true) {
      this.hot.selectCell(this.row, this.col);
      this.focus();
      this.state = EDITOR_STATE.EDITING;
      this._fireCallbacks(false);
    } else {
      this.close();
      this._opened = false;
      this._fullEditMode = false;
      this.state = EDITOR_STATE.VIRGIN;
      this._fireCallbacks(true);
      const shortcutManager = this.hot.getShortcutManager();
      shortcutManager.setActiveContextName('grid');
    }
  }

  /**
   * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated
   * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.
   */
  enableFullEditMode() {
    this._fullEditMode = true;
  }

  /**
   * Checks if editor is in full edit mode.
   *
   * @returns {boolean}
   */
  isInFullEditMode() {
    return this._fullEditMode;
  }

  /**
   * Returns information whether the editor is open.
   *
   * @returns {boolean}
   */
  isOpened() {
    return this._opened;
  }

  /**
   * Returns information whether the editor is waiting, eg.: for async validation.
   *
   * @returns {boolean}
   */
  isWaiting() {
    return this.state === EDITOR_STATE.WAITING;
  }

  /* eslint-disable jsdoc/require-description-complete-sentence */
  /**
   * Gets the object that provides information about the edited cell size and its position
   * relative to the table viewport.
   *
   * The rectangle has six integer properties:
   *  - `top` The top position relative to the table viewport
   *  - `start` The left (or right in RTL) position relative to the table viewport
   *  - `width` The cell's current width;
   *  - `maxWidth` The maximum cell's width after which the editor goes out of the table viewport
   *  - `height` The cell's current height;
   *  - `maxHeight` The maximum cell's height after which the editor goes out of the table viewport
   *
   * @returns {{top: number, start: number, width: number, maxWidth: number, height: number, maxHeight: number} | undefined}
   */
  getEditedCellRect() {
    var _wtOverlays$getParent;
    const TD = this.getEditedCell();

    // TD is outside of the viewport.
    if (!TD) {
      return;
    }
    const {
      wtOverlays,
      wtViewport
    } = this.hot.view._wt;
    const rootWindow = this.hot.rootWindow;
    const currentOffset = (0, _element.offset)(TD);
    const cellWidth = (0, _element.outerWidth)(TD);
    const containerOffset = (0, _element.offset)(this.hot.rootElement);
    const containerWidth = (0, _element.outerWidth)(this.hot.rootElement);
    const scrollableContainerTop = wtOverlays.topOverlay.holder;
    const scrollableContainerLeft = wtOverlays.inlineStartOverlay.holder;
    const containerScrollTop = scrollableContainerTop !== rootWindow ? scrollableContainerTop.scrollTop : 0;
    const containerScrollLeft = scrollableContainerLeft !== rootWindow ? scrollableContainerLeft.scrollLeft : 0;
    const gridMostRightPos = rootWindow.innerWidth - containerOffset.left - containerWidth;
    const {
      wtTable: overlayTable
    } = (_wtOverlays$getParent = wtOverlays.getParentOverlay(TD)) !== null && _wtOverlays$getParent !== void 0 ? _wtOverlays$getParent : this.hot.view._wt;
    const overlayName = overlayTable.name;
    const scrollTop = ['master', 'inline_start'].includes(overlayName) ? containerScrollTop : 0;
    const scrollLeft = ['master', 'top', 'bottom'].includes(overlayName) ? containerScrollLeft : 0;

    // If colHeaders is disabled, cells in the first row have border-top
    const editTopModifier = currentOffset.top === containerOffset.top ? 0 : 1;
    let topPos = currentOffset.top - containerOffset.top - editTopModifier - scrollTop;
    let inlineStartPos = 0;
    if (this.hot.isRtl()) {
      inlineStartPos = rootWindow.innerWidth - currentOffset.left - cellWidth - gridMostRightPos - 1 + scrollLeft;
    } else {
      inlineStartPos = currentOffset.left - containerOffset.left - 1 - scrollLeft;
    }

    // When the scrollable element is Window object then the editor position needs to be compensated
    // by the overlays' position (position relative to the table viewport). In other cases, the overlay's
    // position always returns 0.
    if (['top', 'top_inline_start_corner'].includes(overlayName)) {
      topPos += wtOverlays.topOverlay.getOverlayOffset();
    }
    if (['inline_start', 'top_inline_start_corner'].includes(overlayName)) {
      inlineStartPos += Math.abs(wtOverlays.inlineStartOverlay.getOverlayOffset());
    }
    const hasColumnHeaders = this.hot.hasColHeaders();
    const renderableRow = this.hot.rowIndexMapper.getRenderableFromVisualIndex(this.row);
    const renderableColumn = this.hot.columnIndexMapper.getRenderableFromVisualIndex(this.col);
    const nrOfRenderableRowIndexes = this.hot.rowIndexMapper.getRenderableIndexesLength();
    const firstRowIndexOfTheBottomOverlay = nrOfRenderableRowIndexes - this.hot.view._wt.getSetting('fixedRowsBottom');
    if (hasColumnHeaders && renderableRow <= 0 || renderableRow === firstRowIndexOfTheBottomOverlay) {
      topPos += 1;
    }
    if (renderableColumn <= 0) {
      inlineStartPos += 1;
    }
    const firstRowOffset = wtViewport.rowsRenderCalculator.startPosition;
    const firstColumnOffset = wtViewport.columnsRenderCalculator.startPosition;
    const horizontalScrollPosition = Math.abs(wtOverlays.inlineStartOverlay.getScrollPosition());
    const verticalScrollPosition = wtOverlays.topOverlay.getScrollPosition();
    const scrollbarWidth = (0, _element.getScrollbarWidth)(this.hot.rootDocument);
    let cellTopOffset = TD.offsetTop;
    if (['inline_start', 'master'].includes(overlayName)) {
      cellTopOffset += firstRowOffset - verticalScrollPosition;
    }
    if (['bottom', 'bottom_inline_start_corner'].includes(overlayName)) {
      const {
        wtViewport: bottomWtViewport,
        wtTable: bottomWtTable
      } = wtOverlays.bottomOverlay.clone;
      cellTopOffset += bottomWtViewport.getWorkspaceHeight() - bottomWtTable.getHeight() - scrollbarWidth;
    }
    let cellStartOffset = TD.offsetLeft;
    if (this.hot.isRtl()) {
      if (cellStartOffset >= 0) {
        cellStartOffset = overlayTable.getWidth() - TD.offsetLeft;
      } else {
        // The `offsetLeft` returns negative values when the parent offset element has position relative
        // (it happens when on the cell the selection is applied - the `area` CSS class).
        // When it happens the `offsetLeft` value is calculated from the right edge of the parent element.
        cellStartOffset = Math.abs(cellStartOffset);
      }
      cellStartOffset += firstColumnOffset - horizontalScrollPosition - cellWidth;
    } else if (['top', 'master', 'bottom'].includes(overlayName)) {
      cellStartOffset += firstColumnOffset - horizontalScrollPosition;
    }
    const cellComputedStyle = rootWindow.getComputedStyle(this.TD);
    const borderPhysicalWidthProp = this.hot.isRtl() ? 'borderRightWidth' : 'borderLeftWidth';
    const inlineStartBorderCompensation = parseInt(cellComputedStyle[borderPhysicalWidthProp], 10) > 0 ? 0 : 1;
    const topBorderCompensation = parseInt(cellComputedStyle.borderTopWidth, 10) > 0 ? 0 : 1;
    const width = (0, _element.outerWidth)(TD) + inlineStartBorderCompensation;
    const height = (0, _element.outerHeight)(TD) + topBorderCompensation;
    const actualVerticalScrollbarWidth = (0, _element.hasVerticalScrollbar)(scrollableContainerTop) ? scrollbarWidth : 0;
    const actualHorizontalScrollbarWidth = (0, _element.hasHorizontalScrollbar)(scrollableContainerLeft) ? scrollbarWidth : 0;
    const maxWidth = this.hot.view.maximumVisibleElementWidth(cellStartOffset) - actualVerticalScrollbarWidth + inlineStartBorderCompensation;
    const maxHeight = Math.max(this.hot.view.maximumVisibleElementHeight(cellTopOffset) - actualHorizontalScrollbarWidth + topBorderCompensation, this.hot.view.getDefaultRowHeight());
    return {
      top: topPos,
      start: inlineStartPos,
      height,
      maxHeight,
      width,
      maxWidth
    };
  }
  /* eslint-enable jsdoc/require-description-complete-sentence */

  /**
   * Gets className of the edited cell if exist.
   *
   * @returns {string}
   */
  getEditedCellsLayerClass() {
    const editorSection = this.checkEditorSection();
    switch (editorSection) {
      case 'inline-start':
        return 'ht_clone_left ht_clone_inline_start';
      case 'bottom':
        return 'ht_clone_bottom';
      case 'bottom-inline-start-corner':
        return 'ht_clone_bottom_left_corner ht_clone_bottom_inline_start_corner';
      case 'top':
        return 'ht_clone_top';
      case 'top-inline-start-corner':
        return 'ht_clone_top_left_corner ht_clone_top_inline_start_corner';
      default:
        return 'ht_clone_master';
    }
  }

  /**
   * Gets HTMLTableCellElement of the edited cell if exist.
   *
   * @returns {HTMLTableCellElement|null}
   */
  getEditedCell() {
    return this.hot.getCell(this.row, this.col, true);
  }

  /**
   * Returns name of the overlay, where editor is placed.
   *
   * @private
   * @returns {string}
   */
  checkEditorSection() {
    const totalRows = this.hot.countRows();
    let section = '';
    if (this.row < this.hot.getSettings().fixedRowsTop) {
      if (this.col < this.hot.getSe
